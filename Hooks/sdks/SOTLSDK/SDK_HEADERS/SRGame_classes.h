/*
#############################################################################################
# Spec Ops The Line (idk) SDK
# Generated with TheFeckless UE3 SDK Generator v1.4_Beta-Rev.51
# ========================================================================================= #
# File: SRGame_classes.h
# ========================================================================================= #
# Credits: uNrEaL, Tamimego, SystemFiles, R00T88, _silencer, the1domo, K@N@VEL
# Thanks: HOOAH07, lowHertz
# Forums: www.uc-forum.com, www.gamedeception.net
#############################################################################################
*/

#ifdef _MSC_VER
	#pragma pack ( push, 0x4 )
#endif

/*
# ========================================================================================= #
# Constants
# ========================================================================================= #
*/

#define CONST_CONST_NbMajorPerkLevel                             2
#define CONST_CONST_NbMajorPerks                                 8
#define CONST_UnlockItemShift                                    16
#define CONST_UnlockItemMaskValue                                0x00ff
#define CONST_YPSI_Stat_MaxLimit                                 498
#define CONST_YPSI_ExtraStats40                                  498
#define CONST_YPSI_ExtraStats39                                  497
#define CONST_YPSI_ExtraStats38                                  496
#define CONST_YPSI_ExtraStats37                                  495
#define CONST_YPSI_ExtraStats36                                  494
#define CONST_YPSI_ExtraStats35                                  493
#define CONST_YPSI_ExtraStats34                                  492
#define CONST_YPSI_ExtraStats33                                  491
#define CONST_YPSI_ExtraStats32                                  490
#define CONST_YPSI_ExtraStats31                                  489
#define CONST_YPSI_ExtraStats30                                  488
#define CONST_YPSI_ExtraStats29                                  487
#define CONST_YPSI_ExtraStats28                                  486
#define CONST_YPSI_ExtraStats27                                  485
#define CONST_YPSI_ExtraStats26                                  484
#define CONST_YPSI_ExtraStats25                                  483
#define CONST_YPSI_ExtraStats24                                  482
#define CONST_YPSI_ExtraStats23                                  481
#define CONST_YPSI_ExtraStats22                                  480
#define CONST_YPSI_ExtraStats21                                  479
#define CONST_YPSI_ExtraStats20                                  478
#define CONST_YPSI_ExtraStats19                                  477
#define CONST_YPSI_ExtraStats18                                  476
#define CONST_YPSI_ExtraStats17                                  475
#define CONST_YPSI_ExtraStats16                                  474
#define CONST_YPSI_ExtraStats15                                  473
#define CONST_YPSI_ExtraStats14                                  472
#define CONST_YPSI_ExtraStats13                                  471
#define CONST_YPSI_ExtraStats12                                  470
#define CONST_YPSI_ExtraStats11                                  469
#define CONST_YPSI_ExtraStats10                                  468
#define CONST_YPSI_ExtraStats9                                   467
#define CONST_YPSI_ExtraStats8                                   466
#define CONST_YPSI_ExtraStats7                                   465
#define CONST_YPSI_ExtraStats6                                   464
#define CONST_YPSI_ExtraStats5                                   463
#define CONST_YPSI_ExtraStats4                                   462
#define CONST_YPSI_ExtraStats3                                   461
#define CONST_YPSI_ExtraStats2                                   460
#define CONST_YPSI_ExtraStats1                                   459
#define CONST_YPSI_MarkedKills                                   458
#define CONST_YPSI_Challenge_MapPlayed15                         457
#define CONST_YPSI_Challenge_MapPlayed14                         456
#define CONST_YPSI_Challenge_MapPlayed13                         455
#define CONST_YPSI_Challenge_MapPlayed12                         454
#define CONST_YPSI_Challenge_MapPlayed11                         453
#define CONST_YPSI_Challenge_MapPlayed10                         452
#define CONST_YPSI_Challenge_MapPlayed9                          451
#define CONST_YPSI_Challenge_MapPlayed8                          450
#define CONST_YPSI_Challenge_MapPlayed7                          449
#define CONST_YPSI_Challenge_MapPlayed6                          448
#define CONST_YPSI_Challenge_MapPlayed5                          447
#define CONST_YPSI_Challenge_MapPlayed4                          446
#define CONST_YPSI_Challenge_MapPlayed3                          445
#define CONST_YPSI_Challenge_MapPlayed2                          444
#define CONST_YPSI_Challenge_MapPlayed1                          443
#define CONST_YPSI_Challenge_MapPlayed0                          442
#define CONST_YPSI_DualHeavyWeapons                              441
#define CONST_YPSI_LongestKillStreak                             440
#define CONST_YPSI_CustomLoadoutsChanged                         439
#define CONST_YPSI_YachtLevelBitflags                            438
#define CONST_YPSI_Stat_Shots_Launcher                           437
#define CONST_YPSI_Stat_Hits_Launcher                            436
#define CONST_YPSI_Stat_MinesDisarmed                            435
#define CONST_YPSI_Stat_RankedTEWins                             434
#define CONST_YPSI_Stat_RankedWins                               433
#define CONST_YPSI_Stat_RankedPlays                              432
#define CONST_YPSI_Stat_UnderCover                               431
#define CONST_YPSI_Stat_TimesRevived                             430
#define CONST_YPSI_Stat_Revives                                  429
#define CONST_YPSI_Stat_C4Kills                                  428
#define CONST_YPSI_Stat_DE_BombDisarm                            427
#define CONST_YPSI_Stat_DE_BombDelivery                          426
#define CONST_YPSI_Stat_CA_BasesMarked                           425
#define CONST_YPSI_Stat_BD_VitalPointsRepaired                   424
#define CONST_YPSI_Stat_CA_ChoppersDestroyed                     423
#define CONST_YPSI_Stat_CA_ChopperCalls                          422
#define CONST_YPSI_Stat_SW_StolenLootValue                       421
#define CONST_YPSI_Stat_KillsInSandstorm                         420
#define CONST_YPSI_Stat_SandKills                                419
#define CONST_YPSI_Stat_AvalancheTriggers                        418
#define CONST_YPSI_Stat_ZiplineKills                             417
#define CONST_YPSI_Stat_VaultKills                               416
#define CONST_YPSI_Stat_MeleeKills                               415
#define CONST_YPSI_Stat_TotalHeadShots                           414
#define CONST_YPSI_Stat_TotalDeaths                              413
#define CONST_YPSI_Stat_TotalKills                               412
#define CONST_YSPI_Linkd                                         411
#define CONST_YSPI_MAX                                           410
#define CONST_YPSI_Headcase                                      409
#define CONST_YPSI_Hunter                                        408
#define CONST_YPSI_MUDChallege                                   407
#define CONST_YPSI_RivalPerkUse12                                406
#define CONST_YPSI_RivalPerkUse11                                405
#define CONST_YPSI_RivalPerkUse10                                404
#define CONST_YPSI_RivalPerkUse9                                 403
#define CONST_YPSI_RivalPerkUse8                                 402
#define CONST_YPSI_RivalPerkUse7                                 401
#define CONST_YPSI_RivalPerkUse6                                 400
#define CONST_YPSI_RivalPerkUse5                                 399
#define CONST_YPSI_RivalPerkUse4                                 398
#define CONST_YPSI_RivalPerkUse3                                 397
#define CONST_YPSI_RivalPerkUse2                                 396
#define CONST_YPSI_RivalPerkUse1                                 395
#define CONST_YPSI_RivalPerkUse0                                 394
#define CONST_YPSI_WeaponUse59                                   393
#define CONST_YPSI_WeaponUse58                                   392
#define CONST_YPSI_WeaponUse57                                   391
#define CONST_YPSI_WeaponUse56                                   390
#define CONST_YPSI_WeaponUse55                                   389
#define CONST_YPSI_WeaponUse54                                   388
#define CONST_YPSI_WeaponUse53                                   387
#define CONST_YPSI_WeaponUse52                                   386
#define CONST_YPSI_WeaponUse51                                   385
#define CONST_YPSI_WeaponUse50                                   384
#define CONST_YPSI_WeaponUse49                                   383
#define CONST_YPSI_WeaponUse48                                   382
#define CONST_YPSI_WeaponUse47                                   381
#define CONST_YPSI_WeaponUse46                                   380
#define CONST_YPSI_WeaponUse45                                   379
#define CONST_YPSI_WeaponUse44                                   378
#define CONST_YPSI_WeaponUse43                                   377
#define CONST_YPSI_WeaponUse42                                   376
#define CONST_YPSI_WeaponUse41                                   375
#define CONST_YPSI_WeaponUse40                                   374
#define CONST_YPSI_WeaponUse39                                   373
#define CONST_YPSI_WeaponUse38                                   372
#define CONST_YPSI_WeaponUse37                                   371
#define CONST_YPSI_WeaponUse36                                   370
#define CONST_YPSI_WeaponUse35                                   369
#define CONST_YPSI_WeaponUse34                                   368
#define CONST_YPSI_WeaponUse33                                   367
#define CONST_YPSI_WeaponUse32                                   366
#define CONST_YPSI_WeaponUse31                                   365
#define CONST_YPSI_WeaponUse30                                   364
#define CONST_YPSI_WeaponUse29                                   363
#define CONST_YPSI_WeaponUse28                                   362
#define CONST_YPSI_WeaponUse27                                   361
#define CONST_YPSI_WeaponUse26                                   360
#define CONST_YPSI_WeaponUse25                                   359
#define CONST_YPSI_WeaponUse24                                   358
#define CONST_YPSI_WeaponUse23                                   357
#define CONST_YPSI_WeaponUse22                                   356
#define CONST_YPSI_WeaponUse21                                   355
#define CONST_YPSI_WeaponUse20                                   354
#define CONST_YPSI_WeaponUse19                                   353
#define CONST_YPSI_WeaponUse18                                   352
#define CONST_YPSI_WeaponUse17                                   351
#define CONST_YPSI_WeaponUse16                                   350
#define CONST_YPSI_WeaponUse15                                   349
#define CONST_YPSI_WeaponUse14                                   348
#define CONST_YPSI_WeaponUse13                                   347
#define CONST_YPSI_WeaponUse12                                   346
#define CONST_YPSI_WeaponUse11                                   345
#define CONST_YPSI_WeaponUse10                                   344
#define CONST_YPSI_WeaponUse9                                    343
#define CONST_YPSI_WeaponUse8                                    342
#define CONST_YPSI_WeaponUse7                                    341
#define CONST_YPSI_WeaponUse6                                    340
#define CONST_YPSI_WeaponUse5                                    339
#define CONST_YPSI_WeaponUse4                                    338
#define CONST_YPSI_WeaponUse3                                    337
#define CONST_YPSI_WeaponUse2                                    336
#define CONST_YPSI_WeaponUse1                                    335
#define CONST_YPSI_WeaponUse0                                    334
#define CONST_YPSI_PerkUse67                                     333
#define CONST_YPSI_PerkUse66                                     332
#define CONST_YPSI_PerkUse65                                     331
#define CONST_YPSI_PerkUse64                                     330
#define CONST_YPSI_PerkUse63                                     329
#define CONST_YPSI_PerkUse62                                     328
#define CONST_YPSI_PerkUse61                                     327
#define CONST_YPSI_PerkUse60                                     326
#define CONST_YPSI_PerkUse59                                     325
#define CONST_YPSI_PerkUse58                                     324
#define CONST_YPSI_PerkUse57                                     323
#define CONST_YPSI_PerkUse56                                     322
#define CONST_YPSI_PerkUse55                                     321
#define CONST_YPSI_PerkUse54                                     320
#define CONST_YPSI_PerkUse53                                     319
#define CONST_YPSI_PerkUse52                                     318
#define CONST_YPSI_PerkUse51                                     317
#define CONST_YPSI_PerkUse50                                     316
#define CONST_YPSI_PerkUse49                                     315
#define CONST_YPSI_PerkUse48                                     314
#define CONST_YPSI_PerkUse47                                     313
#define CONST_YPSI_PerkUse46                                     312
#define CONST_YPSI_PerkUse45                                     311
#define CONST_YPSI_PerkUse44                                     310
#define CONST_YPSI_PerkUse43                                     309
#define CONST_YPSI_PerkUse42                                     308
#define CONST_YPSI_PerkUse41                                     307
#define CONST_YPSI_PerkUse40                                     306
#define CONST_YPSI_PerkUse39                                     305
#define CONST_YPSI_PerkUse38                                     304
#define CONST_YPSI_PerkUse37                                     303
#define CONST_YPSI_PerkUse36                                     302
#define CONST_YPSI_PerkUse35                                     301
#define CONST_YPSI_PerkUse34                                     300
#define CONST_YPSI_PerkUse33                                     299
#define CONST_YPSI_PerkUse32                                     298
#define CONST_YPSI_PerkUse31                                     297
#define CONST_YPSI_PerkUse30                                     296
#define CONST_YPSI_PerkUse29                                     295
#define CONST_YPSI_PerkUse28                                     294
#define CONST_YPSI_PerkUse27                                     293
#define CONST_YPSI_PerkUse26                                     292
#define CONST_YPSI_PerkUse25                                     291
#define CONST_YPSI_PerkUse24                                     290
#define CONST_YPSI_PerkUse23                                     289
#define CONST_YPSI_PerkUse22                                     288
#define CONST_YPSI_PerkUse21                                     287
#define CONST_YPSI_PerkUse20                                     286
#define CONST_YPSI_PerkUse19                                     285
#define CONST_YPSI_PerkUse18                                     284
#define CONST_YPSI_PerkUse17                                     283
#define CONST_YPSI_PerkUse16                                     282
#define CONST_YPSI_PerkUse15                                     281
#define CONST_YPSI_PerkUse14                                     280
#define CONST_YPSI_PerkUse13                                     279
#define CONST_YPSI_PerkUse12                                     278
#define CONST_YPSI_PerkUse11                                     277
#define CONST_YPSI_PerkUse10                                     276
#define CONST_YPSI_PerkUse9                                      275
#define CONST_YPSI_PerkUse8                                      274
#define CONST_YPSI_PerkUse7                                      273
#define CONST_YPSI_PerkUse6                                      272
#define CONST_YPSI_PerkUse5                                      271
#define CONST_YPSI_PerkUse4                                      270
#define CONST_YPSI_PerkUse3                                      269
#define CONST_YPSI_PerkUse2                                      268
#define CONST_YPSI_PerkUse1                                      267
#define CONST_YPSI_PerkUse0                                      266
#define CONST_YPSI_MapPlayed15                                   265
#define CONST_YPSI_MapPlayed14                                   264
#define CONST_YPSI_MapPlayed13                                   263
#define CONST_YPSI_MapPlayed12                                   262
#define CONST_YPSI_MapPlayed11                                   261
#define CONST_YPSI_MapPlayed10                                   260
#define CONST_YPSI_MapPlayed9                                    259
#define CONST_YPSI_MapPlayed8                                    258
#define CONST_YPSI_MapPlayed7                                    257
#define CONST_YPSI_MapPlayed6                                    256
#define CONST_YPSI_MapPlayed5                                    255
#define CONST_YPSI_MapPlayed4                                    254
#define CONST_YPSI_MapPlayed3                                    253
#define CONST_YPSI_MapPlayed2                                    252
#define CONST_YPSI_MapPlayed1                                    251
#define CONST_YPSI_MapPlayed0                                    250
#define CONST_YPSI_LowRankKills                                  249
#define CONST_YPSI_HighRankKills                                 248
#define CONST_YPSI_DistanceTraveled                              247
#define CONST_YPSI_PlayedAsDamned                                246
#define CONST_YPSI_PlayedAsExiles                                245
#define CONST_YPSI_TimesDBNO                                     244
#define CONST_YPSI_TeammatesJuiced                               243
#define CONST_YPSI_KilledByExplosive                             242
#define CONST_YPSI_KilledByGun                                   241
#define CONST_YPSI_DeathsUnderOrder                              240
#define CONST_YPSI_KillsUnderOrders                              239
#define CONST_YPSI_OrdersGiven                                   238
#define CONST_YPSI_C4Planted                                     237
#define CONST_YPSI_FlashThrown                                   236
#define CONST_YPSI_PercussionKills                               235
#define CONST_YPSI_PercussionThrown                              234
#define CONST_YPSI_FragKills                                     233
#define CONST_YPSI_FragsThrown                                   232
#define CONST_YPSI_RockKills                                     231
#define CONST_YPSI_RocksThrown                                   230
#define CONST_YPSI_MineKills                                     229
#define CONST_YPSI_MinesPlanted                                  228
#define CONST_YPSI_MinesSteppedOn                                227
#define CONST_YPSI_C4Disarmed                                    226
#define CONST_YPSI_MinesDisarmed                                 225
#define CONST_YPSI_RallyPointsHeld                               224
#define CONST_YPSI_DeathsDuringSandstorm                         223
#define CONST_YPSI_EnemiesStunnedByAvalanche                     222
#define CONST_YPSI_Bailouts                                      221
#define CONST_YPSI_ZiplineDeaths                                 220
#define CONST_YPSI_MatchesPlayed                                 219
#define CONST_YPSI_RP_TimeHeld                                   218
#define CONST_YPSI_DM_LeastDeaths                                217
#define CONST_YPSI_HD_RP_MajorityPoints                          216
#define CONST_YPSI_CA_ChoppersDestroyed                          215
#define CONST_YPSI_CA_BasesMarked                                214
#define CONST_YPSI_CA_ChopperCalls                               213
#define CONST_YPSI_DE_PlanterKills                               212
#define CONST_YPSI_DE_DiffuserKills                              211
#define CONST_YPSI_DE_BombDiffuse                                210
#define CONST_YPSI_DE_BombDelivery                               209
#define CONST_YPSI_DE_BombDisarm                                 208
#define CONST_YPSI_BD_VitalPointsRepaired                        207
#define CONST_YPSI_BD_VitalPointsDestroyed                       206
#define CONST_YPSI_SW_LootDepositedValue                         205
#define CONST_YPSI_SW_LootCarrierKills                           204
#define CONST_YPSI_SW_LootValue                                  203
#define CONST_YPSI_SW_StolenLootValue                            202
#define CONST_YPSI_SW_StolenLoot                                 201
#define CONST_YPSI_OL_FlawlessVictory                            200
#define CONST_YPSI_OL_Detonations                                199
#define CONST_YPSI_OL_Reactivations                              198
#define CONST_YPSI_OL_Deactivations                              197
#define CONST_YPSI_CP_CompletedSectionsFlags                     196
#define CONST_YPSI_CP_CompletedSections                          195
#define CONST_YPSI_HD_Captures                                   194
#define CONST_YPSI_HD_Reparations                                193
#define CONST_YPSI_HD_Destructions                               192
#define CONST_YPSI_TE_EntireTeamKills                            191
#define CONST_YPSI_TE_LastPlayerAlive                            190
#define CONST_YPSI_SDM_Annihilations                             189
#define CONST_YPSI_TDM_BestTeamPlayer                            188
#define CONST_YPSI_CurrentOLVictoryStreak                        187
#define CONST_YPSI_MaxOLVictoryStreak                            186
#define CONST_YPSI_CurrentCAVictoryStreak                        185
#define CONST_YPSI_MaxCAVictoryStreak                            184
#define CONST_YPSI_CurrentSDVictoryStreak                        183
#define CONST_YPSI_MaxSDVictoryStreak                            182
#define CONST_YPSI_CurrentDLVictoryStreak                        181
#define CONST_YPSI_MaxDLVictoryStreak                            180
#define CONST_YPSI_CurrentSWVictoryStreak                        179
#define CONST_YPSI_MaxSWVictoryStreak                            178
#define CONST_YPSI_CurrentBDVictoryStreak                        177
#define CONST_YPSI_MaxBDVictoryStreak                            176
#define CONST_YPSI_CurrentSDMVictoryStreak                       175
#define CONST_YPSI_MaxSDMVictoryStreak                           174
#define CONST_YPSI_CurrentHDVictoryStreak                        173
#define CONST_YPSI_MaxHDVictoryStreak                            172
#define CONST_YPSI_CurrentTDMVictoryStreak                       171
#define CONST_YPSI_MaxTDMVictoryStreak                           170
#define CONST_YPSI_CurrentTEVictoryStreak                        169
#define CONST_YPSI_MaxTEVictoryStreak                            168
#define CONST_YPSI_CurrentDMVictoryStreak                        167
#define CONST_YPSI_MaxDMVictoryStreak                            166
#define CONST_YPSI_CurrentCPVictoryStreak                        165
#define CONST_YPSI_MaxCPVictoryStreak                            164
#define CONST_YPSI_RankedOLPlays                                 163
#define CONST_YPSI_RankedSDPlays                                 162
#define CONST_YPSI_RankedDLPlays                                 161
#define CONST_YPSI_RankedSWPlays                                 160
#define CONST_YPSI_RankedBDPlays                                 159
#define CONST_YPSI_RankedCPPlays                                 158
#define CONST_YPSI_RankedCAPlays                                 157
#define CONST_YPSI_RankedHDPlays                                 156
#define CONST_YPSI_RankedTEPlays                                 155
#define CONST_YPSI_RankedSDMPlays                                154
#define CONST_YPSI_RankedTDMPlays                                153
#define CONST_YPSI_RankedDMPlays                                 152
#define CONST_YPSI_RankedOLWins                                  151
#define CONST_YPSI_RankedSDWins                                  150
#define CONST_YPSI_RankedDLWins                                  149
#define CONST_YPSI_RankedSWWins                                  148
#define CONST_YPSI_RankedBDWins                                  147
#define CONST_YPSI_RankedCPWins                                  146
#define CONST_YPSI_RankedCAWins                                  145
#define CONST_YPSI_RankedHDWins                                  144
#define CONST_YPSI_RankedTEWins                                  143
#define CONST_YPSI_RankedSDMWins                                 142
#define CONST_YPSI_RankedTDMWins                                 141
#define CONST_YPSI_RankedDMWins                                  140
#define CONST_YPSI_NoFriendlyFire                                139
#define CONST_YPSI_StolenWeapons                                 138
#define CONST_YPSI_NoRunMatches                                  137
#define CONST_YPSI_ResupplyPickups                               136
#define CONST_YPSI_CustomLoadouts                                135
#define CONST_YPSI_AdrenalinTeam                                 134
#define CONST_YPSI_Vaults                                        133
#define CONST_YPSI_MetalDetector                                 132
#define CONST_YPSI_King                                          131
#define CONST_YPSI_Nemesis                                       130
#define CONST_YPSI_Less3Kills                                    129
#define CONST_YPSI_NoEquipment                                   128
#define CONST_YPSI_OnTheBench                                    127
#define CONST_YPSI_OneManArmy                                    126
#define CONST_YPSI_NoDeaths                                      125
#define CONST_YPSI_WeaponsPickedUp                               124
#define CONST_YPSI_Psychic                                       123
#define CONST_YPSI_AdrenalineAdministered                        122
#define CONST_YPSI_EveryPointReached                             121
#define CONST_YPSI_10KillStreaks                                 120
#define CONST_YPSI_8KillStreaks                                  119
#define CONST_YPSI_3KillStreaks                                  118
#define CONST_YPSI_EnemiesRevealed                               117
#define CONST_YPSI_OrdersCompleted                               116
#define CONST_YPSI_AvalancheTriggers                             115
#define CONST_YPSI_UnderCover                                    114
#define CONST_YPSI_NoCoverMatches                                113
#define CONST_YPSI_NoKillGames                                   112
#define CONST_YPSI_DoubleKillGames                               111
#define CONST_YPSI_DeathsWithPrimedGrenade                       110
#define CONST_YPSI_ZiplinesUsed                                  109
#define CONST_YPSI_OnlyMeleeGames                                108
#define CONST_YPSI_BoatKills                                     107
#define CONST_YPSI_BigExplosiveMultiKill                         106
#define CONST_YPSI_ExplosiveMultikill                            105
#define CONST_YPSI_BadKnees                                      104
#define CONST_YPSI_Logistics                                     103
#define CONST_YPSI_ShotsSP                                       102
#define CONST_YPSI_HitsSP                                        101
#define CONST_YPSI_Shots_Shotgun                                 100
#define CONST_YPSI_Hits_Shotgun                                  99
#define CONST_YPSI_Shots_HMG                                     98
#define CONST_YPSI_Hits_HMG                                      97
#define CONST_YPSI_Shots_LMG                                     96
#define CONST_YPSI_Hits_LMG                                      95
#define CONST_YPSI_Shots_Sniper                                  94
#define CONST_YPSI_Hits_Sniper                                   93
#define CONST_YPSI_Shots_Handgun                                 92
#define CONST_YPSI_Hits_Handgun                                  91
#define CONST_YPSI_Shots_SMG                                     90
#define CONST_YPSI_Hits_SMG                                      89
#define CONST_YPSI_Shots_AR                                      88
#define CONST_YPSI_Hits_AR                                       87
#define CONST_YPSI_Shots                                         86
#define CONST_YPSI_Hits                                          85
#define CONST_YPSI_PlayTime                                      84
#define CONST_YPSI_KRCP_MaxSpecopsCaptures                       83
#define CONST_YPSI_KRCP_SpecopsTeamCaptures                      82
#define CONST_YPSI_KRCP_BossClassUnlocks                         81
#define CONST_YPSI_KRCP_EliteClassUnlocks                        80
#define CONST_YPSI_SOCP_CompletedSectionsNoCapture               79
#define CONST_YPSI_SOCP_TeammatesFree                            78
#define CONST_YPSI_SOCP_BossKonradKills                          77
#define CONST_YPSI_SOCP_EliteKonradKills                         76
#define CONST_YPSI_SOCP_KonradKills                              75
#define CONST_YPSI_KRHT_KillsInBack                              74
#define CONST_YPSI_KRHT_KillsAfterDetection                      73
#define CONST_YPSI_KRFM_Hacks                                    72
#define CONST_YPSI_KRFM_PickedUpLoots                            71
#define CONST_YPSI_KRRG_KillsWithDroppedGrenade                  70
#define CONST_YPSI_KRRG_KillsInBerserkMode                       69
#define CONST_YPSI_SOHT_HeavyWeaponKills                         68
#define CONST_YPSI_SOHT_SecondaryWeaponKills                     67
#define CONST_YPSI_SOEE_SurvivesToExplosions                     66
#define CONST_YPSI_SOEE_ExplosiveDetections                      65
#define CONST_YPSI_SOTE_CloseDetections                          64
#define CONST_YPSI_SOTE_Scans                                    63
#define CONST_YPSI_ExplosiveSuicide                              62
#define CONST_YPSI_TimesKilledWhileHealing                       61
#define CONST_YPSI_KillCamsSkipped                               60
#define CONST_YPSI_KillCamsWatched                               59
#define CONST_YPSI_SandfallsSurvived                             58
#define CONST_YPSI_TimesRevived                                  57
#define CONST_YPSI_SelfRevives                                   56
#define CONST_YPSI_Revives                                       55
#define CONST_YPSI_SelfKnockedOuts                               54
#define CONST_YPSI_KnockedOuts                                   53
#define CONST_YPSI_Suicides                                      52
#define CONST_YPSI_DeathsPerTeam                                 51
#define CONST_YPSI_Deaths                                        50
#define CONST_YPSI_LMGHeadshots                                  49
#define CONST_YPSI_SniperHeadshots                               48
#define CONST_YPSI_AssaultHeadshots                              47
#define CONST_YPSI_SMGHeadshots                                  46
#define CONST_YPSI_ShotgunHeadshots                              45
#define CONST_YPSI_HandgunHeadshots                              44
#define CONST_YPSI_StuckC4Kills                                  43
#define CONST_YPSI_FallingKills                                  42
#define CONST_YPSI_GhilleSuitKills                               41
#define CONST_YPSI_ExplodingEnvironmentKills                     40
#define CONST_YPSI_InstantKills                                  39
#define CONST_YPSI_VaultKills                                    38
#define CONST_YPSI_LongDistanceKills                             37
#define CONST_YPSI_UndetectableExplosiveKills                    36
#define CONST_YPSI_MessengerKills                                35
#define CONST_YPSI_ScopedKills                                   34
#define CONST_YPSI_StunnedKills                                  33
#define CONST_YPSI_ZipLineGrenadeKills                           32
#define CONST_YPSI_ZiplineKills                                  31
#define CONST_YPSI_OnZipLineGrenadeKills                         30
#define CONST_YPSI_KillsAtObjective                              29
#define CONST_YPSI_HealersKilled                                 28
#define CONST_YPSI_KillsWhileDead                                27
#define CONST_YPSI_KillsInSandstorm                              26
#define CONST_YPSI_Revenges                                      25
#define CONST_YPSI_KillsWithUniqueTeamExplosive                  24
#define CONST_YPSI_KillsWithUniqueTeamWeapon                     23
#define CONST_YPSI_KillsInDark                                   22
#define CONST_YPSI_KillsByHeadshot                               21
#define CONST_YPSI_KillsBehindCover                              20
#define CONST_YPSI_KillsInBlindFire                              19
#define CONST_YPSI_DBNOKills                                     18
#define CONST_YPSI_SandKills                                     17
#define CONST_YPSI_RPGKills                                      16
#define CONST_YPSI_LauncherKills                                 15
#define CONST_YPSI_GrenadeKills                                  14
#define CONST_YPSI_ExplosiveKills                                13
#define CONST_YPSI_C4Kills                                       12
#define CONST_YPSI_LMGKills                                      11
#define CONST_YPSI_SniperKills                                   10
#define CONST_YPSI_AssaultKills                                  9
#define CONST_YPSI_SMGKills                                      8
#define CONST_YPSI_ShotgunKills                                  7
#define CONST_YPSI_HandgunKills                                  6
#define CONST_YPSI_MeleeKills                                    5
#define CONST_YPSI_TakeDowns                                     4
#define CONST_YPSI_Executions                                    3
#define CONST_YPSI_Assists                                       2
#define CONST_YPSI_KillsPerTeam                                  1
#define CONST_YPSI_Kills                                         0
#define CONST_NUM_BITS_DISC_INT                                  32
#define CONST_PSI_KeyAction                                      1649
#define CONST_PSI_KeyAction01                                    1648
#define CONST_PSI_KeyAction02                                    1647
#define CONST_PSI_KeyAction03                                    1646
#define CONST_PSI_KeyAction04                                    1645
#define CONST_PSI_KeyAction05                                    1644
#define CONST_PSI_KeyAction06                                    1643
#define CONST_PSI_KeyAction07                                    1642
#define CONST_PSI_KeyAction08                                    1641
#define CONST_PSI_KeyAction09                                    1640
#define CONST_PSI_KeyAction10                                    1639
#define CONST_PSI_KeyAction11                                    1638
#define CONST_PSI_KeyAction12                                    1637
#define CONST_PSI_KeyAction13                                    1636
#define CONST_PSI_KeyAction14                                    1635
#define CONST_PSI_KeyAction15                                    1634
#define CONST_PSI_KeyAction16                                    1633
#define CONST_PSI_KeyAction17                                    1632
#define CONST_PSI_KeyAction18                                    1631
#define CONST_PSI_KeyAction19                                    1630
#define CONST_PSI_KeyAction20                                    1629
#define CONST_PSI_KeyAction21                                    1628
#define CONST_PSI_KeyAction22                                    1627
#define CONST_PSI_KeyAction23                                    1626
#define CONST_PSI_KeyAction24                                    1625
#define CONST_PSI_KeyAction25                                    1624
#define CONST_PSI_KeyAction26                                    1623
#define CONST_PSI_KeyAction27                                    1622
#define CONST_PSI_KeyAction28                                    1621
#define CONST_PSI_KeyAction29                                    1620
#define CONST_PSI_KeyAction30                                    1619
#define CONST_PSI_KeyAction31                                    1618
#define CONST_PSI_KeyAction32                                    1617
#define CONST_PSI_KeyAction33                                    1616
#define CONST_PSI_KeyAction34                                    1615
#define CONST_PSI_KeyAction35                                    1614
#define CONST_PSI_KeyAction36                                    1613
#define CONST_PSI_KeyAction37                                    1612
#define CONST_PSI_KeyAction38                                    1611
#define CONST_PSI_KeyAction39                                    1610
#define CONST_PSI_KeyAction40                                    1609
#define CONST_PSI_KeyAction41                                    1608
#define CONST_PSI_KeyAction42                                    1607
#define CONST_PSI_KeyAction43                                    1606
#define CONST_PSI_KeyAction44                                    1605
#define CONST_PSI_KeyAction45                                    1604
#define CONST_PSI_KeyAction46                                    1601
#define CONST_PSI_KeyAction47                                    1600
#define CONST_PSI_NewUnlockItem059                               1559
#define CONST_PSI_NewUnlockItem058                               1558
#define CONST_PSI_NewUnlockItem057                               1557
#define CONST_PSI_NewUnlockItem056                               1556
#define CONST_PSI_NewUnlockItem055                               1555
#define CONST_PSI_NewUnlockItem054                               1554
#define CONST_PSI_NewUnlockItem053                               1553
#define CONST_PSI_NewUnlockItem052                               1552
#define CONST_PSI_NewUnlockItem051                               1551
#define CONST_PSI_NewUnlockItem050                               1550
#define CONST_PSI_NewUnlockItem049                               1549
#define CONST_PSI_NewUnlockItem048                               1548
#define CONST_PSI_NewUnlockItem047                               1547
#define CONST_PSI_NewUnlockItem046                               1546
#define CONST_PSI_NewUnlockItem045                               1545
#define CONST_PSI_NewUnlockItem044                               1544
#define CONST_PSI_NewUnlockItem043                               1543
#define CONST_PSI_NewUnlockItem042                               1542
#define CONST_PSI_NewUnlockItem041                               1541
#define CONST_PSI_NewUnlockItem040                               1540
#define CONST_PSI_NewUnlockItem039                               1539
#define CONST_PSI_NewUnlockItem038                               1538
#define CONST_PSI_NewUnlockItem037                               1537
#define CONST_PSI_NewUnlockItem036                               1536
#define CONST_PSI_NewUnlockItem035                               1535
#define CONST_PSI_NewUnlockItem034                               1534
#define CONST_PSI_NewUnlockItem033                               1533
#define CONST_PSI_NewUnlockItem032                               1532
#define CONST_PSI_NewUnlockItem031                               1531
#define CONST_PSI_NewUnlockItem030                               1530
#define CONST_PSI_NewUnlockItem029                               1529
#define CONST_PSI_NewUnlockItem028                               1528
#define CONST_PSI_NewUnlockItem027                               1527
#define CONST_PSI_NewUnlockItem026                               1526
#define CONST_PSI_NewUnlockItem025                               1525
#define CONST_PSI_NewUnlockItem024                               1524
#define CONST_PSI_NewUnlockItem023                               1523
#define CONST_PSI_NewUnlockItem022                               1522
#define CONST_PSI_NewUnlockItem021                               1521
#define CONST_PSI_NewUnlockItem020                               1520
#define CONST_PSI_NewUnlockItem019                               1519
#define CONST_PSI_NewUnlockItem018                               1518
#define CONST_PSI_NewUnlockItem017                               1517
#define CONST_PSI_NewUnlockItem016                               1516
#define CONST_PSI_NewUnlockItem015                               1515
#define CONST_PSI_NewUnlockItem014                               1514
#define CONST_PSI_NewUnlockItem013                               1513
#define CONST_PSI_NewUnlockItem012                               1512
#define CONST_PSI_NewUnlockItem011                               1511
#define CONST_PSI_NewUnlockItem010                               1510
#define CONST_PSI_NewUnlockItem009                               1509
#define CONST_PSI_NewUnlockItem008                               1508
#define CONST_PSI_NewUnlockItem007                               1507
#define CONST_PSI_NewUnlockItem006                               1506
#define CONST_PSI_NewUnlockItem005                               1505
#define CONST_PSI_NewUnlockItem004                               1504
#define CONST_PSI_NewUnlockItem003                               1503
#define CONST_PSI_NewUnlockItem002                               1502
#define CONST_PSI_NewUnlockItem001                               1501
#define CONST_PSI_NewUnlockItem000                               1500
#define CONST_PSI_ACHIEVEMENT_END                                1455
#define CONST_PSI_ACHIEVEMENT_TRIGGERED_04                       1454
#define CONST_PSI_ACHIEVEMENT_TRIGGERED_03                       1453
#define CONST_PSI_ACHIEVEMENT_TRIGGERED_02                       1452
#define CONST_PSI_ACHIEVEMENT_TRIGGERED_01                       1451
#define CONST_PSI_ACHIEVEMENT_INTEL_03                           1450
#define CONST_PSI_ACHIEVEMENT_INTEL_02                           1449
#define CONST_PSI_ACHIEVEMENT_INTEL_01                           1448
#define CONST_PSI_ACHIEVEMENT_ORYX                               1447
#define CONST_PSI_ACHIEVEMENT_PRECISIONSHOOTING                  1446
#define CONST_PSI_ACHIEVEMENT_NODEATH                            1445
#define CONST_PSI_ACHIEVEMENT_STICKYGRENADE                      1444
#define CONST_PSI_ACHIEVEMENT_GRENADETHROWKILL                   1443
#define CONST_PSI_ACHIEVEMENT_MULTIPLEGRENADE                    1442
#define CONST_PSI_ACHIEVEMENT_COMMANDOKILL                       1441
#define CONST_PSI_ACHIEVEMENT_TRAVERSALKILL                      1440
#define CONST_PSI_ACHIEVEMENT_QUICKKILLS                         1439
#define CONST_PSI_ACHIEVEMENT_ATTACKCOMMAND                      1438
#define CONST_PSI_ACHIEVEMENT_EXPLOSIVE                          1437
#define CONST_PSI_ACHIEVEMENT_SANDBOMB                           1436
#define CONST_PSI_ACHIEVEMENT_COVERDASH                          1435
#define CONST_PSI_ACHIEVEMENT_BLINDFIRE                          1434
#define CONST_PSI_ACHIEVEMENT_VAULTKICK                          1433
#define CONST_PSI_ACHIEVEMENT_MELEE                              1432
#define CONST_PSI_ACHIEVEMENT_HEADSHOT                           1431
#define CONST_PSI_ACHIEVEMENT_WEAPONGRENADE                      1430
#define CONST_PSI_ACHIEVEMENT_WEAPONHEAVY                        1429
#define CONST_PSI_ACHIEVEMENT_WEAPONSNIPER                       1428
#define CONST_PSI_ACHIEVEMENT_WEAPONSHOTGUN                      1427
#define CONST_PSI_ACHIEVEMENT_WEAPONSMALL                        1426
#define CONST_PSI_ACHIEVEMENT_WEAPONRIFLE                        1425
#define CONST_PSI_ACHIEVEMENT_FINISHGAME_04                      1424
#define CONST_PSI_ACHIEVEMENT_FINISHGAME_03                      1423
#define CONST_PSI_ACHIEVEMENT_FINISHGAME_02                      1422
#define CONST_PSI_ACHIEVEMENT_FINISHGAME_01                      1421
#define CONST_PSI_ACHIEVEMENT_STORY                              1420
#define CONST_PSI_ACHIEVEMENT_STORY01                            1419
#define CONST_PSI_ACHIEVEMENT_STORY02                            1418
#define CONST_PSI_ACHIEVEMENT_STORY03                            1417
#define CONST_PSI_ACHIEVEMENT_STORY04                            1416
#define CONST_PSI_ACHIEVEMENT_STORY05                            1415
#define CONST_PSI_ACHIEVEMENT_STORY06                            1414
#define CONST_PSI_ACHIEVEMENT_STORY07                            1413
#define CONST_PSI_ACHIEVEMENT_STORY08                            1412
#define CONST_PSI_ACHIEVEMENT_STORY09                            1411
#define CONST_PSI_ACHIEVEMENT_STORY10                            1410
#define CONST_PSI_ACHIEVEMENT_STORY_09                           1409
#define CONST_PSI_ACHIEVEMENT_STORY_08                           1408
#define CONST_PSI_ACHIEVEMENT_STORY_07                           1407
#define CONST_PSI_ACHIEVEMENT_STORY_06                           1406
#define CONST_PSI_ACHIEVEMENT_STORY_05                           1405
#define CONST_PSI_ACHIEVEMENT_STORY_04                           1404
#define CONST_PSI_ACHIEVEMENT_STORY_03                           1403
#define CONST_PSI_ACHIEVEMENT_STORY_02                           1402
#define CONST_PSI_ACHIEVEMENT_STORY_01                           1401
#define CONST_PSI_ACHIEVEMENT_START                              1400
#define CONST_PSI_MISSION                                        1317
#define CONST_PSI_MISSION01                                      1316
#define CONST_PSI_MISSION02                                      1315
#define CONST_PSI_MISSION03                                      1314
#define CONST_PSI_MISSION04                                      1313
#define CONST_PSI_MISSION05                                      1312
#define CONST_PSI_MISSION06                                      1311
#define CONST_PSI_MISSION07                                      1310
#define CONST_PSI_MISSION_09                                     1309
#define CONST_PSI_MISSION_08                                     1308
#define CONST_PSI_MISSION_07                                     1307
#define CONST_PSI_MISSION_06                                     1306
#define CONST_PSI_MISSION_05                                     1305
#define CONST_PSI_MISSION_04                                     1304
#define CONST_PSI_MISSION_03                                     1303
#define CONST_PSI_MISSION_02                                     1302
#define CONST_PSI_MISSION_01                                     1301
#define CONST_PSI_HardwareStatsUploaded                          700
#define CONST_UTPID_FirstTimeMultiplayer                         584
#define CONST_UTPID_MusicVolume                                  583
#define CONST_UTPID_SFXVolume                                    582
#define CONST_UTPID_WeaponSwitchOnPickup                         581
#define CONST_UTPID_Gamma                                        580
#define CONST_PSI_Statistics                                     500
#define CONST_PS_FirstLoginTimeAfterPreorderInstall              494
#define CONST_PS_LastKonradCharacterUsed                         493
#define CONST_PS_LastSpecopsCharacterUsed                        492
#define CONST_PS_LastTeamUsed                                    491
#define CONST_PSI_CharacterDefaultEquipmentVersionNum            490
#define CONST_PSI_CharacterKonrad5TorsoMaterial                  464
#define CONST_PSI_CharacterKonrad5TorsoMesh                      463
#define CONST_PSI_CharacterKonrad5HeadMaterial                   462
#define CONST_PSI_CharacterKonrad5HeadMesh                       461
#define CONST_PSI_CharacterKonrad5MinorPerk3                     460
#define CONST_PSI_CharacterKonrad5Explosive                      459
#define CONST_PSI_CharacterKonrad5SecondaryWeapon                458
#define CONST_PSI_CharacterKonrad5PrimaryWeapon                  457
#define CONST_PSI_CharacterKonrad5MinorPerk2                     456
#define CONST_PSI_CharacterKonrad5MinorPerk1                     455
#define CONST_PSI_CharacterKonrad5FactionPerk                    454
#define CONST_PSI_CharacterKonrad5Name                           453
#define CONST_PSI_CharacterKonrad4TorsoMaterial                  447
#define CONST_PSI_CharacterKonrad4TorsoMesh                      446
#define CONST_PSI_CharacterKonrad4HeadMaterial                   445
#define CONST_PSI_CharacterKonrad4HeadMesh                       444
#define CONST_PSI_CharacterKonrad4MinorPerk3                     443
#define CONST_PSI_CharacterKonrad4Explosive                      442
#define CONST_PSI_CharacterKonrad4SecondaryWeapon                441
#define CONST_PSI_CharacterKonrad4PrimaryWeapon                  440
#define CONST_PSI_CharacterKonrad4MinorPerk2                     439
#define CONST_PSI_CharacterKonrad4MinorPerk1                     438
#define CONST_PSI_CharacterKonrad4FactionPerk                    437
#define CONST_PSI_CharacterKonrad4Name                           436
#define CONST_PSI_CharacterKonrad3TorsoMaterial                  430
#define CONST_PSI_CharacterKonrad3TorsoMesh                      429
#define CONST_PSI_CharacterKonrad3HeadMaterial                   428
#define CONST_PSI_CharacterKonrad3HeadMesh                       427
#define CONST_PSI_CharacterKonrad3MinorPerk3                     426
#define CONST_PSI_CharacterKonrad3Explosive                      425
#define CONST_PSI_CharacterKonrad3SecondaryWeapon                424
#define CONST_PSI_CharacterKonrad3PrimaryWeapon                  423
#define CONST_PSI_CharacterKonrad3MinorPerk2                     422
#define CONST_PSI_CharacterKonrad3MinorPerk1                     421
#define CONST_PSI_CharacterKonrad3FactionPerk                    420
#define CONST_PSI_CharacterKonrad3Name                           419
#define CONST_PSI_CharacterKonrad2TorsoMaterial                  413
#define CONST_PSI_CharacterKonrad2TorsoMesh                      412
#define CONST_PSI_CharacterKonrad2HeadMaterial                   411
#define CONST_PSI_CharacterKonrad2HeadMesh                       410
#define CONST_PSI_CharacterKonrad2MinorPerk3                     409
#define CONST_PSI_CharacterKonrad2Explosive                      408
#define CONST_PSI_CharacterKonrad2SecondaryWeapon                407
#define CONST_PSI_CharacterKonrad2PrimaryWeapon                  406
#define CONST_PSI_CharacterKonrad2MinorPerk2                     405
#define CONST_PSI_CharacterKonrad2MinorPerk1                     404
#define CONST_PSI_CharacterKonrad2FactionPerk                    403
#define CONST_PSI_CharacterKonrad2Name                           402
#define CONST_PSI_CharacterKonrad1TorsoMaterial                  396
#define CONST_PSI_CharacterKonrad1TorsoMesh                      395
#define CONST_PSI_CharacterKonrad1HeadMaterial                   394
#define CONST_PSI_CharacterKonrad1HeadMesh                       393
#define CONST_PSI_CharacterKonrad1MinorPerk3                     392
#define CONST_PSI_CharacterKonrad1Explosive                      391
#define CONST_PSI_CharacterKonrad1SecondaryWeapon                390
#define CONST_PSI_CharacterKonrad1PrimaryWeapon                  389
#define CONST_PSI_CharacterKonrad1MinorPerk2                     388
#define CONST_PSI_CharacterKonrad1MinorPerk1                     387
#define CONST_PSI_CharacterKonrad1FactionPerk                    386
#define CONST_PSI_CharacterKonrad1Name                           385
#define CONST_PSI_CharacterSpecops5TorsoMaterial                 379
#define CONST_PSI_CharacterSpecops5TorsoMesh                     378
#define CONST_PSI_CharacterSpecops5HeadMaterial                  377
#define CONST_PSI_CharacterSpecops5HeadMesh                      376
#define CONST_PSI_CharacterSpecops5MinorPerk3                    375
#define CONST_PSI_CharacterSpecops5Explosive                     374
#define CONST_PSI_CharacterSpecops5SecondaryWeapon               373
#define CONST_PSI_CharacterSpecops5PrimaryWeapon                 372
#define CONST_PSI_CharacterSpecops5MinorPerk2                    371
#define CONST_PSI_CharacterSpecops5MinorPerk1                    370
#define CONST_PSI_CharacterSpecops5FactionPerk                   369
#define CONST_PSI_CharacterSpecops5Name                          368
#define CONST_PSI_CharacterSpecops4TorsoMaterial                 362
#define CONST_PSI_CharacterSpecops4TorsoMesh                     361
#define CONST_PSI_CharacterSpecops4HeadMaterial                  360
#define CONST_PSI_CharacterSpecops4HeadMesh                      359
#define CONST_PSI_CharacterSpecops4MinorPerk3                    358
#define CONST_PSI_CharacterSpecops4Explosive                     357
#define CONST_PSI_CharacterSpecops4SecondaryWeapon               356
#define CONST_PSI_CharacterSpecops4PrimaryWeapon                 355
#define CONST_PSI_CharacterSpecops4MinorPerk2                    354
#define CONST_PSI_CharacterSpecops4MinorPerk1                    353
#define CONST_PSI_CharacterSpecops4FactionPerk                   352
#define CONST_PSI_CharacterSpecops4Name                          351
#define CONST_PSI_CharacterSpecops3TorsoMaterial                 345
#define CONST_PSI_CharacterSpecops3TorsoMesh                     344
#define CONST_PSI_CharacterSpecops3HeadMaterial                  343
#define CONST_PSI_CharacterSpecops3HeadMesh                      342
#define CONST_PSI_CharacterSpecops3MinorPerk3                    341
#define CONST_PSI_CharacterSpecops3Explosive                     340
#define CONST_PSI_CharacterSpecops3SecondaryWeapon               339
#define CONST_PSI_CharacterSpecops3PrimaryWeapon                 338
#define CONST_PSI_CharacterSpecops3MinorPerk2                    337
#define CONST_PSI_CharacterSpecops3MinorPerk1                    336
#define CONST_PSI_CharacterSpecops3FactionPerk                   335
#define CONST_PSI_CharacterSpecops3Name                          334
#define CONST_PSI_CharacterSpecops2TorsoMaterial                 328
#define CONST_PSI_CharacterSpecops2TorsoMesh                     327
#define CONST_PSI_CharacterSpecops2HeadMaterial                  326
#define CONST_PSI_CharacterSpecops2HeadMesh                      325
#define CONST_PSI_CharacterSpecops2MinorPerk3                    324
#define CONST_PSI_CharacterSpecops2Explosive                     323
#define CONST_PSI_CharacterSpecops2SecondaryWeapon               322
#define CONST_PSI_CharacterSpecops2PrimaryWeapon                 321
#define CONST_PSI_CharacterSpecops2MinorPerk2                    320
#define CONST_PSI_CharacterSpecops2MinorPerk1                    319
#define CONST_PSI_CharacterSpecops2FactionPerk                   318
#define CONST_PSI_CharacterSpecops2Name                          317
#define CONST_PSI_CharacterSpecops1TorsoMaterial                 311
#define CONST_PSI_CharacterSpecops1TorsoMesh                     310
#define CONST_PSI_CharacterSpecops1HeadMaterial                  309
#define CONST_PSI_CharacterSpecops1HeadMesh                      308
#define CONST_PSI_CharacterSpecops1MinorPerk3                    307
#define CONST_PSI_CharacterSpecops1Explosive                     306
#define CONST_PSI_CharacterSpecops1SecondaryWeapon               305
#define CONST_PSI_CharacterSpecops1PrimaryWeapon                 304
#define CONST_PSI_CharacterSpecops1MinorPerk2                    303
#define CONST_PSI_CharacterSpecops1MinorPerk1                    302
#define CONST_PSI_CharacterSpecops1FactionPerk                   301
#define CONST_PSI_CharacterSpecops1Name                          300
#define CONST_PS_Character_NumberOfItems                         17
#define CONST_PSI_SinglePlayerCurrentMissionResult               252
#define CONST_PSI_SinglePlayerCurrentMission                     251
#define CONST_PSI_SinglePlayerSkillLevel                         250
#define CONST_PSI_SinglePlayerMapMaskB                           246
#define CONST_PSI_SinglePlayerMapMaskA                           245
#define CONST_PSI_SelectedBadge                                  229
#define CONST_PSI_SelectedTitle                                  228
#define CONST_PSI_ExodusCoopProgressLevel                        227
#define CONST_PSI_AchievedCommunityChallengesBitField            226
#define CONST_PSI_PrestigeLevel                                  222
#define CONST_PSI_XP                                             221
#define CONST_PSI_RankLevel                                      220
#define CONST_PSI_LastPlayedMission                              201
#define CONST_PSI_SaveSlot                                       200
#define CONST_PSI_ProfileSaveCheck                               180
#define CONST_PSI_UsevoiceChat                                   166
#define CONST_PSI_ClanTag4                                       165
#define CONST_PSI_ClanTag3                                       164
#define CONST_PSI_ClanTag2                                       163
#define CONST_PSI_ClanTag1                                       162
#define CONST_PSI_KilledDev                                      161
#define CONST_PSI_ClanTag                                        160
#define CONST_PSI_IsDefaultProfile                               149
#define CONST_PSI_HasBeenAtMPMenu                                148
#define CONST_PSI_HasAdjustedBrightness                          147
#define CONST_PSI_SafeZoneYOffset                                146
#define CONST_PSI_SafeZoneXOffset                                145
#define CONST_PSI_HasAdjustedSafeZone                            144
#define CONST_PSI_SaveZoneY                                      143
#define CONST_PSI_SaveZoneX                                      142
#define CONST_PSI_Subtitles                                      141
#define CONST_PSI_AudioLanguage                                  124
#define CONST_PSI_VoiceoverVolume                                123
#define CONST_PSI_MusicVolume                                    122
#define CONST_PSI_SpeechVolume                                   121
#define CONST_PSI_SFXVolume                                      120
#define CONST_PSI_PostFXPreset                                   101
#define CONST_PSI_Gamma                                          100
#define CONST_PSI_AimSnapOn                                      48
#define CONST_PSI_MouseInversion                                 47
#define CONST_PSI_HorizontalSensitivityMouse                     46
#define CONST_PSI_VerticalSensitivityMouse                       45
#define CONST_PSI_SouthPaw                                       44
#define CONST_PSI_ButtonLayout                                   43
#define CONST_PSI_HorizontalSensitivity                          41
#define CONST_PSI_VerticalSensitivity                            40
#define CONST_YCONST_MAX_KIT_CATEGORIES                          5
#define CONST_YCONST_MAX_BADGES                                  145
#define CONST_YCONST_MAX_TITLES                                  175
#define CONST_YCONST_MAX_WEAPON_CATEGORIES                       7
#define CONST_YCONST_MAX_WEAPONS                                 65
#define CONST_YCONST_MAX_SECONDARY_WEAPONS                       10
#define CONST_YCONST_MAX_PRIMARY_WEAPONS                         30
#define CONST_YCONST_MAX_PERKS                                   70
#define CONST_YCONST_MAX_MINOR_PERKS                             60
#define CONST_YCONST_MAX_MAJOR_PERKS                             7
#define CONST_YCONST_MAXMAJORPERKSECTION                         3
#define CONST_YCONST_MAXEQUIPMENT_SLOT                           7
#define CONST_YNUMCHARACTERSLOT                                  5
#define CONST_SKIP_TO_MULTIPLAYERMENU_URL_OPTION                 "BackToMultiplayerMenu"
#define CONST_NUM_PAGES                                          3
#define CONST_PAGE_HEAD                                          0
#define CONST_PAGE_ACCESSORIES                                   1
#define CONST_PAGE_PATTERNS                                      2
#define CONST_MAX_LOADED_PACKAGES                                5
#define CONST_SKIP_TITLESCREEN_REGISTRY_MARKUPSTRING             "<Registry:GoStraightToMainMenu>"
#define CONST_SKIP_TO_COOP_SYSTEMLINK_MENU_URL_OPTION            "BackToSystemLinkCoop"
#define CONST_SKIP_TO_COOP_ONLINE_MENU_URL_OPTION                "BackToOnlineCoop"
#define CONST_SKIP_TO_COMPETITIVE_SYSTEMLINK_MENU_URL_OPTION     "BackToSystemLinkComp"
#define CONST_SKIP_TO_COMPETITIVE_ONLINE_MENU_URL_OPTION         "BackToOnlineComp"
#define CONST_MAX_LOCAL_PLAYERS_ALLOWED                          1
#define CONST_MAX_PERSONALSERVERS                                15
#define CONST_UTUIBUTTONBAR_MAX_BUTTONS                          6
#define CONST_UTUIBUTTONBAR_BUTTON_SPACING                       -20
#define CONST_INVALIDFIELD                                       -1
#define CONST_A_NoDeathInXLevels                                 3
#define CONST_A_Explosive                                        10
#define CONST_A_MeleeCount                                       10
#define CONST_A_VaultKickCount                                   1
#define CONST_A_TraversalKillCount                               10
#define CONST_A_AttackCommand                                    50
#define CONST_A_MaxCollectable                                   23
#define CONST_A_IntelAchieve                                     12
#define CONST_A_IntelAchieve01                                   1
#define CONST_A_CoverDashCount                                   10
#define CONST_A_ScanCount                                        150
#define CONST_A_PrecisionShooting                                60
#define CONST_A_KillQuickInXSeconds                              10
#define CONST_A_KillXQuick                                       4
#define CONST_A_KillXWith1Grenade                                3
#define CONST_A_KillXBlindfire                                   5
#define CONST_A_KillXHeadshot                                    250
#define CONST_A_KillXGrenade                                     50
#define CONST_A_KillXHeavy                                       150
#define CONST_A_KillXSniper                                      50
#define CONST_A_KillXShotgun                                     75
#define CONST_A_KillXSmallWeapon                                 100
#define CONST_A_KillXRifle                                       350
#define CONST_MAX_SQUADMEMBERS                                   20
#define CONST_EntityInfoCount                                    2
#define CONST_RULE_ANY                                           0
#define CONST_GAMEMESSAGE_NEW_TEAM                               3
#define CONST_GAMEMESSAGE_NEW_PLAYER                             17
#define CONST_Y_MAX_GROUNDBLOODDECALVARIANTS                     3
#define CONST_YANI_AIMING                                        1
#define CONST_Y_NUM_MAX_FLYBYS                                   2
#define CONST_YANI_NO_AIMING                                     0
#define CONST_Y_MAX_FACEFX_REGISTERS                             8
#define CONST_NUM_LOADING_MOVIE_DELAY_FRAMES                     30
#define CONST_CurrentSelectedTacticalMarkableParallelCheckCount  2
#define CONST_ALPHA_INVALID                                      3.0
#define CONST_Y_ENABLE_ROTATION_SPEED                            8
#define CONST_Y_ENABLE_MOVEMENT_SPEED                            4
#define CONST_Y_ENABLE_ALWAYS_LOOK_AT_PLAYER                     2
#define CONST_Y_ENABLE_DEBUG_CAMERA_HEIGHT                       1
#define CONST_Y_SEQUENCE_NODE_CHILD_NUM                          1
#define CONST_Y_STANDARD_BLENDTIME                               0.25
#define CONST_Y_FAST_BLENDTIME                                   0.1
#define CONST_Y_SLOW_BLENDTIME                                   0.5
#define CONST_Y_MAX_WEAPONS                                      3
#define CONST_Y_MAX_GRENADES                                     8
#define CONST_Y_MAX_WEAPONFXREPLICANTS                           20
#define CONST_Y_MAX_WEAPONCLASSES                                65
#define CONST_Y_MAX_ALLOWEDCATEGORIES                            4
#define CONST_Y_MAX_GRENADETYPES                                 16
#define CONST_MAX_TEAM_NUM                                       2
#define CONST_ANNOUNCEMENT_DEATHMATCH_WIN                        2
#define CONST_ANNOUNCEMENT_DEATHMATCH_LOOSE                      3
#define CONST_ANNOUNCEMENT_TEAM_WIN                              4
#define CONST_ANNOUNCEMENT_TEAM_LOSE                             5
#define CONST_ANNOUNCEMENT_TIE                                   6
#define CONST_YCONST_MINIMAP_MASK_WIDTH                          185.0
#define CONST_YCONST_MINIMAP_MASK_HEIGHT                         169.0
#define CONST_YCONST_MINIMAP_UI_BOUNDS                           256.0
#define CONST_YCONST_MINIMAP_METERS_ACROSS                       231.0
#define CONST_YCONST_NUM_MINIMAP_BLIPS                           30
#define CONST_NUM_HD_DESTROY_POINTS                              2
#define CONST_NUM_OFFLINE_COMSTATIONS                            13
#define CONST_NUM_DELIVERY_BASES                                 10
#define CONST_NUM_SW_CAPTURE_POINTS                              2
#define CONST_NUM_SW_ACTIVE_DEPOTS                               8
#define CONST_NUM_BURIED_VITAL_POINTS                            10
#define CONST_NUM_CA_DESTRUCTION_BASES                           5
#define CONST_NUM_CA_ICONS                                       10
#define CONST_NUM_CA_CHOPPERS                                    3
#define CONST_NUM_VARIABLE_TRACES                                10
#define CONST_REFERENCE_RESOLUTION_X                             1280
#define CONST_REFERENCE_RESOLUTION_Y                             720
#define CONST_Y_CPAC_CIRCLE                                      0
#define CONST_Y_CPAC_CROSS                                       1
#define CONST_Y_CPAC_DOT                                         2
#define CONST_Y_CSAC_CIRCLE                                      0
#define CONST_MAX_DATASIZE_FOR_ALL_CHECKPOINTS                   10000000
#define CONST_MATCH_OVER_URL_OPTION                              "MatchOver"
#define CONST_EXPERIENCE_WAS_ENABLED_URL_OPTION                  "ShowXPScreen"
#define CONST_YMAXELITECHALLENGE                                 5
#define CONST_YBOSSINDEX                                         4
#define CONST_YMAXBOSS                                           10
#define CONST_EXODUS_MAX_SCORES_COUNT                            5
#define CONST_START_BEEP_TIME                                    10
#define CONST_CONTEXT_BOTSKILL                                   0
#define CONST_CONTEXT_PURESERVER                                 6
#define CONST_CONTEXT_LOCKEDSERVER                               7
#define CONST_CONTEXT_VSBOTS                                     8
#define CONST_CONTEXT_FORCERESPAWN                               10
#define CONST_CONTEXT_ALLOWKEYBOARD                              11
#define CONST_CONTEXT_FULLSERVER                                 12
#define CONST_CONTEXT_EMPTYSERVER                                13
#define CONST_CONTEXT_DEDICATEDSERVER                            14
#define CONST_CONTEXT_BOTSKILL_AUTOADJUSTSKILL                   0
#define CONST_CONTEXT_BOTSKILL_NOVICE                            1
#define CONST_CONTEXT_BOTSKILL_AVERAGE                           2
#define CONST_CONTEXT_BOTSKILL_EXPERIENCED                       3
#define CONST_CONTEXT_BOTSKILL_SKILLED                           4
#define CONST_CONTEXT_BOTSKILL_ADEPT                             5
#define CONST_CONTEXT_BOTSKILL_MASTERFUL                         6
#define CONST_CONTEXT_BOTSKILL_INHUMAN                           7
#define CONST_CONTEXT_BOTSKILL_GODLIKE                           8
#define CONST_CONTEXT_PURESERVER_NO                              0
#define CONST_CONTEXT_PURESERVER_YES                             1
#define CONST_CONTEXT_PURESERVER_ANY                             2
#define CONST_CONTEXT_LOCKEDSERVER_NO                            0
#define CONST_CONTEXT_LOCKEDSERVER_YES                           1
#define CONST_CONTEXT_CAMPAIGN_NO                                0
#define CONST_CONTEXT_CAMPAIGN_YES                               1
#define CONST_CONTEXT_FORCERESPAWN_NO                            0
#define CONST_CONTEXT_FORCERESPAWN_YES                           1
#define CONST_CONTEXT_ALLOWKEYBOARD_NO                           0
#define CONST_CONTEXT_ALLOWKEYBOARD_YES                          1
#define CONST_CONTEXT_ALLOWKEYBOARD_ANY                          2
#define CONST_CONTEXT_FULLSERVER_NO                              0
#define CONST_CONTEXT_FULLSERVER_YES                             1
#define CONST_CONTEXT_EMPTYSERVER_NO                             0
#define CONST_CONTEXT_EMPTYSERVER_YES                            1
#define CONST_CONTEXT_DEDICATEDSERVER_NO                         0
#define CONST_CONTEXT_DEDICATEDSERVER_YES                        1
#define CONST_CONTEXT_VSBOTS_NONE                                0
#define CONST_CONTEXT_VSBOTS_1_TO                                1
#define CONST_CONTEXT_VSBOTS_1_TO01                              2
#define CONST_CONTEXT_VSBOTS_3_TO                                3
#define CONST_CONTEXT_VSBOTS_2_TO                                4
#define CONST_CONTEXT_VSBOTS_3_TO01                              5
#define CONST_CONTEXT_VSBOTS_4_TO                                6
#define CONST_GS_USERNAME_MAXLENGTH                              15
#define CONST_GS_PASSWORD_MAXLENGTH                              30
#define CONST_GS_MESSAGE_MAXLENGTH                               255
#define CONST_GS_EMAIL_MAXLENGTH                                 50
#define CONST_GS_CDKEY_PART_MAXLENGTH                            4
#define CONST_YMAX_BLEND_PERCENTAGE                              0.25f
#define CONST_MAX_PARTY_SIZE                                     8
#define CONST_MeterToUnrUnit                                     50
#define CONST_DegToUnrRot                                        182.044444444444444f
#define CONST_UnrRotToDeg                                        0.0054931640625f
#define CONST_Y_MAX_TRACERTYPES                                  5
#define CONST_MAX_IMPACT_EMITTERS                                60
#define CONST_MAX_IMPACT_PARTICLE_SYSTEMS                        20
#define CONST_MAX_MINIGUN_IMPACT_PARTICLE_SYSTEMS                60
#define CONST_MED_IMPACT_PARTICLE_SYSTEMS                        10
#define CONST_MIN_IMPACT_PARTICLE_SYSTEMS                        5
#define CONST_MAX_SKELETALMESHES                                 10
#define CONST_MAX_EXPL_PARTICLE_SYSTEMS                          5
#define CONST_MAX_EXPL_BOUNCE_PARTICLE_SYSTEMS                   3
#define CONST_MAX_WEAPON_PICKUPS                                 10
#define CONST_MAX_WEAPON_PICKUPS_COOP                            30
#define CONST_MAX_PAWN_ATTACHMENTS                               30
#define CONST_MAX_BODY_PARTS                                     20
#define CONST_MAX_HEALING_SYRINGE                                2
#define CONST_A_AnimTreePoolSize                                 25
#define CONST_MAX_WEAPON_SKEL_MESHES                             5
#define CONST_MAX_BLOOD_PARTICLE_SYSTEMS                         10
#define CONST_MAX_KILLSHOT_PARTICLE_SYSTEMS                      5
#define CONST_MAX_FOOTSTEP_PARTICLE_SYSTEMS                      20
#define CONST_MAX_HEAD_EXPLODE_PARTICLE_SYSTEMS                  4
#define CONST_MAX_VAPORIZED_PAWN_PARTICLE_SYSTEMS                6
#define CONST_LOOT_TYPE_COUNT                                    5
#define CONST_Y_MAX_PICKUPGRENADES                               5
#define CONST_CMN_CharCrouch                                     0
#define CONST_CMN_CharCrouchAiming                               1
#define CONST_CMN_CharCrouchMove                                 2
#define CONST_CMN_CharCrouchMoveAiming                           3
#define CONST_CMN_CharStay                                       4
#define CONST_CMN_CharStayAiming                                 5
#define CONST_CMN_CharWalk                                       6
#define CONST_CMN_CharWalkAiming                                 7
#define CONST_CMN_CharRun                                        8
#define CONST_CMN_CharCombatSprinting                            9
#define CONST_CMN_CharCombatSprintingStartClose                  10
#define CONST_CMN_CharCombatSprintingStartMid                    11
#define CONST_CMN_CharCombatSprintingStartFar                    12
#define CONST_CMN_CharSprintSliding                              13
#define CONST_CMN_CharSprintSlidingAiming                        14
#define CONST_CMN_CharSprintSlidingCrouched                      15
#define CONST_CMN_CharSprintSlidingCrouchedAiming                16
#define CONST_CMN_CharCrouchAimingCannotShoot                    17
#define CONST_CMN_CharStandAimingCannotShoot                     18
#define CONST_CMN_CharCoverCrouchAimingLeft                      19
#define CONST_CMN_CharCoverCrouchAimingRight                     20
#define CONST_CMN_CharCoverCrouchAimingCannotShootLeft           21
#define CONST_CMN_CharCoverCrouchAimingCannotShootRight          22
#define CONST_CMN_CharCoverStandAimingLeft                       23
#define CONST_CMN_CharCoverStandAimingRight                      24
#define CONST_CMN_CharCoverStandAimingCannotShootLeft            25
#define CONST_CMN_CharCoverStandAimingCannotShootRight           26
#define CONST_CMN_CharCoverCrouchLeft                            27
#define CONST_CMN_CharCoverCrouchLeftBackwards                   28
#define CONST_CMN_CharCoverCrouchRight                           29
#define CONST_CMN_CharCoverCrouchRightBackwards                  30
#define CONST_CMN_CharCoverStandLeft                             31
#define CONST_CMN_CharCoverStandLeftBackwards                    32
#define CONST_CMN_CharCoverStandRight                            33
#define CONST_CMN_CharCoverStandRightBackwards                   34
#define CONST_CMN_CharCoverCrouchAimingCornerLeft                35
#define CONST_CMN_CharCoverCrouchAimingCornerRight               36
#define CONST_CMN_CharCoverCrouchAimingCornerLeftFrom            37
#define CONST_CMN_CharCoverCrouchAimingCornerRightFrom           38
#define CONST_CMN_CharCoverCrouchAimingPopupLeft                 39
#define CONST_CMN_CharCoverCrouchAimingPopupRight                40
#define CONST_CMN_CharCoverCrouchAimingPopupLeftFrom             41
#define CONST_CMN_CharCoverCrouchAimingPopupRightFrom            42
#define CONST_CMN_CharCoverCrouchAimingLeanAroundLeft            43
#define CONST_CMN_CharCoverCrouchAimingLeanAroundRight           44
#define CONST_CMN_CharCoverCrouchAimingLeanAroundLeftFrom        45
#define CONST_CMN_CharCoverCrouchAimingLeanAroundRightFrom       46
#define CONST_CMN_CharCoverStandAimingCornerLeft                 47
#define CONST_CMN_CharCoverStandAimingCornerRight                48
#define CONST_CMN_CharCoverStandAimingCornerLeftFrom             49
#define CONST_CMN_CharCoverStandAimingCornerRightFrom            50
#define CONST_CMN_CharCoverStandAimingLeanAroundLeft             51
#define CONST_CMN_CharCoverStandAimingLeanAroundRight            52
#define CONST_CMN_CharCoverStandAimingLeanAroundLeftFrom         53
#define CONST_CMN_CharCoverStandAimingLeanAroundRightFrom        54
#define CONST_CMN_CharCoverCrouchCornerLeft                      55
#define CONST_CMN_CharCoverCrouchCornerRight                     56
#define CONST_CMN_CharCoverCrouchCornerLeftFrom                  57
#define CONST_CMN_CharCoverCrouchCornerRightFrom                 58
#define CONST_CMN_CharCoverCrouchPopupLeft                       59
#define CONST_CMN_CharCoverCrouchPopupRight                      60
#define CONST_CMN_CharCoverCrouchPopupLeftFrom                   61
#define CONST_CMN_CharCoverCrouchPopupRightFrom                  62
#define CONST_CMN_CharCoverCrouchLeanAroundLeft                  63
#define CONST_CMN_CharCoverCrouchLeanAroundRight                 64
#define CONST_CMN_CharCoverCrouchLeanAroundLeftFrom              65
#define CONST_CMN_CharCoverCrouchLeanAroundRightFrom             66
#define CONST_CMN_CharCoverStandCornerLeft                       67
#define CONST_CMN_CharCoverStandCornerRight                      68
#define CONST_CMN_CharCoverStandCornerLeftFrom                   69
#define CONST_CMN_CharCoverStandCornerRightFrom                  70
#define CONST_CMN_CharCoverStandLeanAroundLeft                   71
#define CONST_CMN_CharCoverStandLeanAroundRight                  72
#define CONST_CMN_CharCoverStandLeanAroundLeftFrom               73
#define CONST_CMN_CharCoverStandLeanAroundRightFrom              74
#define CONST_CMN_CharCoverCrouchBlindfireEdgeLeft               75
#define CONST_CMN_CharCoverCrouchBlindfireEdgeRight              76
#define CONST_CMN_CharCoverCrouchBlindfirePopupEdgeLeft          77
#define CONST_CMN_CharCoverCrouchBlindfirePopupEdgeRight         78
#define CONST_CMN_CharCoverStandBlindfireEdgeLeft                79
#define CONST_CMN_CharCoverStandBlindfireEdgeRight               80
#define CONST_CMN_CharShootingOverCoverLeftAimNew                81
#define CONST_CMN_CharShootingOverCoverRightAimNew               82
#define CONST_CMN_CharLeaningOverCoverUpLeftAimNew               83
#define CONST_CMN_CharLeaningOverCoverUpRightAimNew              84
#define CONST_CMN_CharLeaningOverCoverLeftAimNew                 85
#define CONST_CMN_CharLeaningOverCoverRightAimNew                86
#define CONST_CMN_AIM_SCOPE_STAY                                 87
#define CONST_CMN_AIM_SCOPE_WALK                                 88
#define CONST_CMN_AIM_SCOPE_WALK_Mirror                          89
#define CONST_CMN_AIM_SCOPE_CROUCH                               90
#define CONST_CMN_AIM_SCOPE_CROUCH_Mirror                        91
#define CONST_CMN_AIM_SCOPE_CoverStand                           92
#define CONST_CMN_AIM_SCOPE_CoverCrouch                          93
#define CONST_CMN_AIM_SCOPE_AimOverLeft                          94
#define CONST_CMN_AIM_SCOPE_AimOverRight                         95
#define CONST_CMN_AIM_SCOPE_AimDownLeft                          96
#define CONST_CMN_AIM_SCOPE_AimDownRight                         97
#define CONST_CMN_AIM_SCOPE_CoverEdgeLeftStayFrom                98
#define CONST_CMN_AIM_SCOPE_CoverEdgeLeftStay                    99
#define CONST_CMN_AIM_SCOPE_CoverEdgeRightStayFrom               100
#define CONST_CMN_AIM_SCOPE_CoverEdgeRightStay                   101
#define CONST_CMN_AIM_SCOPE_CoverEdgeLeftCrouchFrom              102
#define CONST_CMN_AIM_SCOPE_CoverEdgeLeftCrouch                  103
#define CONST_CMN_AIM_SCOPE_CoverEdgeRightCrouchFrom             104
#define CONST_CMN_AIM_SCOPE_CoverEdgeRightCrouch                 105
#define CONST_CMN_AIM_SCOPE_LeanAroundLeftStayFrom               106
#define CONST_CMN_AIM_SCOPE_LeanAroundLeftStay                   107
#define CONST_CMN_AIM_SCOPE_LeanAroundRightStayFrom              108
#define CONST_CMN_AIM_SCOPE_LeanAroundRightStay                  109
#define CONST_CMN_AIM_SCOPE_LeanAroundLeftCrouchFrom             110
#define CONST_CMN_AIM_SCOPE_LeanAroundLeftCrouch                 111
#define CONST_CMN_AIM_SCOPE_LeanAroundRightCrouchFrom            112
#define CONST_CMN_AIM_SCOPE_LeanAroundRightCrouch                113
#define CONST_CMN_GrenadeCrouchCoverLeftFrom                     114
#define CONST_CMN_GrenadeCrouchCoverRightFrom                    115
#define CONST_CMN_GrenadeCrouchCoverLeft                         116
#define CONST_CMN_GrenadeCrouchCoverRight                        117
#define CONST_CMN_GrenadeCrouchCoverEdgeLeft                     118
#define CONST_CMN_GrenadeCrouchCoverEdgeRight                    119
#define CONST_CMN_GrenadeStandCoverEdgeLeft                      120
#define CONST_CMN_GrenadeStandCoverEdgeRight                     121
#define CONST_CMN_MineCrouchCover                                122
#define CONST_CMN_MineStandCover                                 123
#define CONST_CMN_SlipOutAroundLeft                              124
#define CONST_CMN_SlipOutAroundRight                             125
#define CONST_CMN_SwatTurn_Left                                  126
#define CONST_CMN_SwatTurn_LeftCrouch                            127
#define CONST_CMN_SwatTurn_Right                                 128
#define CONST_CMN_SwatTurn_RightCrouch                           129
#define CONST_CMN_FastRopeBegin                                  130
#define CONST_CMN_FastRopeStraight                               131
#define CONST_CMN_FastRopeJump                                   132
#define CONST_CMN_FastRopeEnd                                    133
#define CONST_CMN_FastRopeEndNoTurn                              134
#define CONST_CMN_ZiplineBegin                                   135
#define CONST_CMN_ZiplineTraverse                                136
#define CONST_CMN_CoverVaultPrepare                              137
#define CONST_CMN_CoverVault                                     138
#define CONST_CMN_CoverVaultFinished                             139
#define CONST_CMN_Revive                                         140
#define CONST_CMN_PickupWeapon                                   141
#define CONST_CMN_PickupWeaponFromRack                           142
#define CONST_CMN_PickupFromCrate                                143
#define CONST_CMN_Turret                                         144
#define CONST_CMN_TurretAiming                                   145
#define CONST_CMN_TurretCrouch                                   146
#define CONST_CMN_TurretCrouchAiming                             147
#define CONST_CMN_TurretThinCover                                148
#define CONST_CMN_TurretAimingThinCover                          149
#define CONST_CMN_TurretCrouchThinCover                          150
#define CONST_CMN_TurretCrouchAimingThinCover                    151
#define CONST_CMN_TurretThickCover                               152
#define CONST_CMN_TurretAimingThickCover                         153
#define CONST_CMN_TurretCrouchThickCover                         154
#define CONST_CMN_TurretCrouchAimingThickCover                   155
#define CONST_CMN_CharDroppingDown                               156
#define CONST_CMN_CharExecuting                                  157
#define CONST_CMN_RPG_StayAiming                                 158
#define CONST_CMN_RPG_WalkAiming                                 159
#define CONST_CMN_RPG_CrouchAiming                               160
#define CONST_CMN_RPG_CrouchMoveAiming                           161
#define CONST_CMN_MDBNOGunAiming                                 162
#define CONST_CMN_HeliGun                                        163
#define CONST_CMN_HeliGunAiming                                  164
#define CONST_CMN_CharDead                                       165
#define CONST_CMN_SpectatorSelf                                  166
#define CONST_CMN_Spectator                                      167
#define CONST_CMN_OVERRIDE                                       168
#define CONST_CMN_ANY                                            169
#define CONST_CMN_INVALID                                        170
#define CONST_CMN_NUM_CAM_MODES                                  171
#define CONST_CBO_STANDARD                                       0
#define CONST_CBO_CharCoverStandAimingLeft                       1
#define CONST_CBO_CharCoverCrouchAimingLeft                      2
#define CONST_CBO_CharCoverStandAimingRight                      3
#define CONST_CBO_CharCoverCrouchAimingRight                     4
#define CONST_CBO_CharCoverStandMovingAimingLeft                 5
#define CONST_CBO_CharCoverCrouchMovingAimingLeft                6
#define CONST_CBO_CharCoverStandMovingAimingRight                7
#define CONST_CBO_CharCoverCrouchMovingAimingRight               8
#define CONST_CBO_CharCoverStandAimingCornerLeft                 9
#define CONST_CBO_CharCoverCrouchAimingCornerLeft                10
#define CONST_CBO_CharCoverStandAimingCornerRight                11
#define CONST_CBO_CharCoverCrouchAimingCornerRight               12
#define CONST_CBO_CharCoverAimingOverLeft                        13
#define CONST_CBO_CharCoverAimingOverRight                       14
#define CONST_CBO_CharCoverAimingOver                            15
#define CONST_CBO_CharCoverStand                                 16
#define CONST_CBO_CharCoverStandCornerLeft                       17
#define CONST_CBO_CharCoverStandCornerRight                      18
#define CONST_CBO_CharCoverCrouch                                19
#define CONST_CBO_CharCoverCrouchCornerLeft                      20
#define CONST_CBO_CharCoverCrouchCornerRight                     21
#define CONST_CBO_CharUsingTurret                                22
#define CONST_CBO_CharUsingHeliTurret                            23
#define CONST_CBO_CharCoverCrouchLeft                            24
#define CONST_CBO_CharCoverCrouchRight                           25
#define CONST_CBO_CharCoverStandLeft                             26
#define CONST_CBO_CharCoverStandRight                            27
#define CONST_CBO_CharCoverCrouchMovingLeft                      28
#define CONST_CBO_CharCoverCrouchMovingRight                     29
#define CONST_CBO_CharCoverStandMovingLeft                       30
#define CONST_CBO_CharCoverStandMovingRight                      31
#define CONST_CBO_CharCoverLeaningOverLeft                       32
#define CONST_CBO_CharCoverLeaningOverRight                      33
#define CONST_CBO_CharCoverScopingOverLeft                       34
#define CONST_CBO_CharCoverScopingOverRight                      35
#define CONST_CBO_CharGrenadeCornerLeft                          36
#define CONST_CBO_CharGrenadeCornerRight                         37
#define CONST_CBO_CharMobileDDBNO                                38
#define CONST_CBO_NUM_BASE_OFFSETS                               39
#define CONST_DISTANCE_COVER                                     70.0
#define CONST_DISTANCE_AIM                                       65.0
#define CONST_DISTANCE_AIM_CROUCH                                65.0
#define CONST_DISTANCE_AIM_SCOPE                                 -8.0
#define CONST_FOV_COVER                                          72.0
#define CONST_FOV_AIM                                            50.0
#define CONST_FOV_AIM_NOCOVER                                    50.0
#define CONST_FOV_AIM_SCOPE                                      45.0
#define CONST_TRANSITION_SPEED_ZOOMIN                            0.25
#define CONST_TRANSITION_SPEED_ZOOMOUT                           0.6
#define CONST_TRANSITION_SPEED_COVEROFFSET                       0.65
#define CONST_TRANSITION_SPEED_MOVECAM                           0.25
#define CONST_NUM_ROWS                                           4
#define CONST_MAX_PLAYERS                                        5
#define CONST_MAX_LAUNCHED_PROJECTILES                           3
#define CONST_MAX_LAUNCHED_PROJECTILES_CUSTOM                    3
#define CONST_Y_MAX_ADHESIONTARGETS                              3
#define CONST_intToDegreeFactor                                  182.041666f
#define CONST_Y_ROTATION_TOLERANCE                               5
#define CONST_Y_OVER_COVER_HEIGHT_CORRECTION                     2.65
#define CONST_TEAMINDEX_NONE                                     255
#define CONST_TOTAL_PERKS                                        16
#define CONST_MAX_PERK_SLOTS                                     3
#define CONST_PAGE_PRIMARY                                       0
#define CONST_PAGE_SECONDARY                                     1
#define CONST_PAGE_EXPLOSIVE                                     2
#define CONST_ICON_RADIOMAN                                      "y"
#define CONST_ICON_SUICIDE                                       "l"
#define CONST_ICON_KILLEDBYDBNO                                  "8"
#define CONST_ICON_HEADSHOT                                      "i"
#define CONST_ICON_SQUAD_LUGO_DEAD                               "v"
#define CONST_ICON_SQUAD                                         "u"
#define CONST_ICON_BACK_CONSOLE                                  "<"
#define CONST_ICON_BACK                                          "r"
#define CONST_ICON_INTEL                                         "q"
#define CONST_ICON_EXLMARK_RED                                   "o"
#define CONST_ICON_EXLMARK_GREEN                                 "p"
#define CONST_ICON_BAR                                           "s"
#define CONST_PART_SPACING                                       0.5
#define CONST_NUM_ROWS01                                         6
#define CONST_CONST_NbTextures                                   7
#define CONST_MAX_LOADOUTS                                       5
#define CONST_MAX_PERKS                                          3
#define CONST_RULE_INF                                           1
#define CONST_RULE_YES                                           0
#define CONST_RULE_NO                                            1
#define CONST_SPEAKERS_COUNT                                     5
#define CONST_NUM_VISIBLE_BUTTONS                                40
#define CONST_ROUNDS_NUM                                         3
#define CONST_TEAM_NUM                                           2
#define CONST_SEAL_SPECOP                                        0
#define CONST_SEAL_KONRAD                                        1
#define CONST_SEAL_BOTH                                          2
#define CONST_UNLOCK_MAJOR_PERK                                  0
#define CONST_UNLOCK_MINOR_PERK                                  1
#define CONST_UNLOCK_WEAPON                                      2
#define CONST_NUM_ROWS02                                         11
#define CONST_NUM_VISIBLE_BUTTONS01                              20
#define CONST_NUMGRENADES                                        7
#define CONST_NUM_MAJOR_PERKS                                    9
#define CONST_NUM_MINOR_PERKS                                    11
#define CONST_NUM_WEAPONS                                        4
#define CONST_Y_MAX_SHOTGUNIMPACTS                               3

/*
# ========================================================================================= #
# Enums
# ========================================================================================= #
*/

// Enum SRGame.AIFactoryEnums.EInventoryTypes
/*enum EInventoryTypes
{
	WEAP_SRGun                                         = 0,
	WEAP_Shotgun                                       = 1,
	WEAP_Pistol                                        = 2,
	WEAP_Machinegun                                    = 3,
	WEAP_AssaultRifle                                  = 4,
	WEAP_Grenades                                      = 5,
	WEAP_Stationary                                    = 6,
	WEAP_Speznaz                                       = 7,
	WEAP_Sniper                                        = 8,
	WEAP_Submachine                                    = 9,
	WEAP_LaserSniper                                   = 10,
	WEAP_Dummy1                                        = 11,
	WEAP_Dummy2                                        = 12,
	WEAP_Dummy3                                        = 13,
	WEAP_M4Carbine                                     = 14,
	WEAP_SCAR                                          = 15,
	WEAP_MAX                                           = 16
};*/

// Enum SRGame.YNativeLocalization.YE_LocalizedStringType
/*enum YE_LocalizedStringType
{
	YELST_LanguageExtension                            = 0,
	YELST_HostNeedsUpdate                              = 1,
	YELST_ClientNeedsUpdate                            = 2,
	YELST_NoDownload_DLC1                              = 3,
	YELST_NoDownload_DLC1_PS3                          = 4,
	YELST_NoDownload_DLC1_PC                           = 5,
	YELST_NoDownload_Title                             = 6,
	YELST_CoopGameStarted                              = 7,
	YELST_MAX                                          = 8
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_DetachWeaponSlots
/*enum YE_DetachWeaponSlots
{
	YDWS_LeftHand                                      = 0,
	YDWS_Floor                                         = 1,
	YDWS_FirstDefinedUnequipSlot                       = 2,
	YDWS_SecondDefinedUnequipSlot                      = 3,
	YDWS_ThirdDefinedUnequipSlot                       = 4,
	YDWS_ForthDefinedUnequipSlot                       = 5,
	YDWS_FifthDefinedUnequipSlot                       = 6,
	YDWS_SixthDefinedUnequipSlot                       = 7,
	YDWS_SeventhDefinedUnequipSlot                     = 8,
	YDWS_EighthDefinedUnequipSlot                      = 9,
	YDWS_MAX                                           = 10
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponClasses
/*enum YE_WeaponClasses
{
	YWPC_Undefined                                     = 0,
	YWPC_TestWeapon                                    = 1,
	YWPC_NoWeapon                                      = 2,
	YWPC_DummyWeapon1                                  = 3,
	YWPC_DummyWeapon2                                  = 4,
	YWPC_DummyWeapon3                                  = 5,
	YWPC_Grenade                                       = 6,
	YWPC_M4Carbine                                     = 7,
	YWPC_SCAR                                          = 8,
	YWPC_OTs14Groza                                    = 9,
	YWPC_HK417                                         = 10,
	YWPC_AA12                                          = 11,
	YWPC_FAMAS                                         = 12,
	YWPC_TAR21                                         = 13,
	YWPC_AK47                                          = 14,
	YWPC_AK74                                          = 15,
	YWPC_HnKUMP45                                      = 16,
	YWPC_FNP90                                         = 17,
	YWPC_FNP90_LaserScope                              = 18,
	YWPC_TDIVector                                     = 19,
	YWPC_MicroUzi                                      = 20,
	YWPC_MP7                                           = 21,
	YWPC_AKS74u                                        = 22,
	YWPC_Mossberg590A1                                 = 23,
	YWPC_BenelliM1014                                  = 24,
	YWPC_SawedOffShotgun                               = 25,
	YWPC_BarrettM99                                    = 26,
	YWPC_SteyrElite                                    = 27,
	YWPC_SteyrElite_Lugo                               = 28,
	YWPC_M110SniperSystem                              = 29,
	YWPC_MSG90                                         = 30,
	YWPC_DesertEagle50AE                               = 31,
	YWPC_M9A1                                          = 32,
	YWPC_Glock18                                       = 33,
	YWPC_SIGP220                                       = 34,
	YWPC_FNP45                                         = 35,
	YWPC_PythonElite                                   = 36,
	YWPC_SAW                                           = 37,
	YWPC_SAW_Adams                                     = 38,
	YWPC_MilkorMGL                                     = 39,
	YWPC_RPG                                           = 40,
	YWPC_RPG_AI                                        = 41,
	YWPC_Flamethrower                                  = 42,
	YWPC_FlamethrowerAI                                = 43,
	YWPC_Expl_Grenade                                  = 44,
	YWPC_Expl_Percussion                               = 45,
	YWPC_Expl_C4                                       = 46,
	YWPC_Expl_Mine                                     = 47,
	YWPC_Expl_Stun                                     = 48,
	YWPC_Expl_NoExplosive                              = 49,
	YWPC_M2E2HMG                                       = 50,
	YWPC_TurretMiniGun                                 = 51,
	YWPC_TurretMiniGunFlight                           = 52,
	YWPC_Mk47Striker                                   = 53,
	YWPC_HeliGun                                       = 54,
	YWPC_HumveeGun                                     = 55,
	YWPC_HumveeGunDFA                                  = 56,
	YWPC_Mortar                                        = 57,
	YWPC_Knife                                         = 58,
	YWPC_SCAR_Grenade                                  = 59,
	YWPC_MPStone                                       = 60,
	YWPC_MPOfficerBeacon                               = 61,
	YWPC_MPOfficerSupply                               = 62,
	YWPC_MilkorMGL_Truckride                           = 63,
	YWPC_MilkorMGL_AI                                  = 64,
	YWPC_MAX                                           = 65
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponVariationPurpose
/*enum YE_WeaponVariationPurpose
{
	YWVP_Unknown                                       = 0,
	YWVP_ForAI                                         = 1,
	YWVP_ForMultiplayer                                = 2,
	YWVP_PlaceHolder1                                  = 3,
	YWVP_PlaceHolder2                                  = 4,
	YWVP_ForScndFire                                   = 5,
	YWVP_Silencer                                      = 6,
	YWVP_SemiAuto                                      = 7,
	YWVP_FullAuto                                      = 8,
	YWVP_BurstFire                                     = 9,
	YWVP_LaserSight                                    = 10,
	YWVP_UnderBarrel                                   = 11,
	YWVP_Scope                                         = 12,
	YWVP_MAX                                           = 13
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponActiveScndMode
/*enum YE_WeaponActiveScndMode
{
	YWASM_None                                         = 0,
	YWASM_SilencerOff                                  = 1,
	YWASM_SilencerOn                                   = 2,
	YWASM_LauncherOff                                  = 3,
	YWASM_LauncherOn                                   = 4,
	YWASM_ScopeOff                                     = 5,
	YWASM_ScopeOn                                      = 6,
	YWASM_HighPowerScopeOff                            = 7,
	YWASM_HighPowerScopeOn                             = 8,
	YWASM_LaserSightOff                                = 9,
	YWASM_LaserSightOn                                 = 10,
	YWASM_BurstInsteadAuto                             = 11,
	YWASM_AutoInsteadBurst                             = 12,
	YWASM_MAX                                          = 13
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_FireFxReplicationFlags
/*enum YE_FireFxReplicationFlags
{
	YFFX_None                                          = 0,
	YFFX_MuzzleFire                                    = 1,
	YFFX_MuzzleSound                                   = 2,
	YFFX_03                                            = 3,
	YFFX_Tracer                                        = 4,
	YFFX_05                                            = 5,
	YFFX_06                                            = 6,
	YFFX_07                                            = 7,
	YFFX_Impact                                        = 8,
	YFFX_09                                            = 9,
	YFFX_0a                                            = 10,
	YFFX_0b                                            = 11,
	YFFX_0c                                            = 12,
	YFFX_0d                                            = 13,
	YFFX_0e                                            = 14,
	YFFX_0f                                            = 15,
	YFFX_ClusteredImpact                               = 16,
	YFFX_MAX                                           = 17
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_ImpactFxTypeFlags
/*enum YE_ImpactFxTypeFlags
{
	YIFX_None                                          = 0,
	YIFX_Debug                                         = 1,
	YIFX_Decal                                         = 2,
	YIFX_03                                            = 3,
	YIFX_Particles                                     = 4,
	YIFX_05                                            = 5,
	YIFX_06                                            = 6,
	YIFX_07                                            = 7,
	YIFX_Sound                                         = 8,
	YIFX_MAX                                           = 9
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_DamageSpatialization
/*enum YE_DamageSpatialization
{
	YDSP_Linear                                        = 0,
	YDSP_Radial                                        = 1,
	YDSP_Cone                                          = 2,
	YDSP_MAX                                           = 3
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_DamageTemperization
/*enum YE_DamageTemperization
{
	YDTE_Instant                                       = 0,
	YDTE_Linear                                        = 1,
	YDTE_MAX                                           = 2
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_DamageAmplification
/*enum YE_DamageAmplification
{
	YDAM_Constant                                      = 0,
	YDAM_LinearFalloff                                 = 1,
	YDAM_SquaredFalloff                                = 2,
	YDAM_RootedFalloff                                 = 3,
	YDAM_MAX                                           = 4
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_DamageFalloffCalcMode
/*enum YE_DamageFalloffCalcMode
{
	YDFC_None                                          = 0,
	YDFC_EffectsOnly                                   = 1,
	YDFC_DamageOnly                                    = 2,
	YDFC_EffectsAndDamage                              = 3,
	YDFC_MAX                                           = 4
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_DamageImpactTypes
/*enum YE_DamageImpactTypes
{
	YDIT_Unspecified                                   = 0,
	YDIT_Assault                                       = 1,
	YDIT_Submachine                                    = 2,
	YDIT_Shotgun                                       = 3,
	YDIT_AA12                                          = 4,
	YDIT_SAW                                           = 5,
	YDIT_Sniper                                        = 6,
	YDIT_Explosive                                     = 7,
	YDIT_KillShotStd                                   = 8,
	YDIT_KillShotShotgun                               = 9,
	YDIT_KillShotSniper                                = 10,
	YDIT_KillShotAA12                                  = 11,
	YDIT_Turret                                        = 12,
	YDIT_MiniGun                                       = 13,
	YDIT_MiniGunOnFlight                               = 14,
	YDIT_Flames                                        = 15,
	YDIT_Melee                                         = 16,
	YDIT_Execution                                     = 17,
	YDIT_Falling                                       = 18,
	YDIT_Logout                                        = 19,
	YDIT_SandAvalanche                                 = 20,
	YDIT_ProjBounce                                    = 21,
	YDIT_MAX                                           = 22
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_TracerCategory
/*enum YE_TracerCategory
{
	YTRC_Always                                        = 0,
	YTRC_Autonomous                                    = 1,
	YTRC_Exclusive                                     = 2,
	YTRC_Bullet                                        = 3,
	YTRC_SmokeTrail                                    = 4,
	YTRC_MAX                                           = 5
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponJunctures
/*enum YE_WeaponJunctures
{
	YWEV_Never                                         = 0,
	YWEV_OnEquipStart                                  = 1,
	YWEV_OnEquipFinished                               = 2,
	YWEV_OnUnequipStart                                = 3,
	YWEV_OnUnequipFinished                             = 4,
	YWEV_OnPressFire                                   = 5,
	YWEV_OnReleaseFire                                 = 6,
	YWEV_OnShot                                        = 7,
	YWEV_OnReload                                      = 8,
	YWEV_MAX                                           = 9
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponCategories
/*enum YE_WeaponCategories
{
	YWCT_None                                          = 0,
	YWCT_Faction                                       = 1,
	YWCT_Heavy                                         = 2,
	YWCT_Lightweight                                   = 3,
	YWCT_Explosive                                     = 4,
	YWCT_Stationary                                    = 5,
	YWCT_Debug                                         = 6,
	YWCT_MAX                                           = 7
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponAchievCategory
/*enum YE_WeaponAchievCategory
{
	YWAC_None                                          = 0,
	YWAC_Rifle                                         = 1,
	YWAC_Sniper                                        = 2,
	YWAC_LightWeight                                   = 3,
	YWAC_Explosive                                     = 4,
	YWAC_ShotGun                                       = 5,
	YWAC_Heavy                                         = 6,
	YWAC_MAX                                           = 7
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_FiringAnimCallBackType
/*enum YE_FiringAnimCallBackType
{
	YFCB_NoCallBack                                    = 0,
	YFCB_EndThrowGrenade                               = 1,
	YFCB_MAX                                           = 2
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponDetachReason
/*enum YE_WeaponDetachReason
{
	YWDR_None                                          = 0,
	YWDR_MirrorTransition                              = 1,
	YWDR_Command                                       = 2,
	YWDR_Refire                                        = 3,
	YWDR_Reload                                        = 4,
	YWDR_SwitchWeapon                                  = 5,
	YWDR_GrenadeThrow                                  = 6,
	YWDR_MAX                                           = 7
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_PickupActionType
/*enum YE_PickupActionType
{
	YPKA_PickupAmmo                                    = 0,
	YPKA_PickupWeapon                                  = 1,
	YPKA_SwapWeapon                                    = 2,
	YPKA_WaitingWeaponPickup                           = 3,
	YPKA_PickupHealth                                  = 4,
	YPKA_DestroyPickup                                 = 5,
	YPKA_WaitingHealthPickup                           = 6,
	YPKA_GenericAmmo                                   = 7,
	YPKA_WaitingGenericAmmo                            = 8,
	YPKA_MAX                                           = 9
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_PickupAnimType
/*enum YE_PickupAnimType
{
	YPAT_Standard                                      = 0,
	YPAT_BulletBox                                     = 1,
	YPAT_AmmoCrate                                     = 2,
	YPAT_MAX                                           = 3
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_RefireType
/*enum YE_RefireType
{
	YRFT_SingleShot                                    = 0,
	YRFT_Automatic                                     = 1,
	YRFT_FireBursts                                    = 2,
	YRFT_None                                          = 3,
	YRFT_MAX                                           = 4
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_ScopeType
/*enum YE_ScopeType
{
	YSCT_None                                          = 0,
	YSCT_StandardScope                                 = 1,
	YSCT_SniperScope                                   = 2,
	YSCT_MAX                                           = 3
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponAnim
/*enum YE_WeaponAnim
{
	YWPA_Idle                                          = 0,
	YWPA_Firing                                        = 1,
	YWPA_EmptyDuringReload                             = 2,
	YWPA_Windup                                        = 3,
	YWPA_Generic                                       = 4,
	YWPA_MAX                                           = 5
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponSubmeshBone
/*enum YE_WeaponSubmeshBone
{
	YWSB_Magazine                                      = 0,
	YWSB_Silencer                                      = 1,
	YWSB_MAX                                           = 2
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponSubmeshEvent
/*enum YE_WeaponSubmeshEvent
{
	YWSE_HideBoneAndSpawnActor                         = 0,
	YWSE_HideBoneAndShowAtPawn                         = 1,
	YWSE_HideAtPawnAndSpawnActor                       = 2,
	YWSE_OnlyShowAtPawnNow                             = 3,
	YWSE_ShowWeaponBoneAgain                           = 4,
	YWSE_OnlyHideBone                                  = 5,
	YWSE_OnlyHideAtPawn                                = 6,
	YWSE_MAX                                           = 7
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_WeaponModType
/*enum YE_WeaponModType
{
	YWMT_RefireType                                    = 0,
	YWMT_ScopeType                                     = 1,
	YWMT_SRGunFireMode                                 = 2,
	YWMT_GrenadeType                                   = 3,
	YWMT_SilencerType                                  = 4,
	YWMT_Any                                           = 5,
	YWMT_MAX                                           = 6
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_GrenadeDirectionInCover
/*enum YE_GrenadeDirectionInCover
{
	YGDIC_TowardsCover                                 = 0,
	YGDIC_InFaceDirection                              = 1,
	YGDIC_AwayFromCover                                = 2,
	YGDIC_Backwards                                    = 3,
	YGDIC_MAX                                          = 4
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_GrenadeTypes
/*enum YE_GrenadeTypes
{
	YGTP_None                                          = 0,
	YGTP_Frag                                          = 1,
	YGTP_Percussion                                    = 2,
	YGTP_MPFragGrenade                                 = 3,
	YGTP_MPPercussion                                  = 4,
	YGTP_MPMine                                        = 5,
	YGTP_MPC4                                          = 6,
	YGTP_Proxy                                         = 7,
	YGTP_Sticky                                        = 8,
	YGTP_Phosphor                                      = 9,
	YGTP_Stun                                          = 10,
	YGTP_Cluster                                       = 11,
	YGTP_Stone                                         = 12,
	YGTP_MPStone                                       = 13,
	YGTP_MPOfficerBeacon                               = 14,
	YGTP_MPOfficerSupply                               = 15,
	YGTP_MAX                                           = 16
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_GrenadeThrowingStage
/*enum YE_GrenadeThrowingStage
{
	YGTS_LongIn                                        = 0,
	YGTS_LongIdle                                      = 1,
	YGTS_LongThrow                                     = 2,
	YGTS_LongOut                                       = 3,
	YGTS_LongSkip                                      = 4,
	YGTS_NoAnimPlaying                                 = 5,
	YGTS_MAX                                           = 6
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_GrenadeThrowAnimStyle
/*enum YE_GrenadeThrowAnimStyle
{
	YGTAS_None                                         = 0,
	YGTAS_Stand                                        = 1,
	YGTAS_Crouch                                       = 2,
	YGTAS_StandCover                                   = 3,
	YGTAS_StandEdge                                    = 4,
	YGTAS_StandBlindEdge                               = 5,
	YGTAS_StandAimOut                                  = 6,
	YGTAS_StandAimAround                               = 7,
	YGTAS_CrouchCover                                  = 8,
	YGTAS_CrouchEdge                                   = 9,
	YGTAS_CrouchAimOver                                = 10,
	YGTAS_CrouchAimDown                                = 11,
	YGTAS_CrouchBlindEdge                              = 12,
	YGTAS_CrouchAimOut                                 = 13,
	YGTAS_CrouchAimAround                              = 14,
	YGTAS_Zipline                                      = 15,
	YGTAS_MAX                                          = 16
};*/

// Enum SRGame.YGlobalWeaponIncludes.YE_ExecutionWeaponType
/*enum YE_ExecutionWeaponType
{
	YEWT_Pistol                                        = 0,
	YEWT_Rifle                                         = 1,
	YEWT_All                                           = 2,
	YEWT_MAX                                           = 3
};*/

// Enum SRGame.YDifficultyProvider.YE_DifficultyLevel
/*enum YE_DifficultyLevel
{
	YEDIFF_Easy                                        = 0,
	YEDIFF_Normal                                      = 1,
	YEDIFF_Hard                                        = 2,
	YEDIFF_Insane                                      = 3,
	YEDIFF_MAX                                         = 4
};*/

// Enum SRGame.YProfileSettings.YE_GameMission
/*enum YE_GameMission
{
	YMISSION                                           = 0,
	YMISSION01                                         = 1,
	YMISSION02                                         = 2,
	YMISSION03                                         = 3,
	YMISSION04                                         = 4,
	YMISSION05                                         = 5,
	YMISSION06                                         = 6,
	YMISSION07                                         = 7,
	YMISSION08                                         = 8,
	YMISSION09                                         = 9,
	YMISSION10                                         = 10,
	YMISSION11                                         = 11,
	YMISSION12                                         = 12,
	YMISSION13                                         = 13,
	YMISSION14                                         = 14,
	YMISSION15                                         = 15,
	YMISSION16                                         = 16,
	YMISSION17                                         = 17,
	YMISSION_Invalid                                   = 18,
	YMISSION_MAX                                       = 19
};*/

// Enum SRGame.YProfileSettings.YECampaignMemorySlot
/*enum YECampaignMemorySlot
{
	YCMS_Slot                                          = 0,
	YCMS_Slot01                                        = 1,
	YCMS_Slot02                                        = 2,
	YCMS_Slot03                                        = 3,
	YCMS_Slot_MAX                                      = 4
};*/

// Enum SRGame.YTribool.YE_Tribool
/*enum YE_Tribool
{
	YTRI_False                                         = 0,
	YTRI_True                                          = 1,
	YTRI_Indeterminate                                 = 2,
	YTRI_MAX                                           = 3
};*/

// Enum SRGame.YPerk.YE_PerkType
/*enum YE_PerkType
{
	YPKT_Minor                                         = 0,
	YPKT_Major                                         = 1,
	YPKT_MAX                                           = 2
};*/

// Enum SRGame.YPerk.YE_MPCharacterTypes
/*enum YE_MPCharacterTypes
{
	YMPCT_SpecOpsDefault                               = 0,
	YMPCT_KonradDefault                                = 1,
	YMPCT_Rage                                         = 2,
	YMPCT_ExplosiveExpert                              = 3,
	YMPCT_TacticalExpert                               = 4,
	YMPCT_HeavyTrooper                                 = 5,
	YMPCT_Fremen                                       = 6,
	YMPCT_Hunter                                       = 7,
	YMPCT_RageLevel2                                   = 8,
	YMPCT_ExplosiveExpertLevel2                        = 9,
	YMPCT_HeavyTrooperLevel2                           = 10,
	YMPCT_TacticalExpertLevel2                         = 11,
	YMPCT_FremenLevel2                                 = 12,
	YMPCT_HunterLevel2                                 = 13,
	YMPCT_HordeWalker                                  = 14,
	YMPCT_HordeAdams                                   = 15,
	YMPCT_HordeLugo                                    = 16,
	YMPCT_HordeRiggs                                   = 17,
	YMPCT_NoOverrideModel                              = 18,
	YMPCT_MAX                                          = 19
};*/

// Enum SRGame.YPerk.YE_Perk
/*enum YE_Perk
{
	YEP_NoPerk                                         = 0,
	YEP_Breacher                                       = 1,
	YEP_Gunner                                         = 2,
	YEP_Medic                                          = 3,
	YEP_Officer                                        = 4,
	YEP_Scavenger                                      = 5,
	YEP_Sniper                                         = 6,
	YEP_SpecOpsPerks                                   = 7,
	YEP_KonradPerks                                    = 8,
	YEP_HordeWalker                                    = 9,
	YEP_HordeAdams                                     = 10,
	YEP_HordeLugo                                      = 11,
	YEP_HordeRiggs                                     = 12,
	YEP_Bandoleer                                      = 13,
	YEP_SuperLead                                      = 14,
	YEP_Regeneration                                   = 15,
	YEP_GrenadeAlert                                   = 16,
	YEP_Tough                                          = 17,
	YEP_KillerInstinct                                 = 18,
	YEP_SteadyAim                                      = 19,
	YEP_FastReload                                     = 20,
	YEP_Speedy                                         = 21,
	YEP_EagleEye                                       = 22,
	YEP_ExplosivePlusOne                               = 23,
	YEP_Accuracy                                       = 24,
	YEP_LastBreath                                     = 25,
	YEP_BlindFire                                      = 26,
	YEP_FeignDeath                                     = 27,
	YEP_Medkit                                         = 28,
	YEP_Learning                                       = 29,
	YEP_FireRate                                       = 30,
	YEP_SlowBreath                                     = 31,
	YEP_FastSwap                                       = 32,
	YEP_ExtendedClips                                  = 33,
	YEP_Cowboy                                         = 34,
	YEP_Melee                                          = 35,
	YEP_MeleeRush                                      = 36,
	YEP_Runner                                         = 37,
	YEP_RecoilSuppressor                               = 38,
	YEP_CoverRat                                       = 39,
	YEP_SupportOps                                     = 40,
	YEP_NameTaker                                      = 41,
	YEP_TacticalOfficer                                = 42,
	YEP_DesertWarrior                                  = 43,
	YEP_NoMercy                                        = 44,
	YEP_JazzHands                                      = 45,
	YEP_ShockTroop                                     = 46,
	YEP_Commando                                       = 47,
	YEP_Survivor                                       = 48,
	YEP_Reaper                                         = 49,
	YEP_CombatReady                                    = 50,
	YEP_FieldOperative                                 = 51,
	YEP_Trapper                                        = 52,
	YEP_Scrambler                                      = 53,
	YEP_Stealthy                                       = 54,
	YEP_GunSlinger                                     = 55,
	YEP_UnknownKiller                                  = 56,
	YEP_SpecialWeapons                                 = 57,
	YEP_MetalDetector                                  = 58,
	YEP_CombatOperative                                = 59,
	YEP_MAX                                            = 60
};*/

// Enum SRGame.YProfileSettings.YE_ItemType
/*enum YE_ItemType
{
	YIT_None                                           = 0,
	YIT_Weapon                                         = 1,
	YIT_Perk                                           = 2,
	YIT_ClassSlot                                      = 3,
	YIT_Challenge                                      = 4,
	YIT_Title                                          = 5,
	YIT_Badge                                          = 6,
	YIT_MAX                                            = 7
};*/

// Enum SRGame.YProfileSettings.YE_CharacterSlotItem
/*enum YE_CharacterSlotItem
{
	YCSI_SpecopsSlot1                                  = 0,
	YCSI_SpecopsSlot2                                  = 1,
	YCSI_SpecopsSlot3                                  = 2,
	YCSI_SpecopsSlot4                                  = 3,
	YCSI_SpecopsSlot5                                  = 4,
	YCSI_KonradSlot1                                   = 5,
	YCSI_KonradSlot2                                   = 6,
	YCSI_KonradSlot3                                   = 7,
	YCSI_KonradSlot4                                   = 8,
	YCSI_KonradSlot5                                   = 9,
	YCSI_MAX                                           = 10
};*/

// Enum SRGame.YProfileSettings.YE_ProfileStatUpdateCondition
/*enum YE_ProfileStatUpdateCondition
{
	YPSUC_None                                         = 0,
	YPSUC_RankedMatch                                  = 1,
	YPSUC_ChallengesAvailable                          = 2,
	YPSUC_ModeChallengesAvailable                      = 3,
	YPSUC_MAX                                          = 4
};*/

// Enum SRGame.YProfileSettings.YE_ProfileStatUpdateMethod
/*enum YE_ProfileStatUpdateMethod
{
	YPSUM_TakeMin                                      = 0,
	YPSUM_TakeMax                                      = 1,
	YPSUM_DoSum                                        = 2,
	YPSUM_TakeLast                                     = 3,
	YPSUM_BinaryAnd                                    = 4,
	YPSUM_BinaryOr                                     = 5,
	YPSUM_MAX                                          = 6
};*/

// Enum SRGame.YProfileSettings.YE_ProfileStatDataType
/*enum YE_ProfileStatDataType
{
	YPSDT_None                                         = 0,
	YPSDT_Byte                                         = 1,
	YPSDT_Int16                                        = 2,
	YPSDT_Int32                                        = 3,
	YPSDT_Bitfield8                                    = 4,
	YPSDT_Bitfield16                                   = 5,
	YPSDT_Bitfield32                                   = 6,
	YPSDT_Float                                        = 7,
	YPSDT_MAX                                          = 8
};*/

// Enum SRGame.YProfileSettings.YE_ChallengeID
/*enum YE_ChallengeID
{
	YCI_BASIC_TRAINING_START                           = 0,
	YCI_Marksman_Handgun1                              = 1,
	YCI_Marksman_Handgun2                              = 2,
	YCI_Marksman_Handgun3                              = 3,
	YCI_Marksman_Handgun4                              = 4,
	YCI_Marksman_Handgun5                              = 5,
	YCI_Marksman_Shotgun1                              = 6,
	YCI_Marksman_Shotgun2                              = 7,
	YCI_Marksman_Shotgun3                              = 8,
	YCI_Marksman_Shotgun4                              = 9,
	YCI_Marksman_Shotgun5                              = 10,
	YCI_Marksman_SMG1                                  = 11,
	YCI_Marksman_SMG2                                  = 12,
	YCI_Marksman_SMG3                                  = 13,
	YCI_Marksman_SMG4                                  = 14,
	YCI_Marksman_SMG5                                  = 15,
	YCI_Marksman_Assault1                              = 16,
	YCI_Marksman_Assault2                              = 17,
	YCI_Marksman_Assault3                              = 18,
	YCI_Marksman_Assault4                              = 19,
	YCI_Marksman_Assault5                              = 20,
	YCI_Marksman_Sniper1                               = 21,
	YCI_Marksman_Sniper2                               = 22,
	YCI_Marksman_Sniper3                               = 23,
	YCI_Marksman_Sniper4                               = 24,
	YCI_Marksman_Sniper5                               = 25,
	YCI_Marksman_LMG1                                  = 26,
	YCI_Marksman_LMG2                                  = 27,
	YCI_Marksman_LMG3                                  = 28,
	YCI_Marksman_LMG4                                  = 29,
	YCI_Marksman_LMG5                                  = 30,
	YCI_Qualification_Handgun1                         = 31,
	YCI_Qualification_Handgun2                         = 32,
	YCI_Qualification_Handgun3                         = 33,
	YCI_Qualification_Handgun4                         = 34,
	YCI_Qualification_Handgun5                         = 35,
	YCI_Qualification_Shotgun1                         = 36,
	YCI_Qualification_Shotgun2                         = 37,
	YCI_Qualification_Shotgun3                         = 38,
	YCI_Qualification_Shotgun4                         = 39,
	YCI_Qualification_Shotgun5                         = 40,
	YCI_Qualification_SMG1                             = 41,
	YCI_Qualification_SMG2                             = 42,
	YCI_Qualification_SMG3                             = 43,
	YCI_Qualification_SMG4                             = 44,
	YCI_Qualification_SMG5                             = 45,
	YCI_Qualification_Assault1                         = 46,
	YCI_Qualification_Assault2                         = 47,
	YCI_Qualification_Assault3                         = 48,
	YCI_Qualification_Assault4                         = 49,
	YCI_Qualification_Assault5                         = 50,
	YCI_Qualification_Sniper1                          = 51,
	YCI_Qualification_Sniper2                          = 52,
	YCI_Qualification_Sniper3                          = 53,
	YCI_Qualification_Sniper4                          = 54,
	YCI_Qualification_Sniper5                          = 55,
	YCI_Qualification_LMG1                             = 56,
	YCI_Qualification_LMG2                             = 57,
	YCI_Qualification_LMG3                             = 58,
	YCI_Qualification_LMG4                             = 59,
	YCI_Qualification_LMG5                             = 60,
	YCI_Qualification_RPG1                             = 61,
	YCI_Qualification_RPG2                             = 62,
	YCI_Qualification_RPG3                             = 63,
	YCI_Qualification_RPG4                             = 64,
	YCI_Qualification_RPG5                             = 65,
	YCI_Qualification_Grenade1                         = 66,
	YCI_Qualification_Grenade2                         = 67,
	YCI_Qualification_Grenade3                         = 68,
	YCI_Qualification_Grenade4                         = 69,
	YCI_Qualification_Grenade5                         = 70,
	YCI_Qualification_Launcher1                        = 71,
	YCI_Qualification_Launcher2                        = 72,
	YCI_Qualification_Launcher3                        = 73,
	YCI_Qualification_Launcher4                        = 74,
	YCI_Qualification_Launcher5                        = 75,
	YCI_INDIVIDUAL_START                               = 76,
	YCI_Hunter                                         = 77,
	YCI_Avalanche                                      = 78,
	YCI_BadKnees                                       = 79,
	YCI_BigBang                                        = 80,
	YCI_BlindFire                                      = 81,
	YCI_CYouLater                                      = 82,
	YCI_Captain                                        = 83,
	YCI_Crazy                                          = 84,
	YCI_Daredevil                                      = 85,
	YCI_DeadBang                                       = 86,
	YCI_DogTagging                                     = 87,
	YCI_Drunk                                          = 88,
	YCI_Executioner                                    = 89,
	YCI_Experienced                                    = 90,
	YCI_Exposed                                        = 91,
	YCI_Friendly                                       = 92,
	YCI_FromYourColdDeadFingers                        = 93,
	YCI_GangBang                                       = 94,
	YCI_GetItOff                                       = 95,
	YCI_HaveANiceTrip                                  = 96,
	YCI_HeavyMetal                                     = 97,
	YCI_Hoarder                                        = 98,
	YCI_HugeLoad                                       = 99,
	YCI_ICanSeeClearlyNow                              = 100,
	YCI_ISeeYou                                        = 101,
	YCI_IED                                            = 102,
	YCI_InstantExecutioner                             = 103,
	YCI_ItComesWithPerks                               = 104,
	YCI_JumpKick                                       = 105,
	YCI_Jumper                                         = 106,
	YCI_JustSand                                       = 107,
	YCI_KeepOnFighting                                 = 108,
	YCI_KillTheKillCam                                 = 109,
	YCI_Killer                                         = 110,
	YCI_KillingSpree                                   = 111,
	YCI_King                                           = 112,
	YCI_Logistics                                      = 113,
	YCI_LongDistanceRelationship                       = 114,
	YCI_Martyr                                         = 115,
	YCI_Medic                                          = 116,
	YCI_MovieBuff                                      = 117,
	YCI_MVP                                            = 118,
	YCI_Nemesis                                        = 119,
	YCI_NineLives                                      = 120,
	YCI_Noob                                           = 121,
	YCI_Nothing                                        = 122,
	YCI_NothingToSeeHere                               = 123,
	YCI_OnTheBench                                     = 124,
	YCI_OneManArmy                                     = 125,
	YCI_OrderedToKill                                  = 126,
	YCI_PickupArtist                                   = 127,
	YCI_Poison                                         = 128,
	YCI_PostMortem                                     = 129,
	YCI_Pusher                                         = 130,
	YCI_Revenge                                        = 131,
	YCI_SandWarrior                                    = 132,
	YCI_SelfDestructive                                = 133,
	YCI_SerialKiller                                   = 134,
	YCI_Sighted                                        = 135,
	YCI_Spotter                                        = 136,
	YCI_SprayPainter                                   = 137,
	YCI_SuperBad                                       = 138,
	YCI_Headcase                                       = 139,
	YCI_TheBoss                                        = 140,
	YCI_Traveler                                       = 141,
	YCI_TriggerMan                                     = 142,
	YCI_UnderCover                                     = 143,
	YCI_UpClose                                        = 144,
	YCI_WeaponsMaster                                  = 145,
	YCI_YouHaveToBurnTheRope                           = 146,
	YCI_ZipidyDoDie                                    = 147,
	YCI_RightTool                                      = 148,
	YCI_Scanner                                        = 149,
	YCI_PerfectSoldier                                 = 150,
	YCI_MAX                                            = 151,
	YUI_Linkd                                          = 152,
	YCI_INDIVIDUAL_END                                 = 153,
	YCI_MODE_START                                     = 154,
	YCI_TeamPlayer                                     = 155,
	YCI_TerminalDestroyer                              = 156,
	YCI_BlowYourHouseDown                              = 157,
	YCI_FixerUpper                                     = 158,
	YCI_Eliminator                                     = 159,
	YCI_GiantTool                                      = 160,
	YCI_DigitalBoy                                     = 161,
	YCI_KnowWhenToHoldThem                             = 162,
	YCI_LastManStanding                                = 163,
	YCI_PowerOutage                                    = 164,
	YCI_Psychic                                        = 165,
	YCI_RallyRace                                      = 166,
	YCI_StayingAlive                                   = 167,
	YCI_Unstoppable                                    = 168,
	YCI                                                = 169,
	YCI_Breacher                                       = 170,
	YCI_Builder                                        = 171,
	YCI_MODE_END                                       = 172,
	YCI_DLC2_START                                     = 173,
	YCI_Raider                                         = 174,
	YCI_Viking                                         = 175,
	YCI_Thief                                          = 176,
	YCI_Looter                                         = 177,
	YCI_WallStreet                                     = 178,
	YCI_Admin                                          = 179,
	YCI_Electician                                     = 180,
	YCI_Silencer                                       = 181,
	YCI_First                                          = 182,
	YCI_DLC2_END                                       = 183,
	YCI_DLC3_START                                     = 184,
	YCI_NoReturns                                      = 185,
	YCI_ReturnToSender                                 = 186,
	YCI_AntiBomber                                     = 187,
	YCI_Gardener                                       = 188,
	YCI_TheBomber                                      = 189,
	YCI_Intercepter                                    = 190,
	YCI_ATC                                            = 191,
	YCI_Tagger                                         = 192,
	YCI_Radar                                          = 193,
	YCI_Denied                                         = 194,
	YCI_ChopperDown                                    = 195,
	YCI_DLC3_END                                       = 196,
	YE_ChallengeID_MAX                                 = 197
};*/

// Enum SRGame.YProfileSettings.YE_ChallengeConditionOperator
/*enum YE_ChallengeConditionOperator
{
	YCCO_And                                           = 0,
	YCCO_Or                                            = 1,
	YCCO_MAX                                           = 2
};*/

// Enum SRGame.YProfileSettings.YE_TargetTeam
/*enum YE_TargetTeam
{
	YTTI_None                                          = 0,
	YTTI_SpecOps                                       = 1,
	YTTI_Konrad                                        = 2,
	YTTI_Both                                          = 3,
	YTTI_MAX                                           = 4
};*/

// Enum SRGame.YProfileSettings.YE_ChallengeSection
/*enum YE_ChallengeSection
{
	YCS_BasicTraining                                  = 0,
	YCS_FactionTraining                                = 1,
	YCS_CompetitiveModes                               = 2,
	YCS_Crossplayer                                    = 3,
	YCS_MAX                                            = 4
};*/

// Enum SRGame.YProfileSettings.EProfileSensitivity
/*enum EProfileSensitivity
{
	PSENS                                              = 0,
	PSENS01                                            = 1,
	PSENS02                                            = 2,
	PSENS03                                            = 3,
	PSENS04                                            = 4,
	PSENS05                                            = 5,
	PSENS06                                            = 6,
	PSENS07                                            = 7,
	PSENS08                                            = 8,
	PSENS09                                            = 9,
	PSENS10                                            = 10,
	PSENS_MAX                                          = 11
};*/

// Enum SRGame.YProfileSettings.YE_EquipmentSlot
/*enum YE_EquipmentSlot
{
	YET_MajorPerk                                      = 0,
	YET_MinorPerk1                                     = 1,
	YET_MinorPerk2                                     = 2,
	YET_PrimaryWeapon                                  = 3,
	YET_SecondaryWeapon                                = 4,
	YET_Explosives                                     = 5,
	YET_MinorPerk3                                     = 6,
	YET_Anything                                       = 7,
	YET_MAX                                            = 8
};*/

// Enum SRGame.YProfileSettings.YE_EquipmentClass
/*enum YE_EquipmentClass
{
	YEC_PrimaryWeapon                                  = 0,
	YEC_SecondaryWeapon                                = 1,
	YEC_Explosive                                      = 2,
	YEC_MajorPerks                                     = 3,
	YEC_MinorPerks                                     = 4,
	YEC_MAX                                            = 5
};*/

// Enum SRGame.YProfileSettings.EProfileAimSnapOnOptions
/*enum EProfileAimSnapOnOptions
{
	PASO_Default                                       = 0,
	PASO_AimSnapOnOn                                   = 1,
	PASO_AimSnapOnOff                                  = 2,
	PASO_MAX                                           = 3
};*/

// Enum SRGame.YProfileSettings.EProfileButtonLayoutOptions
/*enum EProfileButtonLayoutOptions
{
	PBLO_Default                                       = 0,
	PBLO_Alternative1                                  = 1,
	PBLO_MAX                                           = 2
};*/

// Enum SRGame.YProfileSettings.EProfileReverseStickOptions
/*enum EProfileReverseStickOptions
{
	PRSO_Off                                           = 0,
	PRSO_On                                            = 1,
	PRSO_MAX                                           = 2
};*/

// Enum SRGame.YProfileSettings.YE_BindableKeys
/*enum YE_BindableKeys
{
	YBND_Unbound                                       = 0,
	YBND_MouseX                                        = 1,
	YBND_MouseY                                        = 2,
	YBND_MouseScrollUp                                 = 3,
	YBND_MouseScrollDown                               = 4,
	YBND_LeftMouseButton                               = 5,
	YBND_RightMouseButton                              = 6,
	YBND_MiddleMouseButton                             = 7,
	YBND_ThumbMouseButton                              = 8,
	YBND_ThumbMouseButton2                             = 9,
	YBND_BackSpace                                     = 10,
	YBND_Tab                                           = 11,
	YBND_Enter                                         = 12,
	YBND_Pause                                         = 13,
	YBND_CapsLock                                      = 14,
	YBND_Escape                                        = 15,
	YBND_SpaceBar                                      = 16,
	YBND_PageUp                                        = 17,
	YBND_PageDown                                      = 18,
	YBND_End                                           = 19,
	YBND_Home                                          = 20,
	YBND_Left                                          = 21,
	YBND_Up                                            = 22,
	YBND_Right                                         = 23,
	YBND_Down                                          = 24,
	YBND_Insert                                        = 25,
	YBND_Delete                                        = 26,
	YBND_Zero                                          = 27,
	YBND_One                                           = 28,
	YBND_Two                                           = 29,
	YBND_Three                                         = 30,
	YBND_Four                                          = 31,
	YBND_Five                                          = 32,
	YBND_Six                                           = 33,
	YBND_Seven                                         = 34,
	YBND_Eight                                         = 35,
	YBND_Nine                                          = 36,
	YBND_A                                             = 37,
	YBND_B                                             = 38,
	YBND_C                                             = 39,
	YBND_D                                             = 40,
	YBND_E                                             = 41,
	YBND_F                                             = 42,
	YBND_G                                             = 43,
	YBND_H                                             = 44,
	YBND_I                                             = 45,
	YBND_J                                             = 46,
	YBND_K                                             = 47,
	YBND_L                                             = 48,
	YBND_M                                             = 49,
	YBND_N                                             = 50,
	YBND_O                                             = 51,
	YBND_P                                             = 52,
	YBND_Q                                             = 53,
	YBND_R                                             = 54,
	YBND_S                                             = 55,
	YBND_T                                             = 56,
	YBND_U                                             = 57,
	YBND_V                                             = 58,
	YBND_W                                             = 59,
	YBND_X                                             = 60,
	YBND_Y                                             = 61,
	YBND_Z                                             = 62,
	YBND_NumPadZero                                    = 63,
	YBND_NumPadOne                                     = 64,
	YBND_NumPadTwo                                     = 65,
	YBND_NumPadThree                                   = 66,
	YBND_NumPadFour                                    = 67,
	YBND_NumPadFive                                    = 68,
	YBND_NumPadSix                                     = 69,
	YBND_NumPadSeven                                   = 70,
	YBND_NumPadEight                                   = 71,
	YBND_NumPadNine                                    = 72,
	YBND_Multiply                                      = 73,
	YBND_Add                                           = 74,
	YBND_Subtract                                      = 75,
	YBND_Decimal                                       = 76,
	YBND_Divide                                        = 77,
	YBND_F1                                            = 78,
	YBND_F2                                            = 79,
	YBND_F3                                            = 80,
	YBND_F4                                            = 81,
	YBND_F5                                            = 82,
	YBND_F6                                            = 83,
	YBND_F7                                            = 84,
	YBND_F8                                            = 85,
	YBND_F9                                            = 86,
	YBND_F10                                           = 87,
	YBND_F11                                           = 88,
	YBND_F12                                           = 89,
	YBND_NumLock                                       = 90,
	YBND_ScrollLock                                    = 91,
	YBND_LeftShift                                     = 92,
	YBND_RightShift                                    = 93,
	YBND_LeftControl                                   = 94,
	YBND_RightControl                                  = 95,
	YBND_LeftAlt                                       = 96,
	YBND_RightAlt                                      = 97,
	YBND_Semicolon                                     = 98,
	YBND_Equals                                        = 99,
	YBND_Comma                                         = 100,
	YBND_Underscore                                    = 101,
	YBND_Period                                        = 102,
	YBND_Slash                                         = 103,
	YBND_Tilde                                         = 104,
	YBND_LeftBracket                                   = 105,
	YBND_Backslash                                     = 106,
	YBND_RightBracket                                  = 107,
	YBND_Quote                                         = 108,
	YBND_MAX                                           = 109
};*/

// Enum SRGame.YProfileSettings.YE_GenericInputButton
/*enum YE_GenericInputButton
{
	YGIA_FireWeapon                                    = 0,
	YGIA_Zoom                                          = 1,
	YGIA_Crouch                                        = 2,
	YGIA_PointOfInterest                               = 3,
	YGIA_StartGame                                     = 4,
	YGIA_SprintAndCover                                = 5,
	YGIA_Reload                                        = 6,
	YGIA_Secondary                                     = 7,
	YGIA_Melee                                         = 8,
	YGIA_ChangeWeapon                                  = 9,
	YGIA_Command                                       = 10,
	YGIA_ThrowGrenade                                  = 11,
	YGIA_MoveFwd                                       = 12,
	YGIA_MoveBwd                                       = 13,
	YGIA_MoveLeft                                      = 14,
	YGIA_MoveRight                                     = 15,
	YGIA_Walk                                          = 16,
	YGIA_ShowScores                                    = 17,
	YGIA_ShowObjectives                                = 18,
	YGIA_TogglePrevGrenade                             = 19,
	YGIA_ToggleNextGrenade                             = 20,
	YGIA_MAX                                           = 21
};*/

// Enum SRGame.YProfileSettings.EProfileSouthPawOptions
/*enum EProfileSouthPawOptions
{
	PSPO_Default                                       = 0,
	PSPO_SouthPaw                                      = 1,
	PSPO_MAX                                           = 2
};*/

// Enum SRGame.YProfileSettings.EPostProcessPreset
/*enum EPostProcessPreset
{
	PPP_Default                                        = 0,
	PPP_Muted                                          = 1,
	PPP_Vivid                                          = 2,
	PPP_Intense                                        = 3,
	PPP_MAX                                            = 4
};*/

// Enum SRGame.YProfileSettings.YE_GameChapter
/*enum YE_GameChapter
{
	YCHAPTER                                           = 0,
	YCHAPTER01                                         = 1,
	YCHAPTER02                                         = 2,
	YCHAPTER03                                         = 3,
	YCHAPTER04                                         = 4,
	YCHAPTER05                                         = 5,
	YCHAPTER06                                         = 6,
	YCHAPTER07                                         = 7,
	YCHAPTER08                                         = 8,
	YCHAPTER09                                         = 9,
	YCHAPTER10                                         = 10,
	YCHAPTER11                                         = 11,
	YCHAPTER12                                         = 12,
	YCHAPTER13                                         = 13,
	YCHAPTER14                                         = 14,
	YCHAPTER15                                         = 15,
	YCHAPTER16                                         = 16,
	YCHAPTER17                                         = 17,
	YCHAPTER_CustomMessage                             = 18,
	YCHAPTER_Invalid                                   = 19,
	YCHAPTER_MAX                                       = 20
};*/

// Enum SRGame.YProfileSettings.YECheckpointUsage
/*enum YECheckpointUsage
{
	YCPU_UseLast                                       = 0,
	YCPU_Restart                                       = 1,
	YCPU_MAX                                           = 2
};*/

// Enum SRGame.YUIFrontEnd.YE_IntelEventReason
/*enum YE_IntelEventReason
{
	YIER_Higlighted                                    = 0,
	YIER_Selected                                      = 1,
	YIER_Back                                          = 2,
	YIER_MAX                                           = 3
};*/

// Enum SRGame.YUICharacterCustomPanel.YE_CharacterCustPanel
/*enum YE_CharacterCustPanel
{
	YEPN_INDEX                                         = 0,
	YEPN_LOADOUTS                                      = 1,
	YEPN_CLASSES                                       = 2,
	YEPN_PERKS                                         = 3,
	YEPN_WEAPONS                                       = 4,
	YEPN_ARMOR                                         = 5,
	YEPN_KIT                                           = 6,
	YEPN_MAX                                           = 7
};*/

// Enum SRGame.YUICharacterCustomKitPanel.YE_KitCategory
/*enum YE_KitCategory
{
	YEKC_Head                                          = 0,
	YEKC_Accessories                                   = 1,
	YEKC_Patterns                                      = 2,
	YEKC_Armor                                         = 3,
	YEKC_MAX                                           = 4
};*/

// Enum SRGame.UIComp_DrawTeamString.YE_InterfaceTeamID
/*enum YE_InterfaceTeamID
{
	YITID_Specops                                      = 0,
	YITID_Konrad                                       = 1,
	YITID_MAX                                          = 2
};*/

// Enum SRGame.YAchievementManager.YE_SpecOpsAchievements
/*enum YE_SpecOpsAchievements
{
	YEA_STORY_01                                       = 0,
	YEA_STORY_02                                       = 1,
	YEA_STORY_03                                       = 2,
	YEA_STORY_04                                       = 3,
	YEA_STORY_05                                       = 4,
	YEA_STORY_06                                       = 5,
	YEA_STORY_07                                       = 6,
	YEA_STORY_08                                       = 7,
	YEA_STORY_09                                       = 8,
	YEA_STORY                                          = 9,
	YEA_STORY01                                        = 10,
	YEA_STORY02                                        = 11,
	YEA_STORY03                                        = 12,
	YEA_STORY04                                        = 13,
	YEA_STORY05                                        = 14,
	YEA_STORY06                                        = 15,
	YEA_STORY07                                        = 16,
	YEA_STORY08                                        = 17,
	YEA_STORY09                                        = 18,
	YEA_STORY10                                        = 19,
	YEA_FINISHGAME_01                                  = 20,
	YEA_FINISHGAME_02                                  = 21,
	YEA_FINISHGAME_03                                  = 22,
	YEA_FINISHGAME_04                                  = 23,
	YEA_WEAPONRIFLE                                    = 24,
	YEA_WEAPONSMALL                                    = 25,
	YEA_WEAPONSHOTGUN                                  = 26,
	YEA_WEAPONSNIPER                                   = 27,
	YEA_WEAPONHEAVY                                    = 28,
	YEA_WEAPONGRENADE                                  = 29,
	YEA_HEADSHOT                                       = 30,
	YEA_MELEE                                          = 31,
	YEA_VAULTKICK                                      = 32,
	YEA_BLINDFIRE                                      = 33,
	YEA_COVERDASH                                      = 34,
	YEA_SANDBOMB                                       = 35,
	YEA_EXPLOSIVE                                      = 36,
	YEA_ATTACKCOMMAND                                  = 37,
	YEA_QUICKKILLS                                     = 38,
	YEA_TRAVERSALKILL                                  = 39,
	YEA_COMMANDOKILL                                   = 40,
	YEA_MULTIPLEGRENADE                                = 41,
	YEA_GRENADETHROWKILL                               = 42,
	YEA_STICKYGRENADE                                  = 43,
	YEA_NODEATH                                        = 44,
	YEA_PRECISIONSHOOTING                              = 45,
	YEA_ORYX                                           = 46,
	YEA_INTEL_01                                       = 47,
	YEA_INTEL_02                                       = 48,
	YEA_INTEL_03                                       = 49,
	YEA_MAX                                            = 50
};*/

// Enum SRGame.YDataProvider_Objectives.YE_GameObjective
/*enum YE_GameObjective
{
	YOBJECTIVE_None                                    = 0,
	YOBJECTIVE_Act1_Chapter1                           = 1,
	YOBJECTIVE_Act1_Chapter2                           = 2,
	YOBJECTIVE_Act1_Chapter3                           = 3,
	YOBJECTIVE_Act1_Chapter4                           = 4,
	YOBJECTIVE_Act2_Chapter5                           = 5,
	YOBJECTIVE_Act2_Chapter6                           = 6,
	YOBJECTIVE_Act2_Chapter7                           = 7,
	YOBJECTIVE_Act2_Chapter8                           = 8,
	YOBJECTIVE_Act2_Chapter801                         = 9,
	YOBJECTIVE_Act3_Chapter9                           = 10,
	YOBJECTIVE_Act3_Chapter10                          = 11,
	YOBJECTIVE_Act3_Chapter1001                        = 12,
	YOBJECTIVE_Empty                                   = 13,
	YOBJECTIVE_MAX                                     = 14
};*/

// Enum SRGame.YCoverInfo.YE_TargetPositionType
/*enum YE_TargetPositionType
{
	YTPT_SlipLeft                                      = 0,
	YTPT_SlipRight                                     = 1,
	YTPT_Mantle                                        = 2,
	YTPT_MAX                                           = 3
};*/

// Enum SRGame.YCoverInfo.YE_CoverInfoType
/*enum YE_CoverInfoType
{
	CIT_StandCover                                     = 0,
	CIT_CrouchCover                                    = 1,
	CIT_NoCover                                        = 2,
	CIT_MAX                                            = 3
};*/

// Enum SRGame.YStaticCover.YE_FindCoverPurpose
/*enum YE_FindCoverPurpose
{
	YFCP_TakeCover                                     = 0,
	YFCP_Vault                                         = 1,
	YFCP_DropDown                                      = 2,
	YFCP_LedgeCheck                                    = 3,
	YFCP_MAX                                           = 4
};*/

// Enum SRGame.YStaticCover.YE_CoverStance
/*enum YE_CoverStance
{
	YCST_Default                                       = 0,
	YCST_Stand                                         = 1,
	YCST_Crouch                                        = 2,
	YCST_MAX                                           = 3
};*/

// Enum SRGame.YAICombatPosSet.YE_CombatPosEditorMeshTypes
/*enum YE_CombatPosEditorMeshTypes
{
	YCPMT_AttackPos                                    = 0,
	YCPMT_StandCoverLeft                               = 1,
	YCPMT_StandCoverRight                              = 2,
	YCPMT_CrouchCoverLeft                              = 3,
	YCPMT_CrouchCoverRight                             = 4,
	YCPMT_LeanRightStand                               = 5,
	YCPMT_LeanLeftStand                                = 6,
	YCPMT_LeanRightCrouch                              = 7,
	YCPMT_LeanLeftCrouch                               = 8,
	YCPMT_Popup                                        = 9,
	YCPMT_LeanOver                                     = 10,
	YCPMT_SwatLeft                                     = 11,
	YCPMT_SwatRight                                    = 12,
	YCPMT_SlipLeft                                     = 13,
	YCPMT_SlipRight                                    = 14,
	YCPMT_MoveLeft                                     = 15,
	YCPMT_MoveRight                                    = 16,
	YCPMT_Mantle                                       = 17,
	YCPMT_VaultDrop                                    = 18,
	YCPMT_Climb                                        = 19,
	YCPMT_DropDown                                     = 20,
	YCPMT_ClimbDropDown                                = 21,
	YCPMT_LeanAroundRightStand                         = 22,
	YCPMT_LeanAroundLeftStand                          = 23,
	YCPMT_LeanAroundRightCrouch                        = 24,
	YCPMT_LeanAroundLeftCrouch                         = 25,
	YCPMT_PathObjectInfluenceArea                      = 26,
	YCPMT_AutoAdjust                                   = 27,
	YCPMT_AutoAdjustOff                                = 28,
	YCPMT_NoAI                                         = 29,
	YCPMT_StackingPosLeft                              = 30,
	YCPMT_StackingPosRight                             = 31,
	YCPMT_StepOutLeft                                  = 32,
	YCPMT_StepOutRight                                 = 33,
	YCPMT_ToggleAbleCrouch                             = 34,
	YCPMT_ToggleAbleStand                              = 35,
	YCPMT_SphereView                                   = 36,
	YCPMT_SphereViewBoxHelper                          = 37,
	YCPMT_MAX                                          = 38
};*/

// Enum SRGame.YStaticCover.YE_CoverSlotAction
/*enum YE_CoverSlotAction
{
	YCSA_Stop                                          = 0,
	YCSA_Continue                                      = 1,
	YCSA_PeekStandContinueCrouch                       = 2,
	YCSA_PeekStandPeekCrouch                           = 3,
	YCSA_MAX                                           = 4
};*/

// Enum SRGame.YPlayerController.YE_InteractionActivationType
/*enum YE_InteractionActivationType
{
	YIAT_Standard                                      = 0,
	YIAT_Melee                                         = 1,
	YIAT_Pickup                                        = 2,
	YIAT_Fire                                          = 3,
	YIAT_Zoom                                          = 4,
	YIAT_MAX                                           = 5
};*/

// Enum SRGame.YPlayerController.YE_SpecialMoveButtonType
/*enum YE_SpecialMoveButtonType
{
	YSMBT_None                                         = 0,
	YSMBT_Cover                                        = 1,
	YSMBT_Context                                      = 2,
	YSMBT_Agile                                        = 3,
	YSMBT_MAX                                          = 4
};*/

// Enum SRGame.YPlayerInput_Gamepad.YE_DPadButton
/*enum YE_DPadButton
{
	YDPB_Up                                            = 0,
	YDPB_Down                                          = 1,
	YDPB_Right                                         = 2,
	YDPB_Left                                          = 3,
	YDPB_MAX                                           = 4
};*/

// Enum SRGame.YPlayerInput_Gamepad.YE_InputScheme
/*enum YE_InputScheme
{
	YIS_None                                           = 0,
	YIS_DedicatedMelee                                 = 1,
	YIS_DedicatedMelee_PS                              = 2,
	YIS_MeleeOnShoulder                                = 3,
	YIS_MeleeOnShoulder_PS                             = 4,
	YIS_MP_DBNO                                        = 5,
	YIS_MP_DBNO_PS                                     = 6,
	YIS_MP_Dead                                        = 7,
	YIS_MP_PlayerWaiting                               = 8,
	YIS_PC                                             = 9,
	YIS_MAX                                            = 10
};*/

// Enum SRGame.YContextCommands.YE_ContextCommand
/*enum YE_ContextCommand
{
	YCTX_None                                          = 0,
	YCTX_Regroup                                       = 1,
	YCTX_Hold                                          = 2,
	YCTX_Goto                                          = 3,
	YCTX_AssaultMode                                   = 4,
	YCTX_InfiltrationMode                              = 5,
	YCTX_Heal                                          = 6,
	YCTX_Attack                                        = 7,
	YCTX_SniperAttack                                  = 8,
	YCTX_ClearAreaAttack                               = 9,
	YCTX_Scan                                          = 10,
	YCTX_DeployMortar                                  = 11,
	YCTX_RecallMortar                                  = 12,
	YCTX_MortarAim                                     = 13,
	YCTX_WeaponAim                                     = 14,
	YCTX_FireMortar                                    = 15,
	YCTX_CancelAttack                                  = 16,
	YCTX_OpenFire                                      = 17,
	YCTX_StunEnemies                                   = 18,
	YCTX_FastRopePrepare                               = 19,
	YCTX_FastRopeUseJump                               = 20,
	YCTX_FastRopeUseStraight                           = 21,
	YCTX_ZipLine                                       = 22,
	YCTX_TurretUse                                     = 23,
	YCTX_SuppressiveFire                               = 24,
	YCTX_SquadMarker                                   = 25,
	YCTX_Custom0                                       = 26,
	YCTX_Custom1                                       = 27,
	YCTX_Custom2                                       = 28,
	YCTX_Custom3                                       = 29,
	YCTX_Custom4                                       = 30,
	YCTX_Custom5                                       = 31,
	YCTX_Custom6                                       = 32,
	YCTX_Custom7                                       = 33,
	YCTX_Custom8                                       = 34,
	YCTX_Custom9                                       = 35,
	YCTX_TextOnly                                      = 36,
	YCTX_MAX                                           = 37
};*/

// Enum SRGame.YContextCommands.YE_SquadMember
/*enum YE_SquadMember
{
	YSQMEM_Adams                                       = 0,
	YSQMEM_Lugo                                        = 1,
	YSQMEM_Walker                                      = 2,
	YSQMEM_Daniels                                     = 3,
	YSQMEM_Riggs                                       = 4,
	YSQMEM_Gould                                       = 5,
	YSQMEM_Fari                                        = 6,
	YSQMEM_None                                        = 7,
	YSQMEM_MAX                                         = 8
};*/

// Enum SRGame.YSpecialActionSetTypes.YE_SpecialActionSetTypes
/*enum YE_SpecialActionSetTypes
{
	YSAST_None                                         = 0,
	YSAST_Test1                                        = 1,
	YSAST_GotoCmdGive                                  = 2,
	YSAST_GotoCmdConfirm                               = 3,
	YSAST_GotoCmdDeny                                  = 4,
	YSAST_GotoCmdAbort                                 = 5,
	YSAST_GotoCmdSuccess                               = 6,
	YSAST_RegroupCmdGive                               = 7,
	YSAST_RegroupCmdConfirm                            = 8,
	YSAST_RegroupCmdDeny                               = 9,
	YSAST_RegroupCmdAbort                              = 10,
	YSAST_RegroupCmdSuccess                            = 11,
	YSAST_RegroupCmdFollowing                          = 12,
	YSAST_AttackCmdGive                                = 13,
	YSAST_AttackCmdConfirm                             = 14,
	YSAST_AttackCmdDeny                                = 15,
	YSAST_AttackCmdAbort                               = 16,
	YSAST_AttackCmdSuccess                             = 17,
	YSAST_CancelAttackCmdGive                          = 18,
	YSAST_CancelAttackCmdConfirm                       = 19,
	YSAST_SilentAttackCmdGive                          = 20,
	YSAST_SilentAttackCmdConfirm                       = 21,
	YSAST_SilentAttackCmdDeny                          = 22,
	YSAST_SilentAttackCmdAbort                         = 23,
	YSAST_SilentAttackCmdSuccess                       = 24,
	YSAST_OpenFireCmdGive                              = 25,
	YSAST_OpenFireCmdConfirm                           = 26,
	YSAST_StunEnemiesCmdAvailable                      = 27,
	YSAST_StunEnemiesCmdGive                           = 28,
	YSAST_StunEnemiesCmdConfirm                        = 29,
	YSAST_StunEnemiesCmdDeny                           = 30,
	YSAST_StunEnemiesCmdAbort                          = 31,
	YSAST_StunEnemiesCmdSuccess                        = 32,
	YSAST_ScanCmdGive                                  = 33,
	YSAST_ScanCmdConfirm                               = 34,
	YSAST_ScanCmdScannedNone                           = 35,
	YSAST_ScanCmdScannedNoneRear                       = 36,
	YSAST_ScanCmdScanned1                              = 37,
	YSAST_ScanCmdScanned1Rear                          = 38,
	YSAST_ScanCmdScanned2                              = 39,
	YSAST_ScanCmdScanned2Rear                          = 40,
	YSAST_ScanCmdScanned3                              = 41,
	YSAST_ScanCmdScanned3Rear                          = 42,
	YSAST_ScanCmdScanned4                              = 43,
	YSAST_ScanCmdScanned4Rear                          = 44,
	YSAST_ScanCmdScanned5                              = 45,
	YSAST_ScanCmdScanned5Rear                          = 46,
	YSAST_ScanCmdScanned6                              = 47,
	YSAST_ScanCmdScanned6Rear                          = 48,
	YSAST_ScanCmdScannedMultiple                       = 49,
	YSAST_ScanCmdScannedMultipleRear                   = 50,
	YSAST_ScanCmdScannedSniper1                        = 51,
	YSAST_ScanCmdScannedSniper1Rear                    = 52,
	YSAST_ScanCmdScannedSniper2                        = 53,
	YSAST_ScanCmdScannedSniper2Rear                    = 54,
	YSAST_ScanCmdScannedRocket                         = 55,
	YSAST_ScanCmdScannedRocketRear                     = 56,
	YSAST_ScanCmdScannedTurretHostile                  = 57,
	YSAST_ScanCmdScannedTurretHostileRear              = 58,
	YSAST_ScanCmdScannedTurretUnmanned                 = 59,
	YSAST_ScanCmdScannedTurretUnmannedRear             = 60,
	YSAST_ScanCmdScannedWeaponPickup                   = 61,
	YSAST_ScanCmdScannedWeaponPickupRear               = 62,
	YSAST_ScanCmdScannedAmmoPickup                     = 63,
	YSAST_ScanCmdScannedAmmoPickupRear                 = 64,
	YSAST_ScanCmdScannedCollectible                    = 65,
	YSAST_ScanCmdScannedCollectibleRear                = 66,
	YSAST_ScanCmdScannedContextObject                  = 67,
	YSAST_ScanCmdScannedContextObjectRear              = 68,
	YSAST_ScanCmdScannedTurret                         = 69,
	YSAST_ScanCmdScannedMultipleTurrets                = 70,
	YSAST_DeployMortarCmdGive                          = 71,
	YSAST_DeployMortarCmdConfirm                       = 72,
	YSAST_DeployMortarCmdDeny                          = 73,
	YSAST_DeployMortarCmdAbort                         = 74,
	YSAST_DeployMortarCmdSuccess                       = 75,
	YSAST_MortarLeaderTooFarAway                       = 76,
	YSAST_RecallMortarCmdGive                          = 77,
	YSAST_RecallMortarCmdConfirm                       = 78,
	YSAST_RecallMortarCmdAbort                         = 79,
	YSAST_RecallMortarCmdSuccess                       = 80,
	YSAST_FireMortarCmdGive                            = 81,
	YSAST_FireMortarCmdConfirm                         = 82,
	YSAST_PrepareMortarGrenade                         = 83,
	YSAST_AdamsMortarFireOrder                         = 84,
	YSAST_HealCmdGive                                  = 85,
	YSAST_HealCmdConfirm                               = 86,
	YSAST_HealCmdDeny                                  = 87,
	YSAST_HealCmdAbort                                 = 88,
	YSAST_HealCmdSuccess                               = 89,
	YSAST_SnipeCmdGive                                 = 90,
	YSAST_SwitchToAssault                              = 91,
	YSAST_SwitchToInfiltrate                           = 92,
	YSAST_PlayerHealsMate                              = 93,
	YSAST_MateHealsPlayer                              = 94,
	YSAST_MateHealsMate                                = 95,
	YSAST_PlayerHealedByMate                           = 96,
	YSAST_SquadHealedByMate                            = 97,
	YSAST_DownButNotOutSelf                            = 98,
	YSAST_DownButNotOutAdams                           = 99,
	YSAST_DownButNotOutLugo                            = 100,
	YSAST_CommentPlayerKilledEnemy                     = 101,
	YSAST_CommentPlayerShotMate                        = 102,
	YSAST_Suppressed                                   = 103,
	YSAST_HitByBulletGoodHealth                        = 104,
	YSAST_HitByBulletBadHealth                         = 105,
	YSAST_HitByExplosion                               = 106,
	YSAST_HitByMelee                                   = 107,
	YSAST_PerformMelee                                 = 108,
	YSAST_HealthCritical                               = 109,
	YSAST_Dying                                        = 110,
	YSAST_FirstEnemyContact                            = 111,
	YSAST_EnemyContact                                 = 112,
	YSAST_ThrowingGrenade                              = 113,
	YSAST_IncomingGrenade                              = 114,
	YSAST_TargetKilled                                 = 115,
	YSAST_Reloading                                    = 116,
	YSAST_StartFlanking                                = 117,
	YSAST_IncomingMortar                               = 118,
	YSAST_PanickedByMortar                             = 119,
	YSAST_Burning                                      = 120,
	YSAST_SandCough                                    = 121,
	YSAST_GotoCmdGive_Cover                            = 122,
	YSAST_HoldPositionCmdGive                          = 123,
	YSAST_DoFlanking                                   = 124,
	YSAST_ReactToFlanking                              = 125,
	YSAST_ProvideCoverfire                             = 126,
	YSAST_AskForCoverfire                              = 127,
	YSAST_SniperSpotted                                = 128,
	YSAST_DBNOCritical                                 = 129,
	YSAST_Executing                                    = 130,
	YSAST_BeingExecuted                                = 131,
	YSAST_PostExecutionTaunt                           = 132,
	YSAST_MortarIdle                                   = 133,
	YSAST_IncomingGrenadeFrag                          = 134,
	YSAST_IncomingGrenadePhosphorus                    = 135,
	YSAST_HitByStickyGrenade                           = 136,
	YSAST_ThrowingGrenadeMine                          = 137,
	YSAST_ThrowingGrenadeFrag                          = 138,
	YSAST_ThrowingGrenadeStun                          = 139,
	YSAST_ThrowingGrenadePhosphorus                    = 140,
	YSAST_ThrowingGrenadeProxy                         = 141,
	YSAST_ThrowingGrenadeSticky                        = 142,
	YSAST_ThrowingGrenadeCluster                       = 143,
	YSAST_ThrowingGrenadePercussion                    = 144,
	YSAST_ThrowingGrenadeC4                            = 145,
	YSAST_UseTurretCmdGive                             = 146,
	YSAST_MortarPreparing                              = 147,
	YSAST_MortarReady                                  = 148,
	YSAST_PerformExecution                             = 149,
	YSAST_HumanShieldSquadReaction                     = 150,
	YSAST_HoldPositionCmdConfirm                       = 151,
	YSAST_TurretTakeCmdSuccess                         = 152,
	YSAST_ClearAreaCmdSuccess                          = 153,
	YSAST_SnipeCmdSuccess                              = 154,
	YSAST_GoingBerserk                                 = 155,
	YSAST_KilledByExecution                            = 156,
	YSAST_Stunned                                      = 157,
	YSAST_Advancing                                    = 158,
	YSAST_Retreating                                   = 159,
	YSAST_AllyKilled                                   = 160,
	YSAST_PickedUpHeavy                                = 161,
	YSAST_FlybySniper                                  = 162,
	YSAST_FlybyAA12                                    = 163,
	YSAST_FlybyRPG                                     = 164,
	YSAST_FlybyMGL                                     = 165,
	YSAST_SuppressiveFireCmdGive                       = 166,
	YSAST_SuppressiveFireCmdConfirm                    = 167,
	YSAST_SuppressiveFireCmdDeny                       = 168,
	YSAST_SuppressiveFireCmdBeginFiring                = 169,
	YSAST_ExplosionSoon                                = 170,
	YSAST_ClearAreaCmdGive                             = 171,
	YSAST_ClearAreaCmdConfirm                          = 172,
	YSAST_MeleeAllyHitByStickyGrenade                  = 173,
	YSAST_CallingForHelp                               = 174,
	YSAST_GrenadeDrop                                  = 175,
	YSAST_PlayerRespawn                                = 176,
	YSAST_RageBerserk                                  = 177,
	YSAST_FremenSalvage                                = 178,
	YSAST_KillerInstinct                               = 179,
	YSAST_TacticalExpertScan                           = 180,
	YSAST_WeaponJamming                                = 181,
	YSAST_AllyKilledBurning                            = 182,
	YSAST_KilledByHeadshot                             = 183,
	YSAST_PawnPhysicalBumpEffort                       = 184,
	YSAST_PawnJumpEffort                               = 185,
	YSAST_SquadMoveNoDelay                             = 186,
	YSAST_SquadMoveOneDelayedGiveCover                 = 187,
	YSAST_SquadMoveOneDelayedRequestCover              = 188,
	YSAST_SquadMoveBothDelayedPrepare                  = 189,
	YSAST_SquadMoveBothDelayedGo                       = 190,
	YSAST_SquadMoveFinished                            = 191,
	YSAST_SquadMoveFailed                              = 192,
	YSAST_RpgSpotted                                   = 193,
	YSAST_CommandoSpotted                              = 194,
	YSAST_HeavySpotted                                 = 195,
	YSAST_DBNOIdle                                     = 196,
	YSAST_EnemyHitPlayer                               = 197,
	YSAST_CommandoKilled                               = 198,
	YSAST_HeavyKilled                                  = 199,
	YSAST_ReloadingSingleShell                         = 200,
	YSAST_PlayerIdle                                   = 201,
	YSAST_SeeTerminatorMove                            = 202,
	YSAST_AA12Spotted                                  = 203,
	YSAST_MGLSpotted                                   = 204,
	YSAST_Taunt                                        = 205,
	YSAST_HostileIsGoingToNewCoverPosition             = 206,
	YSAST_DyingSandAvalanche                           = 207,
	YSAST_ShotgunSpotted                               = 208,
	YSAST_AttackCmdGiveSniper                          = 209,
	YSAST_AttackCmdGiveShotgun                         = 210,
	YSAST_AttackCmdGiveHeavy                           = 211,
	YSAST_AttackCmdGiveCommando                        = 212,
	YSAST_AttackCmdGiveRpg                             = 213,
	YSAST_AttackCmdGiveAA12                            = 214,
	YSAST_AttackCmdGiveTurret                          = 215,
	YSAST_EnemyCloseToPlayer                           = 216,
	YSAST_AttackCmdIdle                                = 217,
	YSAST_PanickedReload                               = 218,
	YSAST_PlayerIsStarring                             = 219,
	YSAST_SelfIsGoingToNewCoverPosition                = 220,
	YSAST_ReactToSlipOut                               = 221,
	YSAST_MPAudio                                      = 222,
	YSAST_MPRepair                                     = 223,
	YSAST_MPFriendlyFire                               = 224,
	YSAST_MPMineSpotted                                = 225,
	YSAST_MPStandingOnMine                             = 226,
	YSAST_MPHeavyPickup                                = 227,
	YSAST_MPEffort1                                    = 228,
	YSAST_MPEffort2                                    = 229,
	YSAST_MPC4Spotted                                  = 230,
	YSAST_MPPickupAmmo                                 = 231,
	YSAST_PerformExecutionEffortSmall                  = 232,
	YSAST_PerformExecutionEffortBig                    = 233,
	YSAST_PerformExecutionTaunt                        = 234,
	YSAST_PerformExecutionStruggle                     = 235,
	YSAST_ExecutionVictimGrunt                         = 236,
	YSAST_ExecutionVictimDeath                         = 237,
	YSAST_ExecutionVictimPlead                         = 238,
	YSAST_ExecutionVictimPain                          = 239,
	YSAST_ExecutionVictimChoke                         = 240,
	YSAST_ExecutionVictimMuffledScream                 = 241,
	YSAST_ExecutionVictimStruggle                      = 242,
	YSAST_HealReactionGrunt                            = 243,
	YSAST_MAX                                          = 244
};*/

// Enum SRGame.YSpecialActionSetTypes.YE_SpecialActionSetPriority
/*enum YE_SpecialActionSetPriority
{
	YSAP_0_Overrule                                    = 0,
	YSAP_1_ImportantInfo                               = 1,
	YSAP_2_Info                                        = 2,
	YSAP_3_Comment                                     = 3,
	YSAP_4_Illustrative                                = 4,
	YSAP_5_DontPlay                                    = 5,
	YSAP_UsePriorityFromSet                            = 6,
	YSAP_MAX                                           = 7
};*/

// Enum SRGame.YPlayerController.YE_ButtonAction
/*enum YE_ButtonAction
{
	YBA_None                                           = 0,
	YBA_Cover                                          = 1,
	YBA_DashIntoCoverWalk                              = 2,
	YBA_DashIntoCoverRun                               = 3,
	YBA_DashIntoCoverSprint                            = 4,
	YBA_MantleOverCover                                = 5,
	YBA_VaultOverCover                                 = 6,
	YBA_VaultOverCoverRun                              = 7,
	YBA_VaultOverCoverAuto                             = 8,
	YBA_MantleOverCoverDrop                            = 9,
	YBA_VaultOverCoverDrop                             = 10,
	YBA_VaultOverCoverRunDrop                          = 11,
	YBA_VaultOverCoverAutoDrop                         = 12,
	YBA_SwatTurnStandLeft                              = 13,
	YBA_SwatTurnStandRight                             = 14,
	YBA_SwatTurnCrouchLeft                             = 15,
	YBA_SwatTurnCrouchRight                            = 16,
	YBA_SlipOutFrontLeft                               = 17,
	YBA_SlipOutFrontRight                              = 18,
	YBA_SlipOutSideLeft                                = 19,
	YBA_SlipOutSideRight                               = 20,
	YBA_SlipOutAlongLeft                               = 21,
	YBA_SlipOutAlongRight                              = 22,
	YBA_SlipOutAwayLeft                                = 23,
	YBA_SlipOutAwayRight                               = 24,
	YBA_SlipOutAroundLeft                              = 25,
	YBA_SlipOutAroundRight                             = 26,
	YBA_SlipOutFrontLeftAttack                         = 27,
	YBA_SlipOutFrontRightAttack                        = 28,
	YBA_SlipOutSideLeftAttack                          = 29,
	YBA_SlipOutSideRightAttack                         = 30,
	YBA_SlipOutAlongLeftAttack                         = 31,
	YBA_SlipOutAlongRightAttack                        = 32,
	YBA_SlipOutAwayLeftAttack                          = 33,
	YBA_SlipOutAwayRightAttack                         = 34,
	YBA_SlipOutAroundLeftAttack                        = 35,
	YBA_SlipOutAroundRightAttack                       = 36,
	YBA_DoMeleeAttack                                  = 37,
	YBA_Revive                                         = 38,
	YBA_Execute                                        = 39,
	YBA_ExecuteSpeedUp                                 = 40,
	YBA_AdrenalineShot                                 = 41,
	YBA_ReviveFromDeath                                = 42,
	YBA_FastRopePrepare                                = 43,
	YBA_FastRopeRappel                                 = 44,
	YBA_FastRopeRappelStraight                         = 45,
	YBA_FastRopeRappelStraightNoTurn                   = 46,
	YBA_ZiplineTraverse                                = 47,
	YBA_TurretEnter                                    = 48,
	YBA_TurretLeave                                    = 49,
	YBA_TurretLeaveQuick                               = 50,
	YBA_DetachFromCover                                = 51,
	YBA_DropDown                                       = 52,
	YBA_QuickTurn                                      = 53,
	YBA_Sabotage                                       = 54,
	YBA_Repair                                         = 55,
	YBA_Steal                                          = 56,
	YBA_Deposit                                        = 57,
	YBA_CallChopper                                    = 58,
	YBA_MarkTarget                                     = 59,
	YBA_ArmPackage                                     = 60,
	YBA_DisarmPackage                                  = 61,
	YBA_DefuseExplosive                                = 62,
	YBA_RespawnTeam                                    = 63,
	YBA_CallForHelpOnMine                              = 64,
	YBA_MAX                                            = 65
};*/

// Enum SRGame.YPlayerController.EGenericYesNo
/*enum EGenericYesNo
{
	UTPID_VALUE_NO                                     = 0,
	UTPID_VALUE_YES                                    = 1,
	UTPID_VALUE_MAX                                    = 2
};*/

// Enum SRGame.YPlayerController.YE_PlayerActionMessage
/*enum YE_PlayerActionMessage
{
	YPAM_None                                          = 0,
	YPAM_StandUp                                       = 1,
	YPAM_EnterCover                                    = 2,
	YPAM_LeaveCover                                    = 3,
	YPAM_DashIntoCover                                 = 4,
	YPAM_QuickTurn                                     = 5,
	YPAM_MantleOverCover                               = 6,
	YPAM_SlipOut                                       = 7,
	YPAM_DoMeleeAttack                                 = 8,
	YPAM_VaultOverCover                                = 9,
	YPAM_JumpToCover                                   = 10,
	YPAM_SlideToCover                                  = 11,
	YPAM_ReviveSelf                                    = 12,
	YPAM_ReviveOther                                   = 13,
	YPAM_REMOVE_ME_01                                  = 14,
	YPAM_REMOVE_ME_02                                  = 15,
	YPAM_REMOVE_ME_03                                  = 16,
	YPAM_DetachFromCover                               = 17,
	YPAM_DropDown                                      = 18,
	YPAM_REMOVE_ME_04                                  = 19,
	YPAM_REMOVE_ME_05                                  = 20,
	YPAM_REMOVE_ME_06                                  = 21,
	YPAM_REMOVE_ME_07                                  = 22,
	YPAM_REMOVE_ME_08                                  = 23,
	YPAM_REMOVE_ME_09                                  = 24,
	YPAM_FastRopePrepare                               = 25,
	YPAM_FastRopeRappel                                = 26,
	YPAM_FastRopeRappelStraight                        = 27,
	YPAM_ZiplineTraverse                               = 28,
	YPAM_TurretEnter                                   = 29,
	YPAM_TurretLeave                                   = 30,
	YPAM_ExecuteOther                                  = 31,
	YPAM_ExecuteSpeedUp                                = 32,
	YPAM_AdrenalineShot                                = 33,
	YPAM_VaultOverCoverDropDown                        = 34,
	YPAM_SwatTurnStandLeft                             = 35,
	YPAM_SwatTurnStandRight                            = 36,
	YPAM_SwatTurnCrouchLeft                            = 37,
	YPAM_SwatTurnCrouchRight                           = 38,
	YPAM_MP_ReviveDBNO                                 = 39,
	YPAM_MP_SuicideDBNO                                = 40,
	YPAM_MP_CallForHelpDBNO                            = 41,
	YPAM_REMOVE_ME                                     = 42,
	YPAM_TurretLeaveQuick                              = 43,
	YPAM_LookAtPOI                                     = 44,
	YPAM_SkipKillCamRespawn                            = 45,
	YPAM_TurretStandToCrouch                           = 46,
	YPAM_TurretCrouchToStand                           = 47,
	YPAM_AutoCover                                     = 48,
	YPAM_AutoVault                                     = 49,
	YPAM_SniperModeCrouch                              = 50,
	YPAM_MAX                                           = 51
};*/

// Enum SRGame.YAISquad.YE_AdvanceType
/*enum YE_AdvanceType
{
	YAT_DependingOnMindstate                           = 0,
	YAT_EntireGroupToAP                                = 1,
	YAT_EntireGroupToSubstep                           = 2,
	YAT_PartialGroupToSubstep                          = 3,
	YAT_MAX                                            = 4
};*/

// Enum SRGame.YAISquad.YE_EnemyReaction
/*enum YE_EnemyReaction
{
	YER_HoldIfEnemy                                    = 0,
	YER_AvoidEnemy                                     = 1,
	YER_BreakThrough                                   = 2,
	YER_IgnoreEnemy                                    = 3,
	YER_MAX                                            = 4
};*/

// Enum SRGame.YAISquad.YE_AISquadTypes
/*enum YE_AISquadTypes
{
	YAIST_Basic                                        = 0,
	YAIST_SoldierSquad                                 = 1,
	YAIST_PlayerSquad                                  = 2,
	YAIST_MAX                                          = 3
};*/

// Enum SRGame.YAISquad.YE_BoolOverride
/*enum YE_BoolOverride
{
	YBOV_KeepOverride                                  = 0,
	YBOV_ClearOverride                                 = 1,
	YBOV_ForceOn                                       = 2,
	YBOV_ForceOff                                      = 3,
	YBOV_MAX                                           = 4
};*/

// Enum SRGame.YAISquad.YE_MovementModeOverride
/*enum YE_MovementModeOverride
{
	YMOV_Walk                                          = 0,
	YMOV_WalkCrouched                                  = 1,
	YMOV_Run                                           = 2,
	YMOV_RunCrouched                                   = 3,
	YMOV_Sprint                                        = 4,
	YMOV_CombatSprint                                  = 5,
	YMOV_KismetMode                                    = 6,
	YMOV_MovementOfPlayer                              = 7,
	YMOV_MAX                                           = 8
};*/

// Enum SRGame.YAIPlayerSquad.YE_PlayerSquadCommandType
/*enum YE_PlayerSquadCommandType
{
	YPSCTYP_None                                       = 0,
	YPSCTYP_Attack                                     = 1,
	YPSCTYP_Goto                                       = 2,
	YPSCTYP_Heal                                       = 3,
	YPSCTYP_Regroup                                    = 4,
	YPSCTYP_Mortar                                     = 5,
	YPSCTYP_RecallMortar                               = 6,
	YPSCTYP_FireMortar                                 = 7,
	YPSCTYP_Scan                                       = 8,
	YPSCTYP_OpenFire                                   = 9,
	YPSCTYP_StunEnemies                                = 10,
	YPSCTYP_ZipLine                                    = 11,
	YPSCTYP_SuppressiveFire                            = 12,
	YPSCTYP_Hold                                       = 13,
	YPSCTYP_LAST                                       = 14,
	YPSCTYP_MAX                                        = 15
};*/

// Enum SRGame.YAIPlayerSquad.YE_SquadStatus
/*enum YE_SquadStatus
{
	YSQUADSTATE_Ready                                  = 0,
	YSQUADSTATE_Advancing                              = 1,
	YSQUADSTATE_Holding                                = 2,
	YSQUADSTATE_ReadyToEngage                          = 3,
	YSQUADSTATE_InCombat                               = 4,
	YSQUADSTATE_AdamsDown                              = 5,
	YSQUADSTATE_LugoDown                               = 6,
	YSQUADSTATE_SquadDown                              = 7,
	YSQUADSTATE_Healing                                = 8,
	YSQUADSTATE_Regrouping                             = 9,
	YSQUADSTATE_Following                              = 10,
	YSQUADSTATE_Moving                                 = 11,
	YSQUADSTATE_Scanning                               = 12,
	YSQUADSTATE_UsingMortar                            = 13,
	YSQUADSTATE_SuppressingFire                        = 14,
	YSQUADSTATE_NotAvailable                           = 15,
	YSQUADSTATE_MAX                                    = 16
};*/

// Enum SRGame.YIScanable.YE_ScanAppearance
/*enum YE_ScanAppearance
{
	YSCAN_None                                         = 0,
	YSCAN_Scanned                                      = 1,
	YSCAN_Squad                                        = 2,
	YSCAN_Marked                                       = 3,
	YSCAN_Focused                                      = 4,
	YSCAN_MAX                                          = 5
};*/

// Enum SRGame.YIScanable.YE_ScanableType
/*enum YE_ScanableType
{
	YSCNT_NoComment                                    = 0,
	YSCNT_NoHostiles                                   = 1,
	YSCNT_Hostile                                      = 2,
	YSCNT_Sniper                                       = 3,
	YSCNT_Rocket                                       = 4,
	YSCNT_TurretHostile                                = 5,
	YSCNT_TurretUnmanned                               = 6,
	YSCNT_WeaponPickup                                 = 7,
	YSCNT_AmmoPickup                                   = 8,
	YSCNT_Collectible                                  = 9,
	YSCNT_ContextObject                                = 10,
	YSCNT_MAX                                          = 11
};*/

// Enum SRGame.YAIPlayerSquad.YE_SquadCommandLocationMarker
/*enum YE_SquadCommandLocationMarker
{
	YESCLM_Goto                                        = 0,
	YESCLM_SuppressionFire                             = 1,
	YESCLM_MAX                                         = 2
};*/

// Enum SRGame.YAIPlayerSquad.YE_MortarError
/*enum YE_MortarError
{
	YMORTERR_None                                      = 0,
	YMORTERR_Deploying                                 = 1,
	YMORTERR_Recalling                                 = 2,
	YMORTERR_Minor                                     = 3,
	YMORTERR_LeaderTooFar                              = 4,
	YMORTERR_NotEnoughSpaceToDeploy                    = 5,
	YMORTERR_NeedFreeAirSpace                          = 6,
	YMORTERR_Critical                                  = 7,
	YMORTERR_SquadDown                                 = 8,
	YMORTERR_NeedAmmo                                  = 9,
	YMORTERR_Generic                                   = 10,
	YMORTERR_MAX                                       = 11
};*/

// Enum SRGame.YAIPlayerSquad.YE_ScanReportPosition
/*enum YE_ScanReportPosition
{
	YSRP_Indeterminate                                 = 0,
	YSRP_Front                                         = 1,
	YSRP_Second                                        = 2,
	YSRP_MAX                                           = 3
};*/

// Enum SRGame.YGameInfo.YE_NPCCategory
/*enum YE_NPCCategory
{
	YNPCCAT_Unknown                                    = 0,
	YNPCCAT_Enemy                                      = 1,
	YNPCCAT_Squadmate                                  = 2,
	YNPCCAT_Civilian                                   = 3,
	YNPCCAT_MissionCritical                            = 4,
	YNPCCAT_MAX                                        = 5
};*/

// Enum SRGame.YGameSettingsMultiplayer.YE_ExodusMode
/*enum YE_ExodusMode
{
	YEM_NotExodus                                      = 0,
	YEM_Crossplayer                                    = 1,
	YEM_ExodusCoop                                     = 2,
	YEM_ExodusVersus                                   = 3,
	YEM_MAX                                            = 4
};*/

// Enum SRGame.YGameSettingsMultiplayer.YE_MultiplayerFactions
/*enum YE_MultiplayerFactions
{
	YMPFaction_Specops                                 = 0,
	YMPFaction_Konrads                                 = 1,
	YMPFaction_AnyFaction                              = 2,
	YMPFaction_NoFaction                               = 3,
	YMPFaction_MAX                                     = 4
};*/

// Enum SRGame.YGameSettingsMultiplayer.YE_MultiplayerMaps
/*enum YE_MultiplayerMaps
{
	YMPMap_NoMap                                       = 0,
	YMPMap_Tower                                       = 1,
	YMPMap_Atrium                                      = 2,
	YMPMap_City                                        = 3,
	YMPMap_WindGates                                   = 4,
	YMPMap_RoofTops                                    = 5,
	YMPMap_Sunken                                      = 6,
	YMPMap_Museum                                      = 7,
	YMPMap_Tanker                                      = 8,
	YMPMap_AnyMap                                      = 9,
	YMPMap_HordeCity                                   = 10,
	YMPMap_CustomMap                                   = 11,
	YMPMap_DLCMap1                                     = 12,
	YMPMap_DLCMap2                                     = 13,
	YMPMap_DLCMap3                                     = 14,
	YMPMap_DLCMap4                                     = 15,
	YMPMap_DLCMap5                                     = 16,
	YMPMap_DLCMap6                                     = 17,
	YMPMap_DLCMap7                                     = 18,
	YMPMap_DLCMap8                                     = 19,
	YMPMap_DLCMap9                                     = 20,
	YMPMap_DLCMap10                                    = 21,
	YMPMap_DLCMap11                                    = 22,
	YMPMap_DLCMap12                                    = 23,
	YMPMap_DLCMap13                                    = 24,
	YMPMap_DLCMap14                                    = 25,
	YMPMap_DLCMap15                                    = 26,
	YMPMap_DLCMap16                                    = 27,
	YMPMap_DLCMap17                                    = 28,
	YMPMap_DLCMap18                                    = 29,
	YMPMap_DLCMap19                                    = 30,
	YMPMap_DLCMap20                                    = 31,
	YMPMap_DLCMap21                                    = 32,
	YMPMap_DLCMap22                                    = 33,
	YMPMap_DLCMap23                                    = 34,
	YMPMap_DLCMap24                                    = 35,
	YMPMap_DLCMap25                                    = 36,
	YMPMap_CoopProto                                   = 37,
	YMPMap_CoopIO6                                     = 38,
	YMPMap_CoopTemp1                                   = 39,
	YMPMap_CoopTemp2                                   = 40,
	YMPMap_CoopTemp3                                   = 41,
	YMPMap_CoopTemp4                                   = 42,
	YMPMap_MAX                                         = 43
};*/

// Enum SRGame.YGameSettingsMultiplayer.YE_MultiplayerModes
/*enum YE_MultiplayerModes
{
	YMPMode_NoMode                                     = 0,
	YMPMode_Deathmatch                                 = 1,
	YMPMode_TeamElimination                            = 2,
	YMPMode_TeamDeathmatch                             = 3,
	YMPMode_HoldAndDestroy                             = 4,
	YMPMode_SquadDeathmatch                            = 5,
	YMPMode_RallyPoint                                 = 6,
	YMPMode_AnyMode                                    = 7,
	YMPMode_Buried                                     = 8,
	YMPMode_SpoilsOfWar                                = 9,
	YMPMode_ChopperAttack                              = 10,
	YMPMode_Delivery                                   = 11,
	YMPMode_SpecialDelivery                            = 12,
	YMPMode_Offline                                    = 13,
	YMPMode_Coop                                       = 14,
	YMPMode_CustomMode                                 = 15,
	YMPMode_MAX                                        = 16
};*/

// Enum SRGame.YGameSettingsMultiplayer.YE_AIDifficulty
/*enum YE_AIDifficulty
{
	YMPAIDifficulty_NoDifficulty                       = 0,
	YMPAIDifficulty_Easy                               = 1,
	YMPAIDifficulty_Normal                             = 2,
	YMPAIDifficulty_Hard                               = 3,
	YMPAIDifficulty_Insane                             = 4,
	YMPAIDifficulty_AnyDifficulty                      = 5,
	YMPAIDifficulty_MAX                                = 6
};*/

// Enum SRGame.YGameSettingsMultiplayer.YE_Campaigns
/*enum YE_Campaigns
{
	YMPCampaign_NoCampaign                             = 0,
	YMPCampaign_01                                     = 1,
	YMPCampaign_02                                     = 2,
	YMPCampaign_03                                     = 3,
	YMPCampaign_04                                     = 4,
	YMPCampaign_AnyCampaign                            = 5,
	YMPCampaign_MAX                                    = 6
};*/

// Enum SRGame.YGameSettingsMultiplayer.YE_MultiplayerMatchTypes
/*enum YE_MultiplayerMatchTypes
{
	YMPMatchType_None                                  = 0,
	YMPMatchType_Ranked                                = 1,
	YMPMatchType_Player                                = 2,
	YMPMatchType_Private                               = 3,
	YMPMatchType_SystemLink                            = 4,
	YMPMatchType_MAX                                   = 5
};*/

// Enum SRGame.YGameInfo.YE_Standing
/*enum YE_Standing
{
	YSTAND_Neutral                                     = 0,
	YSTAND_Friendly                                    = 1,
	YSTAND_Hostile                                     = 2,
	YSTAND_MAX                                         = 3
};*/

// Enum SRGame.YSeqAct_AIFactory.YE_CharacterAttachmentInfoTypes
/*enum YE_CharacterAttachmentInfoTypes
{
	YCATIT_KonradTroopsHat                             = 0,
	YCATIT_KonradTroopsHead                            = 1,
	YCATIT_KonradHeavyHelmet                           = 2,
	YCATIT_KonradHeavyBreastPlate                      = 3,
	YCATIT_Lugo                                        = 4,
	YCATIT_Commando                                    = 5,
	YCATIT_MAX                                         = 6
};*/

// Enum SRGame.YSeqAct_AIFactory.EAITypes
/*enum EAITypes
{
	AIType_Adams                                       = 0,
	AIType_Adams_Battered                              = 1,
	AIType_Adams_Wartorn                               = 2,
	AIType_Adams_Empty                                 = 3,
	AIType_Adams_Alone                                 = 4,
	AIType_Lugo                                        = 5,
	AIType_FakeLugo                                    = 6,
	AIType_FakeGould                                   = 7,
	AIType_Lugo_Battered                               = 8,
	AIType_Lugo_Wartorn                                = 9,
	AIType_Lugo_Empty                                  = 10,
	AIType_MP_Civilian                                 = 11,
	AIType_EnemyAssault                                = 12,
	AIType_EnemySniper                                 = 13,
	AIType_EnemyPistol                                 = 14,
	AIType_EnemySMG                                    = 15,
	AIType_EnemyShotgun                                = 16,
	AIType_EnemyMG                                     = 17,
	AIType_EliteAssault                                = 18,
	AIType_EliteShotgun                                = 19,
	AIType_EliteSMG                                    = 20,
	AIType_EliteAA12                                   = 21,
	AIType_EliteSniper                                 = 22,
	AIType_CivilianMale                                = 23,
	AIType_CivilianFemale                              = 24,
	AIType_CivilianChild                               = 25,
	AIType_MarauderAssault                             = 26,
	AIType_MarauderRifle                               = 27,
	AIType_MarauderShotgun                             = 28,
	AIType_MarauderPistol                              = 29,
	AIType_MarauderSMG                                 = 30,
	AIType_GuideArmed                                  = 31,
	AIType_GuideUnarmed                                = 32,
	AIType_Riggs                                       = 33,
	AIType_MP_Guard                                    = 34,
	AIType_MarauderRPG                                 = 35,
	AIType_EnemyRPG                                    = 36,
	AIType_EliteRPG                                    = 37,
	AIType_HeavyTrooperMachine                         = 38,
	AIType_HeavyTrooperAA12                            = 39,
	AIType_Commando                                    = 40,
	AIType_EnemyAssaultAK47                            = 41,
	AIType_EliteAssaultFAMAS                           = 42,
	AIType_MediumEnemyAssault                          = 43,
	AIType_MediumEnemyAssaultAK47                      = 44,
	AIType_MediumEnemySniper                           = 45,
	AIType_MediumEnemyPistol                           = 46,
	AIType_MediumEnemySMG                              = 47,
	AIType_MediumEnemyShotgun                          = 48,
	AIType_MediumEnemyMG                               = 49,
	AIType_MediumEnemyRPG                              = 50,
	AIType_EnemyAssaultHK417                           = 51,
	AIType_MediumEnemyAssaultHK417                     = 52,
	AIType_EliteAssaultHK417                           = 53,
	AIType_USMarine                                    = 54,
	AIType_EnemyMilkor                                 = 55,
	AIType_EliteMG                                     = 56,
	AIType_MAX                                         = 57
};*/

// Enum SRGame.YGamePawn.YE_SpecialMove
/*enum YE_SpecialMove
{
	YSPM_None                                          = 0,
	YSPM_Cancel                                        = 1,
	YSPM_MantleOverCover                               = 2,
	YSPM_VaultOverCoverDropDown                        = 3,
	YSPM_VaultOverCover                                = 4,
	YSPM_VaultOverCoverRun                             = 5,
	YSPM_VaultOverCoverAuto                            = 6,
	YSPM_AIMeleeAttack                                 = 7,
	YSPM_PlayMeleeAttack                               = 8,
	YSPM_TakeHit                                       = 9,
	YSPM_SwatTurn                                      = 10,
	YSPM_SlipOutFront                                  = 11,
	YSPM_SlipOutSide                                   = 12,
	YSPM_SlipOutAlong                                  = 13,
	YSPM_SlipOutAway                                   = 14,
	YSPM_SlipOutAround                                 = 15,
	YSPM_DashIntoCoverSprint                           = 16,
	YSPM_DashIntoCoverRun                              = 17,
	YSPM_DashIntoCoverWalk                             = 18,
	YSPM_SnapToCover                                   = 19,
	YSPM_LeaveCoverCenter                              = 20,
	YSPM_LeaveCoverEdge                                = 21,
	YSPM_LeavePeeking                                  = 22,
	YSPM_Revive                                        = 23,
	YSPM_ReviveSelf                                    = 24,
	YSPM_BeingRevived                                  = 25,
	YSPM_BeingExecuted                                 = 26,
	YSPM_Execute                                       = 27,
	YSPM_IntelOp                                       = 28,
	YSPM_IntelOpStopSucceeded                          = 29,
	YSPM_IntelOpStopFailed                             = 30,
	YSPM_PickUpWeapon                                  = 31,
	YSPM_PickUpWeaponFromRack                          = 32,
	YSPM_PickUpFromCrate                               = 33,
	YSPM_PickUpFromBox                                 = 34,
	YSPM_DropDown                                      = 35,
	YSPM_SpecialDeathAnimation                         = 36,
	YSPM_CustomAnimation                               = 37,
	YSPM_StartSprintFromWalk                           = 38,
	YSPM_StartSprintFromRun                            = 39,
	YSPM_StopSprint                                    = 40,
	YSPM_SprintSlide                                   = 41,
	YSPM_Quickturn                                     = 42,
	YSPM_Mortar                                        = 43,
	YSPM_FastRopePrepare                               = 44,
	YSPM_FastRopeRappel                                = 45,
	YSPM_FastRopeRappelStraight                        = 46,
	YSPM_FastRopeRappelStraightNoTurn                  = 47,
	YSPM_ZiplineTraverse                               = 48,
	YSPM_TakeHumanShield                               = 49,
	YSPM_TakenAsHumanShield                            = 50,
	YSPM_ReleaseHumanShield                            = 51,
	YSPM_ReleasedFromHumanShield                       = 52,
	YSPM_PlayDeathAnim                                 = 53,
	YSPM_KnockDownPawn                                 = 54,
	YSPM_RecoverFromRagdollToDBNOOrNormal              = 55,
	YSPM_RecoverFromRagdollToAnimDBNO                  = 56,
	YSPM_RecoverFromRagdollToDeathDBNO                 = 57,
	YSPM_PlayHitReactionAnim                           = 58,
	YSPM_TurretEnter                                   = 59,
	YSPM_TurretLeave                                   = 60,
	YSPM_TurretEnterRemote                             = 61,
	YSPM_TurretLeaveQuick                              = 62,
	YSPM_StumbleSandBomb                               = 63,
	YSPM_StumbleSandPool                               = 64,
	YSPM_MoveToPos                                     = 65,
	YSPM_InjectAdrenaline                              = 66,
	YSPM_ReviveFromDead                                = 67,
	YSPM_MAX                                           = 68
};*/

// Enum SRGame.YGamePawn.YE_CoverMovementDirection
/*enum YE_CoverMovementDirection
{
	YCMD_None                                          = 0,
	YCMD_Left                                          = 1,
	YCMD_Right                                         = 2,
	YCMD_MAX                                           = 3
};*/

// Enum SRGame.YGamePawn.YE_SpecialMovePhase
/*enum YE_SpecialMovePhase
{
	YSMP_Start                                         = 0,
	YSMP_Loop                                          = 1,
	YSMP_End                                           = 2,
	YSMP_MAX                                           = 3
};*/

// Enum SRGame.YGamePawn.YE_CoverFaceState
/*enum YE_CoverFaceState
{
	YCFS_AwayFromCover                                 = 0,
	YCFS_FaceCover                                     = 1,
	YCFS_LeftOfCover                                   = 2,
	YCFS_RightOfCover                                  = 3,
	YCFS_MAX                                           = 4
};*/

// Enum SRGame.YDBNORule.YE_DBNOExitCondition
/*enum YE_DBNOExitCondition
{
	YDBNOEXIT_None                                     = 0,
	YDBNOEXIT_ByTime                                   = 1,
	YDBNOEXIT_ByExecution                              = 2,
	YDBNOEXIT_ByBleedOut                               = 3,
	YDBNOEXIT_ByDamage                                 = 4,
	YDBNOEXIT_ByAnimation                              = 5,
	YDBNOEXIT_ByTeamRevive                             = 6,
	YDBNOEXIT_BySelfRevive                             = 7,
	YDBNOEXIT_BySuicide                                = 8,
	YDBNOEXIT_ByRagdoll                                = 9,
	YDBNOEXIT_MAX                                      = 10
};*/

// Enum SRGame.YDBNORule.YE_DBNOEnterCondition
/*enum YE_DBNOEnterCondition
{
	YDBNOENTER_None                                    = 0,
	YDBNOENTER_ByHealth                                = 1,
	YDBNOENTER_ByAnimation                             = 2,
	YDBNOENTER_ByRagdoll                               = 3,
	YDBNOENTER_MAX                                     = 4
};*/

// Enum SRGame.YDBNORule.YE_DBNORestoreHealthType
/*enum YE_DBNORestoreHealthType
{
	YDBNORH_Full                                       = 0,
	YDBNORH_Percent                                    = 1,
	YDBNORH_Absolute                                   = 2,
	YDBNORH_Never                                      = 3,
	YDBNORH_MAX                                        = 4
};*/

// Enum SRGame.YDBNORule.YE_DBNOResult
/*enum YE_DBNOResult
{
	YDBNORESULT_AlreadyDBNO                            = 0,
	YDBNORESULT_DBNO                                   = 1,
	YDBNORESULT_Alive                                  = 2,
	YDBNORESULT_Died                                   = 3,
	YDBNORESULT_MAX                                    = 4
};*/

// Enum SRGame.YGamePawn.YE_ReplicatedAnimID
/*enum YE_ReplicatedAnimID
{
	YRPA_None                                          = 0,
	YRPA_ReloadWeapon                                  = 1,
	YRPA_ReloadSingleShellLoop                         = 2,
	YRPA_ReloadSingleShellEnd                          = 3,
	YRPA_ThrowGrenade                                  = 4,
	YRPA_RaiseGrenade                                  = 5,
	YRPA_HoldGrenade                                   = 6,
	YRPA_ReleaseGrenade                                = 7,
	YRPA_PickUp                                        = 8,
	YRPA_HeadCover                                     = 9,
	YRPA_CommandGoto                                   = 10,
	YRPA_CommandAttack                                 = 11,
	YRPA_CommandRegroup                                = 12,
	YRPA_CommandHold                                   = 13,
	YRPA_CommandOpenFire                               = 14,
	YRPA_CommandStunEnemies                            = 15,
	YRPA_Refire                                        = 16,
	YRPA_SandAvalancheStumble                          = 17,
	YRPA_MarkBase                                      = 18,
	YRPA_DropGold                                      = 19,
	YRPA_CallChopperAttack                             = 20,
	YRPA_RepairVitalPoint                              = 21,
	YRPA_HackComputer                                  = 22,
	YRPA_PlaceExplosive                                = 23,
	YRPA_DisarmExplosive                               = 24,
	YRPA_MAX                                           = 25
};*/

// Enum SRGame.YAnimInfo.YE_AnimGroupID
/*enum YE_AnimGroupID
{
	YAGID_None                                         = 0,
	YAGID_Dynamic                                      = 1,
	YAGID_Movement                                     = 2,
	YAGID_Transition                                   = 3,
	YAGID_Combat                                       = 4,
	YAGID_Misc                                         = 5,
	YAGID_Feedback                                     = 6,
	YAGID_Camera                                       = 7,
	YAGID_Additive                                     = 8,
	YAGID_DeathAnim                                    = 9,
	YAGID_MAX                                          = 10
};*/

// Enum SRGame.YAnimInfo.YE_PostureGroupID
/*enum YE_PostureGroupID
{
	YPGID_None                                         = 0,
	YPGID_StandCrouch                                  = 1,
	YPGID_CoverStand                                   = 2,
	YPGID_CoverStandL                                  = 3,
	YPGID_CoverStandR                                  = 4,
	YPGID_CoverCrouch                                  = 5,
	YPGID_CoverCrouchL                                 = 6,
	YPGID_CoverCrouchR                                 = 7,
	YPGID_CoverCrouchAimOver                           = 8,
	YPGID_CoverCrouchBlindfireOver                     = 9,
	YPGID_AimDown                                      = 10,
	YPGID_MAX                                          = 11
};*/

// Enum SRGame.YAnimInfo.YE_PostureID
/*enum YE_PostureID
{
	YPTID_None                                         = 0,
	YPTID_Stand                                        = 1,
	YPTID_Crouch                                       = 2,
	YPTID_CoverStandL                                  = 3,
	YPTID_CoverStandLBackwards                         = 4,
	YPTID_CoverStandR                                  = 5,
	YPTID_CoverStandRBackwards                         = 6,
	YPTID_CoverCrouchL                                 = 7,
	YPTID_CoverCrouchLBackwards                        = 8,
	YPTID_CoverCrouchR                                 = 9,
	YPTID_CoverCrouchRBackwards                        = 10,
	YPTID_CoverStandEdgeL                              = 11,
	YPTID_CoverStandEdgeR                              = 12,
	YPTID_CoverCrouchEdgeL                             = 13,
	YPTID_CoverCrouchEdgeR                             = 14,
	YPTID_CoverStandPeekEdgeL                          = 15,
	YPTID_CoverStandPeekEdgeR                          = 16,
	YPTID_CoverCrouchPeekEdgeL                         = 17,
	YPTID_CoverCrouchPeekEdgeR                         = 18,
	YPTID_CoverStandAimOutL                            = 19,
	YPTID_CoverStandAimOutR                            = 20,
	YPTID_CoverCrouchAimOutL                           = 21,
	YPTID_CoverCrouchAimOutR                           = 22,
	YPTID_CoverStandAimAroundL                         = 23,
	YPTID_CoverStandAimAroundR                         = 24,
	YPTID_CoverCrouchAimAroundL                        = 25,
	YPTID_CoverCrouchAimAroundR                        = 26,
	YPTID_CoverStandBlindfireEdgeL                     = 27,
	YPTID_CoverStandBlindfireEdgeR                     = 28,
	YPTID_CoverCrouchBlindfireEdgeL                    = 29,
	YPTID_CoverCrouchBlindfireEdgeR                    = 30,
	YPTID_CoverCrouchPeekOverL                         = 31,
	YPTID_CoverCrouchPeekOverR                         = 32,
	YPTID_CoverCrouchAimOverL                          = 33,
	YPTID_CoverCrouchAimOverR                          = 34,
	YPTID_CoverCrouchBlindfireOverL                    = 35,
	YPTID_CoverCrouchBlindfireOverR                    = 36,
	YPTID_PeekDownL                                    = 37,
	YPTID_PeekDownR                                    = 38,
	YPTID_AimDownL                                     = 39,
	YPTID_AimDownR                                     = 40,
	YPTID_StackedIdleL                                 = 41,
	YPTID_StackedIdleR                                 = 42,
	YPTID_StackedOutL                                  = 43,
	YPTID_StackedOutR                                  = 44,
	YPTID_TurretCrouch                                 = 45,
	YPTID_TurretStand                                  = 46,
	YPTID_DownButNotOutStandard                        = 47,
	YPTID_MobileDownButNotOut                          = 48,
	YPTID_Dead                                         = 49,
	YPTID_DeathDBNOFront                               = 50,
	YPTID_DeathDBNOBack                                = 51,
	YPTID_HumanShieldCaptor                            = 52,
	YPTID_TruckRide                                    = 53,
	YPTID_MAX                                          = 54
};*/

// Enum SRGame.YAnimInfo.YE_AnimID_DeathAnim
/*enum YE_AnimID_DeathAnim
{
	YAIDDA_None                                        = 0,
	YAIDDA_Crc_Fwd                                     = 1,
	YAIDDA_Crc_Bwd                                     = 2,
	YAIDDA_Crc_Fwd_Head                                = 3,
	YAIDDA_Crc_Fwd_Head_02                             = 4,
	YAIDDA_Crc_Fwd_Neck                                = 5,
	YAIDDA_Crc_Fwd_Neck_02                             = 6,
	YAIDDA_Crc_Fwd_Stomach                             = 7,
	YAIDDA_Crc_Left                                    = 8,
	YAIDDA_Crc_Right                                   = 9,
	YAIDDA_Std_Bwd_01                                  = 10,
	YAIDDA_Std_Bwd_02                                  = 11,
	YAIDDA_Std_Bwd_03                                  = 12,
	YAIDDA_Std_Bwd_04                                  = 13,
	YAIDDA_Std_Bwd_05                                  = 14,
	YAIDDA_Std_Bwd_06                                  = 15,
	YAIDDA_Std_Fwd_01                                  = 16,
	YAIDDA_Std_Fwd_02                                  = 17,
	YAIDDA_Std_Fwd_03                                  = 18,
	YAIDDA_Std_Left                                    = 19,
	YAIDDA_Std_Right                                   = 20,
	YAIDDA_Std_Fwd_Head                                = 21,
	YAIDDA_Std_Fwd_Head_02                             = 22,
	YAIDDA_Std_Run_Fwd_01                              = 23,
	YAIDDA_Std_Run_Fwd_02                              = 24,
	YAIDDA_Std_Run_Fwd_03                              = 25,
	YAIDDA_Std_Run_Fwd_04                              = 26,
	YAIDDA_Std_Run_Fwd_05                              = 27,
	YAIDDA_Std_Run_Fwd_06                              = 28,
	YAIDDA_DBNO_01                                     = 29,
	YAIDDA_FlameThrower_01                             = 30,
	YAIDDA_HumanShieldCaptorDies_01                    = 31,
	YAIDDA_Std_Shotgun_Blast_01                        = 32,
	YAIDDA_Std_Shotgun_Blast_02                        = 33,
	YAIDDA_Std_Shotgun_Blast_03                        = 34,
	YAIDDA_Std_Shotgun_Blast_04                        = 35,
	YAIDDA_Cov_Crc_AimOverCover_01                     = 36,
	YAIDDA_Cov_Crc_AimOverCover_02                     = 37,
	YAIDDA_Cov_Crc_Peekup_01                           = 38,
	YAIDDA_Cov_Crc_LeanOverCover_01                    = 39,
	YAIDDA_Cov_Crc_LeanOverCover_02                    = 40,
	YAIDDA_Cov_Crc_Idle_01                             = 41,
	YAIDDA_Cov_Crc_Idle_02                             = 42,
	YAIDDA_Cov_Crc_Stacking_01_L                       = 43,
	YAIDDA_Cov_Crc_Stacking_01_R                       = 44,
	YAIDDA_Cov_Crc_Stacking_02_L                       = 45,
	YAIDDA_Cov_Crc_Stacking_02_R                       = 46,
	YAIDDA_Cov_Crc_Stepout_01_L                        = 47,
	YAIDDA_Cov_Crc_Stepout_01_R                        = 48,
	YAIDDA_Cov_Crc_Stepout_02_L                        = 49,
	YAIDDA_Cov_Crc_Stepout_02_R                        = 50,
	YAIDDA_Cov_Crc_Stepout_03_L                        = 51,
	YAIDDA_Cov_Crc_Stepout_03_R                        = 52,
	YAIDDA_Cov_Crc_Aimout_01_L                         = 53,
	YAIDDA_Cov_Crc_Aimout_01_R                         = 54,
	YAIDDA_Cov_Crc_Peekout_01_L                        = 55,
	YAIDDA_Cov_Crc_Peekout_01_R                        = 56,
	YAIDDA_Cov_Std_Idle_01                             = 57,
	YAIDDA_Cov_Std_Idle_02                             = 58,
	YAIDDA_Cov_Std_Stepout_01_L                        = 59,
	YAIDDA_Cov_Std_Stepout_01_R                        = 60,
	YAIDDA_Cov_Std_Stepout_02_L                        = 61,
	YAIDDA_Cov_Std_Stepout_02_R                        = 62,
	YAIDDA_Cov_Std_Aimout_01_L                         = 63,
	YAIDDA_Cov_Std_Aimout_01_R                         = 64,
	YAIDDA_Cov_Std_Peekout_01_L                        = 65,
	YAIDDA_Cov_Std_Peekout_01_R                        = 66,
	YAIDDA_Hit_Cov_Crc_AimOut_Left                     = 67,
	YAIDDA_Hit_Cov_Crc_AimOut_Right                    = 68,
	YAIDDA_Hit_Cov_Crc_AimOver_01                      = 69,
	YAIDDA_Hit_Cov_Crc_AimOver_02                      = 70,
	YAIDDA_Hit_Cov_Crc_Aimover_Small_01                = 71,
	YAIDDA_Hit_Cov_Crc_Aimover_Small_02                = 72,
	YAIDDA_Hit_Cov_Crc_EdgeIdle_Left                   = 73,
	YAIDDA_Hit_Cov_Crc_EdgeIdle_Right                  = 74,
	YAIDDA_Hit_Cov_Crc_StepOut_Left                    = 75,
	YAIDDA_Hit_Cov_Crc_StepOut_Right                   = 76,
	YAIDDA_Hit_Cov_Crc_StepOut_Left_Small              = 77,
	YAIDDA_Hit_Cov_Crc_StepOut_Right_Small             = 78,
	YAIDDA_Hit_Cov_Crc_Idle_Small_01                   = 79,
	YAIDDA_Hit_Cov_Crc_Idle_Big_01                     = 80,
	YAIDDA_Hit_Cov_Std_StepOut_Left                    = 81,
	YAIDDA_Hit_Cov_Std_StepOut_Right                   = 82,
	YAIDDA_Hit_Cov_Std_EdgeIdle_Left                   = 83,
	YAIDDA_Hit_Cov_Std_EdgeIdle_Right                  = 84,
	YAIDDA_Hit_Cov_Std_StepOut_Left_Small              = 85,
	YAIDDA_Hit_Cov_Std_StepOut_Right_Small             = 86,
	YAIDDA_Hit_Cov_Std_Idle_Small_01                   = 87,
	YAIDDA_Hit_Cov_Std_Idle_Big_01                     = 88,
	YAIDDA_Hit_Crc_ChestSmall_01                       = 89,
	YAIDDA_Hit_Crc_Arm_Left_Small_01                   = 90,
	YAIDDA_Hit_Crc_Leg_Left_Small_01                   = 91,
	YAIDDA_Hit_Crc_Arm_Right_Small_01                  = 92,
	YAIDDA_Hit_Crc_Leg_Right_Small_01                  = 93,
	YAIDDA_Hit_Std_ChestBig_01                         = 94,
	YAIDDA_Hit_Std_Arm_Left_Big_01                     = 95,
	YAIDDA_Hit_Std_Leg_Left_Big_01                     = 96,
	YAIDDA_Hit_Std_Arm_Right_Big_01                    = 97,
	YAIDDA_Hit_Std_Leg_Right_Big_01                    = 98,
	YAIDDA_Hit_Std_Run_Left                            = 99,
	YAIDDA_Hit_Std_Run_Right                           = 100,
	YAIDDA_Hit_Std_Sprint_Left                         = 101,
	YAIDDA_Hit_Std_Sprint_Right                        = 102,
	YAIDDA_Hit_Std_ChestSmall                          = 103,
	YAIDDA_Hit_Std_Arm_Left_Small                      = 104,
	YAIDDA_Hit_Std_Arm_Right_Small                     = 105,
	YAIDDA_Hit_HeavyTrooper_01                         = 106,
	YAIDDA_Std_Death_Mortar_A                          = 107,
	YAIDDA_Std_Death_Mortar_B                          = 108,
	YAIDDA_Cov_Death_Mortar_A                          = 109,
	YAIDDA_Cov_Death_Mortar_B                          = 110,
	YAIDDA_Explosion_Fwd                               = 111,
	YAIDDA_Explosion_Bwd                               = 112,
	YAIDDA_Explosion_Left                              = 113,
	YAIDDA_Explosion_Right                             = 114,
	YAIDDA_Melee_Back                                  = 115,
	YAIDDA_Melee_Front                                 = 116,
	YAIDDA_Melee_Left                                  = 117,
	YAIDDA_Melee_Right                                 = 118,
	YAIDDA_Death_ZiplineTraverse                       = 119,
	YAIDDA_Death_FastropeRappel                        = 120,
	YAIDDA_MAX                                         = 121
};*/

// Enum SRGame.YAnimInfo.YE_AimingPoseID
/*enum YE_AimingPoseID
{
	YAPID_None                                         = 0,
	YAPID_StandIdle                                    = 1,
	YAPID_StandWalk                                    = 2,
	YAPID_StandRun                                     = 3,
	YAPID_CrouchIdle                                   = 4,
	YAPID_CrouchWalk                                   = 5,
	YAPID_CrouchRun                                    = 6,
	YAPID_Sprint                                       = 7,
	YAPID_SprintSlide                                  = 8,
	YAPID_CoverStandIdle                               = 9,
	YAPID_CoverCrouchIdle                              = 10,
	YAPID_CoverStandWalkR                              = 11,
	YAPID_CoverCrouchWalkR                             = 12,
	YAPID_CoverStandWalkL                              = 13,
	YAPID_CoverCrouchWalkL                             = 14,
	YAPID_CoverStandEdgeIdle                           = 15,
	YAPID_CoverCrouchEdgeIdle                          = 16,
	YAPID_CoverStandAimOut                             = 17,
	YAPID_CoverCrouchAimOut                            = 18,
	YAPID_CoverStandAimAround                          = 19,
	YAPID_CoverCrouchAimAround                         = 20,
	YAPID_CoverStandBlindfireEdge                      = 21,
	YAPID_CoverCrouchBlindfireEdge                     = 22,
	YAPID_CoverCrouchAimOver                           = 23,
	YAPID_CoverCrouchAimOver_Walk                      = 24,
	YAPID_CoverCrouchLeanOver                          = 25,
	YAPID_CoverCrouchBlindfireOver                     = 26,
	YAPID_AimDown                                      = 27,
	YAPID_ThrowGrenadeStandLong                        = 28,
	YAPID_ThrowGrenadeStandShort                       = 29,
	YAPID_ThrowGrenadeCrouchLong                       = 30,
	YAPID_ThrowGrenadeCrouchShort                      = 31,
	YAPID_ThrowGrenadeCoverStandLong                   = 32,
	YAPID_ThrowGrenadeCoverStandShort                  = 33,
	YAPID_ThrowGrenadeCoverCrouchLong                  = 34,
	YAPID_ThrowGrenadeCoverCrouchShort                 = 35,
	YAPID_ThrowGrenadeAimOverCoverLong                 = 36,
	YAPID_ThrowGrenadeAimOverCoverShort                = 37,
	YAPID_ThrowGrenadeLeanOverCover                    = 38,
	YAPID_ThrowGrenadeCoverStandEdgeLong               = 39,
	YAPID_ThrowGrenadeCoverStandEdgeShort              = 40,
	YAPID_ThrowGrenadeCoverCrouchEdgeLong              = 41,
	YAPID_ThrowGrenadeCoverCrouchEdgeShort             = 42,
	YAPID_ThrowGrenadeCoverStandBlindfireSideLong      = 43,
	YAPID_ThrowGrenadeCoverStandBlindfireSideShort     = 44,
	YAPID_ThrowGrenadeCoverCrouchBlindfireSideLong     = 45,
	YAPID_ThrowGrenadeCoverCrouchBlindfireSideShort    = 46,
	YAPID_ThrowGrenadeCoverStandAimOutLong             = 47,
	YAPID_ThrowGrenadeCoverStandAimOutShort            = 48,
	YAPID_ThrowGrenadeCoverCrouchAimOutLong            = 49,
	YAPID_ThrowGrenadeCoverCrouchAimOutShort           = 50,
	YAPID_ThrowGrenadeTossStand                        = 51,
	YAPID_CommandGotoStand                             = 52,
	YAPID_CommandGotoCoverStand                        = 53,
	YAPID_CommandRegroupStand                          = 54,
	YAPID_CommandAttack                                = 55,
	YAPID_CommandStop                                  = 56,
	YAPID_StackIdle                                    = 57,
	YAPID_StackOutIdle                                 = 58,
	YAPID_TurretIdleStand                              = 59,
	YAPID_TurretIdleCrouch                             = 60,
	YAPID_HumanShieldStand                             = 61,
	YAPID_TruckRide                                    = 62,
	YAPID_HangAndShoot                                 = 63,
	YAPID_DBNO                                         = 64,
	YAPID_MAX                                          = 65
};*/

// Enum SRGame.YAnimInfo.YE_IdleAnimSetID
/*enum YE_IdleAnimSetID
{
	YIAS_None                                          = 0,
	YIAS_StandIdle                                     = 1,
	YIAS_StandIdle_Aim                                 = 2,
	YIAS_CrouchIdle                                    = 3,
	YIAS_CrouchIdle_Aim                                = 4,
	YIAS_CoverStandIdle                                = 5,
	YIAS_CoverStandIdle_Aim                            = 6,
	YIAS_CoverCrouchIdle                               = 7,
	YIAS_CoverCrouchIdle_Aim                           = 8,
	YIAS_CoverStandEdgeIdle                            = 9,
	YIAS_CoverStandEdgeIdle_Aim                        = 10,
	YIAS_CoverCrouchEdgeIdle                           = 11,
	YIAS_CoverCrouchEdgeIdle_Aim                       = 12,
	YIAS_CoverStandIdlePeekEdge                        = 13,
	YIAS_CoverCrouchIdlePeekEdge                       = 14,
	YIAS_CoverStandIdleAimOut                          = 15,
	YIAS_CoverStandIdleAimOut_Aim                      = 16,
	YIAS_CoverCrouchIdleAimOut                         = 17,
	YIAS_CoverCrouchIdleAimOut_Aim                     = 18,
	YIAS_CoverStandIdleAimAround                       = 19,
	YIAS_CoverStandIdleAimAround_Aim                   = 20,
	YIAS_CoverCrouchIdleAimAround                      = 21,
	YIAS_CoverCrouchIdleAimAround_Aim                  = 22,
	YIAS_CoverStandIdleBlindfireEdge                   = 23,
	YIAS_CoverStandIdleBlindfireEdge_Aim               = 24,
	YIAS_CoverCrouchIdleBlindfireEdge                  = 25,
	YIAS_CoverCrouchIdleBlindfireEdge_Aim              = 26,
	YIAS_CoverCrouchIdlePeekOver                       = 27,
	YIAS_CoverCrouchIdleAimOver                        = 28,
	YIAS_CoverCrouchIdleAimOver_Aim                    = 29,
	YIAS_CoverCrouchIdleLeanOver                       = 30,
	YIAS_CoverCrouchIdleLeanOver_Aim                   = 31,
	YIAS_CoverCrouchIdleBlindfireOver                  = 32,
	YIAS_CoverCrouchIdleBlindfireOver_Aim              = 33,
	YIAS_PeekDown                                      = 34,
	YIAS_AimDown                                       = 35,
	YIAS_AimDown_Aim                                   = 36,
	YIAS_StackedIdle                                   = 37,
	YIAS_StackedIdle_Aim                               = 38,
	YIAS_StackedOut                                    = 39,
	YIAS_StackedOut_Aim                                = 40,
	YIAS_Stand_Turret_Aim                              = 41,
	YIAS_Crouch_Turret_Aim                             = 42,
	YIAS_DownButNotOutStandard                         = 43,
	YIAS_MobileDownButNotOut                           = 44,
	YIAS_Dead                                          = 45,
	YIAS_DeathDBNOFront                                = 46,
	YIAS_DeathDBNOBack                                 = 47,
	YIAS_HumanShieldCaptor                             = 48,
	YIAS_TruckRide                                     = 49,
	YIAS_TruckRide_Aim                                 = 50,
	YIAS_MAX                                           = 51
};*/

// Enum SRGame.YAnimInfo.YE_SprintAnimSetID
/*enum YE_SprintAnimSetID
{
	YSAS_None                                          = 0,
	YSAS_Sprint                                        = 1,
	YSAS_Sprint_Aim                                    = 2,
	YSAS_Dead                                          = 3,
	YSAS_MAX                                           = 4
};*/

// Enum SRGame.YAnimInfo.YE_MovementAnimSetID
/*enum YE_MovementAnimSetID
{
	YMAS_None                                          = 0,
	YMAS_StandWalk                                     = 1,
	YMAS_StandWalk_Aim                                 = 2,
	YMAS_StandRun                                      = 3,
	YMAS_StandRun_Aim                                  = 4,
	YMAS_CrouchWalk                                    = 5,
	YMAS_CrouchWalk_Aim                                = 6,
	YMAS_CrouchRun                                     = 7,
	YMAS_CrouchRun_Aim                                 = 8,
	YMAS_CoverStandWalk                                = 9,
	YMAS_CoverStandWalkBackwards                       = 10,
	YMAS_CoverStandWalkL_Aim                           = 11,
	YMAS_CoverStandWalkR_Aim                           = 12,
	YMAS_CoverStandWalkLBackwards_Aim                  = 13,
	YMAS_CoverStandWalkRBackwards_Aim                  = 14,
	YMAS_CoverCrouchWalk                               = 15,
	YMAS_CoverCrouchWalkBackwards                      = 16,
	YMAS_CoverCrouchWalkL_Aim                          = 17,
	YMAS_CoverCrouchWalkR_Aim                          = 18,
	YMAS_CoverCrouchWalkLBackwards_Aim                 = 19,
	YMAS_CoverCrouchWalkRBackwards_Aim                 = 20,
	YMAS_CoverCrouchWalkL_AimOver                      = 21,
	YMAS_CoverCrouchWalkR_AimOver                      = 22,
	YMAS_DownButNotOutStandard                         = 23,
	YMAS_Stand_Turret_Aim                              = 24,
	YMAS_Crouch_Turret_Aim                             = 25,
	YMAS_Dead                                          = 26,
	YMAS_HumanShieldCaptor                             = 27,
	YMAS_MAX                                           = 28
};*/

// Enum SRGame.YAnimInfo.YE_AnimID_Additive
/*enum YE_AnimID_Additive
{
	YAIDAD_None                                        = 0,
	YAIDAD_StdIdleAimed                                = 1,
	YAIDAD_CrcIdleAimed                                = 2,
	YAIDAD_MAX                                         = 3
};*/

// Enum SRGame.YAnimInfo.YE_AnimID_Camera
/*enum YE_AnimID_Camera
{
	YAIDCM_None                                        = 0,
	YAIDCM_Sprint                                      = 1,
	YAIDCM_CombatSprint                                = 2,
	YAIDCM_FastRopeTakeRope                            = 3,
	YAIDCM_FastRopeStraightIn                          = 4,
	YAIDCM_FastRopeStraightOut                         = 5,
	YAIDCM_MAX                                         = 6
};*/

// Enum SRGame.YAnimInfo.YE_AnimID_Feedback
/*enum YE_AnimID_Feedback
{
	YAIDFB_None                                        = 0,
	YAIDFB_Commando_Goto_Idle                          = 1,
	YAIDFB_Commando_Goto_CoverCrouch                   = 2,
	YAIDFB_Commando_Goto_CoverCrouch_Back              = 3,
	YAIDFB_Commando_Goto_CoverStand                    = 4,
	YAIDFB_Commando_Regroup_Idle                       = 5,
	YAIDFB_Commando_Regroup_CoverCrouch                = 6,
	YAIDFB_Commando_Regroup_CoverStand                 = 7,
	YAIDFB_Commando_Attack_Idle                        = 8,
	YAIDFB_Commando_Attack_Cover                       = 9,
	YAIDFB_Commando_Hold                               = 10,
	YAIDFB_Commando_OpenFire                           = 11,
	YAIDFB_Commando_StunEnemies                        = 12,
	YAIDFB_Stand_IdleA                                 = 13,
	YAIDFB_Stand_IdleB                                 = 14,
	YAIDFB_Stand_IdleC                                 = 15,
	YAIDFB_Crouch_IdleA                                = 16,
	YAIDFB_Crouch_IdleB                                = 17,
	YAIDFB_Crouch_IdleC                                = 18,
	YAIDFB_Cover_Stand_IdleA                           = 19,
	YAIDFB_Cover_Stand_IdleB                           = 20,
	YAIDFB_Cover_Stand_IdleC                           = 21,
	YAIDFB_Cover_Crouch_IdleA                          = 22,
	YAIDFB_Cover_Crouch_IdleB                          = 23,
	YAIDFB_Cover_Crouch_IdleC                          = 24,
	YAIDFB_Stand_Alert_IdleA                           = 25,
	YAIDFB_AIIdleStandSandStormCoverFace               = 26,
	YAIDFB_AIIdleStandSandStormTurnAround              = 27,
	YAIDFB_AIIdleStandSandStormPushForward             = 28,
	YAIDFB_AIIdleCoverCrouchLookRight                  = 29,
	YAIDFB_AIIdleCoverCrouchEdgeLookRight              = 30,
	YAIDFB_AIIdleCoverCrouchEdgeLookRightMirr          = 31,
	YAIDFB_AIIdleCoverCrouchEdgeRemoveSweat            = 32,
	YAIDFB_AIIdleCoverCrouchEdgeRemoveSweatMirr        = 33,
	YAIDFB_AIIdleCoverCrouchEdgeLoosenUp               = 34,
	YAIDFB_AIIdleCoverCrouchEdgeLoosenUpMirr           = 35,
	YAIDFB_AIIdleCoverStandLookRight                   = 36,
	YAIDFB_AIIdleCoverStandEdgeLookRight               = 37,
	YAIDFB_AIIdleCoverStandEdgeLookRightMirr           = 38,
	YAIDFB_AIIdleCoverStandEdgeLookRightSlow           = 39,
	YAIDFB_AIIdleCoverStandEdgeLookRightSlowMirr       = 40,
	YAIDFB_AIIdleCoverStandEdgeCheckWeapon             = 41,
	YAIDFB_AIIdleCoverStandEdgeCheckWeaponMirr         = 42,
	YAIDFB_AIIdleCrouchAimWithWeaponForward            = 43,
	YAIDFB_AIIdleCrouchAimWithWeaponRight              = 44,
	YAIDFB_AIIdleCrouchAimWithWeaponLeft               = 45,
	YAIDFB_AIIdleCrouchLookBackwards                   = 46,
	YAIDFB_AIIdleStandAimWithWeaponForward             = 47,
	YAIDFB_AIIdleStandAimWithWeaponRight               = 48,
	YAIDFB_AIIdleStandAimWithWeaponLeft                = 49,
	YAIDFB_AIIdleStandLookRight                        = 50,
	YAIDFB_AIIdleStandCheckWeapon                      = 51,
	YAIDFB_AIIdleStandBoredLookAround                  = 52,
	YAIDFB_LugoSniperAttackCrouched                    = 53,
	YAIDFB_LugoSniperAttackStand                       = 54,
	YAIDFB_AITossAwayWeapon                            = 55,
	YAIDFB_AIWeapomJamStd                              = 56,
	YAIDFB_AIWeapomJamCrc                              = 57,
	YAIDFB_PeekSideFiredUponCoverStand                 = 58,
	YAIDFB_StepOutSideFiredUponCoverStand              = 59,
	YAIDFB_PeekSideFiredUponCoverCrouch                = 60,
	YAIDFB_StepOutSideFiredUponCoverCrouch             = 61,
	YAIDFB_PeekUpFiredUponCoverCrouch                  = 62,
	YAIDFB_AimOverFiredUponCoverCrouch                 = 63,
	YAIDFB_HitReact_CrouchCoverAimOver                 = 64,
	YAIDFB_HitReact_CrouchCoverAimSide                 = 65,
	YAIDFB_HitReact_StandCoverAimSide                  = 66,
	YAIDFB_HitReact_DSG_StumbleSandBombA               = 67,
	YAIDFB_HitReact_DSG_StumbleSandBombB               = 68,
	YAIDFB_HitReact_StumbleSandBomb                    = 69,
	YAIDFB_HitReact_StumbleSandPoolA                   = 70,
	YAIDFB_HitReact_StumbleSandPoolB                   = 71,
	YAIDFB_HitReact_StumbleSandPoolC                   = 72,
	YAIDFB_HitReact_StumbleSandPoolD                   = 73,
	YAIDFB_HitReact_StumbleBlindfire                   = 74,
	YAIDFB_HeadCoverCoverCrouch                        = 75,
	YAIDFB_FlinchCoverCrouch                           = 76,
	YAIDFB_FlinchCoverCrouchEdge                       = 77,
	YAIDFB_FlinchCoverStandEdge                        = 78,
	YAIDFB_IdleCoverCrouchEdgeA                        = 79,
	YAIDFB_IdleCoverCrouchEdgeB                        = 80,
	YAIDFB_IdleCoverCrouchEdgeC                        = 81,
	YAIDFB_IdleCoverCrouchEdgeD                        = 82,
	YAIDFB_IdleCoverStandEdgeA                         = 83,
	YAIDFB_IdleCoverStandEdgeB                         = 84,
	YAIDFB_SupressedCoverCrouch                        = 85,
	YAIDFB_SupressedCoverCrouchEdge                    = 86,
	YAIDFB_SupressedCoverStandEdge                     = 87,
	YAIDFB_IdleCoverCrouchEdgeAMirr                    = 88,
	YAIDFB_IdleCoverCrouchEdgeBMirr                    = 89,
	YAIDFB_IdleCoverCrouchEdgeCMirr                    = 90,
	YAIDFB_IdleCoverCrouchEdgeDMirr                    = 91,
	YAIDFB_IdleCoverStandEdgeAMirr                     = 92,
	YAIDFB_IdleCoverStandEdgeBMirr                     = 93,
	YAIDFB_MAX                                         = 94
};*/

// Enum SRGame.YAnimInfo.YE_AnimID_Misc
/*enum YE_AnimID_Misc
{
	YAIDMI_None                                        = 0,
	YAIDMI_RagRecoverFrontStand                        = 1,
	YAIDMI_RagRecoverBackStand                         = 2,
	YAIDMI_RagRecoverFrontCrouch                       = 3,
	YAIDMI_RagRecoverBackCrouch                        = 4,
	YAIDMI_RagRecoverFrontDBNO                         = 5,
	YAIDMI_RagRecoverBackDBNO                          = 6,
	YAIDMI_RagRecoverFrontToAnimDrivenDBNO             = 7,
	YAIDMI_RagRecoverBackAnimDrivenDBNO                = 8,
	YAIDMI_DeathDBNOExpressive_Front_Var_01            = 9,
	YAIDMI_DeathDBNOExpressive_Front_Var_02            = 10,
	YAIDMI_DeathDBNOExpressive_Back_Var_01             = 11,
	YAIDMI_DeathDBNOExpressive_Back_Var_02             = 12,
	YAIDMI_HealStandStart                              = 13,
	YAIDMI_HealStandMid                                = 14,
	YAIDMI_HealStandEnd                                = 15,
	YAIDMI_HealCrouchStart                             = 16,
	YAIDMI_HealCrouchMid                               = 17,
	YAIDMI_HealCrouchEnd                               = 18,
	YAIDMI_HealReactionInto                            = 19,
	YAIDMI_HealReaction                                = 20,
	YAIDMI_HealSelfStart                               = 21,
	YAIDMI_HeadCover_Std                               = 22,
	YAIDMI_HeadCover_Crc                               = 23,
	YAIDMI_HeadCover_CovStd                            = 24,
	YAIDMI_HeadCover_CovCrc                            = 25,
	YAIDMI_HeadCover_CovStd_EdgeL                      = 26,
	YAIDMI_HeadCover_CovCrc_EdgeL                      = 27,
	YAIDMI_HeadCover_CovStd_EdgeR                      = 28,
	YAIDMI_HeadCover_CovCrc_EdgeR                      = 29,
	YAIDMI_FastRopePrepare                             = 30,
	YAIDMI_FastRopeTakeRope                            = 31,
	YAIDMI_FastRopeJumpBegin                           = 32,
	YAIDMI_FastRopeJumpLoop                            = 33,
	YAIDMI_FastRopeJumpEnd                             = 34,
	YAIDMI_FastRopeStraightBegin                       = 35,
	YAIDMI_FastRopeStraightLoop                        = 36,
	YAIDMI_FastRopeStraightEnd                         = 37,
	YAIDMI_FastRopeStraightEndNoTurn                   = 38,
	YAIDMI_ZiplineIn                                   = 39,
	YAIDMI_ZiplineTraversal                            = 40,
	YAIDMI_ZiplineOut                                  = 41,
	YAIDMI_IntelOp1InStand                             = 42,
	YAIDMI_IntelOp1IdleStand                           = 43,
	YAIDMI_IntelOp1OutStand                            = 44,
	YAIDMI_IntelOp1InCrouch                            = 45,
	YAIDMI_IntelOp1IdleCrouch                          = 46,
	YAIDMI_IntelOp1OutCrouch                           = 47,
	YAIDMI_DownToZoom                                  = 48,
	YAIDMI_ZoomToDown                                  = 49,
	YAIDMI_AimToZoom                                   = 50,
	YAIDMI_ZoomToAim                                   = 51,
	YAIDMI_Mortar_AdamsIn                              = 52,
	YAIDMI_Mortar_AdamsIdle                            = 53,
	YAIDMI_Mortar_AdamsOut                             = 54,
	YAIDMI_Mortar_AdamsTweakingIn                      = 55,
	YAIDMI_Mortar_AdamsTweakingIdle                    = 56,
	YAIDMI_Mortar_AdamsTweakingOut                     = 57,
	YAIDMI_Mortar_AdamsFireIn                          = 58,
	YAIDMI_Mortar_AdamsFireIdle                        = 59,
	YAIDMI_Mortar_AdamsFireOut                         = 60,
	YAIDMI_Mortar_LugoIn                               = 61,
	YAIDMI_Mortar_LugoIdle                             = 62,
	YAIDMI_Mortar_LugoOut                              = 63,
	YAIDMI_Mortar_LugoFireIn                           = 64,
	YAIDMI_Mortar_LugoFireIdle                         = 65,
	YAIDMI_Mortar_LugoFireOut                          = 66,
	YAIDMI_Mortar_HitACover                            = 67,
	YAIDMI_Mortar_DeathACover                          = 68,
	YAIDMI_Mortar_DeathBCover                          = 69,
	YAIDMI_Mortar_HitA                                 = 70,
	YAIDMI_Mortar_DeathA                               = 71,
	YAIDMI_Mortar_DeathB                               = 72,
	YAIDMI_TurretEnterStand                            = 73,
	YAIDMI_TurretLeaveStand                            = 74,
	YAIDMI_TurretIdleStand                             = 75,
	YAIDMI_TurretEnterCrouch                           = 76,
	YAIDMI_TurretLeaveCrouch                           = 77,
	YAIDMI_TurretIdleCrouch                            = 78,
	YAIDMI_CallChopper                                 = 79,
	YAIDMI_MarkBase                                    = 80,
	YAIDMI_HackComputer                                = 81,
	YAIDMI_FixVitalPoint                               = 82,
	YAIDMI_ArmBomb                                     = 83,
	YAIDMI_DisarmBomb                                  = 84,
	YAIDMI_MAX                                         = 85
};*/

// Enum SRGame.YAnimInfo.YE_AnimID_Combat
/*enum YE_AnimID_Combat
{
	YAIDCO_None                                        = 0,
	YAIDCO_ReloadWeaponStand                           = 1,
	YAIDCO_ReloadWeaponCrouch                          = 2,
	YAIDCO_ReloadWeaponCoverStand                      = 3,
	YAIDCO_ReloadWeaponCoverCrouch                     = 4,
	YAIDCO_ReloadWeaponCoverEdgeStand                  = 5,
	YAIDCO_ReloadWeaponCoverEdgeCrouch                 = 6,
	YAIDCO_SingleReloadInStand                         = 7,
	YAIDCO_SingleReloadLoopStand                       = 8,
	YAIDCO_SingleReloadOutStand                        = 9,
	YAIDCO_SingleReloadInCrouch                        = 10,
	YAIDCO_SingleReloadLoopCrouch                      = 11,
	YAIDCO_SingleReloadOutCrouch                       = 12,
	YAIDCO_SingleReloadInCoverStand                    = 13,
	YAIDCO_SingleReloadLoopCoverStand                  = 14,
	YAIDCO_SingleReloadOutCoverStand                   = 15,
	YAIDCO_SingleReloadInCoverCrouch                   = 16,
	YAIDCO_SingleReloadLoopCoverCrouch                 = 17,
	YAIDCO_SingleReloadOutCoverCrouch                  = 18,
	YAIDCO_SingleReloadInCoverStandEdge                = 19,
	YAIDCO_SingleReloadLoopCoverStandEdge              = 20,
	YAIDCO_SingleReloadOutCoverStandEdge               = 21,
	YAIDCO_SingleReloadInCoverCrouchEdge               = 22,
	YAIDCO_SingleReloadLoopCoverCrouchEdge             = 23,
	YAIDCO_SingleReloadOutCoverCrouchEdge              = 24,
	YAIDCO_EquipWeaponStandRight                       = 25,
	YAIDCO_EquipWeaponCrouchRight                      = 26,
	YAIDCO_EquipWeaponCoverStandRight                  = 27,
	YAIDCO_EquipWeaponCoverCrouchRight                 = 28,
	YAIDCO_EquipWeaponCoverStandEdgeRight              = 29,
	YAIDCO_EquipWeaponCoverCrouchEdgeRight             = 30,
	YAIDCO_HolsterWeaponStandRight                     = 31,
	YAIDCO_HolsterWeaponCrouchRight                    = 32,
	YAIDCO_HolsterWeaponCoverStandRight                = 33,
	YAIDCO_HolsterWeaponCoverCrouchRight               = 34,
	YAIDCO_HolsterWeaponCoverStandEdgeRight            = 35,
	YAIDCO_HolsterWeaponCoverCrouchEdgeRight           = 36,
	YAIDCO_ThrowGrenadeTossStand                       = 37,
	YAIDCO_ThrowGrenadeLongInStand                     = 38,
	YAIDCO_ThrowGrenadeLongIdleStand                   = 39,
	YAIDCO_ThrowGrenadeLongThrowStand                  = 40,
	YAIDCO_ThrowGrenadeLongOutStand                    = 41,
	YAIDCO_ThrowGrenadeTossCrouch                      = 42,
	YAIDCO_ThrowGrenadeLongInCrouch                    = 43,
	YAIDCO_ThrowGrenadeLongIdleCrouch                  = 44,
	YAIDCO_ThrowGrenadeLongThrowCrouch                 = 45,
	YAIDCO_ThrowGrenadeLongOutCrouch                   = 46,
	YAIDCO_ThrowGrenadeTossCoverStandBack              = 47,
	YAIDCO_ThrowGrenadeTossCoverStandRight             = 48,
	YAIDCO_ThrowGrenadeTossCoverStand                  = 49,
	YAIDCO_ThrowGrenadeLongIdleCoverStand              = 50,
	YAIDCO_ThrowGrenadeLongIntoCoverStand              = 51,
	YAIDCO_ThrowGrenadeLongThrowCoverStand             = 52,
	YAIDCO_ThrowGrenadeLongOutCoverStand               = 53,
	YAIDCO_ThrowGrenadeLongFrontIntoCoverStand         = 54,
	YAIDCO_ThrowGrenadeLongFrontThrowCoverStand        = 55,
	YAIDCO_ThrowGrenadeLongFrontOutCoverStand          = 56,
	YAIDCO_ThrowGrenadeLongLeftIntoCoverStand          = 57,
	YAIDCO_ThrowGrenadeLongLeftThrowCoverStand         = 58,
	YAIDCO_ThrowGrenadeLongLeftOutCoverStand           = 59,
	YAIDCO_ThrowGrenadeLongRightIntoCoverStand         = 60,
	YAIDCO_ThrowGrenadeLongRightThrowCoverStand        = 61,
	YAIDCO_ThrowGrenadeLongRightOutCoverStand          = 62,
	YAIDCO_ThrowGrenadeTossCoverCrouchBack             = 63,
	YAIDCO_ThrowGrenadeTossCoverCrouchRight            = 64,
	YAIDCO_ThrowGrenadeTossCoverCrouch                 = 65,
	YAIDCO_ThrowGrenadeLongIdleCoverCrouch             = 66,
	YAIDCO_ThrowGrenadeLongIntoCoverCrouch             = 67,
	YAIDCO_ThrowGrenadeLongThrowCoverCrouch            = 68,
	YAIDCO_ThrowGrenadeLongOutCoverCrouch              = 69,
	YAIDCO_ThrowGrenadeLongFrontIntoCoverCrouch        = 70,
	YAIDCO_ThrowGrenadeLongFrontThrowCoverCrouch       = 71,
	YAIDCO_ThrowGrenadeLongFrontOutCoverCrouch         = 72,
	YAIDCO_ThrowGrenadeLongLeftIntoCoverCrouch         = 73,
	YAIDCO_ThrowGrenadeLongLeftThrowCoverCrouch        = 74,
	YAIDCO_ThrowGrenadeLongLeftOutCoverCrouch          = 75,
	YAIDCO_ThrowGrenadeLongRightIntoCoverCrouch        = 76,
	YAIDCO_ThrowGrenadeLongRightThrowCoverCrouch       = 77,
	YAIDCO_ThrowGrenadeLongRightOutCoverCrouch         = 78,
	YAIDCO_ThrowGrenadeLongDirectInAimOverCover        = 79,
	YAIDCO_ThrowGrenadeTossAimOverCover                = 80,
	YAIDCO_ThrowGrenadeLongInAimOverCover              = 81,
	YAIDCO_ThrowGrenadeLongIdleAimOverCover            = 82,
	YAIDCO_ThrowGrenadeLongThrowAimOverCover           = 83,
	YAIDCO_ThrowGrenadeLongOutAimOverCover             = 84,
	YAIDCO_ThrowGrenadeLongIdleLeanOverCover           = 85,
	YAIDCO_ThrowGrenadeLongThrowLeanOverCover          = 86,
	YAIDCO_ThrowGrenadeLongOutLeanOverCover            = 87,
	YAIDCO_ThrowGrenadeTossEdgeCoverStand              = 88,
	YAIDCO_ThrowGrenadeTossEdgeCoverCrouch             = 89,
	YAIDCO_ThrowGrenadeTossBlindfireSideCoverStand     = 90,
	YAIDCO_ThrowGrenadeTossBlindfireSideCoverCrouch    = 91,
	YAIDCO_ThrowGrenadeLongDirectInAimOutCoverStand    = 92,
	YAIDCO_ThrowGrenadeTossAimOutCoverStand            = 93,
	YAIDCO_ThrowGrenadeLongIdleAimOutCoverStand        = 94,
	YAIDCO_ThrowGrenadeLongIntoAimOutCoverStand        = 95,
	YAIDCO_ThrowGrenadeLongThrowAimOutCoverStand       = 96,
	YAIDCO_ThrowGrenadeLongOutAimOutCoverStand         = 97,
	YAIDCO_ThrowGrenadeLongDirectInAimOutCoverCrouch   = 98,
	YAIDCO_ThrowGrenadeTossAimOutCoverCrouch           = 99,
	YAIDCO_ThrowGrenadeLongIdleAimOutCoverCrouch       = 100,
	YAIDCO_ThrowGrenadeLongIntoAimOutCoverCrouch       = 101,
	YAIDCO_ThrowGrenadeLongThrowAimOutCoverCrouch      = 102,
	YAIDCO_ThrowGrenadeLongOutAimOutCoverCrouch        = 103,
	YAIDCO_ThrowGrenadeLongInLeanAroundCoverCrouch     = 104,
	YAIDCO_ThrowGrenadeLongInLeanAroundCoverStand      = 105,
	YAIDCO_ThrowGrenadeTossAroundEdgeCoverCrouch       = 106,
	YAIDCO_ThrowGrenadeTossAroundEdgeCoverStand        = 107,
	YAIDCO_ThrowGrenadeZipline                         = 108,
	YAIDCO_ThrowGrenadeZiplineIn                       = 109,
	YAIDCO_ThrowGrenadeZiplineOut                      = 110,
	YAIDCO_RefireStand                                 = 111,
	YAIDCO_RefireStandMirrored                         = 112,
	YAIDCO_RefireStandSlide                            = 113,
	YAIDCO_RefireCrouch                                = 114,
	YAIDCO_RefireCrouchSlide                           = 115,
	YAIDCO_RefireCoverStand                            = 116,
	YAIDCO_RefireCoverCrouch                           = 117,
	YAIDCO_RefireCoverCrouchFromAimOver                = 118,
	YAIDCO_RefireCoverStandEdgeRight                   = 119,
	YAIDCO_RefireCoverCrouchEdgeRight                  = 120,
	YAIDCO_RefireCoverStandEdgeLeft                    = 121,
	YAIDCO_RefireCoverCrouchEdgeLeft                   = 122,
	YAIDCO_RefireCoverStandFromAimOut                  = 123,
	YAIDCO_RefireCoverCrouchFromAimOut                 = 124,
	YAIDCO_RefireCoverStandAimOutRight                 = 125,
	YAIDCO_RefireCoverCrouchAimOutRight                = 126,
	YAIDCO_RefireCoverStandAimOutLeft                  = 127,
	YAIDCO_RefireCoverCrouchAimOutLeft                 = 128,
	YAIDCO_RefireCoverCrouchAimOver                    = 129,
	YAIDCO_RefireCoverStandBlindfireLeft               = 130,
	YAIDCO_RefireCoverStandBlindfireRight              = 131,
	YAIDCO_RefireCoverCrouchBlindfireLeft              = 132,
	YAIDCO_RefireCoverCrouchBlindfireRight             = 133,
	YAIDCO_RefireCoverCrouchBlindfireOver              = 134,
	YAIDCO_MeleeAttackIdle                             = 135,
	YAIDCO_MeleeAttackUpperBody                        = 136,
	YAIDCO_MeleeAttackUpperBodyLeft                    = 137,
	YAIDCO_MeleeAttackIdlePlayerVar02                  = 138,
	YAIDCO_MeleeAttackIdlePlayerVar03                  = 139,
	YAIDCO_MeleeAttackUpperBodyPlayerVar02             = 140,
	YAIDCO_MeleeAttackUpperBodyPlayerVar03             = 141,
	YAIDCO_MeleeAttackIdleCrouch                       = 142,
	YAIDCO_MeleeAttackUpperBodyCrouch                  = 143,
	YAIDCO_AdrenalineInjectionUpperBodyStd             = 144,
	YAIDCO_AdrenalineInjectionUpperBodyCrc             = 145,
	YAIDCO_HumanShieldTakeCaptor                       = 146,
	YAIDCO_HumanShieldTakeVictim                       = 147,
	YAIDCO_HumanShieldIdleVictim                       = 148,
	YAIDCO_HumanShieldCaptorKills                      = 149,
	YAIDCO_HumanShieldVictimDies                       = 150,
	YAIDCO_HumanShieldVictimFlees                      = 151,
	YAIDCO_PickUpStand                                 = 152,
	YAIDCO_PickUpCrouch                                = 153,
	YAIDCO_PickUpCoverStand                            = 154,
	YAIDCO_PickUpCoverCrouch                           = 155,
	YAIDCO_PickUpCrate                                 = 156,
	YAIDCO_PickUpBox                                   = 157,
	YAIDCO_PickUpStandRack                             = 158,
	YAIDCO_PickUpCrouchRack                            = 159,
	YAIDCO_RaiseWeaponStand                            = 160,
	YAIDCO_RaiseWeaponCrouch                           = 161,
	YAIDCO_EquipSecondaryStand                         = 162,
	YAIDCO_EquipSecondaryCrouch                        = 163,
	YAIDCO_EquipSecondaryCoverStand                    = 164,
	YAIDCO_EquipSecondaryCoverCrouch                   = 165,
	YAIDCO_EquipSecondaryCoverStandEdge                = 166,
	YAIDCO_EquipSecondaryCoverCrouchEdge               = 167,
	YAIDCO_UnequipSecondaryStand                       = 168,
	YAIDCO_UnequipSecondaryCrouch                      = 169,
	YAIDCO_UnequipSecondaryCoverStand                  = 170,
	YAIDCO_UnequipSecondaryCoverCrouch                 = 171,
	YAIDCO_UnequipSecondaryCoverStandEdge              = 172,
	YAIDCO_UnequipSecondaryCoverCrouchEdge             = 173,
	YAIDCO_Execute_Censored_Var01                      = 174,
	YAIDCO_ExecutionReaction_Back_Censored_Var01       = 175,
	YAIDCO_ExecutionReaction_Belly_Censored_Var01      = 176,
	YAIDCO_Execute_Var01                               = 177,
	YAIDCO_ExecutionReaction_Back_Var01                = 178,
	YAIDCO_ExecutionReaction_Belly_Var01               = 179,
	YAIDCO_Execute_Var02                               = 180,
	YAIDCO_ExecutionReaction_Back_Var02                = 181,
	YAIDCO_ExecutionReaction_Belly_Var02               = 182,
	YAIDCO_CovCrcBlindFireSprayUp                      = 183,
	YAIDCO_CovCrcBlindFireSpraySide                    = 184,
	YAIDCO_CovStdBlindFireSpraySide                    = 185,
	YAIDCO_MAX                                         = 186
};*/

// Enum SRGame.YAnimInfo.YE_AnimID_Transition
/*enum YE_AnimID_Transition
{
	YAIDTR_None                                        = 0,
	YAIDTR_StandToCrouch                               = 1,
	YAIDTR_CrouchToStand                               = 2,
	YAIDTR_StandToCrouch_Aim                           = 3,
	YAIDTR_CrouchToStand_Aim                           = 4,
	YAIDTR_CoverStandLToCoverStandR                    = 5,
	YAIDTR_CoverStandRToCoverStandL                    = 6,
	YAIDTR_CoverStandToEdgeL                           = 7,
	YAIDTR_CoverCrouchToEdgeL                          = 8,
	YAIDTR_CoverStandEdgeRToCoverStandEdgeL            = 9,
	YAIDTR_CoverCrouchEdgeRToCoverCrouchEdgeL          = 10,
	YAIDTR_CoverStandLToCoverStandPeekEdgeL            = 11,
	YAIDTR_CoverStandPeekEdgeLToCoverStandL            = 12,
	YAIDTR_CoverStandRToCoverStandPeekEdgeR            = 13,
	YAIDTR_CoverStandPeekEdgeRToCoverStandR            = 14,
	YAIDTR_CoverStandLToCoverStandAimOutL              = 15,
	YAIDTR_CoverStandAimOutLToCoverStandL              = 16,
	YAIDTR_CoverStandRToCoverStandAimOutR              = 17,
	YAIDTR_CoverStandAimOutRToCoverStandR              = 18,
	YAIDTR_CoverStandLToCoverStandAimOutL_Aim          = 19,
	YAIDTR_CoverStandAimOutLToCoverStandL_Aim          = 20,
	YAIDTR_CoverStandRToCoverStandAimOutR_Aim          = 21,
	YAIDTR_CoverStandAimOutRToCoverStandR_Aim          = 22,
	YAIDTR_CoverStandPeekEdgeLToCoverStandAimOutL      = 23,
	YAIDTR_CoverStandPeekEdgeRToCoverStandAimOutR      = 24,
	YAIDTR_CoverStandAimOutLToCoverStandAimAroundL     = 25,
	YAIDTR_CoverStandAimAroundLToCoverStandAimOutL     = 26,
	YAIDTR_CoverStandAimOutRToCoverStandAimAroundR     = 27,
	YAIDTR_CoverStandAimAroundRToCoverStandAimOutR     = 28,
	YAIDTR_CoverCrouchLToCoverCrouchR                  = 29,
	YAIDTR_CoverCrouchRToCoverCrouchL                  = 30,
	YAIDTR_CoverCrouchLToCoverCrouchPeekEdgeL          = 31,
	YAIDTR_CoverCrouchRToCoverCrouchPeekEdgeR          = 32,
	YAIDTR_CoverCrouchPeekEdgeLToCoverCrouchL          = 33,
	YAIDTR_CoverCrouchPeekEdgeRToCoverCrouchR          = 34,
	YAIDTR_CoverCrouchLToCoverCrouchAimOutL            = 35,
	YAIDTR_CoverCrouchAimOutLToCoverCrouchL            = 36,
	YAIDTR_CoverCrouchRToCoverCrouchAimOutR            = 37,
	YAIDTR_CoverCrouchAimOutRToCoverCrouchR            = 38,
	YAIDTR_CoverCrouchAimOutLToAimOver                 = 39,
	YAIDTR_CoverCrouchAimOverToAimOutL                 = 40,
	YAIDTR_CoverCrouchLToCoverCrouchAimOutL_Aim        = 41,
	YAIDTR_CoverCrouchAimOutLToCoverCrouchL_Aim        = 42,
	YAIDTR_CoverCrouchRToCoverCrouchAimOutR_Aim        = 43,
	YAIDTR_CoverCrouchAimOutRToCoverCrouchR_Aim        = 44,
	YAIDTR_CoverCrouchAimOutRToCoverCrouchAimOverR     = 45,
	YAIDTR_CoverCrouchPeekEdgeLToCoverCrouchAimOutL    = 46,
	YAIDTR_CoverCrouchPeekEdgeRToCoverCrouchAimOutR    = 47,
	YAIDTR_CoverCrouchAimOutLToCoverCrouchAimAroundL   = 48,
	YAIDTR_CoverCrouchAimAroundLToCoverCrouchAimOutL   = 49,
	YAIDTR_CoverCrouchAimOutRToCoverCrouchAimAroundR   = 50,
	YAIDTR_CoverCrouchAimAroundRToCoverCrouchAimOutR   = 51,
	YAIDTR_CoverStandToCoverStandBlindfireEdge         = 52,
	YAIDTR_CoverStandBlindfireEdgeToCoverStand         = 53,
	YAIDTR_CoverCrouchBlindfireEdgeToAimOver           = 54,
	YAIDTR_CoverCrouchAimOverToBlindfireEdge           = 55,
	YAIDTR_CoverCrouchBlindfireEdgeLToAimOver          = 56,
	YAIDTR_CoverCrouchLToCoverCrouchBlindfireEdgeL     = 57,
	YAIDTR_CoverCrouchBlindfireEdgeLToCoverCrouchL     = 58,
	YAIDTR_CoverCrouchRToCoverCrouchBlindfireEdgeR     = 59,
	YAIDTR_CoverCrouchBlindfireEdgeRToCoverCrouchR     = 60,
	YAIDTR_CoverCrouchBlindfireEdgeLToAimOverCoverCrouchBlindfireOver = 61,
	YAIDTR_AimOverCoverCrouchBlindfireOverToCoverCrouchBlindfireEdgeL = 62,
	YAIDTR_CoverCrouchLToCoverCrouchPeekOverL          = 63,
	YAIDTR_CoverCrouchPeekOverLToCoverCrouchL          = 64,
	YAIDTR_CoverCrouchRToCoverCrouchPeekOverR          = 65,
	YAIDTR_CoverCrouchPeekOverRToCoverCrouchR          = 66,
	YAIDTR_CoverCrouchToAimOverL                       = 67,
	YAIDTR_CoverCrouchToAimOverR                       = 68,
	YAIDTR_AimOverToCoverCrouch                        = 69,
	YAIDTR_CoverCrouchToAimOverL_Aim                   = 70,
	YAIDTR_CoverCrouchToAimOverR_Aim                   = 71,
	YAIDTR_CoverCrouchEdgeLToAimOver                   = 72,
	YAIDTR_AimOverToCoverCrouchEdgeL                   = 73,
	YAIDTR_AimOverToAimedCoverCrouchEdgeL              = 74,
	YAIDTR_CoverCrouchEdgeRToAimOver                   = 75,
	YAIDTR_AimOverToCoverCrouchEdgeR                   = 76,
	YAIDTR_AimOverToAimedCoverCrouchEdgeR              = 77,
	YAIDTR_CoverCrouchToBlindfireOver                  = 78,
	YAIDTR_CoverCrouchLAimToBlindfireOver              = 79,
	YAIDTR_BlindfireOverToCoverCrouch                  = 80,
	YAIDTR_BlindfireOverToCoverCrouchLAimedBwd         = 81,
	YAIDTR_BlindfireOverToCoverCrouchLAimed            = 82,
	YAIDTR_BlindfireOverToAimOver                      = 83,
	YAIDTR_CoverCrouchBlindfireOverRToCoverCrouchEdgeR = 84,
	YAIDTR_CoverCrouchEdgeRToCoverCrouchBlindfireOverR = 85,
	YAIDTR_CoverCrouchBlindfireOverLToCoverCrouchEdgeL = 86,
	YAIDTR_CoverCrouchEdgeLToCoverCrouchBlindfireOverL = 87,
	YAIDTR_CoverCrouchPeekOverLToPeekDownL             = 88,
	YAIDTR_PeekDownLToCoverCrouchPeekOverL             = 89,
	YAIDTR_CoverCrouchPeekOverRToPeekDownR             = 90,
	YAIDTR_PeekDownRToCoverCrouchPeekOverR             = 91,
	YAIDTR_CoverCrouchToAimDown                        = 92,
	YAIDTR_AimDownToCoverCrouch                        = 93,
	YAIDTR_StandToStackedIdleR                         = 94,
	YAIDTR_StandToStackedIdleL                         = 95,
	YAIDTR_StackedIdleRToStand                         = 96,
	YAIDTR_StackedIdleLToStand                         = 97,
	YAIDTR_StackedIdleLToStackedL                      = 98,
	YAIDTR_StackedLToStackedIdleL                      = 99,
	YAIDTR_StackedIdleRToStackedR                      = 100,
	YAIDTR_StackedRToStackedIdleR                      = 101,
	YAIDTR_StandToDownButNotOut                        = 102,
	YAIDTR_CrouchToDownButNotOut                       = 103,
	YAIDTR_DownButNotOutToStand                        = 104,
	YAIDTR_DownButNotOutToCrouch                       = 105,
	YAIDTR_StandToMobileDownButNotOut                  = 106,
	YAIDTR_CrouchToMobileDownButNotOut                 = 107,
	YAIDTR_MobileDownButNotOutToStand                  = 108,
	YAIDTR_MobileDownButNotOutToCrouch                 = 109,
	YAIDTR_MobileDBNOToStumble                         = 110,
	YAIDTR_StumbleToMobileDBNO                         = 111,
	YAIDTR_AimOverCrouchCoverToStand                   = 112,
	YAIDTR_AimOutOfCrouchCoverToCrouchL                = 113,
	YAIDTR_AimOutOfCrouchCoverToCrouchR                = 114,
	YAIDTR_AimOutOfCrouchCoverToStandL                 = 115,
	YAIDTR_AimOutOfCrouchCoverToStandR                 = 116,
	YAIDTR_AimOutOfStandCoverToStandL                  = 117,
	YAIDTR_AimOutOfStandCoverToStandR                  = 118,
	YAIDTR_AimOutOfStackCoverToStandL                  = 119,
	YAIDTR_AimOutOfStackCoverToStandR                  = 120,
	YAIDTR_CovStd_IdleToBwd                            = 121,
	YAIDTR_CovStd_BwdToIdle                            = 122,
	YAIDTR_CovStd_IdleToFwd                            = 123,
	YAIDTR_CovStd_FwdToIdle                            = 124,
	YAIDTR_CovStd_BwdToFwd                             = 125,
	YAIDTR_CovStd_BwdToMirroredEdge                    = 126,
	YAIDTR_CovStd_MirroredEdgeToFwd                    = 127,
	YAIDTR_CovStd_AimToMirroredEdgeAim                 = 128,
	YAIDTR_CovCrc_BwdToFwd                             = 129,
	YAIDTR_CovCrc_BwdToMirroredEdge                    = 130,
	YAIDTR_CovCrc_MirroredEdgeToFwd                    = 131,
	YAIDTR_CovCrc_AimToMirroredEdgeAim                 = 132,
	YAIDTR_CovCrc_IdleToBwd                            = 133,
	YAIDTR_CovCrc_BwdToIdle                            = 134,
	YAIDTR_CovCrc_IdleToFwd                            = 135,
	YAIDTR_CovCrc_FwdToIdle                            = 136,
	YAIDTR_ToHack                                      = 137,
	YAIDTR_FromHack                                    = 138,
	YAIDTR_MAX                                         = 139
};*/

// Enum SRGame.YAnimInfo.YE_AnimID_Movement
/*enum YE_AnimID_Movement
{
	YAIDMO_None                                        = 0,
	YAIDMO_MantleOverCover                             = 1,
	YAIDMO_MantleOverCoverDrop                         = 2,
	YAIDMO_MantleOverCoverThin                         = 3,
	YAIDMO_VaultOverCover                              = 4,
	YAIDMO_VaultOverCoverDrop                          = 5,
	YAIDMO_VaultOverCoverThin                          = 6,
	YAIDMO_VaultKick                                   = 7,
	YAIDMO_VaultTurnAround                             = 8,
	YAIDMO_Fall                                        = 9,
	YAIDMO_FallSuperSoft                               = 10,
	YAIDMO_LandSoftStand                               = 11,
	YAIDMO_LandSoftStand_MP                            = 12,
	YAIDMO_LandSoftCrouch                              = 13,
	YAIDMO_LandHardStand                               = 14,
	YAIDMO_LandHardStand_MP                            = 15,
	YAIDMO_LandHardCrouch                              = 16,
	YAIDMO_SwatTurnCoverStandToCoverStand256Left       = 17,
	YAIDMO_SwatTurnCoverStandToCoverStand256Right      = 18,
	YAIDMO_SwatTurnCoverCrouchToCoverCrouch256Left     = 19,
	YAIDMO_SwatTurnCoverCrouchToCoverCrouch256Right    = 20,
	YAIDMO_SwatTurnCoverStandToCoverCrouch256Left      = 21,
	YAIDMO_SwatTurnCoverStandToCoverCrouch256Right     = 22,
	YAIDMO_CoverStandSlipOutLeft                       = 23,
	YAIDMO_CoverStandSlipOutRight                      = 24,
	YAIDMO_CoverCrouchSlipOutLeft                      = 25,
	YAIDMO_CoverCrouchSlipOutRight                     = 26,
	YAIDMO_CoverStandSlipOutPeekLeft                   = 27,
	YAIDMO_CoverStandSlipOutPeekRight                  = 28,
	YAIDMO_CoverCrouchSlipOutPeekLeft                  = 29,
	YAIDMO_CoverCrouchSlipOutPeekRight                 = 30,
	YAIDMO_CoverStandSlipOutStepOutLeft                = 31,
	YAIDMO_CoverStandSlipOutStepOutRight               = 32,
	YAIDMO_CoverCrouchSlipOutStepOutLeft               = 33,
	YAIDMO_CoverCrouchSlipOutStepOutRight              = 34,
	YAIDMO_CoverStandSlipOutAlongLeft                  = 35,
	YAIDMO_CoverStandSlipOutAlongRight                 = 36,
	YAIDMO_CoverCrouchSlipOutAlongLeft                 = 37,
	YAIDMO_CoverCrouchSlipOutAlongRight                = 38,
	YAIDMO_CoverStandSlipOutAwayLeft                   = 39,
	YAIDMO_CoverStandSlipOutAwayRight                  = 40,
	YAIDMO_CoverCrouchSlipOutAwayLeft                  = 41,
	YAIDMO_CoverCrouchSlipOutAwayRight                 = 42,
	YAIDMO_CoverSlipOutAroundLeft                      = 43,
	YAIDMO_CoverSlipOutAroundRight                     = 44,
	YAIDMO_MeleeStumbleBackStand                       = 45,
	YAIDMO_MeleeStumbleFrontStand                      = 46,
	YAIDMO_MeleeStumbleLeftStand                       = 47,
	YAIDMO_MeleeStumbleRightStand                      = 48,
	YAIDMO_MeleeResistBackStand                        = 49,
	YAIDMO_MeleeResistFrontStand                       = 50,
	YAIDMO_MeleeResistLeftStand                        = 51,
	YAIDMO_MeleeResistRightStand                       = 52,
	YAIDMO_MeleeIntoFront                              = 53,
	YAIDMO_MeleeIntoBack                               = 54,
	YAIDMO_MeleeIntoLeft                               = 55,
	YAIDMO_MeleeIntoRight                              = 56,
	YAIDMO_MeleeIdleBack                               = 57,
	YAIDMO_MeleeIdleSide                               = 58,
	YAIDMO_MeleeOutBack                                = 59,
	YAIDMO_MeleeOutSide                                = 60,
	YAIDMO_DashIntoCover_CrcToCrc_Middle               = 61,
	YAIDMO_DashIntoCover_StdToCrc_Far_Start            = 62,
	YAIDMO_DashIntoCover_StdToCrc_Far_EndCenter        = 63,
	YAIDMO_DashIntoCover_StdToCrc_Far_EndLeft          = 64,
	YAIDMO_DashIntoCover_StdToCrc_Far_EndRight         = 65,
	YAIDMO_DashIntoCover_StdToStd_Far_Start            = 66,
	YAIDMO_DashIntoCover_StdToStd_Far_StartRight       = 67,
	YAIDMO_DashIntoCover_StdToStd_Far_EndCenter        = 68,
	YAIDMO_DashIntoCover_StdToStd_Far_EndLeft          = 69,
	YAIDMO_DashIntoCover_StdToStd_Middle_EndCenter     = 70,
	YAIDMO_DashIntoCover_StdToStd_Middle_EndLeft       = 71,
	YAIDMO_DashIntoCover_StdToStd_Middle_EndRight      = 72,
	YAIDMO_DashIntoCover_StdToCrc_Middle_Start         = 73,
	YAIDMO_DashIntoCover_StdToCrc_Middle_StartRight    = 74,
	YAIDMO_DashIntoCover_StdToCrc_Middle_EndRight      = 75,
	YAIDMO_SnapToCover_StdToStd_EndCenter              = 76,
	YAIDMO_SnapToCover_StdToStd_EndLeft                = 77,
	YAIDMO_SnapToCover_StdToStd_EndRight               = 78,
	YAIDMO_SnapToCover_StdToCrc_EndCenter              = 79,
	YAIDMO_SnapToCover_StdToCrc_EndLeft                = 80,
	YAIDMO_SnapToCover_StdToCrc_EndRight               = 81,
	YAIDMO_SnapToCover_CrcToCrc_EndCenter              = 82,
	YAIDMO_SnapToCover_CrcToCrc_EndLeft                = 83,
	YAIDMO_SnapToCover_CrcToCrc_EndRight               = 84,
	YAIDMO_DodgeRollStandForward                       = 85,
	YAIDMO_DodgeRollStandRight                         = 86,
	YAIDMO_DodgeRollStandLeft                          = 87,
	YAIDMO_DodgeMoveLeft                               = 88,
	YAIDMO_DodgeMoveRight                              = 89,
	YAIDMO_RetreatMove                                 = 90,
	YAIDMO_StickyAttached                              = 91,
	YAIDMO_SlideIntoCoverCrouchToCrouchForwardLeft     = 92,
	YAIDMO_SlideIntoCoverCrouchToCrouchForwardRight    = 93,
	YAIDMO_SlideIntoCoverCrouchToCrouchBackwardLeft    = 94,
	YAIDMO_SlideIntoCoverCrouchToCrouchBackwardRight   = 95,
	YAIDMO_SlideIntoCoverCrouchToCrouchFacingLeft      = 96,
	YAIDMO_SlideIntoCoverCrouchToCrouchFacingRight     = 97,
	YAIDMO_SlideIntoCoverCrouchToCrouchFacingAwayLeft  = 98,
	YAIDMO_SlideIntoCoverCrouchToCrouchFacingAwayRight = 99,
	YAIDMO_DropDown                                    = 100,
	YAIDMO_LeavePeekStandLeft                          = 101,
	YAIDMO_LeavePeekStandRight                         = 102,
	YAIDMO_LeavePeekCrouchLeft                         = 103,
	YAIDMO_LeavePeekCrouchRight                        = 104,
	YAIDMO_StandRunFwdUphillTumble                     = 105,
	YAIDMO_StandRunFwdDownhillTumble                   = 106,
	YAIDMO_StartSprintFwdCrouch                        = 107,
	YAIDMO_StartSprintBwdCrouch                        = 108,
	YAIDMO_StartSprintFwdStand                         = 109,
	YAIDMO_StartSprintBwdStand                         = 110,
	YAIDMO_StartSprintFromWalk                         = 111,
	YAIDMO_StartSprintFromPrepared                     = 112,
	YAIDMO_StartSprintFromForwardRun                   = 113,
	YAIDMO_StartSprintFromBackwardRun                  = 114,
	YAIDMO_StartSprintLeftCrouch                       = 115,
	YAIDMO_StartSprintRightCrouch                      = 116,
	YAIDMO_StartSprintLeftStand                        = 117,
	YAIDMO_StartSprintRightStand                       = 118,
	YAIDMO_StandToRun                                  = 119,
	YAIDMO_StopSprintToRun                             = 120,
	YAIDMO_StopSprintToStand                           = 121,
	YAIDMO_StopSprintToCrouch                          = 122,
	YAIDMO_RunToStand                                  = 123,
	YAIDMO_SideStepLeftStd                             = 124,
	YAIDMO_SideStepRightStd                            = 125,
	YAIDMO_SideStepLeftCrc                             = 126,
	YAIDMO_SideStepRightCrc                            = 127,
	YAIDMO_QuickTurnToBack                             = 128,
	YAIDMO_QuickTurnToLeft                             = 129,
	YAIDMO_QuickTurnToRight                            = 130,
	YAIDMO_PlayerQuickturnToBackStdLeft                = 131,
	YAIDMO_PlayerQuickturnToBackStdRight               = 132,
	YAIDMO_PlayerQuickturnToBackStd                    = 133,
	YAIDMO_PlayerQuickturnToLeftStd                    = 134,
	YAIDMO_PlayerQuickturnToRightStd                   = 135,
	YAIDMO_PlayerQuickturnToBackCrcLeft                = 136,
	YAIDMO_PlayerQuickturnToBackCrcRight               = 137,
	YAIDMO_PlayerQuickturnToBackCrc                    = 138,
	YAIDMO_PlayerQuickturnToLeftCrc                    = 139,
	YAIDMO_PlayerQuickturnToRightCrc                   = 140,
	YAIDMO_LeaveCoverStandToFwdStand                   = 141,
	YAIDMO_LeaveCoverStandToBwdStand                   = 142,
	YAIDMO_LeaveCoverCrouchToFwdStand                  = 143,
	YAIDMO_LeaveCoverCrouchToBwdStand                  = 144,
	YAIDMO_LeaveCoverCrouchToFwdCrouch                 = 145,
	YAIDMO_LeaveCoverCrouchToBwdCrouch                 = 146,
	YAIDMO_LeaveCoverEdgeStandLeftToFwdStand           = 147,
	YAIDMO_LeaveCoverEdgeStandRightToFwdStand          = 148,
	YAIDMO_LeaveCoverEdgeCrouchLeftToFwdCrouch         = 149,
	YAIDMO_LeaveCoverEdgeCrouchRightToFwdCrouch        = 150,
	YAIDMO_SprintSlide                                 = 151,
	YAIDMO_SprintSlide_Aimed                           = 152,
	YAIDMO_SprintSlideCrouched                         = 153,
	YAIDMO_SprintSlideCrouched_Aimed                   = 154,
	YAIDMO_StopRun                                     = 155,
	YAIDMO_StopRunMelee                                = 156,
	YAIDMO_JumpAwayFromGrenade                         = 157,
	YAIDMO_DiveAwayFromGrenade                         = 158,
	YAIDMO_CrouchToStand                               = 159,
	YAIDMO_StandToCrouch                               = 160,
	YAIDMO_AimedWalk2Run180                            = 161,
	YAIDMO_Run2AimedWalk180                            = 162,
	YAIDMO_AimedQuickTurnToLeft                        = 163,
	YAIDMO_AimedquickTurnToRight                       = 164,
	YAIDMO_MAX                                         = 165
};*/

// Enum SRGame.YAnimInfo.YE_AnimID_Dynamic
/*enum YE_AnimID_Dynamic
{
	YAIDDY_Dynamic1                                    = 0,
	YAIDDY_Dynamic2                                    = 1,
	YAIDDY_Dynamic3                                    = 2,
	YAIDDY_MAX                                         = 3
};*/

// Enum SRGame.YAnimInfo.YE_AnimMirrorMode
/*enum YE_AnimMirrorMode
{
	YAMM_Auto                                          = 0,
	YAMM_AutoReverse                                   = 1,
	YAMM_Mirrored                                      = 2,
	YAMM_NotMirrored                                   = 3,
	YAMM_Default                                       = 4,
	YAMM_MAX                                           = 5
};*/

// Enum SRGame.YAnimInfo.YE_AnimPriority
/*enum YE_AnimPriority
{
	YAP_None                                           = 0,
	YAP_Decorative                                     = 1,
	YAP_Illustrative                                   = 2,
	YAP_Aiming                                         = 3,
	YAP_RelevantTransition                             = 4,
	YAP_Relevant                                       = 5,
	YAP_Scripted                                       = 6,
	YAP_Crucial                                        = 7,
	YAP_MAX                                            = 8
};*/

// Enum SRGame.YAnimInfo.YE_AnimChannelID
/*enum YE_AnimChannelID
{
	YACID_FullBody                                     = 0,
	YACID_UpperBody                                    = 1,
	YACID_LowerBody                                    = 2,
	YACID_Idle                                         = 3,
	YACID_FullBodyOverlay                              = 4,
	YACID_UpperBodyOverlay                             = 5,
	YACID_Camera                                       = 6,
	YACID_FullBodyAdditive                             = 7,
	YACID_MoveFullBodyAdditive                         = 8,
	YACID_WeakFullBodyAdditive                         = 9,
	YACID_IdleFullBodyAdditive                         = 10,
	YACID_MAX                                          = 11
};*/

// Enum SRGame.YCameraModifier_CamBone.YE_CameraAnimOption
/*enum YE_CameraAnimOption
{
	YCAO_None                                          = 0,
	YCAO_TranslateDelta                                = 1,
	YCAO_TranslateRotateDelta                          = 2,
	YCAO_AbsoluteLocation                              = 3,
	YCAO_AbsoluteLocationRotation                      = 4,
	YCAO_MAX                                           = 5
};*/

// Enum SRGame.YAnimInfo.YE_AimTransitionSetID
/*enum YE_AimTransitionSetID
{
	YATS_None                                          = 0,
	YATS_Stand                                         = 1,
	YATS_MAX                                           = 2
};*/

// Enum SRGame.YAnimInfo.YE_AimingState
/*enum YE_AimingState
{
	YAS_NoAim                                          = 0,
	YAS_Aim                                            = 1,
	YAS_Zoom                                           = 2,
	YAS_Retract                                        = 3,
	YAS_MAX                                            = 4
};*/

// Enum SRGame.YAnimInfo.YE_MovementAnimChannelID
/*enum YE_MovementAnimChannelID
{
	YMAC_Standard                                      = 0,
	YMAC_Sand                                          = 1,
	YMAC_SandUphill                                    = 2,
	YMAC_SandDownhill                                  = 3,
	YMAC_MAX                                           = 4
};*/

// Enum SRGame.YPawnState.YE_Substate
/*enum YE_Substate
{
	YPSS_None                                          = 0,
	YPSS_StandardLeft                                  = 1,
	YPSS_StandardLeftBackwards                         = 2,
	YPSS_StandardRight                                 = 3,
	YPSS_StandardRightBackwards                        = 4,
	YPSS_StandardEdgeLeft                              = 5,
	YPSS_StandardEdgeRight                             = 6,
	YPSS_PeekEdgeLeft                                  = 7,
	YPSS_PeekEdgeRight                                 = 8,
	YPSS_AimOutLeft                                    = 9,
	YPSS_AimOutRight                                   = 10,
	YPSS_AimAroundLeft                                 = 11,
	YPSS_AimAroundRight                                = 12,
	YPSS_BlindfireEdgeLeft                             = 13,
	YPSS_BlindfireEdgeRight                            = 14,
	YPSS_PeekOverLeft                                  = 15,
	YPSS_PeekOverRight                                 = 16,
	YPSS_AimOverLeft                                   = 17,
	YPSS_AimOverRight                                  = 18,
	YPSS_BlindfireOverLeft                             = 19,
	YPSS_BlindfireOverRight                            = 20,
	YPSS_PeekDownLeft                                  = 21,
	YPSS_PeekDownRight                                 = 22,
	YPSS_AimDownLeft                                   = 23,
	YPSS_AimDownRight                                  = 24,
	YPSS_StackedIdleLeft                               = 25,
	YPSS_StackedIdleRight                              = 26,
	YPSS_StackedLeft                                   = 27,
	YPSS_StackedRight                                  = 28,
	YPSS_UseMortar                                     = 29,
	YPSS_DownButNotOutStandard                         = 30,
	YPSS_DownButNotOutRagdoll                          = 31,
	YPSS_DownButNotOutCoverLeft                        = 32,
	YPSS_DownButNotOutCoverRight                       = 33,
	YPSS_DownButNotOutAnimationDriven                  = 34,
	YPSS_MobileDownButNotOut                           = 35,
	YPSS_HumanShieldCaptor                             = 36,
	YPSS_DeathDBNOFront                                = 37,
	YPSS_DeathDBNOBack                                 = 38,
	YPSS_MAX                                           = 39
};*/

// Enum SRGame.YPawnState.YE_MainState
/*enum YE_MainState
{
	YPMS_StandardMove                                  = 0,
	YPMS_StandCover                                    = 1,
	YPMS_CrouchCover                                   = 2,
	YPMS_Stacked                                       = 3,
	YPMS_DownButNotOut                                 = 4,
	YPMS_DeathDBNO                                     = 5,
	YPMS_Dead                                          = 6,
	YPMS_UseMortar                                     = 7,
	YPMS_UseTurret                                     = 8,
	YPMS_TruckRide                                     = 9,
	YPMS_MAX                                           = 10
};*/

// Enum SRGame.YGamePawn.YE_SoundType
/*enum YE_SoundType
{
	YPST_Default                                       = 0,
	YPST_Reload                                        = 1,
	YPST_MAX                                           = 2
};*/

// Enum SRGame.YGamePawn.YE_DeathDBNOState
/*enum YE_DeathDBNOState
{
	YDDS_NoDeathDBNO                                   = 0,
	YDDS_WaitingForRagSleep                            = 1,
	YDDS_Recovering                                    = 2,
	YDDS_Idling                                        = 3,
	YDDS_Finished                                      = 4,
	YDDS_MAX                                           = 5
};*/

// Enum SRGame.YSpeakLineSystem.YE_SubtitlePriority
/*enum YE_SubtitlePriority
{
	YSTPR_SuppressSubtitle                             = 0,
	YSTPR_Lowest                                       = 1,
	YSTPR_Generic                                      = 2,
	YSTPR_ScriptedLow                                  = 3,
	YSTPR_ScriptedMedium                               = 4,
	YSTPR_ScriptedHigh                                 = 5,
	YSTPR_MAX                                          = 6
};*/

// Enum SRGame.YSpeakLineSystem.YE_SpeakLineBroadcastFilter
/*enum YE_SpeakLineBroadcastFilter
{
	YSLBF_Everybody                                    = 0,
	YSLBF_SpeakerAndTeamOnly                           = 1,
	YSLBF_SpeakerOnly                                  = 2,
	YSLBF_MAX                                          = 3
};*/

// Enum SRGame.YCrosshairInfo.YE_CrosshairType
/*enum YE_CrosshairType
{
	YCHT_Standard                                      = 0,
	YCHT_AimOut                                        = 1,
	YCHT_Faded                                         = 2,
	YCHT_Hide                                          = 3,
	YCHT_MAX                                           = 4
};*/

// Enum SRGame.YCrosshairInfo.YE_CrosshairColorType
/*enum YE_CrosshairColorType
{
	YCHC_Standard                                      = 0,
	YCHC_Enemy                                         = 1,
	YCHC_Friend                                        = 2,
	YCHC_Neutral                                       = 3,
	YCHC_Unreachable                                   = 4,
	YCHC_MAX                                           = 5
};*/

// Enum SRGame.YShootable.YE_MeleeAttackType
/*enum YE_MeleeAttackType
{
	YMAT_None                                          = 0,
	YMAT_Punch                                         = 1,
	YMAT_TakeHumanShield                               = 2,
	YMAT_ReleaseHumanShield                            = 3,
	YMAT_CoverInvalid                                  = 4,
	YMAT_LandingKick                                   = 5,
	YMAT_VaultKick                                     = 6,
	YMAT_ZipKick                                       = 7,
	YMAT_FastRope                                      = 8,
	YMAT_MAX                                           = 9
};*/

// Enum SRGame.YMovementDirection.YE_MovementDirection
/*enum YE_MovementDirection
{
	YMMD_None                                          = 0,
	YMMD_Forward                                       = 1,
	YMMD_Backward                                      = 2,
	YMMD_Left                                          = 3,
	YMMD_Right                                         = 4,
	YMMD_MAX                                           = 5
};*/

// Enum SRGame.YGamePawn.YE_LandingState
/*enum YE_LandingState
{
	YLS_None                                           = 0,
	YLS_LandingSuperSoft                               = 1,
	YLS_LandingSoft                                    = 2,
	YLS_LandingHard                                    = 3,
	YLS_MAX                                            = 4
};*/

// Enum SRGame.YGamePawn.YE_AnimSetPriority
/*enum YE_AnimSetPriority
{
	YASP_Pawn                                          = 0,
	YASP_Weapon                                        = 1,
	YASP_Explosive                                     = 2,
	YASP_SpecialMove                                   = 3,
	YASP_Sandstorm                                     = 4,
	YASP_Overwriting                                   = 5,
	YASP_CustomAnimation                               = 6,
	YASP_MAX                                           = 7
};*/

// Enum SRGame.YGamePawn.YE_AnimModifier
/*enum YE_AnimModifier
{
	YAM_Relaxed                                        = 0,
	YAM_Alert                                          = 1,
	YAM_MAX                                            = 2
};*/

// Enum SRGame.YGamePawn.YE_HandToWorldLocationMode
/*enum YE_HandToWorldLocationMode
{
	YHTW_None                                          = 0,
	YHTW_LeftHand                                      = 1,
	YHTW_RightHand                                     = 2,
	YHTW_BothHands                                     = 3,
	YHTW_MAX                                           = 4
};*/

// Enum SRGame.YGamePawn.YE_MovementState
/*enum YE_MovementState
{
	YMMS_IdleStand                                     = 0,
	YMMS_IdleCrouch                                    = 1,
	YMMS_WalkStand                                     = 2,
	YMMS_WalkCrouch                                    = 3,
	YMMS_RunStand                                      = 4,
	YMMS_RunCrouch                                     = 5,
	YMMS_Sprint                                        = 6,
	YMMS_MAX                                           = 7
};*/

// Enum SRGame.YGamePawn.YE_SpecialBoneType
/*enum YE_SpecialBoneType
{
	YSBT_ViewBone                                      = 0,
	YSBT_HeadBone                                      = 1,
	YSBT_BreastBone                                    = 2,
	YSBT_PelvisBone                                    = 3,
	YSBT_NeckBone                                      = 4,
	YSBT_LeftFootBone                                  = 5,
	YSBT_RightFootBone                                 = 6,
	YSBT_LeftHandBone                                  = 7,
	YSBT_RightHandBone                                 = 8,
	YSBT_MAX                                           = 9
};*/

// Enum SRGame.YGamePawn.YE_SpeedMode
/*enum YE_SpeedMode
{
	YSM_Walk                                           = 0,
	YSM_Run                                            = 1,
	YSM_MAX                                            = 2
};*/

// Enum SRGame.YGamePawn.YE_FallingState
/*enum YE_FallingState
{
	YFS_None                                           = 0,
	YFS_Prefalling                                     = 1,
	YFS_FallingPending                                 = 2,
	YFS_Falling                                        = 3,
	YFS_Landed                                         = 4,
	YFS_MAX                                            = 5
};*/

// Enum SRGame.YGamePawn.YE_ReloadAnimState
/*enum YE_ReloadAnimState
{
	YRAS_None                                          = 0,
	YRAS_In                                            = 1,
	YRAS_Loop                                          = 2,
	YRAS_Out                                           = 3,
	YRAS_MAX                                           = 4
};*/

// Enum SRGame.YGamePawn.YE_CoverLostReason
/*enum YE_CoverLostReason
{
	YCLR_Unknown                                       = 0,
	YCLR_CoverDestroyed                                = 1,
	YCLR_TooFarAway                                    = 2,
	YCLR_PushedOut                                     = 3,
	YCLR_MAX                                           = 4
};*/

// Enum SRGame.YAIDefinition.YE_ShootPatternDirectionMode
/*enum YE_ShootPatternDirectionMode
{
	YSPDM_RANDOM                                       = 0,
	YSPDM_ALTERNATE                                    = 1,
	YSPDM_RESTARTDIRECTION                             = 2,
	YSPDM_MAX                                          = 3
};*/

// Enum SRGame.YAIDefinition.YBT_GateScope
/*enum YBT_GateScope
{
	YGCS_Bot                                           = 0,
	YGCS_Squad                                         = 1,
	YGCS_World                                         = 2,
	YGCS_CommunicationPool                             = 3,
	YGCS_MAX                                           = 4
};*/

// Enum SRGame.YAIDefinition.YE_AIWeaponTypes
/*enum YE_AIWeaponTypes
{
	YWT_None                                           = 0,
	YWT_CloseRanged                                    = 1,
	YWT_StandardRanged                                 = 2,
	YWT_Melee                                          = 3,
	YWT_Sniper                                         = 4,
	YWT_AntiTank                                       = 5,
	YWT_MAX                                            = 6
};*/

// Enum SRGame.YAIDefinition.YE_BotTargetCertainty
/*enum YE_BotTargetCertainty
{
	YBTC_Sure                                          = 0,
	YBTC_Guess                                         = 1,
	YBTC_Lost                                          = 2,
	YBTC_MAX                                           = 3
};*/

// Enum SRGame.YAIDefinition.YE_BehaviorFilterType
/*enum YE_BehaviorFilterType
{
	YBFT_DEFAULT                                       = 0,
	YBFT_Combat_Basic                                  = 1,
	YBFT_Combat_Defensive                              = 2,
	YBFT_Combat_ShortRange                             = 3,
	YBFT_Combat_Static                                 = 4,
	YBFT_Kismet_OrientLikePosition                     = 5,
	YBFT_Kismet_ExactReach                             = 6,
	YBFT_Kismet_AimToFront                             = 7,
	YBFT_Kismet_MayTurnBodyForLookAimAt                = 8,
	YBFT_Kismet_OnlyLookAtTarget                       = 9,
	YBFT_Kismet_PreventAngularMovementWhileMoving      = 10,
	YBFT_Kismet_NotAbortBehavior                       = 11,
	YBFT_Kismet_MoveOn                                 = 12,
	YBFT_Kismet_NoStopAnimation                        = 13,
	YBFT_Kismet_Idle                                   = 14,
	YBFT_Kismet_AbortOnEnemySeenOrHeard                = 15,
	YBFT_Kismet_AbortOnReactionToGrenadeOrStun         = 16,
	YBFT_Weapon_SMG                                    = 17,
	YBFT_Weapon_Pistol                                 = 18,
	YBFT_Weapon_Shotgun                                = 19,
	YBFT_Crossplayer                                   = 20,
	YBFT_Adams                                         = 21,
	YBFT_Lugo                                          = 22,
	YBFT_Riggs                                         = 23,
	YBFT_Kismet_EnableCrouch                           = 24,
	YBFT_Kismet_EnterCover                             = 25,
	YBFT_Civilian                                      = 26,
	YBFT_PlayerSquadTrigger                            = 27,
	YBFT_Kismet_PlayCustomAnimation                    = 28,
	YBFT_EnemyType_Marauder                            = 29,
	YBFT_EnemyType_Elite                               = 30,
	YBFT_WeaponJamming                                 = 31,
	YBFT_EnemyType_Commando                            = 32,
	YBFT_EnemyType_Heavy                               = 33,
	YBFT_SquadMoveEnterCoverAndStayThere               = 34,
	YBFT_SquadMoveDelayed                              = 35,
	YBFT_SquadMoveDelayedFeedbackBegin                 = 36,
	YBFT_SquadMoveDelayedFeedbackBeginRequestCover     = 37,
	YBFT_SquadMoveDelayedFeedbackPrepareGo             = 38,
	YBFT_SquadMoveDelayedFeedbackFinish                = 39,
	YBFT_SquadMoveDelayedFeedbackFinishForced          = 40,
	YBFT_Kismet_RunDefaultBehavior                     = 41,
	YBFT_Kismet_ScriptedA                              = 42,
	YBFT_Kismet_ScriptedB                              = 43,
	YBFT_Kismet_ScriptedC                              = 44,
	YBFT_Kismet_ScriptedD                              = 45,
	YBFT_Kismet_ScriptedE                              = 46,
	YBFT_Kismet_ScriptedF                              = 47,
	YBFT_Kismet_ScriptedG                              = 48,
	YBFT_Kismet_ScriptedH                              = 49,
	YBFT_MAX                                           = 50
};*/

// Enum SRGame.YAIDefinition.YBT_Event
/*enum YBT_Event
{
	YBTE_TestEvent1                                    = 0,
	YBTE_TestEvent2                                    = 1,
	YBTE_TestEvent3                                    = 2,
	YBTE_AttackPosInvalid                              = 3,
	YBTE_CoverPosInvalid                               = 4,
	YBTE_CoverPosChanged                               = 5,
	YBTE_AttackPosChanged                              = 6,
	YBTE_AttackTargetChanged                           = 7,
	YBTE_EnterCombat                                   = 8,
	YBTE_NewEnemy                                      = 9,
	YBTE_NewSureEnemy                                  = 10,
	YBTE_NewSpecOpsEnemy                               = 11,
	YBTE_DBNO                                          = 12,
	YBTE_ShouldCover                                   = 13,
	YBTE_NeedCover                                     = 14,
	YBTE_FightAreaChangedAndCoverPosOutside            = 15,
	YBTE_FightAreaChangedAndAttackPosOutside           = 16,
	YBTE_EnemyClose                                    = 17,
	YBTE_Alarmed                                       = 18,
	YBTE_EnemyFootSteps                                = 19,
	YBTE_HearGunNoise                                  = 20,
	YBTE_HearSilencedGun                               = 21,
	YBTE_HearDeathSound                                = 22,
	YBTE_HearMeleeSound                                = 23,
	YBTE_CloseDeath                                    = 24,
	YBTE_SwitchToInfiltrate                            = 25,
	YBTE_SwitchToAssault                               = 26,
	YBTE_GrenadeImpact                                 = 27,
	YBTE_NoSureAttackTarget                            = 28,
	YBTE_NoSureCoverTarget                             = 29,
	YBTE_IsShotAtNotByCoverTarget                      = 30,
	YBTE_IsShotAtNotByAttackTarget                     = 31,
	YBTE_CoverTargetIsDead                             = 32,
	YBTE_AttackTargetIsDead                            = 33,
	YBTE_BeginOpenFire                                 = 34,
	YBTE_StunEnemiesCommand                            = 35,
	YBTE_SpeakLine                                     = 36,
	YBTE_TacticalEmergency                             = 37,
	YBTE_BadCover                                      = 38,
	YBTE_EnemyClose_Response                           = 39,
	YBTE_ISS_Event0                                    = 40,
	YBTE_ISS_Event1                                    = 41,
	YBTE_ISS_Event2                                    = 42,
	YBTE_ISS_Event3                                    = 43,
	YBTE_ISS_Event4                                    = 44,
	YBTE_ISS_Event5                                    = 45,
	YBTE_ISS_Event6                                    = 46,
	YBTE_ISS_Event7                                    = 47,
	YBTE_ISS_Event8                                    = 48,
	YBTE_ISS_Event9                                    = 49,
	YBTE_FightAreaChangedAndCoverPosOutside_Response   = 50,
	YBTE_FightAreaChangedAndAttackPosOutside_Response  = 51,
	YBTE_WantChangeCoverPos                            = 52,
	YBTE_WantChangeCoverPos_Response                   = 53,
	YBTE_WantChangeAttackPos                           = 54,
	YBTE_WantChangeAttackPos_Response                  = 55,
	YBTE_WantFlankingPos                               = 56,
	YBTE_WantFlankingPos_Response                      = 57,
	YBTE_EnemyClose_Reaction                           = 58,
	YBTE_InstantKill                                   = 59,
	YBTE_PrepareSitRep                                 = 60,
	YBTE_LostAttackTargetAndNewEnemy                   = 61,
	YBTE_LostCoverTargetAndNewEnemy                    = 62,
	YBTE_GrenadeStickyAttached                         = 63,
	YBTE_GrenadeStickyClose                            = 64,
	YBTE_InLineOfFire                                  = 65,
	YBTE_ShouldReload                                  = 66,
	YBTE_GrenadyStickyExplodedOnMe                     = 67,
	YBTE_DangerousEnemyClose                           = 68,
	YBTE_ExpectVaultKick                               = 69,
	YBTE_InformTargetOnTerminatorMove                  = 70,
	YBTE_InformTargetOnMoveToCover                     = 71,
	YBTE_EnemyClose_AttackTargetSelection              = 72,
	YBTE_EnemyClose_CoverTargetSelection               = 73,
	YBTE_EnemyClose_ToPlayer                           = 74,
	YBTE_ReactionToStunImpact                          = 75,
	YBTE_ReactionToSandPool                            = 76,
	YBTE_ReactionToSandBomb                            = 77,
	YBTE_EnemyIsStunned                                = 78,
	YBTE_AttackCommandAreaChanged                      = 79,
	YBTE_SniperAttackCommandReadyToShoot               = 80,
	YBTE_MAX                                           = 81
};*/

// Enum SRGame.YAIDefinition.YE_MovementStyle
/*enum YE_MovementStyle
{
	YMST_None                                          = 0,
	YMST_Full                                          = 1,
	YMST_Heavy                                         = 2,
	YMST_MAX                                           = 3
};*/

// Enum SRGame.YAIDefinition.YE_SensorPropertyPreset
/*enum YE_SensorPropertyPreset
{
	YSPP_Combat                                        = 0,
	YSPP_Idle                                          = 1,
	YSPP_KismetMode                                    = 2,
	YSPP_MAX                                           = 3
};*/

// Enum SRGame.YAIAnimationDefinition.YE_AIMovementMode
/*enum YE_AIMovementMode
{
	YAIMM_Walk                                         = 0,
	YAIMM_WalkCrouched                                 = 1,
	YAIMM_Run                                          = 2,
	YAIMM_RunCrouched                                  = 3,
	YAIMM_Sprint                                       = 4,
	YAIMM_CombatSprint                                 = 5,
	YAIMM_MAX                                          = 6
};*/

// Enum SRGame.YAIDefinition.YE_BehaviorState
/*enum YE_BehaviorState
{
	YSBS_Idle                                          = 0,
	YSBS_Suspicious                                    = 1,
	YSBS_Combat                                        = 2,
	YSBS_KismetState                                   = 3,
	YSBS_MAX                                           = 4
};*/

// Enum SRGame.YGamePawn.YE_CheckGetupResult
/*enum YE_CheckGetupResult
{
	YECGUR_CancelTests                                 = 0,
	YECGUR_ContinueTests                               = 1,
	YECGUR_Getup                                       = 2,
	YECGUR_MAX                                         = 3
};*/

// Enum SRGame.YGamePawn.YE_ForceSilhouette
/*enum YE_ForceSilhouette
{
	YEFS_none                                          = 0,
	YEFS_on                                            = 1,
	YEFS_off                                           = 2,
	YEFS_MAX                                           = 3
};*/

// Enum SRGame.YGamePawn.YE_JointMotorState
/*enum YE_JointMotorState
{
	YJMS_Disabled                                      = 0,
	YJMS_Position                                      = 1,
	YJMS_VelocityAll                                   = 2,
	YJMS_VelocityPartial                               = 3,
	YJMS_MAX                                           = 4
};*/

// Enum SRGame.YGamePawn.YE_RaiseWeaponAnimation
/*enum YE_RaiseWeaponAnimation
{
	YRWA_None                                          = 0,
	YRWA_RaiseWeaponStand                              = 1,
	YRWA_RaiseWeaponCrouch                             = 2,
	YRWA_MAX                                           = 3
};*/

// Enum SRGame.YGamePawn.YE_RaiseWeaponState
/*enum YE_RaiseWeaponState
{
	YRWS_None                                          = 0,
	YRWS_NoAim                                         = 1,
	YRWS_Raised                                        = 2,
	YRWS_MAX                                           = 3
};*/

// Enum SRGame.YGamePawn.YE_PawnEffortStatus
/*enum YE_PawnEffortStatus
{
	YPES_Invalid                                       = 0,
	YPES_Idle                                          = 1,
	YPES_Run                                           = 2,
	YPES_Sprint                                        = 3,
	YPES_MAX                                           = 4
};*/

// Enum SRGame.YGamePawn.YE_TakeUpWeaponState
/*enum YE_TakeUpWeaponState
{
	YTUWS_None                                         = 0,
	YTUWS_TakingUpWeapon                               = 1,
	YTUWS_ReadyToFire                                  = 2,
	YTUWS_TakingDownWeapon                             = 3,
	YTUWS_MAX                                          = 4
};*/

// Enum SRGame.YAIEventPropagator.YE_GrenadeType
/*enum YE_GrenadeType
{
	YGRENADE_Frag                                      = 0,
	YGRENADE_Stun                                      = 1,
	YGRENADE_Sticky                                    = 2,
	YGRENADE_Mortar                                    = 3,
	YGRENADE_RPG                                       = 4,
	YGRENADE_PropaneTankSmall                          = 5,
	YGRENADE_PropaneTankLarge                          = 6,
	YGRENADE_FireExtinguisher                          = 7,
	YGRENADE_Milkor                                    = 8,
	YGRENADE_SCAR                                      = 9,
	YGRENADE_MAX                                       = 10
};*/

// Enum SRGame.YAIEventPropagator.YE_PropagationEventType
/*enum YE_PropagationEventType
{
	YPET_Hear                                          = 0,
	YPET_UnderFire                                     = 1,
	YPET_Shot                                          = 2,
	YPET_Impact                                        = 3,
	YPET_GrenadeImpact                                 = 4,
	YPET_FlyBy                                         = 5,
	YPET_MAX                                           = 6
};*/

// Enum SRGame.YGamePawn.YE_FlyByType
/*enum YE_FlyByType
{
	YFBT_Projectile                                    = 0,
	YFBT_Shotgun                                       = 1,
	YFBT_MAX                                           = 2
};*/

// Enum SRGame.YGamePawn.YE_FootPlacementAimOverCoverHandling
/*enum YE_FootPlacementAimOverCoverHandling
{
	YFAOCH_Lowest                                      = 0,
	YFAOCH_Highest                                     = 1,
	YFAOCH_Foremost                                    = 2,
	YFAOCH_MAX                                         = 3
};*/

// Enum SRGame.YAnimation.YE_AnimRestrictionType
/*enum YE_AnimRestrictionType
{
	YART_Any                                           = 0,
	YART_PC                                            = 1,
	YART_Enemy                                         = 2,
	YART_Squad                                         = 3,
	YART_NPC                                           = 4,
	YART_MAX                                           = 5
};*/

// Enum SRGame.YProjectile.YE_GrenadeMode
/*enum YE_GrenadeMode
{
	YGM_None                                           = 0,
	YGM_Roll                                           = 1,
	YGM_Throw                                          = 2,
	YGM_MAX                                            = 3
};*/

// Enum SRGame.YGamePawn.YE_ContextualSlomoTriggerEvent
/*enum YE_ContextualSlomoTriggerEvent
{
	YCSTE_Headshot                                     = 0,
	YCSTE_ExplodingHead                                = 1,
	YCSTE_GrenadeKill                                  = 2,
	YCSTE_VaultKill                                    = 3,
	YCSTE_HeavyKilled                                  = 4,
	YCSTE_CommandoKilled                               = 5,
	YCSTE_Melee                                        = 6,
	YCSTE_VaultKick                                    = 7,
	YCSTE_ZipKick                                      = 8,
	YCSTE_RPGFlyBy                                     = 9,
	YCSTE_SquadStun                                    = 10,
	YCSTE_PlayerStun                                   = 11,
	YCSTE_MAX                                          = 12
};*/

// Enum SRGame.YGamePawn.YE_FallingType
/*enum YE_FallingType
{
	YFT_Fall                                           = 0,
	YFT_Drop                                           = 1,
	YFT_VaultDrop                                      = 2,
	YFT_MAX                                            = 3
};*/

// Enum SRGame.YAnimation.YE_MovementSpeed
/*enum YE_MovementSpeed
{
	YMS_Idle                                           = 0,
	YMS_Walk                                           = 1,
	YMS_Run                                            = 2,
	YMS_Sprint                                         = 3,
	YMS_MAX                                            = 4
};*/

// Enum SRGame.YCustomAnimation.YE_CoverLeaveTime
/*enum YE_CoverLeaveTime
{
	YCLT_DoNotLeaveCover                               = 0,
	YCLT_LeaveCoverPriorToAnimation                    = 1,
	YCLT_LeaveCoverDuringAnimation                     = 2,
	YCLT_MAX                                           = 3
};*/

// Enum SRGame.YCustomAnimation.YE_CustomAnimationType
/*enum YE_CustomAnimationType
{
	YCAN_FullBody                                      = 0,
	YCAN_FullBodyIdle                                  = 1,
	YCAN_FullBodyRootMotion2D                          = 2,
	YCAN_FullBodyRootMotion2DFootPlacement             = 3,
	YCAN_FullBodyRootMotion3D                          = 4,
	YCAN_UpperBody                                     = 5,
	YCAN_MAX                                           = 6
};*/

// Enum SRGame.YGamePawn.YE_ForcedVaporizationType
/*enum YE_ForcedVaporizationType
{
	YFVT_None                                          = 0,
	YFVT_VaporizeHead                                  = 1,
	YFVT_VaporizeBody                                  = 2,
	YFVT_VaporizationOff                               = 3,
	YFVT_MAX                                           = 4
};*/

// Enum SRGame.YProjectile.YE_GrenadeSimState
/*enum YE_GrenadeSimState
{
	YGSS_Init                                          = 0,
	YGSS_Calc                                          = 1,
	YGSS_MAX                                           = 2
};*/

// Enum SRGame.YGamePawn.YE_AsyncLineCheckEntryGamePawn
/*enum YE_AsyncLineCheckEntryGamePawn
{
	YALCEGP_LeanToCoverLeft                            = 0,
	YALCEGP_LeanToCoverRight                           = 1,
	YALCEGP_RaiseWeapon1                               = 2,
	YALCEGP_RaiseWeapon2                               = 3,
	YALCEGP_TestShootThroughWalls                      = 4,
	YALCEGP_SimpleFootPlacement                        = 5,
	YALCEGP_FootMaterialLeft                           = 6,
	YALCEGP_FootMaterialRight                          = 7,
	YALCEGP_MeshTranslation1                           = 8,
	YALCEGP_MeshTranslation2                           = 9,
	YALCEGP_MAX                                        = 10
};*/

// Enum SRGame.YGamePawn.YE_PawnInitializationState
/*enum YE_PawnInitializationState
{
	YPIS_NotInitialized                                = 0,
	YPIS_PawnBasicsInitialized                         = 1,
	YPIS_ArsenalManagerCreated                         = 2,
	YPIS_ArsenalManagerInitialized                     = 3,
	YPIS_Initialized                                   = 4,
	YPIS_MAX                                           = 5
};*/

// Enum SRGame.YGamePawn.YE_FootPlacementDetailLevel
/*enum YE_FootPlacementDetailLevel
{
	YFDL_Full                                          = 0,
	YFDL_VelDependent                                  = 1,
	YFDL_Simple                                        = 2,
	YFDL_SuperSimple                                   = 3,
	YFDL_Disabled                                      = 4,
	YFDL_MAX                                           = 5
};*/

// Enum SRGame.YGamePawn.YE_ModeAnimState
/*enum YE_ModeAnimState
{
	YEMAS_None                                         = 0,
	YEMAS_WeaponAway                                   = 1,
	YEMAS_In                                           = 2,
	YEMAS_Loop                                         = 3,
	YEMAS_Out                                          = 4,
	YEMAS_WeaponEquip                                  = 5,
	YEMAS_MAX                                          = 6
};*/

// Enum SRGame.YConfigFileCreationDummy.YE_ConfigVersionLoad
/*enum YE_ConfigVersionLoad
{
	YCVL_Normal                                        = 0,
	YCVL_Easy                                          = 1,
	YCVL_Hard                                          = 2,
	YCVL_Insane                                        = 3,
	YCVL_Multiplayer                                   = 4,
	YCVL_MAX                                           = 5
};*/

// Enum SRGame.YPhysicalMaterialProperty.YE_PhysMaterialType
/*enum YE_PhysMaterialType
{
	YPMT_Solid                                         = 0,
	YPMT_Sand                                          = 1,
	YPMT_Soft                                          = 2,
	YPMT_SandNoGameplay                                = 3,
	YPMT_MAX                                           = 4
};*/

// Enum SRGame.YRecoverValue.YE_ValueCallbackType
/*enum YE_ValueCallbackType
{
	YVCT_DropBelow                                     = 0,
	YVCT_RaiseAbove                                    = 1,
	YVCT_DropAndRaise                                  = 2,
	YVCT_ExactlyReach                                  = 3,
	YVCT_ValueChange                                   = 4,
	YVCT_MAX                                           = 5
};*/

// Enum SRGame.YRecoverValue.YE_ModifierPriority
/*enum YE_ModifierPriority
{
	YMPR_Basic                                         = 0,
	YMPR_Extra                                         = 1,
	YMPR_Replicated                                    = 2,
	YMPR_MAX                                           = 3
};*/

// Enum SRGame.YPostProcessManager.YE_PPStyle
/*enum YE_PPStyle
{
	YPOSTFX_Death                                      = 0,
	YPOSTFX_StunFadeout                                = 1,
	YPOSTFX_StunFull                                   = 2,
	YPOSTFX_StunMid                                    = 3,
	YPOSTFX_StunLow                                    = 4,
	YPOSTFX_Aiming                                     = 5,
	YPOSTFX_Scope                                      = 6,
	YPOSTFX_Menu                                       = 7,
	YPOSTFX_ToDefault                                  = 8,
	YPOSTFX_Default                                    = 9,
	YPOSTFX_MAX                                        = 10
};*/

// Enum SRGame.YPlayerController.YE_DebugCamMode
/*enum YE_DebugCamMode
{
	YDCM_None                                          = 0,
	YDCM_Locked                                        = 1,
	YDCM_LockedOffset                                  = 2,
	YDCM_TopView                                       = 3,
	YDCM_Spectator                                     = 4,
	YDCM_Screenshot                                    = 5,
	YDCM_SecondCamera                                  = 6,
	YDCM_MAX                                           = 7
};*/

// Enum SRGame.YFocusPoint.YE_FocusPointOffsetSpace
/*enum YE_FocusPointOffsetSpace
{
	YEFPOS_World                                       = 0,
	YEFPOS_Actor                                       = 1,
	YEFPOS_Bone                                        = 2,
	YEFPOS_MAX                                         = 3
};*/

// Enum SRGame.YProfileWriter.YE_ProfileSaveReason
/*enum YE_ProfileSaveReason
{
	YEPSR_Default                                      = 0,
	YEPSR_Settings                                     = 1,
	YEPSR_Validation                                   = 2,
	YEPSR_MAX                                          = 3
};*/

// Enum SRGame.YPlayerController.YE_KickReason
/*enum YE_KickReason
{
	YKR_None                                           = 0,
	YKR_Idler                                          = 1,
	YKR_FriendKiller                                   = 2,
	YKR_Banned                                         = 3,
	YKR_MAX                                            = 4
};*/

// Enum SRGame.YPlayerController.YE_AsyncLineCheckEntryPlayerController
/*enum YE_AsyncLineCheckEntryPlayerController
{
	YALCEPC_FocusedActor                               = 0,
	YALCEPC_FrictionTarget                             = 1,
	YALCEPC_MAX                                        = 2
};*/

// Enum SRGame.YPlayerController.ENetworkType
/*enum ENetworkType
{
	NETWORKTYPE_Unknown                                = 0,
	NETWORKTYPE_Modem                                  = 1,
	NETWORKTYPE_ISDN                                   = 2,
	NETWORKTYPE_Cable                                  = 3,
	NETWORKTYPE_LAN                                    = 4,
	NETWORKTYPE_MAX                                    = 5
};*/

// Enum SRGame.YHUD.YE_FontSize
/*enum YE_FontSize
{
	YFONT_None                                         = 0,
	YFONT                                              = 1,
	YFONT01                                            = 2,
	YFONT_MAX                                          = 3
};*/

// Enum SRGame.YHUD.YE_DebugType
/*enum YE_DebugType
{
	YDT_None                                           = 0,
	YDT_CurrentCover                                   = 1,
	YDT_PawnState                                      = 2,
	YDT_Aiming                                         = 3,
	YDT_Weapon                                         = 4,
	YDT_Controller                                     = 5,
	YDT_Input                                          = 6,
	YDT_Camera                                         = 7,
	YDT_WeaponTuning                                   = 8,
	YDT_AimAssist                                      = 9,
	YDT_NetPlayer                                      = 10,
	YDT_CoverSlots                                     = 11,
	YDT_PerceivedCover                                 = 12,
	YDT_TacticalView                                   = 13,
	YDT_HitFeedback                                    = 14,
	YDT_AnimtreeManager                                = 15,
	YDT_Position                                       = 16,
	YDT_Performance                                    = 17,
	YDT_Standing                                       = 18,
	YDT_CharacterManager                               = 19,
	YDT_Challenges                                     = 20,
	YDT_Mood                                           = 21,
	YDT_MAX                                            = 22
};*/

// Enum SRGame.YHUD.YE_PS3DateFormat
/*enum YE_PS3DateFormat
{
	YPDF_CELL_SYSUTIL_DATE_FMT_YYYYMMDD                = 0,
	YPDF_CELL_SYSUTIL_DATE_FMT_DDMMYYYY                = 1,
	YPDF_CELL_SYSUTIL_DATE_FMT_MMDDYYYY                = 2,
	YPDF_CELL_SYSUTIL_DATE_FMT_MAX                     = 3
};*/

// Enum SRGame.YAICombatPosSet_CoverSlotEditorData.YE_CoverErrorPart
/*enum YE_CoverErrorPart
{
	YECR_Cover                                         = 0,
	YECR_MoveLeft                                      = 1,
	YECR_MoveRight                                     = 2,
	YECR_SwatLeft                                      = 3,
	YECR_SwatRight                                     = 4,
	YECR_SlipLeft                                      = 5,
	YECR_SlipRight                                     = 6,
	YECR_LeanLeft                                      = 7,
	YECR_LeanRight                                     = 8,
	YECR_PopUp                                         = 9,
	YECR_Mantle                                        = 10,
	YECR_Climb                                         = 11,
	YECR_DropDown                                      = 12,
	YECR_StackingPos                                   = 13,
	YECR_MAX                                           = 14
};*/

// Enum SRGame.YAIController.YE_FakeTargetType
/*enum YE_FakeTargetType
{
	YFTT_Ignore                                        = 0,
	YFTT_Enabled                                       = 1,
	YFTT_Forced                                        = 2,
	YFTT_MAX                                           = 3
};*/

// Enum SRGame.YAIController.YE_WeaponReloadStates
/*enum YE_WeaponReloadStates
{
	YWRS_ShouldReload                                  = 0,
	YWRS_IsReloading                                   = 1,
	YWRS_Reloaded                                      = 2,
	YWRS_MAX                                           = 3
};*/

// Enum SRGame.YAIController.YE_FakeTargetVisibility
/*enum YE_FakeTargetVisibility
{
	YFTV_KnownTargetAlwaysVisible                      = 0,
	YFTV_KnownTargetNormalVisibility                   = 1,
	YFTV_UnknownTargetNormalVisibility                 = 2,
	YFTV_MAX                                           = 3
};*/

// Enum SRGame.YAIController.YE_DecisionMakerTypes
/*enum YE_DecisionMakerTypes
{
	YDMT_BehaviorTree                                  = 0,
	YDMT_Invalid                                       = 1,
	YDMT_MAX                                           = 2
};*/

// Enum SRGame.YAIController.YFSM_StateType
/*enum YFSM_StateType
{
	YFSMST_Base                                        = 0,
	YFSMST_EnterCover                                  = 1,
	YFSMST_InCover                                     = 2,
	YFSMST_InCoverMove                                 = 3,
	YFSMST_LeaveCover                                  = 4,
	YFSMST_PeekOutFromCover                            = 5,
	YFSMST_PeekingFromCover                            = 6,
	YFSMST_AdjustPeekingFromCover                      = 7,
	YFSMST_StopPeekingFromCover                        = 8,
	YFSMST_EnterStack                                  = 9,
	YFSMST_InStack                                     = 10,
	YFSMST_LeaveStack                                  = 11,
	YFSMST_PeekOutFromStack                            = 12,
	YFSMST_PeekingFromStack                            = 13,
	YFSMST_StopPeekingFromStack                        = 14,
	YFSMST_TurnInStack                                 = 15,
	YFSMST_DoSpecialMove                               = 16,
	YFSMST_ThrowGrenade                                = 17,
	YFSMST_DownOnTheGround                             = 18,
	YFSMST_MAX                                         = 19
};*/

// Enum SRGame.YAIController.YE_GenericInteractionStatus
/*enum YE_GenericInteractionStatus
{
	YGIS_None                                          = 0,
	YGIS_Started                                       = 1,
	YGIS_Cancelled                                     = 2,
	YGIS_Completed                                     = 3,
	YGIS_MAX                                           = 4
};*/

// Enum SRGame.YAIController.YE_BotCoverPeekMode
/*enum YE_BotCoverPeekMode
{
	YBCPM_NoPeek                                       = 0,
	YBCPM_PeekOver                                     = 1,
	YBCPM_PeekLeft                                     = 2,
	YBCPM_PeekRight                                    = 3,
	YBCPM_AimOver                                      = 4,
	YBCPM_AimLeft                                      = 5,
	YBCPM_AimRight                                     = 6,
	YBCPM_BlindfireOver                                = 7,
	YBCPM_BlindfireLeft                                = 8,
	YBCPM_BlindfireRight                               = 9,
	YBCPM_MAX                                          = 10
};*/

// Enum SRGame.YGrenadeThrow.YE_SpawnableGrenades
/*enum YE_SpawnableGrenades
{
	YSGR_Frag                                          = 0,
	YSGR_Percussion                                    = 1,
	YSGR_Proxy                                         = 2,
	YSGR_Sticky                                        = 3,
	YSGR_Phosphor                                      = 4,
	YSGR_Stun                                          = 5,
	YSGR_Stone                                         = 6,
	YSGR_Frag_PlayerSquad                              = 7,
	YSGR_Stun_PlayerSquad                              = 8,
	YSGR_MAX                                           = 9
};*/

// Enum SRGame.YAICtrl_Humanoid.YE_AiStunState
/*enum YE_AiStunState
{
	YASS_StunGrenade                                   = 0,
	YASS_SandPool                                      = 1,
	YASS_SandBomb                                      = 2,
	YASS_MAX                                           = 3
};*/

// Enum SRGame.YAICtrl_Humanoid.YE_CustomAnimationState
/*enum YE_CustomAnimationState
{
	YCAS_None                                          = 0,
	YCAS_Started                                       = 1,
	YCAS_StartFailed                                   = 2,
	YCAS_Failed                                        = 3,
	YCAS_Succeeded                                     = 4,
	YCAS_MAX                                           = 5
};*/

// Enum SRGame.YAICtrl_Humanoid.YE_SpecialActionState
/*enum YE_SpecialActionState
{
	YSPAS_Start                                        = 0,
	YSPAS_Running                                      = 1,
	YSPAS_Finished                                     = 2,
	YSPAS_Failed                                       = 3,
	YSPAS_Cancel                                       = 4,
	YSPAS_MAX                                          = 5
};*/

// Enum SRGame.YAIFallbackDirectionTrigger.YE_AffactedFactionsPresets
/*enum YE_AffactedFactionsPresets
{
	YAFP_None                                          = 0,
	YAFP_PlayerEnemies                                 = 1,
	YAFP_PlayerFriends                                 = 2,
	YAFP_PlayerFriendsOrNeutral                        = 3,
	YAFP_MAX                                           = 4
};*/

// Enum SRGame.YAITuning_Base.YAIT_AiTuningVariable_BT
/*enum YAIT_AiTuningVariable_BT
{
	YAIT_NONE                                          = 0,
	YAIT_min_delayForAquiringNewTarget_EnemyMarauder   = 1,
	YAIT_max_delayForAquiringNewTarget_EnemyMarauder   = 2,
	YAIT_min_delayForAquiringNewTarget_EnemyKonrad     = 3,
	YAIT_max_delayForAquiringNewTarget_EnemyKonrad     = 4,
	YAIT_min_delayForAquiringNewTarget_EnemyElite      = 5,
	YAIT_max_delayForAquiringNewTarget_EnemyElite      = 6,
	YAIT_min_delayForEscapeFromGrenade_EnemyMarauder   = 7,
	YAIT_max_delayForEscapeFromGrenade_EnemyMarauder   = 8,
	YAIT_min_delayForEscapeFromGrenade_EnemyKonrad     = 9,
	YAIT_max_delayForEscapeFromGrenade_EnemyKonrad     = 10,
	YAIT_min_delayForEscapeFromGrenade_EnemyElite      = 11,
	YAIT_max_delayForEscapeFromGrenade_EnemyElite      = 12,
	YAIT_min_delayForEscapeFromGrenadeInSandStorm_EnemyMarauder = 13,
	YAIT_max_delayForEscapeFromGrenadeInSandStorm_EnemyMarauder = 14,
	YAIT_min_delayForEscapeFromGrenadeInSandStorm_EnemyKonrad = 15,
	YAIT_max_delayForEscapeFromGrenadeInSandStorm_EnemyKonrad = 16,
	YAIT_min_delayForEscapeFromGrenadeInSandStorm_EnemyElite = 17,
	YAIT_max_delayForEscapeFromGrenadeInSandStorm_EnemyElite = 18,
	YAIT_timePassedUntilFlankingBehaviorStarts_EnemyMarauder = 19,
	YAIT_timePassedUntilFlankingBehaviorStarts_EnemyKonrad = 20,
	YAIT_timePassedUntilFlankingBehaviorStarts_EnemyElite = 21,
	YAIT_min_delayBeforeReactingToCoverNeed_EnemyMarauder = 22,
	YAIT_max_delayBeforeReactingToCoverNeed_EnemyMarauder = 23,
	YAIT_min_delayBeforeReactingToCoverNeed_EnemyKonrad = 24,
	YAIT_max_delayBeforeReactingToCoverNeed_EnemyKonrad = 25,
	YAIT_min_delayBeforeReactingToCoverNeed_EnemyElite = 26,
	YAIT_max_delayBeforeReactingToCoverNeed_EnemyElite = 27,
	YAIT_min_delayBetweenSidestepDodgeMoves_EnemyMarauder = 28,
	YAIT_max_delayBetweenSidestepDodgeMoves_EnemyMarauder = 29,
	YAIT_min_delayBetweenSidestepDodgeMoves_EnemyKonrad = 30,
	YAIT_max_delayBetweenSidestepDodgeMoves_EnemyKonrad = 31,
	YAIT_min_delayBetweenSidestepDodgeMoves_EnemyElite = 32,
	YAIT_max_delayBetweenSidestepDodgeMoves_EnemyElite = 33,
	YAIT_min_delayBeforeMeleeAttack_EnemyMarauder      = 34,
	YAIT_max_delayBeforeMeleeAttack_EnemyMarauder      = 35,
	YAIT_min_delayBeforeMeleeAttack_EnemyKonrad        = 36,
	YAIT_max_delayBeforeMeleeAttack_EnemyKonrad        = 37,
	YAIT_min_delayBeforeMeleeAttack_EnemyElite         = 38,
	YAIT_max_delayBeforeMeleeAttack_EnemyElite         = 39,
	YAIT_min_delayBeforeMeleeAttack_EnemyHeavy         = 40,
	YAIT_max_delayBeforeMeleeAttack_EnemyHeavy         = 41,
	YAIT_min_delayBeforeMeleeAttack_EnemyCommando      = 42,
	YAIT_max_delayBeforeMeleeAttack_EnemyCommando      = 43,
	YAIT_probabilityForWeapomJam_EnemyMarauder         = 44,
	YAIT_min_delayBetweenMeleeAttacks_Commando         = 45,
	YAIT_max_delayBetweenMeleeAttacks_Commando         = 46,
	YAIT_delay_TargetSelection_AfterFlanking_min       = 47,
	YAIT_delay_TargetSelection_AfterFlanking_max       = 48,
	YAIT_delay_TargetSelection_EnemyClose_min          = 49,
	YAIT_delay_TargetSelection_EnemyClose_max          = 50,
	YAIT_delay_TargetSelection_AfterIsShotAt_min       = 51,
	YAIT_delay_TargetSelection_AfterIsShotAt_max       = 52,
	YAIT_delay_TargetSelection_TargetIsDead_min        = 53,
	YAIT_delay_TargetSelection_TargetIsDead_max        = 54,
	YAIT_delay_TargetSelection_TargetIsGuess_min       = 55,
	YAIT_delay_TargetSelection_TargetIsGuess_max       = 56,
	YAIT_delay_TargetSelection_LostAndNewEnemy_min     = 57,
	YAIT_delay_TargetSelection_LostAndNewEnemy_max     = 58,
	YAIT_distance_terminatorMove_shortRange            = 59,
	YAIT_distance_terminatorMove_konrad                = 60,
	YAIT_distance_terminatorMove_marauder              = 61,
	YAIT_distance_terminatorMove_elite                 = 62,
	YAIT_distance_terminatorMove_playersquad           = 63,
	YAIT_time_attackCommandIdleVoiceOver_min           = 64,
	YAIT_time_attackCommandIdleVoiceOver_max           = 65,
	YAIT_time_playerIsStarringVoiceOver_min            = 66,
	YAIT_time_playerIsStarringVoiceOver_max            = 67,
	YAIT_delay_TargetSelection_EnemyIsStunned_min      = 68,
	YAIT_delay_TargetSelection_EnemyIsStunned_max      = 69,
	YAIT_MAX                                           = 70
};*/

// Enum SRGame.YAITuning_Base.YAITR_AiTuning_Ranges
/*enum YAITR_AiTuning_Ranges
{
	YAITR_AiTuning_Long                                = 0,
	YAITR_AiTuning_Medium                              = 1,
	YAITR_AiTuning_Short                               = 2,
	YAITR_AiTuning_MAX                                 = 3
};*/

// Enum SRGame.YMarkerAnimation.YE_MarkerAnimType
/*enum YE_MarkerAnimType
{
	YMANT_None                                         = 0,
	YMANT_Opacity                                      = 1,
	YMANT_Scale                                        = 2,
	YMANT_ScaleX                                       = 3,
	YMANT_ScaleY                                       = 4,
	YMANT_MatRotation                                  = 5,
	YMANT_Rotation                                     = 6,
	YMANT_Color                                        = 7,
	YMANT_Visibility                                   = 8,
	YMANT_Notify                                       = 9,
	YMANT_Offset3D                                     = 10,
	YMANT_Offset2D                                     = 11,
	YMANT_Origin                                       = 12,
	YMANT_MatFlash                                     = 13,
	YMANT_BlendPos                                     = 14,
	YMANT_TopLeft                                      = 15,
	YMANT_BottomRight                                  = 16,
	YMANT_MAX                                          = 17
};*/

// Enum SRGame.YMarkerAnimation.YE_MarkerAnimNotifyType
/*enum YE_MarkerAnimNotifyType
{
	YANT_None                                          = 0,
	YANT_Function                                      = 1,
	YANT_Kismet                                        = 2,
	YANT_Sound                                         = 3,
	YANT_MAX                                           = 4
};*/

// Enum SRGame.YDeathAnimInfo.YE_BoneFixationState
/*enum YE_BoneFixationState
{
	YBFS_Fixed                                         = 0,
	YBFS_SpringDriven                                  = 1,
	YBFS_Loose                                         = 2,
	YBFS_MAX                                           = 3
};*/

// Enum SRGame.YAnimNodeBlendByPosture.YE_SimplePostureID
/*enum YE_SimplePostureID
{
	YSPTID_Other                                       = 0,
	YSPTID_Stand                                       = 1,
	YSPTID_Crouch                                      = 2,
	YSPTID_CoverStand                                  = 3,
	YSPTID_CoverCrouch                                 = 4,
	YSPTID_CoverStandEdge                              = 5,
	YSPTID_CoverCrouchEdge                             = 6,
	YSPTID_Turret                                      = 7,
	YSPTID_DBNO                                        = 8,
	YSPTID_MAX                                         = 9
};*/

// Enum SRGame.YAnimNodeBlendDirectional.YE_Directions
/*enum YE_Directions
{
	YDIR_Forward                                       = 0,
	YDIR_Forward_Right                                 = 1,
	YDIR_Backward_Right                                = 2,
	YDIR_Backward                                      = 3,
	YDIR_Backward_Left                                 = 4,
	YDIR_Forward_Left                                  = 5,
	YDIR_MAX                                           = 6
};*/

// Enum SRGame.YBT_Register.YE_BTRegisterPosition
/*enum YE_BTRegisterPosition
{
	YBTRP_AttackPos                                    = 0,
	YBTRP_CoverPos                                     = 1,
	YBTRP_CurrentPos                                   = 2,
	YBTRP_LookAtPos                                    = 3,
	YBTRP_AimAtPos                                     = 4,
	YBTRP_MoveTarget                                   = 5,
	YBTRP_Stage                                        = 6,
	YBTRP_AttackTargetPredictedPos                     = 7,
	YBTRP_AttackTargetLastKnownPos                     = 8,
	YBTRP_CoverTargetPredictedPos                      = 9,
	YBTRP_CoverTargetLastKnownPos                      = 10,
	YBTRP_SquadPosition                                = 11,
	YBTRP_AttackOrigin                                 = 12,
	YBTRP_GrenadePosition                              = 13,
	YBTRP_SquadMoveTarget                              = 14,
	YBTRP_GrenadeTargetPosition                        = 15,
	YBTRP_MAX                                          = 16
};*/

// Enum SRGame.YBT_Register.YE_BTRegisterEntity
/*enum YE_BTRegisterEntity
{
	YBTRE_Self                                         = 0,
	YBTRE_Player                                       = 1,
	YBTRE_SquadMate                                    = 2,
	YBTRE_AttackTarget                                 = 3,
	YBTRE_CoverTarget                                  = 4,
	YBTRE_ObserveTarget                                = 5,
	YBTRE_CommandAttackTarget                          = 6,
	YBTRE_MAX                                          = 7
};*/

// Enum SRGame.YBT_Register.YE_BTUserDataListType
/*enum YE_BTUserDataListType
{
	YBTUDL_Position                                    = 0,
	YBTUDL_Entity                                      = 1,
	YBTUDL_MAX                                         = 2
};*/

// Enum SRGame.YAnimNotify_Execution.YE_ExecutionNotityType
/*enum YE_ExecutionNotityType
{
	YENT_None                                          = 0,
	YENT_Hit                                           = 1,
	YENT_Death                                         = 2,
	YENT_Kill                                          = 3,
	YENT_BlendToRagdoll                                = 4,
	YENT_ShootHead                                     = 5,
	YENT_MAX                                           = 6
};*/

// Enum SRGame.YAnimNotify_Interpolate.YE_InterpolationTime
/*enum YE_InterpolationTime
{
	YINPT_TimeLeftOfAnimation                          = 0,
	YINPT_CustomTime                                   = 1,
	YINPT_MAX                                          = 2
};*/

// Enum SRGame.YAnimNotify_KnockDown.YE_KnockDownNotifyType
/*enum YE_KnockDownNotifyType
{
	YKDNT_KnockedDown                                  = 0,
	YKDNT_StandingUp                                   = 1,
	YKDNT_MAX                                          = 2
};*/

// Enum SRGame.YAnimNotify_Rope.YE_RopeAction
/*enum YE_RopeAction
{
	YRA_Grab                                           = 0,
	YRA_GrabFeet                                       = 1,
	YRA_Release                                        = 2,
	YRA_ReleaseFeet                                    = 3,
	YRA_GroundReached                                  = 4,
	YRA_StartSound                                     = 5,
	YRA_EndSound                                       = 6,
	YRA_EnableCollision                                = 7,
	YRA_MAX                                            = 8
};*/

// Enum SRGame.YAnimNotify_ShowHealingSyringe.YE_ShowHealingSyringe
/*enum YE_ShowHealingSyringe
{
	YSHS_SpawnInHand                                   = 0,
	YSHS_SpawnInHandLeft                               = 1,
	YSHS_DropToGround                                  = 2,
	YSHS_MAX                                           = 3
};*/

// Enum SRGame.YAnimNotify_ShowScndModeMesh.YE_ToggleScndModeMeshAction
/*enum YE_ToggleScndModeMeshAction
{
	YTSMA_ShowMeshOnEquip                              = 0,
	YTSMA_HideMeshOnUnequip                            = 1,
	YTSMA_MAX                                          = 2
};*/

// Enum SRGame.YAnimNotify_Zipline.YE_ZiplineNotityType
/*enum YE_ZiplineNotityType
{
	YZLNT_None                                         = 0,
	YZLNT_StartTraversal                               = 1,
	YZLNT_HolsterWeapon                                = 2,
	YZLNT_EquipWeapon                                  = 3,
	YZLNT_MAX                                          = 4
};*/

// Enum SRGame.YAnimstateManager.YE_ProjectileType
/*enum YE_ProjectileType
{
	YPTT_Bullets                                       = 0,
	YPTT_Grenade                                       = 1,
	YPTT_MAX                                           = 2
};*/

// Enum SRGame.YAnimtreeManager.YE_AnimChannelDataType
/*enum YE_AnimChannelDataType
{
	YACD_None                                          = 0,
	YACD_Animation                                     = 1,
	YACD_AimingPose                                    = 2,
	YACD_MAX                                           = 3
};*/

// Enum SRGame.YAnimtreeManager.YE_AimingPoseState
/*enum YE_AimingPoseState
{
	YAPS_Off                                           = 0,
	YAPS_Inactive                                      = 1,
	YAPS_Active                                        = 2,
	YAPS_MAX                                           = 3
};*/

// Enum SRGame.YBT_StaticNode.YBT_CurrentState
/*enum YBT_CurrentState
{
	YBT_Continue                                       = 0,
	YBT_Success                                        = 1,
	YBT_Failed                                         = 2,
	YBT_Abort                                          = 3,
	YBT_Exception                                      = 4,
	YBT_MAX                                            = 5
};*/

// Enum SRGame.YBT_StaticNode.YBT_EventReaction
/*enum YBT_EventReaction
{
	YBTER_HandleEvent                                  = 0,
	YBTER_DropEvent                                    = 1,
	YBTER_MAX                                          = 2
};*/

// Enum SRGame.YBT_StaticNode.YBT_KismetTimer
/*enum YBT_KismetTimer
{
	YBTKT_NoTimer                                      = 0,
	YBTKT_TimerA                                       = 1,
	YBTKT_TimerB                                       = 2,
	YBTKT_TimerC                                       = 3,
	YBTKT_TimerD                                       = 4,
	YBTKT_TimerE                                       = 5,
	YBTKT_TimerF                                       = 6,
	YBTKT_TimerG                                       = 7,
	YBTKT_TimerH                                       = 8,
	YBTKT_MAX                                          = 9
};*/

// Enum SRGame.YBT_StaticActionCheckAttackPosNode.YE_WhichAttackTarget
/*enum YE_WhichAttackTarget
{
	YWAT_AttackTarget                                  = 0,
	YWAT_SquadAttackTarget                             = 1,
	YWAT_None                                          = 2,
	YWAT_MAX                                           = 3
};*/

// Enum SRGame.YBT_StaticActionCopyUserDataToRegisterNode.YBT_RegisterToChange
/*enum YBT_RegisterToChange
{
	YBTRTC_SquadMate                                   = 0,
	YBTRTC_AttackTarget                                = 1,
	YBTRTC_CoverTarget                                 = 2,
	YBTRTC_ObserveTarget                               = 3,
	YBTRTC_AttackPos                                   = 4,
	YBTRTC_CoverPos                                    = 5,
	YBTRTC_MAX                                         = 6
};*/

// Enum SRGame.YBT_StaticActionCopyUserDataToRegisterNode.YBT_UserDataPos
/*enum YBT_UserDataPos
{
	YBTUDP_Current                                     = 0,
	YBTUDP_First                                       = 1,
	YBTUDP_Last                                        = 2,
	YBTUDP_MAX                                         = 3
};*/

// Enum SRGame.YBT_StaticActionDoSidestepNode.YE_BTSideStepMode
/*enum YE_BTSideStepMode
{
	YBTSSM_Normal                                      = 0,
	YBTSSM_Running                                     = 1,
	YBTSSM_DodgeRoll                                   = 2,
	YBTSSM_ForwardEvade                                = 3,
	YBTSSM_ForwardDive                                 = 4,
	YBTSSM_MAX                                         = 5
};*/

// Enum SRGame.YBT_StaticActionDoSpecialMoveNode.YE_BTSpecialMove
/*enum YE_BTSpecialMove
{
	YBTSM_Vault                                        = 0,
	YBTSM_DropDown                                     = 1,
	YBTSM_Heal                                         = 2,
	YBTSM_Execute                                      = 3,
	YBTSM_Melee                                        = 4,
	YBTSM_Mortar                                       = 5,
	YBTSM_DashIntoCover                                = 6,
	YBTSM_SlipOut                                      = 7,
	YBTSM_FastRope                                     = 8,
	YBTSM_ZipLine                                      = 9,
	YBTSM_TakeHumanShield                              = 10,
	YBTSM_ReleaseHumanShield                           = 11,
	YBTSM_EnterTurret                                  = 12,
	YBTSM_LeaveTurret                                  = 13,
	YBTSM_SwatTurn                                     = 14,
	YBTSM_ForcedGoTo                                   = 15,
	YBTSM_MAX                                          = 16
};*/

// Enum SRGame.YBT_StaticActionGetClosestEntityNode.YE_ClosestEntityNodeSetAs
/*enum YE_ClosestEntityNodeSetAs
{
	YCENSA_None                                        = 0,
	YCENSA_AttackTarget                                = 1,
	YCENSA_CoverTarget                                 = 2,
	YCENSA_ObserveTarget                               = 3,
	YCENSA_MAX                                         = 4
};*/

// Enum SRGame.YBT_StaticActionGotoPos.YBT_EnterCoverMode
/*enum YBT_EnterCoverMode
{
	YBTECM_DoNotEnter                                  = 0,
	YBTECM_WhenCoveredAgainstCoverTarget               = 1,
	YBTECM_AlwaysEnterCover                            = 2,
	YBTECM_StayInCover                                 = 3,
	YBTECM_MAX                                         = 4
};*/

// Enum SRGame.YBT_StaticActionGotoPos.YE_MoveTargetReachModes
/*enum YE_MoveTargetReachModes
{
	YMTRM_ReachOnce                                    = 0,
	YMTRM_Follow                                       = 1,
	YMTRM_FollowAdaptingSpeed                          = 2,
	YMTRM_Direction                                    = 3,
	YMTRM_MAX                                          = 4
};*/

// Enum SRGame.YBT_StaticActionGotoPos.YBT_EdgeCost
/*enum YBT_EdgeCost
{
	YBTEC_Low                                          = 0,
	YBTEC_Normal                                       = 1,
	YBTEC_High                                         = 2,
	YBTEC_MAX                                          = 3
};*/

// Enum SRGame.YBT_StaticObservePosition.YBT_ObserveStart
/*enum YBT_ObserveStart
{
	YBTOS_Left                                         = 0,
	YBTOS_Right                                        = 1,
	YBTOS_CenterLeft                                   = 2,
	YBTOS_CenterRight                                  = 3,
	YBTOS_CenterRandom                                 = 4,
	YBTOS_MAX                                          = 5
};*/

// Enum SRGame.YBT_StaticObservePosition.YBT_ObserveAction
/*enum YBT_ObserveAction
{
	YBTOA_Look                                         = 0,
	YBTOA_Aim                                          = 1,
	YBTOA_Shoot                                        = 2,
	YBTOA_MAX                                          = 3
};*/

// Enum SRGame.YBT_StaticObservePosition.YBT_ObserveSubPosition
/*enum YBT_ObserveSubPosition
{
	YBTOSP_None                                        = 0,
	YBTOSP_Head                                        = 1,
	YBTOSP_Chest                                       = 2,
	YBTOSP_MAX                                         = 3
};*/

// Enum SRGame.YBT_StaticActionSetBehaviorGateNode.YE_BehaviorGateModificationType
/*enum YE_BehaviorGateModificationType
{
	YBGMT_OPEN                                         = 0,
	YBGMT_CLOSE                                        = 1,
	YBGMT_SET                                          = 2,
	YBGMT_INCREMENT                                    = 3,
	YBGMT_MAX                                          = 4
};*/

// Enum SRGame.YBT_StaticActionToogleWeaponNode.YE_ToggleWeaponAction
/*enum YE_ToggleWeaponAction
{
	YTWA_SIMPLETOGGLE                                  = 0,
	YTWA_SWITCH_TOSIDEARM                              = 1,
	YTWA_SWITCH_TOMAINARM                              = 2,
	YTWA_MAX                                           = 3
};*/

// Enum SRGame.YBT_StaticConditionEntityIsValidNode.YE_EntityIsValidCheckType
/*enum YE_EntityIsValidCheckType
{
	YEIV_ALL                                           = 0,
	YEIV_AIONLY                                        = 1,
	YEIV_HUMANONLY                                     = 2,
	YEIV_MAX                                           = 3
};*/

// Enum SRGame.YBT_StaticConditionEntitySpeedIsNode.YBTE_EntityMovementSpeed
/*enum YBTE_EntityMovementSpeed
{
	YBTEMS_SPRINTING                                   = 0,
	YBTEMS_MAX                                         = 1
};*/

// Enum SRGame.YBT_StaticConditionHasPositionInPlayerSquadPathNode.YBTE_PathOrder
/*enum YBTE_PathOrder
{
	YBTEPO_FirstInPath                                 = 0,
	YBTEPO_SecondInPath                                = 1,
	YBTEPO_NoCommonPath                                = 2,
	YBTEPO_MAX                                         = 3
};*/

// Enum SRGame.YBT_StaticConditionIsInRangeNode.YBT_RangeCheckMode
/*enum YBT_RangeCheckMode
{
	YAIRCM_Distance3D                                  = 0,
	YAIRCM_Distance2D5                                 = 1,
	YAIRCM_Distance2D                                  = 2,
	YAIRCM_MAX                                         = 3
};*/

// Enum SRGame.YBT_StaticCover.YBT_CoverStance
/*enum YBT_CoverStance
{
	YBTCS_Auto                                         = 0,
	YBTCS_Left                                         = 1,
	YBTCS_Right                                        = 2,
	YBTCS_LeaveCover                                   = 3,
	YBTCS_Middle                                       = 4,
	YBTCS_MAX                                          = 5
};*/

// Enum SRGame.YBT_StaticDecoratorLoopNode.YBT_LoopMode
/*enum YBT_LoopMode
{
	YAILM_UntilSuccess                                 = 0,
	YAILM_UntilFailure                                 = 1,
	YAILM_Forever                                      = 2,
	YAILM_MAX                                          = 3
};*/

// Enum SRGame.YBT_StaticDecoratorModifyPawnFlagNode.YBT_ModifyPawnFlagAction
/*enum YBT_ModifyPawnFlagAction
{
	YMPFA_DoNotChange                                  = 0,
	YMPFA_UseDefault                                   = 1,
	YMPFA_Enable                                       = 2,
	YMPFA_Disable                                      = 3,
	YMPFA_MAX                                          = 4
};*/

// Enum SRGame.YBT_StaticObserveDirection.YBT_ObserveSide
/*enum YBT_ObserveSide
{
	YBTOSI_Center                                      = 0,
	YBTOSI_Left                                        = 1,
	YBTOSI_Right                                       = 2,
	YBTOSI_LeanOver                                    = 3,
	YBTOSI_FromPosition                                = 4,
	YBTOSI_MAX                                         = 5
};*/

// Enum SRGame.YGameInfo_MP.YE_StartMatchSequence
/*enum YE_StartMatchSequence
{
	YSMS_Nothing                                       = 0,
	YSMS_WaitForPlayers                                = 1,
	YSMS_Warmup                                        = 2,
	YSMS_WaitPlayerReady                               = 3,
	YSMS_PlayChoreo                                    = 4,
	YSMS_Startup                                       = 5,
	YSMS_MAX                                           = 6
};*/

// Enum SRGame.YSeqAct_LinkAttackCommandArea.YE_CommandType
/*enum YE_CommandType
{
	YCT_Normal                                         = 0,
	YCT_Sniper                                         = 1,
	YCT_MAX                                            = 2
};*/

// Enum SRGame.YCheapShooter.YE_CheapShooterMovingSpeed
/*enum YE_CheapShooterMovingSpeed
{
	YCSMoveSpeed_Walk                                  = 0,
	YCSMoveSpeed_Run                                   = 1,
	YCSMoveSpeed_Sprint                                = 2,
	YCSMoveSpeed_AimedWalk                             = 3,
	YCSMoveSpeed_AimedRun                              = 4,
	YCSMoveSpeed_Civilian_Walk                         = 5,
	YCSMoveSpeed_Civilian_Run                          = 6,
	YCSMoveSpeed_MAX                                   = 7
};*/

// Enum SRGame.YCheapShooter.YE_CheapShooterShootingState
/*enum YE_CheapShooterShootingState
{
	YCSShootState_Shooting                             = 0,
	YCSShootState_Aiming                               = 1,
	YCSShootState_Covering                             = 2,
	YCSShootState_MAX                                  = 3
};*/

// Enum SRGame.YCheapShooter.YCS_ReplicatedAnimationState
/*enum YCS_ReplicatedAnimationState
{
	YCSRAS_None                                        = 0,
	YCSRAS_Aiming                                      = 1,
	YCSRAS_Moving                                      = 2,
	YCSRAS_FromAimingToCover                           = 3,
	YCSRAS_FromMovingToCover                           = 4,
	YCSRAS_DeathAnimation                              = 5,
	YCSRAS_MAX                                         = 6
};*/

// Enum SRGame.YCheapShooter.YCS_CurrentKismetAction
/*enum YCS_CurrentKismetAction
{
	YCSKA_Nothing                                      = 0,
	YCSKA_ShootingAt                                   = 1,
	YCSKA_TakingCover                                  = 2,
	YCSKA_Moving                                       = 3,
	YCSKA_CustomAnim                                   = 4,
	YCSKA_Dead                                         = 5,
	YCSKA_MAX                                          = 6
};*/

// Enum SRGame.YCheapShooter.YE_CheapShooterEnemyTypes
/*enum YE_CheapShooterEnemyTypes
{
	YCSET_Civilian_Male                                = 0,
	YCSET_Civilian_Female                              = 1,
	YCSET_Marauder_Assault                             = 2,
	YCSET_Marauder_RPG                                 = 3,
	YCSET_Enemy_Assault                                = 4,
	YCSET_Enemy_Sniper                                 = 5,
	YCSET_Enemy_RPG                                    = 6,
	YCSET_MediumEnemy_Assault                          = 7,
	YCSET_MediumEnemy_Sniper                           = 8,
	YCSET_MediumEnemy_RPG                              = 9,
	YCSET_EliteEnemy_Assault                           = 10,
	YCSET_EliteEnemy_Sniper                            = 11,
	YCSET_EliteEnemy_RPG                               = 12,
	YCSET_Marauder_NoWeapon                            = 13,
	YCSET_EliteEnemy_NoWeapon                          = 14,
	YCSET_EnemyKonrad_NoWeapon                         = 15,
	YCSET_Lugo_WarTorn                                 = 16,
	YCSET_USMarine                                     = 17,
	YCSET_MAX                                          = 18
};*/

// Enum SRGame.YCheapShooter.YE_CheapShooterMovingState
/*enum YE_CheapShooterMovingState
{
	YCSMoveState_Move                                  = 0,
	YCSMoveState_Move_Prepare                          = 1,
	YCSMoveState_Move_Finishing                        = 2,
	YCSMoveState_MAX                                   = 3
};*/

// Enum SRGame.YCheapShooter.YE_CheapShooterCoverType
/*enum YE_CheapShooterCoverType
{
	YCSCoverType_StandNormal                           = 0,
	YCSCoverType_CrouchPopUp                           = 1,
	YCSCoverType_CrouchNoCover                         = 2,
	YCSCoverType_Civilian_StandNormal                  = 3,
	YCSCoverType_MAX                                   = 4
};*/

// Enum SRGame.YCheckpoint.YE_CheckpointFileLoadResult
/*enum YE_CheckpointFileLoadResult
{
	YCFLR_None                                         = 0,
	YCFLR_AccessDenied                                 = 1,
	YCFLR_ReadFailed                                   = 2,
	YCFLR_FileNotFound                                 = 3,
	YCFLR_DataCorrupted                                = 4,
	YCFLR_Success                                      = 5,
	YCFLR_MAX                                          = 6
};*/

// Enum SRGame.YCollisionEffectMgr.YE_WeaponEffectResult
/*enum YE_WeaponEffectResult
{
	YWER_Stop                                          = 0,
	YWER_ShootThrough                                  = 1,
	YWER_Error                                         = 2,
	YWER_MAX                                           = 3
};*/

// Enum SRGame.YCoverGizmo.YE_TraceHeightIndex
/*enum YE_TraceHeightIndex
{
	THI_StepHeight                                     = 0,
	THI_CrouchCoverHeight                              = 1,
	THI_StandCoverHeight                               = 2,
	THI_MAX                                            = 3
};*/

// Enum SRGame.YCoverGizmo.YE_GizmoResult
/*enum YE_GizmoResult
{
	GIZMO_Success                                      = 0,
	GIZMO_Failed                                       = 1,
	GIZMO_Adjusted                                     = 2,
	GIZMO_MAX                                          = 3
};*/

// Enum SRGame.YCoverGizmo.YE_TraceResultIndex
/*enum YE_TraceResultIndex
{
	TRI_Left                                           = 0,
	TRI_Mid                                            = 1,
	TRI_Right                                          = 2,
	TRI_MAX                                            = 3
};*/

// Enum SRGame.YCrosshair_Indicator.YE_CrosshairIndicator
/*enum YE_CrosshairIndicator
{
	YXHAIR_Hit1                                        = 0,
	YXHAIR_Hit2                                        = 1,
	YXHAIR_Hit3                                        = 2,
	YXHAIR_ArmorHit1                                   = 3,
	YXHAIR_ArmorHit2                                   = 4,
	YXHAIR_ArmorHit3                                   = 5,
	YXHAIR_ArmorHit4                                   = 6,
	YXHAIR_DontShoot                                   = 7,
	YXHAIR_Sonar                                       = 8,
	YXHAIR_MAX                                         = 9
};*/

// Enum SRGame.YDBNORule_SinglePlayer.YE_DBNORuleSet_SP
/*enum YE_DBNORuleSet_SP
{
	YDBNORuleSet_SP_HumanPlayer                        = 0,
	YDBNORuleSet_SP_Revivable                          = 1,
	YDBNORuleSet_SP_PlayerSquad                        = 2,
	YDBNORuleSet_SP_AI                                 = 3,
	YDBNORuleSet_SP_MAX                                = 4
};*/

// Enum SRGame.YDBNORule_CrossPlayer.YE_DBNORuleSet_CP
/*enum YE_DBNORuleSet_CP
{
	YDBNORuleSet_CP_SpecOps                            = 0,
	YDBNORuleSet_CP_Konrad                             = 1,
	YDBNORuleSet_CP_PerkUser                           = 2,
	YDBNORuleSet_CP_MAX                                = 3
};*/

// Enum SRGame.YDBNORule_Horde.YE_DBNORuleSet_HRD
/*enum YE_DBNORuleSet_HRD
{
	YDBNORuleSet_HRD_Players                           = 0,
	YDBNORuleSet_HRD_Horde                             = 1,
	YDBNORuleSet_HRD_MAX                               = 2
};*/

// Enum SRGame.YDeathMessage.YE_KillFlags
/*enum YE_KillFlags
{
	YKF_StandardKill                                   = 0,
	YKF_Suicide                                        = 1,
	YKF_TeamKill                                       = 2,
	YKF_SpawnKill                                      = 3,
	YKF_HeadShot                                       = 4,
	YKF_DBNOKill                                       = 5,
	YKF_MAX                                            = 6
};*/

// Enum SRGame.YDirectionIndicator.YE_IndicatorPositionType
/*enum YE_IndicatorPositionType
{
	YIPT_ScaleUniform                                  = 0,
	YIPT_ScaleNonUniform                               = 1,
	YIPT_Radius                                        = 2,
	YIPT_MAX                                           = 3
};*/

// Enum SRGame.YDrawPatchSplineComponent.EPatchSplineMode
/*enum EPatchSplineMode
{
	PSM_H                                              = 0,
	PSM_V                                              = 1,
	PSM_CROSS                                          = 2,
	PSM_MAX                                            = 3
};*/

// Enum SRGame.YDuneActor.YE_FilterMode
/*enum YE_FilterMode
{
	YEFM_None                                          = 0,
	YEFM_Ignore                                        = 1,
	YEFM_Affect                                        = 2,
	YEFM_MAX                                           = 3
};*/

// Enum SRGame.YDynCover.YE_CoverSlotType
/*enum YE_CoverSlotType
{
	SlotType_Standard                                  = 0,
	SlotType_Peek                                      = 1,
	SlotType_MAX                                       = 2
};*/

// Enum SRGame.YErrorMarker.YE_ErrorMarkerType
/*enum YE_ErrorMarkerType
{
	YEMT_All                                           = 0,
	YEMT_Warning                                       = 1,
	YEMT_Error                                         = 2,
	YEMT_Warning_AI                                    = 3,
	YEMT_Error_AI                                      = 4,
	YEMT_MAX                                           = 5
};*/

// Enum SRGame.YFogVolumeSandDensityInfo.EFogSandState
/*enum EFogSandState
{
	E_FSS_OFF                                          = 0,
	E_FSS_START                                        = 1,
	E_FSS_FADEIN                                       = 2,
	E_FSS_RUN                                          = 3,
	E_FSS_FADEOUT                                      = 4,
	E_FSS_MAX                                          = 5
};*/

// Enum SRGame.YGameEngine.YE_CheckpointAction
/*enum YE_CheckpointAction
{
	Checkpoint_Default                                 = 0,
	Checkpoint_Load                                    = 1,
	Checkpoint_FinishLoad                              = 2,
	Checkpoint_Save                                    = 3,
	Checkpoint_DeleteAll                               = 4,
	Checkpoint_MAX                                     = 5
};*/

// Enum SRGame.YGameEngine.YE_PositionCacheInfo
/*enum YE_PositionCacheInfo
{
	YPosCache_LoadIcon                                 = 0,
	YPosCache_Skip                                     = 1,
	YPosCache_SaveIcon                                 = 2,
	YPosCache_PauseIcon                                = 3,
	YPosCache_MAX                                      = 4
};*/

// Enum SRGame.YGameEngine.YE_InviteNetworkState
/*enum YE_InviteNetworkState
{
	YINS_NoInvite                                      = 0,
	YINS_InviteAccepted                                = 1,
	YINS_InviteFirstAttemptFailed                      = 2,
	YINS_MAX                                           = 3
};*/

// Enum SRGame.YGameReplicationInfo.YE_GRIMenuType
/*enum YE_GRIMenuType
{
	YGMT_None                                          = 0,
	YGMT_Frontend                                      = 1,
	YGMT_Shell                                         = 2,
	YGMT_MAX                                           = 3
};*/

// Enum SRGame.YGameReplicationInfo_MPBase.YE_MatchmakingState
/*enum YE_MatchmakingState
{
	YMMKS_NotMatchmaking                               = 0,
	YMMKS_TravellingBackToMenu                         = 1,
	YMMKS_TravellingBackToOnlineMenu                   = 2,
	YMMKS_QuittingMatchmaking                          = 3,
	YMMKS_CancellingMatchmaking                        = 4,
	YMMKS_HostCancellingMatchmaking                    = 5,
	YMMKS_ReadyForInitialization                       = 6,
	YMMKS_InitializingMatchmaking                      = 7,
	YMMKS_ReadyForMatchmaking                          = 8,
	YMMKS_ReadingPartySkills                           = 9,
	YMMKS_StartingPartyMatching                        = 10,
	YMMKS_FindingMatchingSessions                      = 11,
	YMMKS_FindingBestMatchingSession                   = 12,
	YMMKS_JoiningBestMatchingSession                   = 13,
	YMMKS_HostingMatch                                 = 14,
	YMMKS_ConnectingBeacon                             = 15,
	YMMKS_WaitingForSession                            = 16,
	YMMKS_JoiningSession                               = 17,
	YMMKS_TravellingToSession                          = 18,
	YMMKS_InLobby                                      = 19,
	YMMKS_LoadingGame                                  = 20,
	YMMKS_InGame                                       = 21,
	YMMKS_MAX                                          = 22
};*/

// Enum SRGame.YGameReplicationInfo_MPBase.YE_MPLobbyState
/*enum YE_MPLobbyState
{
	YMPLS_NotReady                                     = 0,
	YMPLS_VoteInProgress                               = 1,
	YMPLS_VoteFinished                                 = 2,
	YMPLS_WaitingForPlayersToBeReady                   = 3,
	YMPLS_Starting                                     = 4,
	YMPLS_MAX                                          = 5
};*/

// Enum SRGame.YGameInfo_Coop.YE_CoopPlayers
/*enum YE_CoopPlayers
{
	YCP_CoopPlayerNone                                 = 0,
	YCP_CoopPlayerA                                    = 1,
	YCP_CoopPlayerB                                    = 2,
	YCP_CoopPlayerC                                    = 3,
	YCP_MAX                                            = 4
};*/

// Enum SRGame.YGameInfo_CP.YE_StrategyMngrGameNotification
/*enum YE_StrategyMngrGameNotification
{
	YESMGN_BOT_STARTED                                 = 0,
	YESMGN_ROUND_ENDED                                 = 1,
	YESMGN_DELAYED_SPAWNS_COMPLETE                     = 2,
	YESMGN_SPECOPS_DBNOED                              = 3,
	YESMGN_SPECOPS_CALL4HELP                           = 4,
	YESMGN_SO_TAC_MARKER_ENABLED                       = 5,
	YESMGN_SO_TAC_MARKER_DISABLED                      = 6,
	YESMGN_MAX                                         = 7
};*/

// Enum SRGame.YGamepadInputScheme.YE_GamepadInputButton
/*enum YE_GamepadInputButton
{
	YGIB_LeftThumbstick                                = 0,
	YGIB_RightThumbstick                               = 1,
	YGIB_Back                                          = 2,
	YGIB_Start                                         = 3,
	YGIB_A                                             = 4,
	YGIB_B                                             = 5,
	YGIB_X                                             = 6,
	YGIB_Y                                             = 7,
	YGIB_LeftShoulder                                  = 8,
	YGIB_RightShoulder                                 = 9,
	YGIB_LeftTrigger                                   = 10,
	YGIB_RightTrigger                                  = 11,
	YGIB_DPadUp                                        = 12,
	YGIB_DPadDown                                      = 13,
	YGIB_DPadRight                                     = 14,
	YGIB_DPadLeft                                      = 15,
	YGIB_DPadUpRaw                                     = 16,
	YGIB_DPadDownRaw                                   = 17,
	YGIB_DPadRightRaw                                  = 18,
	YGIB_DPadLeftRaw                                   = 19,
	YGIB_MAX                                           = 20
};*/

// Enum SRGame.YGamepadInputScheme.YE_GamepadInputEvent
/*enum YE_GamepadInputEvent
{
	YGIE_Press                                         = 0,
	YGIE_Release                                       = 1,
	YGIE_SingleTap                                     = 2,
	YGIE_Hold                                          = 3,
	YGIE_HoldRelease                                   = 4,
	YGIE_MAX                                           = 5
};*/

// Enum SRGame.YGameReplicationInfo_Menu.YE_PartyMenuType
/*enum YE_PartyMenuType
{
	YPMT_OnlineMP                                      = 0,
	YPMT_CustomMatch                                   = 1,
	YPMT_MAX                                           = 2
};*/

// Enum SRGame.YGameSettingsCampaign.YE_SinglePlayerChapters
/*enum YE_SinglePlayerChapters
{
	YSPC_Chapter01                                     = 0,
	YSPC_Chapter02                                     = 1,
	YSPC_Chapter03                                     = 2,
	YSPC_Chapter04                                     = 3,
	YSPC_Chapter05                                     = 4,
	YSPC_Chapter06                                     = 5,
	YSPC_Chapter07                                     = 6,
	YSPC_Chapter08                                     = 7,
	YSPC_Chapter09                                     = 8,
	YSPC_Chapter10                                     = 9,
	YSPC_Chapter11                                     = 10,
	YSPC_MAX                                           = 11
};*/

// Enum SRGame.YGameSettingsCampaign.YE_SinglePlayerMissions
/*enum YE_SinglePlayerMissions
{
	YSPM_Desert01                                      = 0,
	YSPM_Desert02                                      = 1,
	YSPM_Atrium01                                      = 2,
	YSPM_Atrium02                                      = 3,
	YSPM_Gorge01                                       = 4,
	YSPM_Gorge02                                       = 5,
	YSPM_CityGate01                                    = 6,
	YSPM_CityGate02                                    = 7,
	YSPM_Road                                          = 8,
	YSPM_StealingWater01                               = 9,
	YSPM_StealingWater02                               = 10,
	YSPM_DollsHouse                                    = 11,
	YSPM_Radioman02                                    = 12,
	YSPM_ShipsGraveyard                                = 13,
	YSPM_Bridge                                        = 14,
	YSPM_BurjDubai                                     = 15,
	YSPM_Epilogue                                      = 16,
	YSPM_Prologue                                      = 17,
	YSPM_MAX                                           = 18
};*/

// Enum SRGame.YGeometryUtils.YE_LineIntersectionResult
/*enum YE_LineIntersectionResult
{
	YLIR_Parallel                                      = 0,
	YLIR_Coincident                                    = 1,
	YLIR_NotIntersecting                               = 2,
	YLIR_Intersecting                                  = 3,
	YLIR_MAX                                           = 4
};*/

// Enum SRGame.YIcon_AmmoPickup.YE_AmmoType
/*enum YE_AmmoType
{
	YEAT_Grenade                                       = 0,
	YEAT_C4                                            = 1,
	YEAT_Bullet                                        = 2,
	YEAT_ExtClip                                       = 3,
	YEAT_Weapon                                        = 4,
	YEAT_Armor                                         = 5,
	YEAT_Medkit                                        = 6,
	YEAT_Scan                                          = 7,
	YEAT_Mine                                          = 8,
	YEAT_Stun                                          = 9,
	YEAT_MAX                                           = 10
};*/

// Enum SRGame.YIcon_HD_CaptureZone.YE_CapturingTeam
/*enum YE_CapturingTeam
{
	YCAPTEAM_Specops                                   = 0,
	YCAPTEAM_Konrad                                    = 1,
	YCAPTEAM_Nobody                                    = 2,
	YCAPTEAM_MAX                                       = 3
};*/

// Enum SRGame.YIcon_MP_DBNO.YE_DBNOType
/*enum YE_DBNOType
{
	YDBNOTYPE_DBNO                                     = 0,
	YDBNOTYPE_CallForHelp                              = 1,
	YDBNOTYPE_MAX                                      = 2
};*/

// Enum SRGame.YInterfaceManager.YE_Interface
/*enum YE_Interface
{
	YIFC_Shootable                                     = 0,
	YIFC_Controller                                    = 1,
	YIFC_TacticalMarkable                              = 2,
	YIFC_TacticalDetector                              = 3,
	YIFC_PSGNode                                       = 4,
	YIFC_Scanable                                      = 5,
	YIFC_MAX                                           = 6
};*/

// Enum SRGame.YLeaderboardSettings.ELeaderboardFilters
/*enum ELeaderboardFilters
{
	LF_GameMode                                        = 0,
	LF_MatchType                                       = 1,
	LF_PlayerFilterType                                = 2,
	LF_Faction                                         = 3,
	LF_MAX                                             = 4
};*/

// Enum SRGame.YLeaderboardSettings.EMatchTypeSettings
/*enum EMatchTypeSettings
{
	MTS_Ranked                                         = 0,
	MTS_Player                                         = 1,
	MTS_MAX                                            = 2
};*/

// Enum SRGame.YLeaderboardSettings.EPlayerFilterSettings
/*enum EPlayerFilterSettings
{
	PFS_Player                                         = 0,
	PFS_CenteredOnPlayer                               = 1,
	PFS_Friends                                        = 2,
	PFS_TopRankings                                    = 3,
	PFS_MAX                                            = 4
};*/

// Enum SRGame.YLeaderboardSettings.EFactionFilterSettings
/*enum EFactionFilterSettings
{
	FFS_Global                                         = 0,
	FFS_SpecOps                                        = 1,
	FFS_Konrad                                         = 2,
	FFS_MAX                                            = 3
};*/

// Enum SRGame.YLocator.YLT_AIType
/*enum YLT_AIType
{
	YLT_Arrow                                          = 0,
	YLT_Adams                                          = 1,
	YLT_Lugo                                           = 2,
	YLT_Riggs                                          = 3,
	YLT_Civilian                                       = 4,
	YLT_Enemy                                          = 5,
	YLT_MAX                                            = 6
};*/

// Enum SRGame.YMatchmakingJoinComponent.YE_MatchMakingJoinFailureState
/*enum YE_MatchMakingJoinFailureState
{
	YMMJFS_None                                        = 0,
	YMMJFS_ReservationRequestFailure                   = 1,
	YMMJFS_RequestTimedOut                             = 2,
	YMMJFS_NoSpace                                     = 3,
	YMMJFS_MAX                                         = 4
};*/

// Enum SRGame.YMatchmakingManager.YE_MultiplayerGameType
/*enum YE_MultiplayerGameType
{
	YMPGT_OnlinePublic                                 = 0,
	YMPGT_OnlinePrivate                                = 1,
	YMPGT_SystemLink                                   = 2,
	YMPGT_Local                                        = 3,
	YMPGT_MAX                                          = 4
};*/

// Enum SRGame.YMaterialExpressionPartialDerivative.EPartialDerivativeType
/*enum EPartialDerivativeType
{
	PartialDerivative_X                                = 0,
	PartialDerivative_Y                                = 1,
	PartialDerivative_MAX                              = 2
};*/

// Enum SRGame.YMaterialExpressionWorldAlignedUV.YE_Axis
/*enum YE_Axis
{
	X_AXIS                                             = 0,
	Y_AXIS                                             = 1,
	Z_AXIS                                             = 2,
	YE_Axis_MAX                                        = 3
};*/

// Enum SRGame.YMathUtils.YE_IntersectionResult
/*enum YE_IntersectionResult
{
	YISR_Identical                                     = 0,
	YISR_Parallel                                      = 1,
	YISR_Antiparallel                                  = 2,
	YISR_Intersecting                                  = 3,
	YISR_Skew                                          = 4,
	YISR_MAX                                           = 5
};*/

// Enum SRGame.YMathUtils.YE_InfluencePower
/*enum YE_InfluencePower
{
	YIPW_Linear                                        = 0,
	YIPW_Squared                                       = 1,
	YIPW_Squareroot                                    = 2,
	YIPW_Cubic                                         = 3,
	YIPW_MAX                                           = 4
};*/

// Enum SRGame.YObjectPoolScript.YEEmitterTypes
/*enum YEEmitterTypes
{
	YEET_Whatever                                      = 0,
	YEET_IMPACT_BLOOD_00                               = 1,
	YEET_IMPACT_BLOOD_01                               = 2,
	YEET_IMPACT_BLOOD_02                               = 3,
	YEET_IMPACT_BLOOD_04                               = 4,
	YEET_IMPACT_BLOOD_05                               = 5,
	YEET_IMPACT_KILLSHOT_00                            = 6,
	YEET_IMPACT_KILLSHOT_01                            = 7,
	YEET_IMPACT_KILLSHOT_03                            = 8,
	YEET_IMPACT_KILLSHOT_05                            = 9,
	YEET_FOOTSTEP_WALK_SAND_00                         = 10,
	YEET_FOOTSTEP_SPRINT_SAND_00                       = 11,
	YEET_FOOTSTEP_LANDING_SAND_00                      = 12,
	YEET_FOOTSTEP_LANDING_SAND_01                      = 13,
	YEET_FOOTSTEP_LANDING_SAND_02                      = 14,
	YEET_IMPACT_FABRIC_00                              = 15,
	YEET_IMPACT_FABRIC_01                              = 16,
	YEET_IMPACT_CONCRETE_00                            = 17,
	YEET_IMPACT_CONCRETE_01                            = 18,
	YEET_IMPACT_CONCRETE_02                            = 19,
	YEET_IMPACT_CONCRETE_03                            = 20,
	YEET_IMPACT_DEFAULT_02                             = 21,
	YEET_IMPACT_DEFAULT_03                             = 22,
	YEET_IMPACT_FLESHOLD_00                            = 23,
	YEET_IMPACT_GLASS_00                               = 24,
	YEET_IMPACT_METALSHEET_00                          = 25,
	YEET_IMPACT_METALSHEET_01                          = 26,
	YEET_IMPACT_METALSHEET_02                          = 27,
	YEET_IMPACT_METALSHEET_03                          = 28,
	YEET_IMPACT_SAND_00                                = 29,
	YEET_IMPACT_SAND_01                                = 30,
	YEET_IMPACT_SAND_02                                = 31,
	YEET_IMPACT_SAND_03                                = 32,
	YEET_IMPACT_WATER_00                               = 33,
	YEET_IMPACT_WOOD_00                                = 34,
	YEET_IMPACT_WOOD_01                                = 35,
	YEET_IMPACT_MINIGUN_STD                            = 36,
	YEET_IMPACT_MINIGUN_METAL                          = 37,
	YEET_EXPL_GRENADE_GROUND_00                        = 38,
	YEET_EXPL_GRENADE_SAND_00                          = 39,
	YEET_EXPL_GRENADE_SS_00                            = 40,
	YEET_EXPL_STUN_00                                  = 41,
	YEET_EXPL_STUN_SS_00                               = 42,
	YEET_EXPL_RPG_00                                   = 43,
	YEET_IMPACT_GRENADE_BOUNCE_STICKY                  = 44,
	YEET_IMPACT_GRENADE_BOUNCE                         = 45,
	YEET_IMPACT_GRENADE_BOUNCE_SAND                    = 46,
	YEET_HEAD_EXPLODE                                  = 47,
	YEET_VAPORIZED_PAWN                                = 48,
	YEET_MAX                                           = 49
};*/

// Enum SRGame.YObjectPoolScript.YE_SkelMeshTypes
/*enum YE_SkelMeshTypes
{
	YSMT_Whatever                                      = 0,
	YSMT_WEAPON_M4Carbine                              = 1,
	YSMT_WEAPON_SCAR                                   = 2,
	YSMT_WEAPON_OTs14Groza                             = 3,
	YSMT_WEAPON_HK417                                  = 4,
	YSMT_WEAPON_AA12                                   = 5,
	YSMT_WEAPON_FAMAS                                  = 6,
	YSMT_WEAPON_TAR21                                  = 7,
	YSMT_WEAPON_AK74                                   = 8,
	YSMT_WEAPON_AK47                                   = 9,
	YSMT_WEAPON_HuntingRifle                           = 10,
	YSMT_WEAPON_HnKUMP45                               = 11,
	YSMT_WEAPON_FNP90                                  = 12,
	YSMT_WEAPON_TDIVector                              = 13,
	YSMT_WEAPON_MicroUzi                               = 14,
	YSMT_WEAPON_MP7                                    = 15,
	YSMT_WEAPON_AKS74u                                 = 16,
	YSMT_WEAPON_M249                                   = 17,
	YSMT_WEAPON_Mossberg590A1                          = 18,
	YSMT_WEAPON_BenelliM1014                           = 19,
	YSMT_WEAPON_SawedOffShotgun                        = 20,
	YSMT_WEAPON_BarrettM99                             = 21,
	YSMT_WEAPON_SteyrElite                             = 22,
	YSMT_WEAPON_M110SniperSystem                       = 23,
	YSMT_WEAPON_MSG90                                  = 24,
	YSMT_WEAPON_Milkor                                 = 25,
	YSMT_WEAPON_RPG                                    = 26,
	YSMT_WEAPON_DesertEagle50AE                        = 27,
	YSMT_WEAPON_M9A1                                   = 28,
	YSMT_WEAPON_Glock18                                = 29,
	YSMT_WEAPON_SIGP220                                = 30,
	YSMT_WEAPON_FNP45                                  = 31,
	YSMT_WEAPON_PythonElite                            = 32,
	YSMT_MAX                                           = 33
};*/

// Enum SRGame.YParticleModuleLocationVertex.VertexSpawnOrder
/*enum VertexSpawnOrder
{
	VertexSpawn_Sequential                             = 0,
	VertexSpawn_Bounce                                 = 1,
	VertexSpawn_Random                                 = 2,
	VertexSpawn_RandomExhaustive                       = 3,
	VertexSpawn_MAX                                    = 4
};*/

// Enum SRGame.YPawn_Multiplayer.YE_DetectionReason
/*enum YE_DetectionReason
{
	YDR_EnemyScan                                      = 0,
	YDR_NoisyAction                                    = 1,
	YDR_HunterPerk                                     = 2,
	YDR_HelpNeeded                                     = 3,
	YDR_MAX                                            = 4
};*/

// Enum SRGame.YPawn_Multiplayer.EMeshLocation
/*enum EMeshLocation
{
	EMeshLocation_Head                                 = 0,
	EMeshLocation_Torso                                = 1,
	EMeshLocation_Arms                                 = 2,
	EMeshLocation_Legs                                 = 3,
	EMeshLocation_MAX                                  = 4
};*/

// Enum SRGame.YPickup_FremenLoot.YE_FremenLootType
/*enum YE_FremenLootType
{
	YFLT_Medkit                                        = 0,
	YFLT_Ammo                                          = 1,
	YFLT_Explosive                                     = 2,
	YFLT_Armor                                         = 3,
	YFLT_Scan                                          = 4,
	YFLT_MAX                                           = 5
};*/

// Enum SRGame.YPlayerCamTransition.YE_CamRotationInterpolationMode
/*enum YE_CamRotationInterpolationMode
{
	YCRIM_TARGET_ROT                                   = 0,
	YCRIM_TARGET_FIXED_ROT                             = 1,
	YCRIM_CURRENT_FIXED_ROT                            = 2,
	YCRIM_USERCONTROLLED_ROT                           = 3,
	YCRIM_STAY_ON_TARGET                               = 4,
	YCRIM_STAY_ON_TARGET_FIXED                         = 5,
	YCRIM_MAX                                          = 6
};*/

// Enum SRGame.YPlayerCamTransition.YE_TransitionSmoothingMode
/*enum YE_TransitionSmoothingMode
{
	YTSM_Default                                       = 0,
	YTSM_Linear                                        = 1,
	YTSM_SmoothInAndOut                                = 2,
	YTSM_SmoothIn                                      = 3,
	YTSM_SmoothOut                                     = 4,
	YTSM_MAX                                           = 5
};*/

// Enum SRGame.YPlayerController_MPBase.YE_LeaveReason
/*enum YE_LeaveReason
{
	YLR_Unvoluntary                                    = 0,
	YLR_Voluntary                                      = 1,
	YKR_KickedForIdling                                = 2,
	YKR_KickedForFriendlyFire                          = 3,
	YE_LeaveReason_MAX                                 = 4
};*/

// Enum SRGame.YPlayerController_Buried.DE_PlayerActionMessageBuried
/*enum DE_PlayerActionMessageBuried
{
	DPAMHD_None                                        = 0,
	DPAMHD_Repair                                      = 1,
	DPAMHD_MaxHealth                                   = 2,
	DPAMHD_MAX                                         = 3
};*/

// Enum SRGame.YPlayerController_CA.YE_PlayerActionMessageCA
/*enum YE_PlayerActionMessageCA
{
	YPAMSW_None                                        = 0,
	YPAMSW_MarkBase                                    = 1,
	YPAMSW_MarkedBase                                  = 2,
	YPAMSW_MarkingBase                                 = 3,
	YPAMSW_CallChopper                                 = 4,
	YPAMSW_NoBasesMarked                               = 5,
	YPAMSW_ChopperCooldown                             = 6,
	YPAMSW_ChopperActive                               = 7,
	YPAMSW_BaseDestroyed                               = 8,
	YPAMSW_MAX                                         = 9
};*/

// Enum SRGame.YPlayerController_CA.DE_PlayerActionMessageChopper
/*enum DE_PlayerActionMessageChopper
{
	DPAMCA_None                                        = 0,
	DPAMCA_DEACTIVATE                                  = 1,
	DPAMCA_ACTIVATE                                    = 2,
	DPAMCA_MAX                                         = 3
};*/

// Enum SRGame.YPlayerController_HD.YE_PlayerActionMessageHD
/*enum YE_PlayerActionMessageHD
{
	YPAMHD_None                                        = 0,
	YPAMHD_Sabotaging                                  = 1,
	YPAMHD_Repairing                                   = 2,
	YPAMHD_AlreadySabotaged                            = 3,
	YPAMHD_AlreadyRepaired                             = 4,
	YPAMHD_MAX                                         = 5
};*/

// Enum SRGame.YPlayerController_Offline.DE_PlayerActionMessageOffline
/*enum DE_PlayerActionMessageOffline
{
	DPAMOL_None                                        = 0,
	DPAMOL_DEACTIVATE                                  = 1,
	DPAMOL_ACTIVATE                                    = 2,
	DPAMOL_MAX                                         = 3
};*/

// Enum SRGame.YPlayerController_SDM.DE_PlayerActionMessageSDM
/*enum DE_PlayerActionMessageSDM
{
	DPAMOL_None                                        = 0,
	DPAMOL_ACTIVATE                                    = 1,
	DPAMOL_MAX                                         = 2
};*/

// Enum SRGame.YPlayerController_SW.YE_PlayerActionMessageSW
/*enum YE_PlayerActionMessageSW
{
	YPAMSW_None                                        = 0,
	YPAMSW_Steal                                       = 1,
	YPAMSW_Deposit                                     = 2,
	YPAMSW_MAX                                         = 3
};*/

// Enum SRGame.YPlayerInput3.YE_InputProcessingMethod
/*enum YE_InputProcessingMethod
{
	YINPUT_Square                                      = 0,
	YINPUT_Cubic                                       = 1,
	YINPUT_SCurve                                      = 2,
	YINPUT_SCurve_Targeting                            = 3,
	YINPUT_MAX                                         = 4
};*/

// Enum SRGame.YPlayerStart.YE_PlayerStartCharacterTypes
/*enum YE_PlayerStartCharacterTypes
{
	YPSCT_Walker                                       = 0,
	YPSCT_Adams                                        = 1,
	YPSCT_Lugo                                         = 2,
	YPSCT_Multiplayer                                  = 3,
	YPSCT_HordePlayerA                                 = 4,
	YPSCT_HordePlayerB                                 = 5,
	YPSCT_HordePlayerC                                 = 6,
	YPSCT_HordePlayerD                                 = 7,
	YPSCT_WalkerBattered                               = 8,
	YPSCT_WalkerWartorn                                = 9,
	YPSCT_WalkerEmpty                                  = 10,
	YPSCT_CoopPlayerA                                  = 11,
	YPSCT_CoopPlayerB                                  = 12,
	YPSCT_CoopPlayerA_Marauder                         = 13,
	YPSCT_CoopPlayerB_Marauder                         = 14,
	YPSCT_CoopPlayerA_Marine                           = 15,
	YPSCT_CoopPlayerB_Marine                           = 16,
	YPSCT_MAX                                          = 17
};*/

// Enum SRGame.YProj_Physical.YE_GrenadeCollisionBehaviour
/*enum YE_GrenadeCollisionBehaviour
{
	YGCB_NoBounce                                      = 0,
	YGCB_ReflectBounce                                 = 1,
	YGCB_StickyBomb                                    = 2,
	YGCB_PhysBounce                                    = 3,
	YGCB_UnrealBounce                                  = 4,
	YGCB_MAX                                           = 5
};*/

// Enum SRGame.YWeapon.YE_WeaponCrosshairState
/*enum YE_WeaponCrosshairState
{
	YXHAIRSTATE_NonRaisedInCover                       = 0,
	YXHAIRSTATE_NonRaisedNotInCover                    = 1,
	YXHAIRSTATE_Raised                                 = 2,
	YXHAIRSTATE_Aiming                                 = 3,
	YXHAIRSTATE_Blindfiring                            = 4,
	YXHAIRSTATE_MAX                                    = 5
};*/

// Enum SRGame.YWeapon.YE_FiringSoundState
/*enum YE_FiringSoundState
{
	YFSS_NoFiringSound                                 = 0,
	YFSS_FiringWarmupSound                             = 1,
	YFSS_FiringLoopSound                               = 2,
	YFSS_FiringCoolDownSound                           = 3,
	YFSS_MAX                                           = 4
};*/

// Enum SRGame.YWeapon.YE_RecoilStart
/*enum YE_RecoilStart
{
	YRS_Zero                                           = 0,
	YRS_Random                                         = 1,
	YRS_MAX                                            = 2
};*/

// Enum SRGame.YWeapon.YE_OfficerSupplyRefillType
/*enum YE_OfficerSupplyRefillType
{
	YOSREFILL_None                                     = 0,
	YOSREFILL_Standard                                 = 1,
	YOSREFILL_SAW                                      = 2,
	YOSREFILL_Explosive                                = 3,
	YOSREFILL_MAX                                      = 4
};*/

// Enum SRGame.YWeapon.YE_CrosshairStyle
/*enum YE_CrosshairStyle
{
	YXHAIRTYPE_None                                    = 0,
	YXHAIRTYPE_Standard                                = 1,
	YXHAIRTYPE_Bracket                                 = 2,
	YXHAIRTYPE_MAX                                     = 3
};*/

// Enum SRGame.YRopeActor.YE_FastRopeType
/*enum YE_FastRopeType
{
	YFRT_None                                          = 0,
	YFRT_Straight                                      = 1,
	YFRT_StraightNoTurn                                = 2,
	YFRT_Jump                                          = 3,
	YFRT_MAX                                           = 4
};*/

// Enum SRGame.YSpecialActionUseRestriction.YE_SAUseRestrictionScope
/*enum YE_SAUseRestrictionScope
{
	YURS_Object                                        = 0,
	YURS_Global                                        = 1,
	YURS_MAX                                           = 2
};*/

// Enum SRGame.YSC_SelectionModifierBase.YE_SelectionModifierPriorities
/*enum YE_SelectionModifierPriorities
{
	YESMP_ShouldHave                                   = 0,
	YESMP_MustHave                                     = 1,
	YESMP_MAX                                          = 2
};*/

// Enum SRGame.YSC_SelectionModifierBase.YE_SelectionModifierComplexity
/*enum YE_SelectionModifierComplexity
{
	YESMC_CheapImmediate                               = 0,
	YESMC_CheapDistributed                             = 1,
	YESMC_Complex                                      = 2,
	YESMC_MAX                                          = 3
};*/

// Enum SRGame.YSC_TargetModifierBase.YE_TargetModifierPriorities
/*enum YE_TargetModifierPriorities
{
	YETMP_ShouldHave                                   = 0,
	YETMP_MustHave                                     = 1,
	YETMP_MAX                                          = 2
};*/

// Enum SRGame.YSCTM_IsTargetShootingAtMe.YSCTM_IsTargetShootingAtMeMode
/*enum YSCTM_IsTargetShootingAtMeMode
{
	YSCTMITSAMM_ONLY_DAMAGE                            = 0,
	YSCTMITSAMM_ONLY_IMPACT_AROUND                     = 1,
	YSCTMITSAMM_ALL                                    = 2,
	YSCTMITSAMM_MAX                                    = 3
};*/

// Enum SRGame.YSeqAct_AssignEquipment.YE_SquadEquipment
/*enum YE_SquadEquipment
{
	YEQUIPMENT_Scanner                                 = 0,
	YEQUIPMENT_Mortar                                  = 1,
	YEQUIPMENT_MortarAssist                            = 2,
	YEQUIPMENT_None                                    = 3,
	YEQUIPMENT_MAX                                     = 4
};*/

// Enum SRGame.YSeqAct_ChangeStunEnemiesCommand.YE_ChangeStunEnemiesCommandMode
/*enum YE_ChangeStunEnemiesCommandMode
{
	YCSEC_GenericMode                                  = 0,
	YCSEC_ForcedOn                                     = 1,
	YCSEC_TurnedOff                                    = 2,
	YCSEC_MAX                                          = 3
};*/

// Enum SRGame.YSeqAct_Latent.YE_Latent_InputLinkIndex
/*enum YE_Latent_InputLinkIndex
{
	YLILI_Start                                        = 0,
	YLILI_Cancel                                       = 1,
	YLILI_MAX                                          = 2
};*/

// Enum SRGame.YSeqAct_Latent.YE_Latent_OutputLinkIndex
/*enum YE_Latent_OutputLinkIndex
{
	YLOLI_Started                                      = 0,
	YLOLI_StartFailed                                  = 1,
	YLOLI_Succeeded                                    = 2,
	YLOLI_Failed                                       = 3,
	YLOLI_MAX                                          = 4
};*/

// Enum SRGame.YSeqAct_Latent.YE_LatenActionState
/*enum YE_LatenActionState
{
	YLAS_None                                          = 0,
	YLAS_Started                                       = 1,
	YLAS_Finishing                                     = 2,
	YLAS_StartFailed                                   = 3,
	YLAS_Succeeded                                     = 4,
	YLAS_Failed                                        = 5,
	YLAS_MAX                                           = 6
};*/

// Enum SRGame.YSeqAct_DummyWeaponFire.YE_DummyFireObjectCyclingMethod
/*enum YE_DummyFireObjectCyclingMethod
{
	YDFCM_Sequential                                   = 0,
	YDFCM_Random                                       = 1,
	YDFCM_MAX                                          = 2
};*/

// Enum SRGame.YSeqAct_EnableGrenadeDirector.YGD_GrenadeDirectorMode
/*enum YGD_GrenadeDirectorMode
{
	YGD_OnlyValidGrenadeThrowers                       = 0,
	YGD_Forced                                         = 1,
	YGD_Disabled                                       = 2,
	YGD_MAX                                            = 3
};*/

// Enum SRGame.YSeqAct_EnterTurret.YE_EnterTurretState
/*enum YE_EnterTurretState
{
	YETS_Started                                       = 0,
	YETS_FirstFailed                                   = 1,
	YETS_SecondFailed                                  = 2,
	YETS_Successfull                                   = 3,
	YETS_Finished                                      = 4,
	YETS_MAX                                           = 5
};*/

// Enum SRGame.YSeqAct_IntelOp.YE_IntelOp_InputLinkIndex
/*enum YE_IntelOp_InputLinkIndex
{
	YIOILI_Start                                       = 0,
	YIOILI_Cancel                                      = 1,
	YIOILI_StopSucceeded                               = 2,
	YIOILI_StopFailed                                  = 3,
	YIOILI_MAX                                         = 4
};*/

// Enum SRGame.YSeqAct_IntelOp.YE_IntelOp_OutputLinkIndex
/*enum YE_IntelOp_OutputLinkIndex
{
	YIOOLI_Started                                     = 0,
	YIOOLI_StartFailed                                 = 1,
	YIOOLI_Succeeded                                   = 2,
	YIOOLI_Failed                                      = 3,
	YIOOLI_MAX                                         = 4
};*/

// Enum SRGame.YSeqAct_IntelOp.YE_IntelOpActionState
/*enum YE_IntelOpActionState
{
	YIOAS_None                                         = 0,
	YIOAS_Begin                                        = 1,
	YIOAS_Loop                                         = 2,
	YIOAS_End                                          = 3,
	YIOAS_StartFailed                                  = 4,
	YIOAS_Succeeded                                    = 5,
	YIOAS_Failed                                       = 6,
	YIOAS_MAX                                          = 7
};*/

// Enum SRGame.YSeqAct_SetFaceFXRegister.YE_FaceFXRegisterVarInput
/*enum YE_FaceFXRegisterVarInput
{
	YFRVI_Target                                       = 0,
	YFRVI_FirstValue                                   = 1,
	YFRVI_FirstInterpolDuration                        = 2,
	YFRVI_NextValue                                    = 3,
	YFRVI_NextInterpolDuration                         = 4,
	YFRVI_MAX                                          = 5
};*/

// Enum SRGame.YSeqAct_SetLookAtTarget.YE_LookAtActivation
/*enum YE_LookAtActivation
{
	YLAA_None                                          = 0,
	YLAA_Activate                                      = 1,
	YLAA_Deactivate                                    = 2,
	YLAA_Toggle                                        = 3,
	YLAA_MAX                                           = 4
};*/

// Enum SRGame.YSeqAct_SetSquadEvolution.YE_SquadEvolutionStates
/*enum YE_SquadEvolutionStates
{
	YSES_Clean                                         = 0,
	YSES_Battered                                      = 1,
	YSES_Wartorn                                       = 2,
	YSES_Evo00                                         = 3,
	YSES_Evo01                                         = 4,
	YSES_Evo02                                         = 5,
	YSES_Evo03                                         = 6,
	YSES_Evo04                                         = 7,
	YSES_Evo05                                         = 8,
	YSES_Evo06                                         = 9,
	YSES_Evo07                                         = 10,
	YSES_MAX                                           = 11
};*/

// Enum SRGame.YSeqAct_SpecialMove.YE_SpecialMoveGroup
/*enum YE_SpecialMoveGroup
{
	YSMG_None                                          = 0,
	YSMG_MoveOverCover                                 = 1,
	YSMG_DropDown                                      = 2,
	YSMG_SlipOut                                       = 3,
	YSMG_SlipOutSilent                                 = 4,
	YSMG_FastRope                                      = 5,
	YSMG_ZipLine                                       = 6,
	YSMG_EnterTurret                                   = 7,
	YSMG_LeaveTurret                                   = 8,
	YSMG_SwatTurn                                      = 9,
	YSMG_EnterCover                                    = 10,
	YSMG_SnapToCover                                   = 11,
	YSMG_SandBomb                                      = 12,
	YSMG_MAX                                           = 13
};*/

// Enum SRGame.YSeqEvent_ContextCommand.YE_ContextCommandState
/*enum YE_ContextCommandState
{
	YCTXSTATE_Issued                                   = 0,
	YCTXSTATE_Started                                  = 1,
	YCTXSTATE_Finished                                 = 2,
	YCTXSTATE_Aborted                                  = 3,
	YCTXSTATE_MAX                                      = 4
};*/

// Enum SRGame.YSeqEvt_BD_VitalStateChanged.YE_VitalEventOutputLink
/*enum YE_VitalEventOutputLink
{
	YVE_Heal                                           = 0,
	YVE_Destroy                                        = 1,
	YVE_FullDestroy                                    = 2,
	YVE_MAX                                            = 3
};*/

// Enum SRGame.YSeqEvt_HD_CapturePointStateChange.YE_CapturePointEventOutputLink
/*enum YE_CapturePointEventOutputLink
{
	YCPE_Neutral                                       = 0,
	YCPE_Specops                                       = 1,
	YCPE_Konrads                                       = 2,
	YCPE_Disabled                                      = 3,
	YCPE_MAX                                           = 4
};*/

// Enum SRGame.YSeqEvt_HD_StationStateChanged.YE_StationEventOutputLink
/*enum YE_StationEventOutputLink
{
	YSE_Destroying                                     = 0,
	YSE_Repairing                                      = 1,
	YSE_Destroyed                                      = 2,
	YSE_Repaired                                       = 3,
	YSE_AbortDestroy                                   = 4,
	YSE_AbortRepair                                    = 5,
	YSE_MAX                                            = 6
};*/

// Enum SRGame.YSeqEvt_OL_ComStationChanged.YE_ComStationEventOutputLink
/*enum YE_ComStationEventOutputLink
{
	YCE_Deactivated                                    = 0,
	YCE_FriendlyActivated                              = 1,
	YCE_EnemyActivated                                 = 2,
	YCE_SpecopsSpawns                                  = 3,
	YCE_KonradSpawns                                   = 4,
	YCE_BeginActivation                                = 5,
	YCE_BeginDeactivation                              = 6,
	YCE_CancelActivation                               = 7,
	YCE_MAX                                            = 8
};*/

// Enum SRGame.YSeqEvt_TM_RADStationActivated.YE_StationEventOutputLink
/*enum YE_StationEventOutputLink
{
	YSE_SpecOpsActivated                               = 0,
	YSE_KonradActivated                                = 1,
	YSE_Deactivated                                    = 2,
	YSE_MAX                                            = 3
};*/

// Enum SRGame.YSeqVar_AliveCount.YE_AliveCountPresets
/*enum YE_AliveCountPresets
{
	YACP_None                                          = 0,
	YACP_PlayerEnemies                                 = 1,
	YACP_PlayerFriends                                 = 2,
	YACP_PlayerFriendsOrNeutral                        = 3,
	YACP_MAX                                           = 4
};*/

// Enum SRGame.YSeqVar_CombatPos.YE_CombatPosSlotType
/*enum YE_CombatPosSlotType
{
	YCPST_CombatPos                                    = 0,
	YCPST_CoverSlot                                    = 1,
	YCPST_MAX                                          = 2
};*/

// Enum SRGame.YSeqVar_PlayerClass.YEPlayerClass
/*enum YEPlayerClass
{
	YEPC_Walker                                        = 0,
	YEPC_Adams                                         = 1,
	YEPC_Lugo                                          = 2,
	YEPC_MAX                                           = 3
};*/

// Enum SRGame.YShyfflr.YE_ShyfflrState
/*enum YE_ShyfflrState
{
	YEShyfflrState_NeedsInit                           = 0,
	YEShyfflrState_Idle                                = 1,
	YEShyfflrState_Loading                             = 2,
	YEShyfflrState_FinishedLoading                     = 3,
	YEShyfflrState_MAX                                 = 4
};*/

// Enum SRGame.YSimpleList.YE_SimpleListStyleStates
/*enum YE_SimpleListStyleStates
{
	YSTYLE_Disabled                                    = 0,
	YSTYLE_Enabled                                     = 1,
	YSTYLE_Focused                                     = 2,
	YSTYLE_Active                                      = 3,
	YSTYLE_Pressed                                     = 4,
	YSTYLE_MAX                                         = 5
};*/

// Enum SRGame.YSpecialActionsDefinition.YE_SAAnimBlockLevel
/*enum YE_SAAnimBlockLevel
{
	YABL_None                                          = 0,
	YABL_Head                                          = 1,
	YABL_UpperBody                                     = 2,
	YABL_FullBody                                      = 3,
	YABL_MAX                                           = 4
};*/

// Enum SRGame.YSpecialActionsDefinition.YE_SAAIBlockLevel
/*enum YE_SAAIBlockLevel
{
	YAIBL_NoBlock                                      = 0,
	YAIBL_EscapeDangerAllowed                          = 1,
	YAIBL_NoChangeAllowed                              = 2,
	YAIBL_FullBlock                                    = 3,
	YAIBL_MAX                                          = 4
};*/

// Enum SRGame.YSpecialMove.YE_SpecialMoveState
/*enum YE_SpecialMoveState
{
	YSMST_PreStart                                     = 0,
	YSMST_Stopped                                      = 1,
	YSMST_Started                                      = 2,
	YSMST_Cancelled                                    = 3,
	YSMST_MAX                                          = 4
};*/

// Enum SRGame.YSpecialMove.YE_SpecialMoveStance
/*enum YE_SpecialMoveStance
{
	YSMSC_Stand                                        = 0,
	YSMSC_Crouch                                       = 1,
	YSMSC_MAX                                          = 2
};*/

// Enum SRGame.YSpecialMove_CoverVault.YE_VaultCoverType
/*enum YE_VaultCoverType
{
	YCOVT_Regular                                      = 0,
	YCOVT_Drop                                         = 1,
	YCOVT_Thin                                         = 2,
	YCOVT_VaultKick                                    = 3,
	YCOVT_TurnAround                                   = 4,
	YCOVT_MAX                                          = 5
};*/

// Enum SRGame.YSpecialMove_IntoCover.YE_CoverEdgeType
/*enum YE_CoverEdgeType
{
	YCET_None                                          = 0,
	YCET_Left                                          = 1,
	YCET_Right                                         = 2,
	YCET_MAX                                           = 3
};*/

// Enum SRGame.YSpecialMove_FastRopeRappel.YE_FastRopeState
/*enum YE_FastRopeState
{
	YFRS_None                                          = 0,
	YFRS_Begin                                         = 1,
	YFRS_Rappel                                        = 2,
	YFRS_End                                           = 3,
	YFRS_MAX                                           = 4
};*/

// Enum SRGame.YSpecialMove_IntelOp.YE_IntelOpState
/*enum YE_IntelOpState
{
	YIOS_None                                          = 0,
	YIOS_Begin                                         = 1,
	YIOS_Loop                                          = 2,
	YIOS_End                                           = 3,
	YIOS_MAX                                           = 4
};*/

// Enum SRGame.YSpecialMove_LeavePeeking.YE_LeavePeekingAnimID
/*enum YE_LeavePeekingAnimID
{
	YLPAID_LeavePeekingStandLeft                       = 0,
	YLPAID_LeavePeekingStandRight                      = 1,
	YLPAID_LeavePeekingCrouchLeft                      = 2,
	YLPAID_LeavePeekingCrouchRight                     = 3,
	YLPAID_MAX                                         = 4
};*/

// Enum SRGame.YSpecialMove_PickUpWeapon.YE_PickupWeaponAnimID
/*enum YE_PickupWeaponAnimID
{
	YPUW_Stand                                         = 0,
	YPUW_Crouch                                        = 1,
	YPUW_MAX                                           = 2
};*/

// Enum SRGame.YSpecialMove_PickUpLimitedUse.YE_PickupWeaponAnimID
/*enum YE_PickupWeaponAnimID
{
	YPUW_Stand                                         = 0,
	YPUW_Crouch                                        = 1,
	YPUW_MAX                                           = 2
};*/

// Enum SRGame.YSpecialMove_RecoverFromRagdoll.YE_GetupAnimType
/*enum YE_GetupAnimType
{
	YGAT_FrontToCrouch                                 = 0,
	YGAT_BackToCrouch                                  = 1,
	YGAT_FrontToStand                                  = 2,
	YGAT_BackToStand                                   = 3,
	YGAT_FrontToDBNO                                   = 4,
	YGAT_BackToDBNO                                    = 5,
	YGAT_MAX                                           = 6
};*/

// Enum SRGame.YSpecialMove_Revive.YE_ReviveState
/*enum YE_ReviveState
{
	YRVS_None                                          = 0,
	YRVS_Begin                                         = 1,
	YRVS_Mid                                           = 2,
	YRVS_End                                           = 3,
	YRVS_MAX                                           = 4
};*/

// Enum SRGame.YSpecialMove_Revive_MP.YE_ReviveMPState
/*enum YE_ReviveMPState
{
	YRVMPS_None                                        = 0,
	YRVMPS_Begin                                       = 1,
	YRVMPS_Mid                                         = 2,
	YRVMPS_End                                         = 3,
	YRVMPS_MAX                                         = 4
};*/

// Enum SRGame.YSpecialMove_ReviveFromDeath.YE_ReviveDeathState
/*enum YE_ReviveDeathState
{
	YRDS_None                                          = 0,
	YRDS_Begin                                         = 1,
	YRDS_Mid                                           = 2,
	YRDS_End                                           = 3,
	YRDS_MAX                                           = 4
};*/

// Enum SRGame.YSpecialMove_SlipOut.YE_SlipOutAnim
/*enum YE_SlipOutAnim
{
	YSOA_SlipOutLeft                                   = 0,
	YSOA_SlipOutRight                                  = 1,
	YSOA_MAX                                           = 2
};*/

// Enum SRGame.YSpecialMove_StumbleSandPool.YE_StumbleSandPoolVariations
/*enum YE_StumbleSandPoolVariations
{
	SSPV_VariantA                                      = 0,
	SSPV_VariantB                                      = 1,
	SSPV_VariantC                                      = 2,
	SSPV_VariantD                                      = 3,
	SSPV_MAX                                           = 4
};*/

// Enum SRGame.YSpecialMove_SwatTurn.YE_SwatTurnCoverTransition
/*enum YE_SwatTurnCoverTransition
{
	YSTCT_StandToStand                                 = 0,
	YSTCT_StandToCrouch                                = 1,
	YSTCT_CrouchToCrouch                               = 2,
	YSTCT_MAX                                          = 3
};*/

// Enum SRGame.YSpecialMove_TakeHit.YE_TakeHitAnimPhase
/*enum YE_TakeHitAnimPhase
{
	THAP_DontUseSeparateAnims                          = 0,
	THAP_PreStart                                      = 1,
	THAP_Into                                          = 2,
	THAP_Idle                                          = 3,
	THAP_Out                                           = 4,
	THAP_MAX                                           = 5
};*/

// Enum SRGame.YSpecialMove_TurretEnter.YE_TurretEnterState
/*enum YE_TurretEnterState
{
	YTES_None                                          = 0,
	YTES_Holster                                       = 1,
	YTES_Into                                          = 2,
	YTES_MAX                                           = 3
};*/

// Enum SRGame.YSpecialMove_ZiplineTraverse.YE_ZiplineState
/*enum YE_ZiplineState
{
	YZLS_None                                          = 0,
	YZLS_Begin                                         = 1,
	YZLS_Traverse                                      = 2,
	YZLS_End                                           = 3,
	YZLS_MAX                                           = 4
};*/

// Enum SRGame.YStartupMessage.YE_StartUpStage
/*enum YE_StartUpStage
{
	YSUS_None                                          = 0,
	YSUS_WaitingForOtherPlayers                        = 1,
	YSUS_WaitingForOtherPlayersToBeReady               = 2,
	YSUS_MatchAboutToBegin                             = 3,
	YSUS_MatchHasBegun                                 = 4,
	YSUS_RoundHasBegun                                 = 5,
	YSUS_OverTime                                      = 6,
	YSUS_MAX                                           = 7
};*/

// Enum SRGame.YStatsObject.YE_PlayerState
/*enum YE_PlayerState
{
	YPS_Undefined                                      = 0,
	YPS_Cover                                          = 1,
	YPS_CrouchedCover                                  = 2,
	YPS_Sprinting                                      = 3,
	YPS_Crouching                                      = 4,
	YPS_MAX                                            = 5
};*/

// Enum SRGame.YStatsObject.YE_StatEvent
/*enum YE_StatEvent
{
	YSE_PlayerScore                                    = 0,
	YSE_UnlockBoss                                     = 1,
	YSE_UnlockElite                                    = 2,
	YSE_XP                                             = 3,
	YSE_CurrentTotalXP                                 = 4,
	YSE_PlayerLogin                                    = 5,
	YSE_Victory                                        = 6,
	YSE_Defeat                                         = 7,
	YSE_ControlScheme                                  = 8,
	YSE_MAX                                            = 9
};*/

// Enum SRGame.YTimerMessage.YE_TimerMessages
/*enum YE_TimerMessages
{
	YTM_None                                           = 0,
	YTM_LastSecondsCountDown                           = 1,
	YTM_ThirtySecondsWarning                           = 2,
	YTM_LastMinuteWarning                              = 3,
	YTM_MAX                                            = 4
};*/

// Enum SRGame.YTrigger_EffectsInteraction.YE_EffectTriggerAction
/*enum YE_EffectTriggerAction
{
	YETA_EnableEffects                                 = 0,
	YETA_DisableEffects                                = 1,
	YETA_MAX                                           = 2
};*/

// Enum SRGame.YTurretActor.YE_TurretCamSubMode
/*enum YE_TurretCamSubMode
{
	YTCSM_Stand                                        = 0,
	YTCSM_StandAiming                                  = 1,
	YTCSM_Crouched                                     = 2,
	YTCSM_CrouchedAiming                               = 3,
	YTCSM_MAX                                          = 4
};*/

// Enum SRGame.YTurretActor.YE_TurretCamModes
/*enum YE_TurretCamModes
{
	YTCM_StandAlone                                    = 0,
	YTCM_ThinCover                                     = 1,
	YTCM_ThickCover                                    = 2,
	YTCM_MAX                                           = 3
};*/

// Enum SRGame.YTurretActor.YE_MountTypes
/*enum YE_MountTypes
{
	YMTT_Standalone                                    = 0,
	YMTT_Cover                                         = 1,
	YMTT_MAX                                           = 2
};*/

// Enum SRGame.YTurretActor.YE_TurretTypes
/*enum YE_TurretTypes
{
	YTUT_HMG                                           = 0,
	YTUT_MiniGun                                       = 1,
	YTUT_MiniGunFlight                                 = 2,
	YTUT_GrenadeLauncher                               = 3,
	YTUT_HeliGun                                       = 4,
	YTUT_HumveeGun                                     = 5,
	YTUT_HumveeGunDFA                                  = 6,
	YTUT_Mortar                                        = 7,
	YTUT_MAX                                           = 8
};*/

// Enum SRGame.YUIDataProvider_Equipment.EYUISection
/*enum EYUISection
{
	YUIS_All                                           = 0,
	YUIS_SpecOps                                       = 1,
	YUIS_Enemies                                       = 2,
	YUIS_None                                          = 3,
	YUIS_MAX                                           = 4
};*/

// Enum SRGame.YUIDataProvider_Weapons.YE_MPWeaponCategories
/*enum YE_MPWeaponCategories
{
	YWMPCT_Handgun                                     = 0,
	YWMPCT_SMG                                         = 1,
	YWMPCT_Assault                                     = 2,
	YWMPCT_Shotgun                                     = 3,
	YWMPCT_Sniper                                      = 4,
	YWMPCT_Heavy                                       = 5,
	YWMPCT_Explosive                                   = 6,
	YWMPCT_LMG                                         = 7,
	YWMPCT_Launcher                                    = 8,
	YWMPCT_MAX                                         = 9
};*/

// Enum SRGame.YUIDataStore_Missions.YE_ModeMissions
/*enum YE_ModeMissions
{
	YMM_SinglePlayer                                   = 0,
	YMM_Crossplayer                                    = 1,
	YMM_MAX                                            = 2
};*/

// Enum SRGame.YUIDataProvider_PlaylistInfo.YE_PlaylistType
/*enum YE_PlaylistType
{
	YEPT_Core                                          = 0,
	YEPT_HardCore                                      = 1,
	YEPT_Special                                       = 2,
	YEPT_MAX                                           = 3
};*/

// Enum SRGame.YUIEventTracker.YE_ColorName
/*enum YE_ColorName
{
	YCOLOR_Text                                        = 0,
	YCOLOR_Bar                                         = 1,
	YCOLOR_Icon                                        = 2,
	YCOLOR_Squad                                       = 3,
	YCOLOR_Enemy                                       = 4,
	YCOLOR_Neutral                                     = 5,
	YCOLOR_MAX                                         = 6
};*/

// Enum SRGame.YUIFrontEnd_SelectSaveSlotScreen.YE_SlotSelectionVisualState
/*enum YE_SlotSelectionVisualState
{
	YESLOTSTATE_Normal                                 = 0,
	YESLOTSTATE_Selected                               = 1,
	YESLOTSTATE_MAX                                    = 2
};*/

// Enum SRGame.YUIFrontEnd_SelectSaveSlotScreen.YE_SceneMode
/*enum YE_SceneMode
{
	YESCENEMODE_Load                                   = 0,
	YESCENEMODE_Save                                   = 1,
	YESCENEMODE_New                                    = 2,
	YESCENEMODE_MAX                                    = 3
};*/

// Enum SRGame.YUIFrontEnd_ClassSelection.YE_PreviewRotationState
/*enum YE_PreviewRotationState
{
	YEPRS_None                                         = 0,
	YEPRS_Left                                         = 1,
	YEPRS_Right                                        = 2,
	YEPRS_MAX                                          = 3
};*/

// Enum SRGame.YUIFrontEnd_CustomMatch.YE_MatchSettingsMenuStates
/*enum YE_MatchSettingsMenuStates
{
	YMatchSettings_None                                = 0,
	YMatchSettings_CreateOnline                        = 1,
	YMatchSettings_CreateSystemLink                    = 2,
	YMatchSettings_ChangeSettings                      = 3,
	YMatchSettings_CreateOnlineFriend                  = 4,
	YMatchSettings_MAX                                 = 5
};*/

// Enum SRGame.YUIFrontEnd_ServerBrowser.EQueryCompletionAction
/*enum EQueryCompletionAction
{
	QUERYACTION_None                                   = 0,
	QUERYACTION_Default                                = 1,
	QUERYACTION_CloseScene                             = 2,
	QUERYACTION_JoinServer                             = 3,
	QUERYACTION_RefreshAll                             = 4,
	QUERYACTION_MAX                                    = 5
};*/

// Enum SRGame.YUIFrontEnd_OnlineMPMenu.YE_OnlineMenuState
/*enum YE_OnlineMenuState
{
	YOnlineMenuState_Standard                          = 0,
	YOnlineMenuState_Friend                            = 1,
	YOnlineMenuState_MAX                               = 2
};*/

// Enum SRGame.YUIInfo_ModificatorPlacement.YE_SelectedEntry
/*enum YE_SelectedEntry
{
	YSMA_None                                          = 0,
	YSMA_Left                                          = 1,
	YSMA_Right                                         = 2,
	YSMA_Top                                           = 3,
	YSMA_Down                                          = 4,
	YSMA_MAX                                           = 5
};*/

// Enum SRGame.YUIScene_HUD_Life_MP.YE_ScavengerImages
/*enum YE_ScavengerImages
{
	YSI_ArmorGauge                                     = 0,
	YSI_AmmoPlus                                       = 1,
	YSI_GrenadePlus                                    = 2,
	YSI_MinesPlus                                      = 3,
	YSI_StunPlus                                       = 4,
	YSI_MAX                                            = 5
};*/

// Enum SRGame.YUIScene_HUD_Life_SP.YE_SquadStatusImageInfo
/*enum YE_SquadStatusImageInfo
{
	YSQUADIMAGE_None                                   = 0,
	YSQUADIMAGE_AdamsDown                              = 1,
	YSQUADIMAGE_LugoDown                               = 2,
	YSQUADIMAGE_BothDown                               = 3,
	YSQUADIMAGE_MAX                                    = 4
};*/

// Enum SRGame.YUIScoreboardPanel.YE_ColumnDataDisplayType
/*enum YE_ColumnDataDisplayType
{
	YCDDT_OneLabelCells                                = 0,
	YCDDT_RankIconCells                                = 1,
	YCDDT_OneLabelColumn                               = 2,
	YCDDT_ConnectionIconCells                          = 3,
	YCDDT_SpacerColumn                                 = 4,
	YCDDT_MAX                                          = 5
};*/

// Enum SRGame.YUIScoreboardPanel.YE_CellTextState
/*enum YE_CellTextState
{
	YCTS_Normal                                        = 0,
	YCTS_Glow                                          = 1,
	YCTS_MAX                                           = 2
};*/

// Enum SRGame.YUIScoreboardPanel_KillsLeaderboard.YE_ColumnDisplayType
/*enum YE_ColumnDisplayType
{
	YCDT_OneLabelCells                                 = 0,
	YCDT_RankIconCells                                 = 1,
	YCDT_SpacerColumn                                  = 2,
	YCDT_MAX                                           = 3
};*/

// Enum SRGame.YUnrealScriptStudioParserBuster.ESubID1
/*enum ESubID1
{
	SUBID1                                             = 0,
	SUBID101                                           = 1,
	SUBID102                                           = 2,
	SUBID103                                           = 3,
	SUBID104                                           = 4,
	SUBID1_MAX                                         = 5
};*/

// Enum SRGame.YUnrealScriptStudioParserBuster.EGroupID
/*enum EGroupID
{
	Group                                              = 0,
	Group01                                            = 1,
	Group_MAX                                          = 2
};*/

// Enum SRGame.YUnrealScriptStudioParserBuster.ESubID2
/*enum ESubID2
{
	SUBID2                                             = 0,
	SUBID201                                           = 1,
	SUBID202                                           = 2,
	SUBID203                                           = 3,
	SUBID204                                           = 4,
	SUBID2_MAX                                         = 5
};*/

// Enum SRGame.YWeapon_Shotgun.YE_ShotgunImpactPriority
/*enum YE_ShotgunImpactPriority
{
	YSIP_World                                         = 0,
	YSIP_Destructible                                  = 1,
	YSIP_Explosive                                     = 2,
	YSIP_CheapShooter                                  = 3,
	YSIP_Pawn                                          = 4,
	YSIP_MAX                                           = 5
};*/


/*
# ========================================================================================= #
# Classes
# ========================================================================================= #
*/

// Class SRGame.GameNote
// 0x001C (0x0214 - 0x01F8)
class AGameNote : public AActor
{
public:
	class UGameNoteRenderComponent*                    m_text;                                           		// 0x01F8 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )
	struct FNoteProperties                             m_replicationProps;                               		// 0x01FC (0x0018) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1421 ];

		return pClassPointer;
	};

	void OnToggle ( class USeqAct_Toggle* Action );
	void PostBeginPlay ( );
	void ReplicatedEvent ( struct FName VarName );
	void ForceUpdateData ( );
};

UClass* AGameNote::pClassPointer = NULL;

// Class SRGame.GameNoteRenderComponent
// 0x0018 (0x0218 - 0x0200)
class UGameNoteRenderComponent : public UPrimitiveComponent
{
public:
	struct FNoteProperties                             m_props;                                          		// 0x0200 (0x0018) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1422 ];

		return pClassPointer;
	};

};

UClass* UGameNoteRenderComponent::pClassPointer = NULL;

// Class SRGame.YAAAResolve
// 0x0000 (0x0061 - 0x0061)
class UYAAAResolve : public UPostProcessEffect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1423 ];

		return pClassPointer;
	};

};

UClass* UYAAAResolve::pClassPointer = NULL;

// Class SRGame.YActorFactory_CombatPosSet
// 0x0000 (0x005C - 0x005C)
class UYActorFactory_CombatPosSet : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1424 ];

		return pClassPointer;
	};

};

UClass* UYActorFactory_CombatPosSet::pClassPointer = NULL;

// Class SRGame.YActorFactory_YAISpawnPoint
// 0x0000 (0x005C - 0x005C)
class UYActorFactory_YAISpawnPoint : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1425 ];

		return pClassPointer;
	};

};

UClass* UYActorFactory_YAISpawnPoint::pClassPointer = NULL;

// Class SRGame.YActorFactory_YPlayerStart
// 0x0000 (0x005C - 0x005C)
class UYActorFactory_YPlayerStart : public UActorFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1426 ];

		return pClassPointer;
	};

};

UClass* UYActorFactory_YPlayerStart::pClassPointer = NULL;

// Class SRGame.YAIBlockingVolume
// 0x0000 (0x0238 - 0x0238)
class AYAIBlockingVolume : public ABlockingVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1427 ];

		return pClassPointer;
	};

};

UClass* AYAIBlockingVolume::pClassPointer = NULL;

// Class SRGame.YAIFakeTarget
// 0x0018 (0x0210 - 0x01F8)
class AYAIFakeTarget : public AActor
{
public:
	struct FPointer                                    m_kynapseConnector;                               		// 0x01F8 (0x0004) [0x0000000000001000]              ( CPF_Native )
	float                                              m_width;                                          		// 0x01FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_height;                                         		// 0x0200 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_usageCount;                                     		// 0x0204 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_entityConnectorType;                            		// 0x0208 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYCheapShooter*                              m_cheapShooter;                                   		// 0x020C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1428 ];

		return pClassPointer;
	};

	void ConnectEntity ( );
	void PostBeginPlay ( );
};

UClass* AYAIFakeTarget::pClassPointer = NULL;

// Class SRGame.YAssetReference
// 0x001C (0x0058 - 0x003C)
class UYAssetReference : public UObject
{
public:
	class UClass*                                      m_assetClass;                                     		// 0x003C (0x0004) [0x0000000000000000]              
	struct FName                                       m_referencePath;                                  		// 0x0040 (0x0008) [0x0000000000000000]              
	class UObject*                                     m_referenceObject;                                		// 0x0048 (0x0004) [0x0000000000000000]              
	TArray< class UObject* >                           m_forcedReferences;                               		// 0x004C (0x000C) [0x0000000000422003]              ( CPF_Edit | CPF_Const | CPF_Transient | CPF_EditConst | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1429 ];

		return pClassPointer;
	};

	class UObject* GetReference ( );
	void SetReference ( class UClass* assetClass, struct FName referencePath );
};

UClass* UYAssetReference::pClassPointer = NULL;

// Class SRGame.YBadge
// 0x0014 (0x0050 - 0x003C)
class UYBadge : public UObject
{
public:
	struct FString                                     m_badgeName;                                      		// 0x003C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	unsigned char                                      m_ChallengeEnum;                                  		// 0x0048 (0x0001) [0x0000000000000000]              
	int                                                m_UnlockLevel;                                    		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1430 ];

		return pClassPointer;
	};

	struct FName StaticGetProviderTag ( );
	struct FString StaticGetBadgeFriendlyName ( int Index );
};

UClass* UYBadge::pClassPointer = NULL;

// Class SRGame.YBlockingVolume
// 0x0004 (0x023C - 0x0238)
class AYBlockingVolume : public ABlockingVolume
{
public:
	unsigned long                                      m_blockCamera : 1;                                		// 0x0238 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1431 ];

		return pClassPointer;
	};

};

UClass* AYBlockingVolume::pClassPointer = NULL;

// Class SRGame.YBoneData
// 0x0004 (0x0040 - 0x003C)
class UYBoneData : public UObject
{
public:
	unsigned long                                      m_vaporizeEnemies : 1;                            		// 0x003C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_civilianDamage : 1;                             		// 0x003C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_explodingHeads : 1;                             		// 0x003C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_toughExecutions : 1;                            		// 0x003C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1432 ];

		return pClassPointer;
	};

};

UClass* UYBoneData::pClassPointer = NULL;

// Class SRGame.YCameraActor
// 0x0010 (0x0378 - 0x0368)
class AYCameraActor : public ACameraActor
{
public:
	struct FString                                     CameraName;                                       		// 0x0368 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                OrderIndex;                                       		// 0x0374 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1433 ];

		return pClassPointer;
	};

	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
};

UClass* AYCameraActor::pClassPointer = NULL;

// Class SRGame.YLookatCameraActor
// 0x0044 (0x03BC - 0x0378)
class AYLookatCameraActor : public AYCameraActor
{
public:
	class AActor*                                      m_target;                                         		// 0x0378 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AActor*                                      m_lookAtTarget;                                   		// 0x037C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_targetOffset;                                   		// 0x0380 (0x000C) [0x0000000000000000]              
	struct FTPOV                                       m_lastPOV;                                        		// 0x038C (0x001C) [0x0000000000000000]              
	float                                              m_distanceToTarget;                               		// 0x03A8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minAngle;                                       		// 0x03AC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAngle;                                       		// 0x03B0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minAngleInterpSpeed;                            		// 0x03B4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lookAtAngleInterp;                              		// 0x03B8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1434 ];

		return pClassPointer;
	};

	void RotateAroundTarget ( struct FRotator DeltaRot, float dt );
	struct FVector GetTargetLocationWithOffset ( );
	void GetCameraView ( float DeltaTime, struct FTPOV* OutPOV );
	void SetLookatTarget ( class AActor* Target );
	void SetTarget ( class AActor* Target, struct FVector TargetOffset );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
};

UClass* AYLookatCameraActor::pClassPointer = NULL;

// Class SRGame.YCheatManager
// 0x0000 (0x005C - 0x005C)
class UYCheatManager : public UCheatManager
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1435 ];

		return pClassPointer;
	};

	void TriggerLiveTuning ( );
	void OnReadGameNewsCompleted ( unsigned long bWasSuccessful, unsigned char NewsType );
	void TriggerNewsRead ( );
	void ResetPerkStats ( );
	void GetStatProgress ( int statistic );
	void SetRemainingTime ( int secondsLeft );
	void ProfileResetCharacter ( );
	void DisplayPlayersCount ( );
	void OnReadPlayersCountCompleted ( unsigned long bSuccesful, int Count );
	void SendKeepAlive ( );
	void UnmarkHardwareStatsAsUploaded ( );
	void UpdateAchievement ( unsigned char achievement, int Value );
	void ToggleAiStuckResponse ( );
	void ClearProfileStats ( );
	void ResetProfileStat ( struct FString YPSIName );
	void IncrementProfileStat_Menu ( struct FString YPSIName, int Value, unsigned char TeamID );
	void IncrementProfileStat ( struct FString YPSIName, int Value );
	void SetExodusProgressLevel ( int Level );
	void SetCommunityChallengeState ( int ChallengeID, unsigned long bAchieved );
	void ClearUnlockedItem ( );
	void SetProfilePrestigeLevelForPlayer ( int PlayerID, int Value );
	void SetProfileRankForPlayer ( int PlayerID, int Value );
	void SetProfileXPForPlayer ( int PlayerID, int Value );
	void DumpSceneStack ( );
	class APlayerReplicationInfo* GetPlayerByScoreboardPos ( int PlayerID );
	void SetProfilePrestigeLevelForAll ( int Value );
	void SetProfileRankForAll ( int Value );
	void SetProfileXPForAll ( int Value );
	void SetProfilePrestigeLevel ( int Value );
	void SetStatProgress ( int statistic, int Value );
	void PerkLevel2Toggle ( );
	void SetProfileRank ( int Value );
	void SetProfileXP ( int Value );
	void GVXP ( int Amount );
	void DrawMatch ( );
	void LoseMatch ( );
	void WinMatch ( struct FString Param );
	void EvilTakeover ( );
	void KillFriends ( );
	void KillEnemies ( );
	void MPRegenerateCharacterList ( struct FString Provider, int magicNumber );
	void MPLogCharacterList ( int Team, unsigned long bLogAI );
	void Crash ( );
	void UnlockAllIntelCollectibles ( );
	void DumpMissionProgress ( );
	void ResetMissionProgress ( );
	void UnlockMissionPersistent ( unsigned char mission, unsigned char diff );
	void TestMissionCompleted ( unsigned char Difficulty );
	void ClearAllCollectiblesPersistent ( );
	void SetLastPlayedMissionPersistent ( int Idx );
	void UnlockAllMissionsPersistent ( );
	void Gods ( );
	void pGod ( );
	void God ( );
	void DebugLogToScreen ( struct FString Message );
	void DemiGods ( );
	void demiGod ( );
	void testMB ( );
	unsigned char Grenade ( struct FString grenadeTypeStr );
	class AWeapon* GiveWeapon ( struct FString WeaponClassStr );
	void FakeAmmo ( );
	void AllWeapons ( );
	void InfiniteGrenades ( );
	void AllAmmo ( );
	void DebugSloMo ( float TimeScale );
	void ToggleEventTracker ( );
	void ClearAchievementsOnStart ( );
};

UClass* UYCheatManager::pClassPointer = NULL;

// Class SRGame.YConfigFileCreationDummy
// 0x0000 (0x003C - 0x003C)
class UYConfigFileCreationDummy : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1436 ];

		return pClassPointer;
	};

};

UClass* UYConfigFileCreationDummy::pClassPointer = NULL;

// Class SRGame.YCustomAnimationBase
// 0x0031 (0x006D - 0x003C)
class UYCustomAnimationBase : public UObject
{
public:
	struct FName                                       m_animName;                                       		// 0x003C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_animNameAdditive;                               		// 0x0044 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UAnimSet*                                    m_animSet;                                        		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_alignPosition;                                  		// 0x0050 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_alignDirection;                                 		// 0x005C (0x000C) [0x0000000000000000]              
	unsigned long                                      m_disableLookAt : 1;                              		// 0x0068 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      m_aimingPose;                                     		// 0x006C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1437 ];

		return pClassPointer;
	};

	struct FName GetAnimName ( );
};

UClass* UYCustomAnimationBase::pClassPointer = NULL;

// Class SRGame.YDamageType
// 0x003C (0x00C4 - 0x0088)
class UYDamageType : public UDamageType
{
public:
	unsigned long                                      m_neverKills : 1;                                 		// 0x0088 (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_allowDeathAnimation : 1;                        		// 0x0088 (0x0004) [0x0000000000004001] [0x00000002] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_preventDBNO : 1;                                		// 0x0088 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_isExecution : 1;                                		// 0x0088 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_isExplosive : 1;                                		// 0x0088 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_isFire : 1;                                     		// 0x0088 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_ignorePawnInstantDeathAvoidance : 1;            		// 0x0088 (0x0004) [0x0000000000004001] [0x00000040] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_canDestroyRadiomanSpeakers : 1;                 		// 0x0088 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned char                                      m_weaponEnum;                                     		// 0x008C (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_impactType;                                     		// 0x008D (0x0001) [0x0000000000000000]              
	unsigned char                                      m_impactTypeKillShot;                             		// 0x008E (0x0001) [0x0000000000000000]              
	struct FString                                     m_damageIconCharacter;                            		// 0x0090 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	float                                              m_hitReactionProbabilityMod;                      		// 0x009C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_hitReactionBigProbabilityMod;                   		// 0x00A0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxPhysImpulse;                                 		// 0x00A4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_burnDuration;                                   		// 0x00A8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_burnDamageInterval;                             		// 0x00AC (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_burnDamageAmount;                               		// 0x00B0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sfxDuration;                                    		// 0x00B4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< struct FYS_DamageCamShakeParams >          m_damageCamShakes;                                		// 0x00B8 (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1438 ];

		return pClassPointer;
	};

};

UClass* UYDamageType::pClassPointer = NULL;

// Class SRGame.YDamageType_Scripted
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Scripted : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1439 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Scripted::pClassPointer = NULL;

// Class SRGame.YDamageType_Suicide
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Suicide : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1440 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Suicide::pClassPointer = NULL;

// Class SRGame.YDecalManager
// 0x0030 (0x0258 - 0x0228)
class AYDecalManager : public ADecalManager
{
public:
	struct FPointer                                    m_pDecalClusterManager;                           		// 0x0228 (0x0004) [0x0000000000001000]              ( CPF_Native )
	unsigned long                                      m_bStopDecalProcessing : 1;                       		// 0x022C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_clusterRadius[ 0x3 ];                           		// 0x0230 (0x000C) [0x0000000000004000]              ( CPF_Config )
	int                                                m_maxDecalPerCluster[ 0x2 ];                      		// 0x023C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_occlusionPSRadius;                              		// 0x0244 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_pawnGroundBloodCounter;                         		// 0x0248 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_DelayedImpactSound >            m_impactSounds;                                   		// 0x024C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1441 ];

		return pClassPointer;
	};

	void ForceTick ( float DeltaTime );
	void Reset ( );
	class UDecalComponent* SpawnDecalWithLifetime ( class UMaterialInterface* DecalMaterial, struct FVector DecalLocation, struct FRotator DecalOrientation, float Width, float Height, float Thickness, unsigned long bNoClip, float DecalRotation, class UPrimitiveComponent* HitComponent, unsigned long bProjectOnTerrain, unsigned long bProjectOnSkeletalMeshes, struct FName HitBone, int HitNodeIndex, int HitLevelIndex, float InDecalLifeSpan, float BackfaceAngle, struct FVector2D InBlendRange );
	class UDecalComponent* SpawnDecalWithLifetimeNative ( class UMaterialInterface* DecalMaterial, struct FVector DecalLocation, struct FRotator DecalOrientation, float Width, float Height, float Thickness, unsigned long bNoClip, float DecalRotation, class UPrimitiveComponent* HitComponent, unsigned long bProjectOnTerrain, unsigned long bProjectOnSkeletalMeshes, struct FName HitBone, int HitNodeIndex, int HitLevelIndex, float InDecalLifeSpan, float BackfaceAngle, struct FVector2D InBlendRange );
	bool CheckFlameClusters ( struct FVector pos, float TimeOut, float Radius );
	bool CheckFootstepClusters ( struct FVector pos, float TimeOut, float Radius );
	void SetClusterRadius ( int clusterLevel, float Radius );
	void SetMaxDecalPerCluster ( int clusterLevel, int Value );
	void RemoveDecalSP ( class UDecalComponent* Decal );
};

UClass* AYDecalManager::pClassPointer = NULL;

// Class SRGame.YDestructibleObject
// 0x01A8 (0x03A0 - 0x01F8)
class AYDestructibleObject : public AActor
{
public:
	class UAudioComponent*                             m_ambientSoundComponent;                          		// 0x01F8 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned long                                      m_playFromStart : 1;                              		// 0x01FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_componentsSetUp : 1;                            		// 0x01FC (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_destroyWhenWeaponSticksThroughInCover : 1;      		// 0x01FC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_destroyOnTouch : 1;                             		// 0x01FC (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_useExtendedBreakageConditions : 1;              		// 0x01FC (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_forceBreakageOnSlipOut : 1;                     		// 0x01FC (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_alwaysBreakForAI : 1;                           		// 0x01FC (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_alwaysBreakForProjectiles : 1;                  		// 0x01FC (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_disableCollisionOnDestroy : 1;                  		// 0x01FC (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      m_burnable : 1;                                   		// 0x01FC (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_damagingEnabled : 1;                            		// 0x01FC (0x0004) [0x0000000000000001] [0x00000400] ( CPF_Edit )
	unsigned long                                      m_destroyingHitsPassRightThrough : 1;             		// 0x01FC (0x0004) [0x0000000000000001] [0x00000800] ( CPF_Edit )
	unsigned long                                      m_bAmbientSoundShouldBePlaying : 1;               		// 0x01FC (0x0004) [0x0000000000000000] [0x00001000] 
	float                                              m_ambientSoundStartDelay;                         		// 0x0200 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FYS_DestructibleSubobject >         m_subObjects;                                     		// 0x0204 (0x000C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	TArray< class UStaticMeshComponent* >              m_tempSubMeshes;                                  		// 0x0210 (0x000C) [0x0000000004482008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	TArray< float >                                    m_subObjectHealths;                               		// 0x021C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< float >                                    m_subObjectTempHealths;                           		// 0x0228 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< float >                                    m_tempDamageCache;                                		// 0x0234 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_resetCount;                                     		// 0x0240 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FYS_ReplicatedDamageModInfo                 m_replicatedDamageMods[ 0x20 ];                   		// 0x0244 (0x0100) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_processedMods[ 0x20 ];                          		// 0x0344 (0x0020) [0x0000000000000000]              
	class ULightEnvironmentComponent*                  m_lightEnvironment;                               		// 0x0364 (0x0004) [0x000000000408000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_breakageVelocity;                               		// 0x0368 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_damageModToApplyOnTouch;                        		// 0x036C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDamagePerHit;                                		// 0x0374 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UClass* >                            m_vulnerableToDamageTypes;                        		// 0x0378 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FYS_AttractionActorParams >         m_attractionActor;                                		// 0x0384 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FVector                                     m_lastHitLocation;                                		// 0x0390 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_actorReactivationCheckDist;                     		// 0x039C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1442 ];

		return pClassPointer;
	};

	void OnToggle ( class USeqAct_Toggle* Action );
	void UnShutDownObject ( );
	void ShutDownSubObject ( struct FYS_DestructibleSubobject* subObj );
	void DisableSubObjectsRBCollision ( );
	void ShutDownObject ( );
	void InformBasedObjectsAboutDetruction ( class AController* EventInstigator );
	void CheckSleepingObjectReactivation ( );
	void ConditionalStopAmbientSound ( );
	void StartAmbientSound ( );
	void ConditionalStartAmbientSound ( );
	void OnDestroyedEvent ( );
	void TriggerDestroyedEvent ( class AController* EventInstigator );
	void TakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void PostBeginPlay ( );
	void DamageSubObject ( int objIdx, int Damage, class AController* EventInstigator, class UClass* damType, float Delay );
	void RemoveDecals ( );
	void ApplyDamageMod ( int objIdx, int modIdx, unsigned long bPartial, class AController* DamageInstigator );
	void SpawnAttractionActor ( );
	void SetSubObjectStaticMesh ( class UStaticMesh* StaticMesh, struct FYS_DestructibleSubobject* subObj );
	void SetupComponents ( );
	void UnDestroy ( );
	void OneTimeInit ( );
	void Reset ( );
	bool TriggerDamageModAppliedEvent ( class AActor* causer, struct FYS_DestructibleSubobject* subObj, struct FYS_ObjectDamageModifier* mod );
	void ReplicateDamageMod ( int objIdx, int modIdx, unsigned long bPartial );
	void ReplicatedEvent ( struct FName VarName );
	void DestroyedByWeaponStickingThrough ( class AController* InstigatorController );
	void Touch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* AYDestructibleObject::pClassPointer = NULL;

// Class SRGame.YDestructibleObjectDelayed
// 0x0010 (0x03B0 - 0x03A0)
class AYDestructibleObjectDelayed : public AYDestructibleObject
{
public:
	TArray< struct FYS_DamageToApply >                 m_damageToApply;                                  		// 0x03A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_delayedDmgFuncRunning : 1;                      		// 0x03AC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1443 ];

		return pClassPointer;
	};

	void TakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void AddDamageToDamageArray ( int subObjIdx, int modToApplyIdx, int Damage, unsigned long bPartial, class AController* EventInstigator, class UClass* DamageType, float Delay );
	void DamageSubObject ( int objIdx, int Damage, class AController* EventInstigator, class UClass* damType, float Delay );
	void DelayedDamageFunc ( );
	void TriggerDelayedDamageFunc ( );
};

UClass* AYDestructibleObjectDelayed::pClassPointer = NULL;

// Class SRGame.YDO_RadioManSpeaker
// 0x0040 (0x03E0 - 0x03A0)
class AYDO_RadioManSpeaker : public AYDestructibleObject
{
public:
	float                                              m_distanceScaleStepsize;                          		// 0x03A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_speakerHealth;                                  		// 0x03A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_speakerDestroyMeshOnDestruction : 1;            		// 0x03A8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_isDisabled : 1;                                 		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_isMuted : 1;                                    		// 0x03A8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	int                                                m_collectibleID;                                  		// 0x03AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UAudioComponent*                             m_speakerAmbientSoundComponent;                   		// 0x03B0 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UStaticMesh*                                 m_speakerMesh;                                    		// 0x03B4 (0x0004) [0x0000000000000000]              
	TArray< class USoundCue* >                         m_speakerDestructionSounds;                       		// 0x03B8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UStaticMesh*                                 m_speakerDestructionMesh;                         		// 0x03C4 (0x0004) [0x0000000000000000]              
	TArray< struct FYS_MaterialReplaceMod >            m_speakerDestructoinMaterials;                    		// 0x03C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_ParticleEffectParams >          m_speakerDestructionParticleEffects;              		// 0x03D4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1444 ];

		return pClassPointer;
	};

	bool IsSpeakerEnabled ( );
	void FadeVolume ( float Time, float vol );
	void FadeIn ( float Time );
	void FadeOut ( float Time );
	void TakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void PostBeginPlay ( );
	void PreBeginPlay ( );
	void OnDestroyedEvent ( );
};

UClass* AYDO_RadioManSpeaker::pClassPointer = NULL;

// Class SRGame.YDuneActor
// 0x0030 (0x0230 - 0x0200)
class AYDuneActor : public AStaticMeshActor
{
public:
	class UStaticMesh*                                 OriginalStaticMesh;                               		// 0x0200 (0x0004) [0x0000000000000000]              
	class UStaticMesh*                                 ModifiedStaticMesh;                               		// 0x0204 (0x0004) [0x0000000000000000]              
	float                                              YCurveMaxEdgeDistance;                            		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              YCurvePower;                                      		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              YTesselationFactor;                               		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      YUseVertexColorAlignmentMask : 1;                 		// 0x0214 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      YInvertVertexColorAlignmentMask : 1;              		// 0x0214 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      YProjectOnBSP : 1;                                		// 0x0214 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      YProjectOnStaticMeshes : 1;                       		// 0x0214 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      YProjectOnTerrain : 1;                            		// 0x0214 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	float                                              YCurveMaxEdgeDistanceVertexAlpha;                 		// 0x0218 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              YCurvePowerVertexAlpha;                           		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      YFilterMode;                                      		// 0x0220 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< class AActor* >                            YFilter;                                          		// 0x0224 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1445 ];

		return pClassPointer;
	};

	void PreBeginPlay ( );
};

UClass* AYDuneActor::pClassPointer = NULL;

// Class SRGame.YDynamicFireLinksVolume
// 0x0004 (0x0238 - 0x0234)
class AYDynamicFireLinksVolume : public AVolume
{
public:
	unsigned long                                      m_isEnabled : 1;                                  		// 0x0234 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1446 ];

		return pClassPointer;
	};

	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYDynamicFireLinksVolume::pClassPointer = NULL;

// Class SRGame.YDynamicSceneCaptureActor
// 0x0000 (0x0200 - 0x0200)
class AYDynamicSceneCaptureActor : public ASceneCapture2DActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1447 ];

		return pClassPointer;
	};

	class UTexture* GetTexture ( );
	bool Init ( int Width, int Height );
	bool InitComponentTexture ( );
};

UClass* AYDynamicSceneCaptureActor::pClassPointer = NULL;

// Class SRGame.YEmitter
// 0x0004 (0x0208 - 0x0204)
class AYEmitter : public AEmitter
{
public:
	class UPrimitiveComponent*                         m_belongsToComponent;                             		// 0x0204 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1448 ];

		return pClassPointer;
	};

};

UClass* AYEmitter::pClassPointer = NULL;

// Class SRGame.YGrenadeThrow
// 0x0030 (0x0238 - 0x0208)
class AYGrenadeThrow : public AYEmitter
{
public:
	unsigned char                                      m_grenadeType;                                    		// 0x0208 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_grenadeThrowMode;                               		// 0x0209 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class AActor*                                      m_destination;                                    		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AYProj_Physical*                             m_simulatedGrenade;                               		// 0x0210 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UClass* >                            m_grenadeTypeClasses;                             		// 0x0214 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UClass* >                            m_grenadeTypeClassesNoCollision;                  		// 0x0220 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_grenadeTypeEnums;                               		// 0x022C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1449 ];

		return pClassPointer;
	};

	void SpawnGrenade ( class AActor* callActorMethodsHere, class UClass* grenadeClass, unsigned char throwMode, struct FVector Start, struct FVector End, float aimZ, unsigned long notifyAI, class AYProj_Physical** spawnedGrenade );
	void SpawnTrail ( class AActor* callActorMethodsHere, class UClass* grenadeClass, unsigned char throwMode, struct FVector Start, struct FVector End, float aimZ, class AYProj_Physical** spawnedGrenade );
	bool IsPIE ( );
};

UClass* AYGrenadeThrow::pClassPointer = NULL;

// Class SRGame.YErrorMarker
// 0x001C (0x0214 - 0x01F8)
class AYErrorMarker : public AActor
{
public:
	unsigned char                                      m_markerType;                                     		// 0x01F8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     m_shortErrorDesc;                                 		// 0x01FC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FYS_ErrorInfo >                     m_errorInfos;                                     		// 0x0208 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1450 ];

		return pClassPointer;
	};

	void SpawnNewErrorMarker ( struct FString shortErrorDesc, struct FString detailedErrorDesc, struct FVector SpawnLocation, unsigned char markerType );
	void HideAllErrorMarkers ( unsigned char markerType );
	void ShowAllErrorMarkers ( unsigned char markerType );
};

UClass* AYErrorMarker::pClassPointer = NULL;

// Class SRGame.YExplosionTriggerVolume
// 0x0000 (0x0234 - 0x0234)
class AYExplosionTriggerVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1451 ];

		return pClassPointer;
	};

	bool StopsProjectile ( class AProjectile* P );
};

UClass* AYExplosionTriggerVolume::pClassPointer = NULL;

// Class SRGame.YFightArea
// 0x002C (0x0260 - 0x0234)
class AYFightArea : public AVolume
{
public:
	TArray< class AYAICombatPosSet* >                  m_modifiedCombatPosSets;                          		// 0x0234 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FYOctreeDataHndl >                  m_octreePositions;                                		// 0x0240 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned char                                      m_FightAreaId;                                    		// 0x024C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_center;                                         		// 0x0250 (0x000C) [0x0000000000000000]              
	unsigned long                                      m_useForSquadCommands : 1;                        		// 0x025C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1452 ];

		return pClassPointer;
	};

};

UClass* AYFightArea::pClassPointer = NULL;

// Class SRGame.YFracturedSMActorMovable
// 0x0000 (0x0260 - 0x0260)
class AYFracturedSMActorMovable : public AFracturedStaticMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1453 ];

		return pClassPointer;
	};

	void TakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool IsFracturedByDamageType ( class UClass* dmgType );
};

UClass* AYFracturedSMActorMovable::pClassPointer = NULL;

// Class SRGame.YGameDump
// 0x003C (0x0078 - 0x003C)
class UYGameDump : public UObject
{
public:
	struct FYS_GameDumpNode                            m_rootNode;                                       		// 0x003C (0x003C) [0x0000000000001001]              ( CPF_Edit | CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1454 ];

		return pClassPointer;
	};

	void AttachToRoot ( );
	void DumpToLog ( unsigned long dumpObjects );
};

UClass* UYGameDump::pClassPointer = NULL;

// Class SRGame.YGameplayEventsWriter
// 0x0000 (0x0130 - 0x0130)
class UYGameplayEventsWriter : public UGameplayEventsWriter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1455 ];

		return pClassPointer;
	};

	void Poll ( );
	void LogControllerPositionsByClass ( );
};

UClass* UYGameplayEventsWriter::pClassPointer = NULL;

// Class SRGame.YGameplayMultiSpotComponent
// 0x0000 (0x0274 - 0x0274)
class UYGameplayMultiSpotComponent : public UStaticMeshComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1456 ];

		return pClassPointer;
	};

};

UClass* UYGameplayMultiSpotComponent::pClassPointer = NULL;

// Class SRGame.YGameplayMultiSpotEditorData
// 0x0020 (0x005C - 0x003C)
class UYGameplayMultiSpotEditorData : public UObject
{
public:
	TArray< struct FYS_SubspotEditState >              m_subspotEditStates;                              		// 0x003C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_curPlacedSubspotIndex;                          		// 0x0048 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_shallRedrawViewports : 1;                       		// 0x004C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_isEditingSubspot : 1;                           		// 0x004C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	struct FRotator                                    m_RotationHelper;                                 		// 0x0050 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1457 ];

		return pClassPointer;
	};

};

UClass* UYGameplayMultiSpotEditorData::pClassPointer = NULL;

// Class SRGame.YAISpawnPointEditorData
// 0x0004 (0x0060 - 0x005C)
class UYAISpawnPointEditorData : public UYGameplayMultiSpotEditorData
{
public:
	class UYAssetReference*                            m_spawnLocMesh;                                   		// 0x005C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1458 ];

		return pClassPointer;
	};

};

UClass* UYAISpawnPointEditorData::pClassPointer = NULL;

// Class SRGame.YGameplaySpot
// 0x0010 (0x0208 - 0x01F8)
class AYGameplaySpot : public AActor
{
public:
	unsigned long                                      yEnabled : 1;                                     		// 0x01F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FVector                                     m_lastClickPos;                                   		// 0x01FC (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1459 ];

		return pClassPointer;
	};

	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYGameplaySpot::pClassPointer = NULL;

// Class SRGame.YGameplayMultiSpot
// 0x0008 (0x0210 - 0x0208)
class AYGameplayMultiSpot : public AYGameplaySpot
{
public:
	class UYGameplayMultiSpotEditorData*               m_editorData;                                     		// 0x0208 (0x0004) [0x0000000004402008]              ( CPF_ExportObject | CPF_Transient | CPF_NeedCtorLink | CPF_EditInline )
	class UYGameplayMultiSpotComponent*                m_multispotComponent;                             		// 0x020C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1460 ];

		return pClassPointer;
	};

};

UClass* AYGameplayMultiSpot::pClassPointer = NULL;

// Class SRGame.YAISpawnPoint
// 0x0014 (0x0224 - 0x0210)
class AYAISpawnPoint : public AYGameplayMultiSpot
{
public:
	TArray< struct FYS_SpawnPoint >                    m_spawnPoints;                                    		// 0x0210 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_minPlayerDistance;                              		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minPlayerHeightDistance;                        		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1461 ];

		return pClassPointer;
	};

	void SetWorldRot ( int Idx, struct FRotator Rot );
	void SetWorldPos ( int Idx, struct FVector pos );
	struct FRotator GetSpawnWorldRot ( int Idx );
	struct FVector GetSpawnWorldPos ( int Idx );
};

UClass* AYAISpawnPoint::pClassPointer = NULL;

// Class SRGame.YGameSettingsCommon
// 0x0008 (0x00CC - 0x00C4)
class UYGameSettingsCommon : public UOnlineGameSettings
{
public:
	int                                                MaxPlayers;                                       		// 0x00C4 (0x0004) [0x0000000040000000]              ( CPF_EditInlineNotify )
	int                                                MinNetPlayers;                                    		// 0x00C8 (0x0004) [0x0000000040000000]              ( CPF_EditInlineNotify )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1462 ];

		return pClassPointer;
	};

	void UpdateFromURL ( class AGameInfo* Game, struct FString* URL );
	void BuildURL ( struct FString* OutURL );
	void SetCustomMapName ( struct FString MapName );
	struct FString BlobToString ( struct FString* InBlob );
	bool StringToBlob ( struct FString* InString, struct FString* OutBlob );
};

UClass* UYGameSettingsCommon::pClassPointer = NULL;

// Class SRGame.YGameSettingsMultiplayer
// 0x0014 (0x00D8 - 0x00C4)
class UYGameSettingsMultiplayer : public UOnlineGameSettings
{
public:
	int                                                m_SpecopsMaxPlayers;                              		// 0x00C4 (0x0004) [0x0000000000000000]              
	int                                                m_KonradsMaxPlayers;                              		// 0x00C8 (0x0004) [0x0000000000000000]              
	int                                                m_KonradsMaxBots;                                 		// 0x00CC (0x0004) [0x0000000000000000]              
	int                                                m_MaxPlayers;                                     		// 0x00D0 (0x0004) [0x0000000000000000]              
	int                                                m_MinNetPlayers;                                  		// 0x00D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1463 ];

		return pClassPointer;
	};

	bool IsRankedSession ( class UOnlineGameSettings* GameSettings );
	bool IsFriendPartySession ( class UOnlineGameSettings* GameInviteSettings );
	bool IsFriendParty ( );
	void SetCustomGameMode ( struct FString GameMode );
	bool GetCustomGameMode ( struct FString* GameMode );
	void SetCustomMapName ( struct FString MapName );
	bool GetCustomMapName ( struct FString* MapName );
	void SetCustomMapDifficulity ( int Difficulity );
	bool GetCustomMapDifficulity ( int* Difficulity );
	void SetNumRounds ( int NumRounds );
	void SetExodusMode ( unsigned char exodusMode );
	bool IsRanked ( );
	void SetRanked ( unsigned long bRanked );
	void SetBotRank ( int iRank );
	void SetExperience ( int xp );
	int GetNumRounds ( );
	int GetMaxFreeSlotCount ( );
	int GetMaxTeamFreeSlotCount ( );
	int GetTeamFreeSlotCount ( unsigned char MPFaction, unsigned long bIsBot );
	int GetKonradsFreeSlotCount ( unsigned long bIsBot );
	int GetSpecopsFreeSlotCount ( );
	void SetSessionOwnerFullName ( struct FString OwnerFullName );
	bool GetSessionOwnerFullName ( struct FString* OwnerFullName );
	unsigned char SetRandomMultiplayerFaction ( );
	struct FName GetRandomPlaylistEntryFromPlaylist ( int PlaylistId );
	unsigned char SetRandomMultiplayerMap ( unsigned char MultiplayerModeId, int AchievedCommunityChalenges, int CrossplayerProgress );
	unsigned char SetRandomMultiplayerMode ( int AchievedCommunityChalenges, int exodusCoopProgress );
	void ApplyDefaultRuleValue ( int nDefaultValue, unsigned long bEnforce, int* nWantedValue );
	bool ApplyDefaultModeRules ( unsigned char MPModeId, unsigned long bEnforce, struct FYS_RuleSettings* rules );
	struct FYS_RuleSettings GetCurrentRules ( );
	void SetRules ( struct FYS_RuleSettings MPRules );
	unsigned char GetCurrentAIDifficulty ( );
	void SetAIDifficultyEnum ( unsigned char AIDifficulty );
	unsigned char GetCurrentFaction ( );
	void SetFactionEnum ( unsigned char MPFaction );
	unsigned char GetCurrentMap ( );
	void SetMapEnum ( unsigned char Map );
	int GetTuningMask ( );
	void SetTuningMask ( int TuningMask );
	int GetPlaylistId ( );
	void SetPlaylistId ( int MPPlaylistId );
	unsigned char GetCurrentMode ( );
	void SetMultiplayerModeEnum ( unsigned char MPMode );
	int GetMinNetPlayers ( );
	int GetMaxPlayers ( );
	bool IsMapCompatibleWithMultiplayerMode ( unsigned char MPMapId, unsigned char MPModeId );
	bool GetMapNameAndCharacterList ( unsigned char MPModeId, unsigned char MPMapId, struct FString* MapName, struct FName* CharListName );
	class UYUIDataProvider_MapInfo* GetMPMapDataProvider ( unsigned char MPMapId );
	class UYUIDataProvider_DifficultyInfo* GetDifficultyProvider ( unsigned char Difficulty );
	bool GetMPMapDataProvidersCompatibleWithMPModePrefixes ( struct FString MPModePrefixes, TArray< int >* CompatibleMapInfoProviderIndexList );
	bool GetMPModePrefixes ( unsigned char MPModeId, struct FString* Prefixes );
	unsigned char GetYE_DifficultyLevelEnum ( unsigned char Difficulty );
	bool GetMPModeGameInfo ( unsigned char MPModeId, struct FString* MPModeGameInfo );
	class UYUIDataProvider_GameModeInfo* GetMPModeDataProvider ( unsigned char MPModeId );
	unsigned char GetMPModeFromPrefix ( struct FString Prefix );
	void BuildURL ( struct FString* OutURL );
	bool IsTeamMode ( );
	bool HasEnoughPlayers ( );
	void UpdateFreeSlotCounters ( int SpecopsFreeSlots, int KonradsFreeSlots, int MaxTeamFreeSlots, int MaxFreeSlots );
	void UpdateTeamFreeSlots ( int SpecopsPlayerCount, int KonradsPlayerCount );
	bool InitTeamFreeSlots ( unsigned long bPrivateMatch );
	struct FName GetCharacterListName ( );
	int GetMaxBotsForTeam ( unsigned char Team );
	int GetMaxHumanPlayersForTeam ( unsigned char Team );
};

UClass* UYGameSettingsMultiplayer::pClassPointer = NULL;

// Class SRGame.YInterpTrackFloatAudioParam
// 0x000C (0x007C - 0x0070)
class UYInterpTrackFloatAudioParam : public UInterpTrackFloatBase
{
public:
	struct FName                                       m_paramName;                                      		// 0x0070 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_soundCue;                                       		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1464 ];

		return pClassPointer;
	};

};

UClass* UYInterpTrackFloatAudioParam::pClassPointer = NULL;

// Class SRGame.YInterpTrackInstFloatAudioParam
// 0x0008 (0x0044 - 0x003C)
class UYInterpTrackInstFloatAudioParam : public UInterpTrackInst
{
public:
	float                                              ResetFloat;                                       		// 0x003C (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             m_audioComponent;                                 		// 0x0040 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1465 ];

		return pClassPointer;
	};

};

UClass* UYInterpTrackInstFloatAudioParam::pClassPointer = NULL;

// Class SRGame.YIScanable
// 0x0000 (0x003C - 0x003C)
class UYIScanable : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1466 ];

		return pClassPointer;
	};

	unsigned char GetScanableType ( int m_scanningTeamIdx );
	void OnScanEnded ( );
	void OnScanned ( class AYPlayerController* PC, unsigned char Appearance, float Delay, unsigned long PlaySound );
};

UClass* UYIScanable::pClassPointer = NULL;

// Class SRGame.YLeaderboardSettings
// 0x0008 (0x008C - 0x0084)
class UYLeaderboardSettings : public USettings
{
public:
	int                                                m_nStartIndex;                                    		// 0x0084 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nRowCountPerPage;                               		// 0x0088 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1467 ];

		return pClassPointer;
	};

	int GetRowCountPerPage ( );
	void PageDown ( );
	void PageUp ( );
	void Friends ( );
	void TopOfList ( );
	void CenterOnPlayer ( );
	void ShowGlobal ( );
	void MoveToNextSettingValue ( int SettingId );
};

UClass* UYLeaderboardSettings::pClassPointer = NULL;

// Class SRGame.YLocator
// 0x0030 (0x0228 - 0x01F8)
class AYLocator : public AActor
{
public:
	struct FString                                     m_comment;                                        		// 0x01F8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      m_meshType;                                       		// 0x0204 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_linkToNearbyCovers : 1;                         		// 0x0208 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_linkedSubspotIsStack : 1;                       		// 0x0208 (0x0004) [0x0000000000020001] [0x00000002] ( CPF_Edit | CPF_EditConst )
	float                                              m_linkRadius;                                     		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AYAICombatPosSet*                            m_linkedCombatPosSet;                             		// 0x0210 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_linkedSubspot;                                  		// 0x0214 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	TArray< class UYAssetReference* >                  m_meshes;                                         		// 0x0218 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	class UStaticMeshComponent*                        m_meshComponent;                                  		// 0x0224 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1468 ];

		return pClassPointer;
	};

	void UpdateLinkedPosition ( );
};

UClass* AYLocator::pClassPointer = NULL;

// Class SRGame.YLocatorFightArea
// 0x0060 (0x0288 - 0x0228)
class AYLocatorFightArea : public AYLocator
{
public:
	class AYAIAbstractPlayerSquadTrigger*              m_trigger;                                        		// 0x0228 (0x0004) [0x0000000000000000]              
	class UYAssetReference*                            m_highlightMesh;                                  		// 0x022C (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class UStaticMeshComponent*                        m_highlightMeshComponent;                         		// 0x0230 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	TArray< class AYAICombatPosSet* >                  m_modifiedCombatPosSets;                          		// 0x0234 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UYDrawBoxComponent*                          m_drawBoxComponent;                               		// 0x0240 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	TArray< struct FYOctreeDataHndl >                  m_octreePositions;                                		// 0x0244 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_fightAreaGroup;                                 		// 0x0250 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_fightAreaOffset;                                		// 0x0254 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_FightAreaId;                                    		// 0x0260 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_fightAreaPosition;                              		// 0x0264 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_fightAreaExtent;                                		// 0x0270 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_fightAreaRotation;                              		// 0x027C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1469 ];

		return pClassPointer;
	};

	void UpdateFightAreaMemberships ( class AYAICombatPosSet* cps, int subspot, unsigned long Add );
	void RemoveOctreePosition ( struct FYOctreeDataHndl hndl );
	void AddOctreePosition ( struct FYOctreeDataHndl hndl );
	void GetFightAreaGroup ( TArray< class AYLocatorFightArea* >* fightAreaGroup );
	void GetLeftAndRightFromGroup ( TArray< class AYLocatorFightArea* >* fightAreaGroup, class AYLocatorFightArea** Left, class AYLocatorFightArea** Right );
	void GetFightArea ( struct FVector* Position, struct FVector* Extent, struct FRotator* Orientation );
	bool IsPositionInFightArea ( struct FVector pos );
	bool IsSubspotInFightArea ( class AYAICombatPosSet* cps, int subspot );
	void ResetCombatPosSets ( );
	void CollectCombatPosSetsInEditor ( );
	void UpdateFightAreaInGroup ( );
	void UpdateFightArea ( );
	void ForceUpdateComponents ( unsigned long bCollisionUpdate, unsigned long bTransformOnly );
};

UClass* AYLocatorFightArea::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionACOS
// 0x001C (0x0088 - 0x006C)
class UYMaterialExpressionACOS : public UMaterialExpression
{
public:
	struct FExpressionInput                            X;                                                		// 0x006C (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1470 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionACOS::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionAlignedLayerGradient
// 0x0074 (0x00E0 - 0x006C)
class UYMaterialExpressionAlignedLayerGradient : public UMaterialExpression
{
public:
	class UTexture*                                    DistortionTexture;                                		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FExpressionInput                            FalloffFactor;                                    		// 0x0070 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            FalloffDistortion;                                		// 0x008C (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            WorldAlignment;                                   		// 0x00A8 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            Normal;                                           		// 0x00C4 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1471 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionAlignedLayerGradient::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionAtan2
// 0x0038 (0x00A4 - 0x006C)
class UYMaterialExpressionAtan2 : public UMaterialExpression
{
public:
	struct FExpressionInput                            X;                                                		// 0x006C (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            Y;                                                		// 0x0088 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1472 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionAtan2::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionLocalPosition
// 0x0000 (0x006C - 0x006C)
class UYMaterialExpressionLocalPosition : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1473 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionLocalPosition::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionMax
// 0x0038 (0x00A4 - 0x006C)
class UYMaterialExpressionMax : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x006C (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x0088 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1474 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionMax::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionMin
// 0x0038 (0x00A4 - 0x006C)
class UYMaterialExpressionMin : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                		// 0x006C (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            B;                                                		// 0x0088 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1475 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionMin::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionPartialDerivative
// 0x001D (0x0089 - 0x006C)
class UYMaterialExpressionPartialDerivative : public UMaterialExpression
{
public:
	struct FExpressionInput                            DD;                                               		// 0x006C (0x001C) [0x0000000000000000]              
	unsigned char                                      PartialDerivativeType;                            		// 0x0088 (0x0001) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1476 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionPartialDerivative::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionReflectionBlending
// 0x0094 (0x0100 - 0x006C)
class UYMaterialExpressionReflectionBlending : public UMaterialExpression
{
public:
	class UTexture*                                    RT_Texture;                                       		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              ParticleAlpha;                                    		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FExpressionInput                            BlendTo;                                          		// 0x0074 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            RTTexture;                                        		// 0x0090 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            RefColorBrightness;                               		// 0x00AC (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            RefDesaturation;                                  		// 0x00C8 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            BlendStrength;                                    		// 0x00E4 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1477 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionReflectionBlending::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionSceneFilter
// 0x002C (0x0098 - 0x006C)
class UYMaterialExpressionSceneFilter : public UMaterialExpression
{
public:
	unsigned char                                      SceneTextureType;                                 		// 0x006C (0x0001) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	TArray< struct FSceneFilter >                      Filter;                                           		// 0x0070 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	struct FExpressionInput                            Coordinates;                                      		// 0x007C (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1478 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionSceneFilter::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionSHLightingConstant
// 0x0000 (0x006C - 0x006C)
class UYMaterialExpressionSHLightingConstant : public UMaterialExpression
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1479 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionSHLightingConstant::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionTan
// 0x001C (0x0088 - 0x006C)
class UYMaterialExpressionTan : public UMaterialExpression
{
public:
	struct FExpressionInput                            X;                                                		// 0x006C (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1480 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionTan::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionTexcoordFlipped
// 0x0024 (0x0090 - 0x006C)
class UYMaterialExpressionTexcoordFlipped : public UMaterialExpression
{
public:
	unsigned long                                      Mirroring : 1;                                    		// 0x006C (0x0004) [0x0000000004000001] [0x00000001] ( CPF_Edit | CPF_EditInline )
	float                                              MirroringFactor;                                  		// 0x0070 (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	struct FExpressionInput                            Coordinates;                                      		// 0x0074 (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1481 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionTexcoordFlipped::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionTextureSampleCube
// 0x0020 (0x008C - 0x006C)
class UYMaterialExpressionTextureSampleCube : public UMaterialExpression
{
public:
	struct FExpressionInput                            LODBias;                                          		// 0x006C (0x001C) [0x0000000000000000]              
	class UTexture*                                    Texture;                                          		// 0x0088 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1482 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionTextureSampleCube::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionTextureSampleNormal
// 0x0048 (0x00B4 - 0x006C)
class UYMaterialExpressionTextureSampleNormal : public UMaterialExpression
{
public:
	class UTexture*                                    Texture;                                          		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FExpressionInput                            Coordinates;                                      		// 0x0070 (0x001C) [0x0000000000000000]              
	class UTexture*                                    DetailTexture;                                    		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FExpressionInput                            DScale;                                           		// 0x0090 (0x001C) [0x0000000000000000]              
	float                                              ScaleX;                                           		// 0x00AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              ScaleY;                                           		// 0x00B0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1483 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionTextureSampleNormal::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionTextureSampleNormalParameter
// 0x0010 (0x00C4 - 0x00B4)
class UYMaterialExpressionTextureSampleNormalParameter : public UYMaterialExpressionTextureSampleNormal
{
public:
	struct FName                                       m_parameterNameTexture;                           		// 0x00B4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_parameterNameDetail;                            		// 0x00BC (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1484 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionTextureSampleNormalParameter::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionTransformNormal
// 0x001C (0x0088 - 0x006C)
class UYMaterialExpressionTransformNormal : public UMaterialExpression
{
public:
	struct FExpressionInput                            Normal;                                           		// 0x006C (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1485 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionTransformNormal::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionVolumeMapping
// 0x00B4 (0x0120 - 0x006C)
class UYMaterialExpressionVolumeMapping : public UMaterialExpression
{
public:
	struct FExpressionInput                            ScaleX;                                           		// 0x006C (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            ScaleY;                                           		// 0x0088 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            ScaleZ;                                           		// 0x00A4 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            OffsetX;                                          		// 0x00C0 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            OffsetY;                                          		// 0x00DC (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            OffsetZ;                                          		// 0x00F8 (0x001C) [0x0000000000000000]              
	class UTexture*                                    Texture_X;                                        		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTexture*                                    Texture_Y;                                        		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTexture*                                    Texture_Z;                                        		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1486 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionVolumeMapping::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionWorldAlignedUV
// 0x003C (0x00A8 - 0x006C)
class UYMaterialExpressionWorldAlignedUV : public UMaterialExpression
{
public:
	unsigned char                                      Alignment;                                        		// 0x006C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FExpressionInput                            Scale;                                            		// 0x0070 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            Offset;                                           		// 0x008C (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1487 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionWorldAlignedUV::pClassPointer = NULL;

// Class SRGame.YMaterialExpressionWorldMappedDualLayer
// 0x005C (0x00C8 - 0x006C)
class UYMaterialExpressionWorldMappedDualLayer : public UMaterialExpression
{
public:
	class UTexture*                                    NearTexture;                                      		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTexture*                                    FarTexture;                                       		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FExpressionInput                            DepthBlend;                                       		// 0x0074 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            ScaleNear;                                        		// 0x0090 (0x001C) [0x0000000000000000]              
	struct FExpressionInput                            ScaleFar;                                         		// 0x00AC (0x001C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1488 ];

		return pClassPointer;
	};

};

UClass* UYMaterialExpressionWorldMappedDualLayer::pClassPointer = NULL;

// Class SRGame.YNativeLocalization
// 0x0000 (0x003C - 0x003C)
class UYNativeLocalization : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1489 ];

		return pClassPointer;
	};

	unsigned char GetForPlatform ( unsigned char x360, unsigned char ps3, unsigned char PC );
};

UClass* UYNativeLocalization::pClassPointer = NULL;

// Class SRGame.YParticleModuleCollisionDecal
// 0x0020 (0x0104 - 0x00E4)
class UYParticleModuleCollisionDecal : public UParticleModuleCollision
{
public:
	float                                              m_decalSize;                                      		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_decalLifeTime;                                  		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_useHitDirection : 1;                            		// 0x00EC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_distanceSizeFactor;                             		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FDecalMap >                         m_decalMap;                                       		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_startIndex;                                     		// 0x0100 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1490 ];

		return pClassPointer;
	};

	void SpawnImpactDecal ( class AYDecalManager* decalMgr, struct FVector HitLocation, struct FVector HitNormal, float HitDir, float hitEmiiterDistance, class UPhysicalMaterial* phyMat );
};

UClass* UYParticleModuleCollisionDecal::pClassPointer = NULL;

// Class SRGame.YParticleModuleColorSet
// 0x0018 (0x0060 - 0x0048)
class UYParticleModuleColorSet : public UParticleModuleColorBase
{
public:
	TArray< struct FVector >                           StartColor;                                       		// 0x0048 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< float >                                    StartAlpha;                                       		// 0x0054 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1491 ];

		return pClassPointer;
	};

};

UClass* UYParticleModuleColorSet::pClassPointer = NULL;

// Class SRGame.YParticleModuleLocationBeamEnd
// 0x0008 (0x0050 - 0x0048)
class UYParticleModuleLocationBeamEnd : public UParticleModuleLocationBase
{
public:
	struct FName                                       BeamEmitterName;                                  		// 0x0048 (0x0008) [0x0000000002000009]              ( CPF_Edit | CPF_ExportObject | CPF_NoClear )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1492 ];

		return pClassPointer;
	};

};

UClass* UYParticleModuleLocationBeamEnd::pClassPointer = NULL;

// Class SRGame.YParticleModuleLocationPosArray
// 0x0000 (0x004C - 0x004C)
class UYParticleModuleLocationPosArray : public UParticleModuleSpawnBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1493 ];

		return pClassPointer;
	};

	void AddSpawnPosition ( struct FPointer Owner, struct FVector SpawnPos );
};

UClass* UYParticleModuleLocationPosArray::pClassPointer = NULL;

// Class SRGame.YParticleModuleLocationVertex
// 0x0005 (0x004D - 0x0048)
class UYParticleModuleLocationVertex : public UParticleModuleLocationBase
{
public:
	class UStaticMesh*                                 VertexMesh;                                       		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      VertexOrder;                                      		// 0x004C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1494 ];

		return pClassPointer;
	};

};

UClass* UYParticleModuleLocationVertex::pClassPointer = NULL;

// Class SRGame.YParticleModuleLocationWorldPosArray
// 0x0000 (0x0048 - 0x0048)
class UYParticleModuleLocationWorldPosArray : public UParticleModuleLocationBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1495 ];

		return pClassPointer;
	};

};

UClass* UYParticleModuleLocationWorldPosArray::pClassPointer = NULL;

// Class SRGame.YParticleModuleRadialVelocity
// 0x001C (0x0068 - 0x004C)
class UYParticleModuleRadialVelocity : public UParticleModuleVelocityBase
{
public:
	class UDistributionVector*                         yStartVelocityDirection;                          		// 0x004C (0x0004) [0x0000000006080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_NoClear | CPF_EditInline )
	class UDistributionFloat*                          yStartVelocityValue;                              		// 0x0050 (0x0004) [0x0000000006080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_NoClear | CPF_EditInline )
	unsigned long                                      yUseCurvature : 1;                                		// 0x0054 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class UDistributionFloat*                          yStartVelocityCurvatureX;                         		// 0x0058 (0x0004) [0x0000000006080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_NoClear | CPF_EditInline )
	class UDistributionFloat*                          yStartVelocityCurvatureY;                         		// 0x005C (0x0004) [0x0000000006080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_NoClear | CPF_EditInline )
	float                                              yCurvatureSizeX;                                  		// 0x0060 (0x0004) [0x0000000002000009]              ( CPF_Edit | CPF_ExportObject | CPF_NoClear )
	float                                              yCurvatureSizeY;                                  		// 0x0064 (0x0004) [0x0000000002000009]              ( CPF_Edit | CPF_ExportObject | CPF_NoClear )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1496 ];

		return pClassPointer;
	};

};

UClass* UYParticleModuleRadialVelocity::pClassPointer = NULL;

// Class SRGame.YParticleModuleScaleByBeamLength
// 0x0010 (0x0058 - 0x0048)
class UYParticleModuleScaleByBeamLength : public UParticleModuleSizeBase
{
public:
	struct FName                                       BeamEmitterName;                                  		// 0x0048 (0x0008) [0x0000000002000009]              ( CPF_Edit | CPF_ExportObject | CPF_NoClear )
	float                                              MinScale;                                         		// 0x0050 (0x0004) [0x0000000002000009]              ( CPF_Edit | CPF_ExportObject | CPF_NoClear )
	float                                              ScaleFactor;                                      		// 0x0054 (0x0004) [0x0000000002000009]              ( CPF_Edit | CPF_ExportObject | CPF_NoClear )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1497 ];

		return pClassPointer;
	};

};

UClass* UYParticleModuleScaleByBeamLength::pClassPointer = NULL;

// Class SRGame.YParticleModuleYagerBase
// 0x0000 (0x0048 - 0x0048)
class UYParticleModuleYagerBase : public UParticleModule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1498 ];

		return pClassPointer;
	};

};

UClass* UYParticleModuleYagerBase::pClassPointer = NULL;

// Class SRGame.YParticleModuleAdvSet
// 0x011C (0x0164 - 0x0048)
class UYParticleModuleAdvSet : public UYParticleModuleYagerBase
{
public:
	struct FRawDistributionFloat                       Lifetime;                                         		// 0x0048 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionVector                      StartSize;                                        		// 0x0064 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionVector                      StartVelocity;                                    		// 0x0080 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionFloat                       StartVelocityRadial;                              		// 0x009C (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionVector                      ColorOverLife;                                    		// 0x00B8 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionFloat                       AlphaOverLife;                                    		// 0x00D4 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	unsigned long                                      bClampAlpha : 1;                                  		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      MultiplyX : 1;                                    		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      MultiplyY : 1;                                    		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      MultiplyZ : 1;                                    		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	struct FRawDistributionVector                      LifeMultiplier;                                   		// 0x00F4 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionFloat                       StartRotation;                                    		// 0x0110 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionFloat                       StartRotationRate;                                		// 0x012C (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionFloat                       RotRateLifeMultiplier;                            		// 0x0148 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1499 ];

		return pClassPointer;
	};

};

UClass* UYParticleModuleAdvSet::pClassPointer = NULL;

// Class SRGame.YParticleModuleBasicRotation
// 0x0054 (0x009C - 0x0048)
class UYParticleModuleBasicRotation : public UYParticleModuleYagerBase
{
public:
	struct FRawDistributionFloat                       StartRotation;                                    		// 0x0048 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionFloat                       StartRotationRate;                                		// 0x0064 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionFloat                       RotRateLifeMultiplier;                            		// 0x0080 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1500 ];

		return pClassPointer;
	};

};

UClass* UYParticleModuleBasicRotation::pClassPointer = NULL;

// Class SRGame.YParticleModuleBasicSet
// 0x00C8 (0x0110 - 0x0048)
class UYParticleModuleBasicSet : public UYParticleModuleYagerBase
{
public:
	struct FRawDistributionFloat                       Lifetime;                                         		// 0x0048 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionVector                      StartSize;                                        		// 0x0064 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionVector                      StartVelocity;                                    		// 0x0080 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionFloat                       StartVelocityRadial;                              		// 0x009C (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionVector                      ColorOverLife;                                    		// 0x00B8 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FRawDistributionFloat                       AlphaOverLife;                                    		// 0x00D4 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	unsigned long                                      bClampAlpha : 1;                                  		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      MultiplyX : 1;                                    		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      MultiplyY : 1;                                    		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      MultiplyZ : 1;                                    		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	struct FRawDistributionVector                      LifeMultiplier;                                   		// 0x00F4 (0x001C) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1501 ];

		return pClassPointer;
	};

};

UClass* UYParticleModuleBasicSet::pClassPointer = NULL;

// Class SRGame.YParticleSystemComponent
// 0x0004 (0x030C - 0x0308)
class UYParticleSystemComponent : public UParticleSystemComponent
{
public:
	unsigned long                                      yForceRendering : 1;                              		// 0x0308 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1502 ];

		return pClassPointer;
	};

};

UClass* UYParticleSystemComponent::pClassPointer = NULL;

// Class SRGame.YPerk
// 0x0014 (0x0050 - 0x003C)
class UYPerk : public UObject
{
public:
	unsigned char                                      m_Perk;                                           		// 0x003C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_type;                                           		// 0x003D (0x0001) [0x0000000000000000]              
	unsigned char                                      m_charType;                                       		// 0x003E (0x0001) [0x0000000000000000]              
	class AYPawn_Multiplayer*                          m_pawn;                                           		// 0x0040 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bCanStack : 1;                                  		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 
	class UClass*                                      PawnClass;                                        		// 0x0048 (0x0004) [0x0000000000000000]              
	int                                                m_level;                                          		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1503 ];

		return pClassPointer;
	};

	void OnTakeDownWeapon ( class AYPawn_Multiplayer* P );
	void OnTakeUpWeapon ( class AYPawn_Multiplayer* P );
	void OnUnCrouch ( class AYPawn_Multiplayer* P );
	void OnCrouch ( class AYPawn_Multiplayer* P );
	void ReloadWeapon ( class AYPawn_Multiplayer* P );
	void OnWeaponFired ( class AYPawn_Multiplayer* P );
	void OnEndRaiseGrenade ( class AYPawn_Multiplayer* P );
	void TakeDamage ( class AYPawn_Multiplayer* P, int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	struct FString StaticGetDescription ( );
	struct FString StaticGetFriendlyName ( );
	class UYUIDataProvider_Perks* StaticGetProviderFromEnum ( unsigned char perkEnum );
	class UYUIDataProvider_Perks* StaticGetProvider ( );
	struct FName StaticGetProviderTag ( );
	unsigned char GetPerkEnum ( );
	unsigned char StaticGetPerkEnum ( );
	void RemovePerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	void ApplyPerkModified ( class AYPawn_Multiplayer* yPawn, int perkSlot, int Level );
	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	int GetPerkLevel ( );
	struct FString GetPerkFriendlyName ( unsigned char perkEnum );
};

UClass* UYPerk::pClassPointer = NULL;

// Class SRGame.YPerk_Cowboy
// 0x0008 (0x0058 - 0x0050)
class UYPerk_Cowboy : public UYPerk
{
public:
	float                                              m_accuracyModifier;                               		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_refireRateMultiplier;                           		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1504 ];

		return pClassPointer;
	};

};

UClass* UYPerk_Cowboy::pClassPointer = NULL;

// Class SRGame.YPerk_FireRate
// 0x0004 (0x0054 - 0x0050)
class UYPerk_FireRate : public UYPerk
{
public:
	float                                              m_refireRateMultiplier;                           		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1505 ];

		return pClassPointer;
	};

};

UClass* UYPerk_FireRate::pClassPointer = NULL;

// Class SRGame.YPlayerController
// 0x0AA8 (0x1058 - 0x05B0)
class AYPlayerController : public AGamePlayerController
{
public:
	struct FPointer                                    VfTable_IYIController;                            		// 0x05B0 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_YIAIConnectable;                          		// 0x05B4 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	TArray< struct FYS_DLCSimpleFriendlyPair >         DLCSimpleToFriendly;                              		// 0x05B8 (0x000C) [0x0000000000404002]              ( CPF_Const | CPF_Config | CPF_NeedCtorLink )
	struct FYS_PointOfInterest                         m_POIData;                                        		// 0x05C4 (0x0008) [0x0000000000000000]              
	float                                              m_POIFOVOverride;                                 		// 0x05CC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_POIKickInTime;                                  		// 0x05D0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_POIKickOutTime;                                 		// 0x05D4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_POIPitchTolerance;                              		// 0x05D8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_POIYawTolerance;                                		// 0x05DC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned long                                      m_POICheckLOS : 1;                                		// 0x05E0 (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_turnController : 1;                             		// 0x05E0 (0x0004) [0x0000000000004001] [0x00000002] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_POIFocused : 1;                                 		// 0x05E0 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_wantsToFocusPOI : 1;                            		// 0x05E0 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_cameraMirrored : 1;                             		// 0x05E0 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_keepAimedCamSideWhenLeavingCover : 1;           		// 0x05E0 (0x0004) [0x0000000000004001] [0x00000020] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_curTargetDebugEnabled : 1;                      		// 0x05E0 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_useFocusPoint : 1;                              		// 0x05E0 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      m_isSpectating : 1;                               		// 0x05E0 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_inSniperMode : 1;                               		// 0x05E0 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_sniperScopeOn : 1;                              		// 0x05E0 (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      m_sprintCameraOn : 1;                             		// 0x05E0 (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      m_asyncFocusedActorCheck : 1;                     		// 0x05E0 (0x0004) [0x0000000000002000] [0x00001000] ( CPF_Transient )
	unsigned long                                      m_pullAwayFromCoverPossible : 1;                  		// 0x05E0 (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      m_reenterCoverPossible : 1;                       		// 0x05E0 (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      m_showCoverTagging : 1;                           		// 0x05E0 (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	unsigned long                                      m_primaryFireInput : 1;                           		// 0x05E0 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_primaryFireInputOld : 1;                        		// 0x05E0 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_secondaryFireInput : 1;                         		// 0x05E0 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_weaponChangeButtonIsUsedToCancelSecondaryFire : 1;		// 0x05E0 (0x0004) [0x0000000000002000] [0x00080000] ( CPF_Transient )
	unsigned long                                      m_oldMayFireSecondary : 1;                        		// 0x05E0 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_isPrimaryFiring : 1;                            		// 0x05E0 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_isSecondaryFiring : 1;                          		// 0x05E0 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      m_isFiring : 1;                                   		// 0x05E0 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_pickupCleanupLoggingActivated : 1;              		// 0x05E0 (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      m_hasWeaponFiredEventAttached : 1;                		// 0x05E0 (0x0004) [0x0000000000002000] [0x02000000] ( CPF_Transient )
	unsigned long                                      m_hasGrenadeTutorialEventAttached : 1;            		// 0x05E0 (0x0004) [0x0000000000002000] [0x04000000] ( CPF_Transient )
	unsigned long                                      m_mayExecute : 1;                                 		// 0x05E0 (0x0004) [0x0000000000002000] [0x08000000] ( CPF_Transient )
	unsigned long                                      m_mayMelee : 1;                                   		// 0x05E0 (0x0004) [0x0000000000002000] [0x10000000] ( CPF_Transient )
	unsigned long                                      m_reloadConfigModeActive : 1;                     		// 0x05E0 (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      m_autoTakeDownWeapon : 1;                         		// 0x05E0 (0x0004) [0x0000000000000000] [0x40000000] 
	unsigned long                                      m_forceWeaponRaised : 1;                          		// 0x05E0 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      m_isInCombatSituation : 1;                        		// 0x05E4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_wantsToZoom : 1;                                		// 0x05E4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_wantsToRepair : 1;                              		// 0x05E4 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_zoomButtonPressed : 1;                          		// 0x05E4 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_enableStrafeInAimOver : 1;                      		// 0x05E4 (0x0004) [0x0000000000004001] [0x00000010] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_aimOutOnlyByZoom : 1;                           		// 0x05E4 (0x0004) [0x0000000000002001] [0x00000020] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_forcedWeaponRaisedByKismet : 1;                 		// 0x05E4 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_wantsToWalk : 1;                                		// 0x05E4 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_wantsToSprint : 1;                              		// 0x05E4 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_wantsToCombatSprint : 1;                        		// 0x05E4 (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	unsigned long                                      m_wantsNoStartSprintTransition : 1;               		// 0x05E4 (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      m_wasSprintingBefore : 1;                         		// 0x05E4 (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      m_sprintStickPressed : 1;                         		// 0x05E4 (0x0004) [0x0000000000002000] [0x00001000] ( CPF_Transient )
	unsigned long                                      m_sprintButtonPressed : 1;                        		// 0x05E4 (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      m_contextButtonPressed : 1;                       		// 0x05E4 (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      m_uncrouchOnSprint : 1;                           		// 0x05E4 (0x0004) [0x0000000000004003] [0x00008000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_sprintAbortableByCrouch : 1;                    		// 0x05E4 (0x0004) [0x0000000000000001] [0x00010000] ( CPF_Edit )
	unsigned long                                      m_wantsToCrouch : 1;                              		// 0x05E4 (0x0004) [0x0000000000002000] [0x00020000] ( CPF_Transient )
	unsigned long                                      m_wantsToCover : 1;                               		// 0x05E4 (0x0004) [0x0000000000002000] [0x00040000] ( CPF_Transient )
	unsigned long                                      m_coverButtonPressed : 1;                         		// 0x05E4 (0x0004) [0x0000000000002000] [0x00080000] ( CPF_Transient )
	unsigned long                                      m_coverButtonPressedBefore : 1;                   		// 0x05E4 (0x0004) [0x0000000000002000] [0x00100000] ( CPF_Transient )
	unsigned long                                      m_wantsToSprintAfterVault : 1;                    		// 0x05E4 (0x0004) [0x0000000000002000] [0x00200000] ( CPF_Transient )
	unsigned long                                      m_autoVaultPromptEnabled : 1;                     		// 0x05E4 (0x0004) [0x0000000000004001] [0x00400000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_autoVaultPromptRangeLimited : 1;                		// 0x05E4 (0x0004) [0x0000000000004001] [0x00800000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_vaultHighlightEnabled : 1;                      		// 0x05E4 (0x0004) [0x0000000000004001] [0x01000000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_autoCoverPromptEnabled : 1;                     		// 0x05E4 (0x0004) [0x0000000000004001] [0x02000000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_wantsToDoCoverSpecialMove : 1;                  		// 0x05E4 (0x0004) [0x0000000000002000] [0x04000000] ( CPF_Transient )
	unsigned long                                      m_wantsToDoAutoCoverSpecialMove : 1;              		// 0x05E4 (0x0004) [0x0000000000002000] [0x08000000] ( CPF_Transient )
	unsigned long                                      m_wantsToQueueCoverSpecialMove : 1;               		// 0x05E4 (0x0004) [0x0000000000002000] [0x10000000] ( CPF_Transient )
	unsigned long                                      m_wantsToDoContextSpecialMove : 1;                		// 0x05E4 (0x0004) [0x0000000000002000] [0x20000000] ( CPF_Transient )
	unsigned long                                      m_wantsToDoAutoContextSpecialMove : 1;            		// 0x05E4 (0x0004) [0x0000000000002000] [0x40000000] ( CPF_Transient )
	unsigned long                                      m_wantsToQueueContextSpecialMove : 1;             		// 0x05E4 (0x0004) [0x0000000000002000] [0x80000000] ( CPF_Transient )
	unsigned long                                      m_wantsToDoAgileSpecialMove : 1;                  		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_wantsToDoAutoAgileSpecialMove : 1;              		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_wantsToQueueAgileSpecialMove : 1;               		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_doSpecialMoveAfterPostureTransition : 1;        		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_sprintCoverDashEnabled : 1;                     		// 0x05E8 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_edgeSpecialMoveEnabled : 1;                     		// 0x05E8 (0x0004) [0x0000000000004002] [0x00000020] ( CPF_Const | CPF_Config )
	unsigned long                                      m_canPrepareFastRope : 1;                         		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_bCinematicInputMode : 1;                        		// 0x05E8 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_midGameMenuOpen : 1;                            		// 0x05E8 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_showingIntelDetails : 1;                        		// 0x05E8 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      bQuittingToMainMenu : 1;                          		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      m_OnlineOverlayIsOpen : 1;                        		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      m_debugCamLookAtPlayer : 1;                       		// 0x05E8 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_standCamPlaying : 1;                            		// 0x05E8 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_walkCamPlaying : 1;                             		// 0x05E8 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_sprintCamPlaying : 1;                           		// 0x05E8 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_sprintCamAnimationPlaying : 1;                  		// 0x05E8 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_combatSprintCamPlaying : 1;                     		// 0x05E8 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_combatSprintCamAnimationPlaying : 1;            		// 0x05E8 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_moveCamShakesEnabled : 1;                       		// 0x05E8 (0x0004) [0x0000000000000001] [0x00080000] ( CPF_Edit )
	unsigned long                                      m_allowHitCamShakes : 1;                          		// 0x05E8 (0x0004) [0x0000000000004003] [0x00100000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_hitCamShakesEnabled : 1;                        		// 0x05E8 (0x0004) [0x0000000000002000] [0x00200000] ( CPF_Transient )
	unsigned long                                      m_wasCrouched : 1;                                		// 0x05E8 (0x0004) [0x0000000000002000] [0x00400000] ( CPF_Transient )
	unsigned long                                      m_wasInCover : 1;                                 		// 0x05E8 (0x0004) [0x0000000000002000] [0x00800000] ( CPF_Transient )
	unsigned long                                      m_wasAiming : 1;                                  		// 0x05E8 (0x0004) [0x0000000000002000] [0x01000000] ( CPF_Transient )
	unsigned long                                      m_wasScoped : 1;                                  		// 0x05E8 (0x0004) [0x0000000000002000] [0x02000000] ( CPF_Transient )
	unsigned long                                      m_wasInSandStorm : 1;                             		// 0x05E8 (0x0004) [0x0000000000002000] [0x04000000] ( CPF_Transient )
	unsigned long                                      m_usedTransitionAlpha : 1;                        		// 0x05E8 (0x0004) [0x0000000000000000] [0x08000000] 
	unsigned long                                      m_playerInvisble : 1;                             		// 0x05E8 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      m_belowCriticalHealth : 1;                        		// 0x05E8 (0x0004) [0x0000000000002000] [0x20000000] ( CPF_Transient )
	unsigned long                                      m_debugTacView : 1;                               		// 0x05E8 (0x0004) [0x0000000000000000] [0x40000000] 
	unsigned long                                      m_currentSelectedTacticalMarkableSelected : 1;    		// 0x05E8 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      m_attackMarkingMode : 1;                          		// 0x05EC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_squadCommandModeOn : 1;                         		// 0x05EC (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_reduceDifficultyMessageBoxActive : 1;           		// 0x05EC (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_isSquadControlEnabled : 1;                      		// 0x05EC (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_squadControlAvailable : 1;                      		// 0x05EC (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_bStunFadeOut : 1;                               		// 0x05EC (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_shouldUsePanickedReload : 1;                    		// 0x05EC (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      bCheckpointDummy : 1;                             		// 0x05EC (0x0004) [0x0000000000002002] [0x00000080] ( CPF_Const | CPF_Transient )
	unsigned long                                      bClientLoadingCheckpoint : 1;                     		// 0x05EC (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_pendingControllerDisconnectMessage : 1;         		// 0x05EC (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	unsigned long                                      m_bRetrieveSettingsFromProfileOnNextTick : 1;     		// 0x05EC (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      m_lowHealthSFXActive : 1;                         		// 0x05EC (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      bLateComer : 1;                                   		// 0x05EC (0x0004) [0x0000000000000020] [0x00001000] ( CPF_Net )
	unsigned long                                      m_disableCameraSideSwitch : 1;                    		// 0x05EC (0x0004) [0x0000000000004002] [0x00002000] ( CPF_Const | CPF_Config )
	unsigned long                                      m_bWantsToCreateOnlineGame : 1;                   		// 0x05EC (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      m_bWantsToJoinOnlineGame : 1;                     		// 0x05EC (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	unsigned long                                      m_bConnectionError : 1;                           		// 0x05EC (0x0004) [0x0000000000002000] [0x00010000] ( CPF_Transient )
	unsigned long                                      m_bQuittingToMainMenu : 1;                        		// 0x05EC (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_forceTravelBackToMainMenu : 1;                  		// 0x05EC (0x0004) [0x0000000000002000] [0x00040000] ( CPF_Transient )
	unsigned long                                      m_onlineDelegatesAreRegistered : 1;               		// 0x05EC (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      m_allowToProcessInvite : 1;                       		// 0x05EC (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_bProfileSaveCheckPending : 1;                   		// 0x05EC (0x0004) [0x0000000000002000] [0x00200000] ( CPF_Transient )
	unsigned long                                      m_isAwaitingVoiceHandshake : 1;                   		// 0x05EC (0x0004) [0x0000000000002000] [0x00400000] ( CPF_Transient )
	class AActor*                                      m_currentPOITarget;                               		// 0x05F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_stunPerkRatio;                                  		// 0x05F4 (0x0004) [0x0000000000000000]              
	int                                                m_asyncLineChecks[ 0x2 ];                         		// 0x05F8 (0x0008) [0x0000000000000000]              
	class AYGamePawn*                                  m_myPawn;                                         		// 0x0600 (0x0004) [0x0000000000000000]              
	class AYGamePawn*                                  m_myCorpsePawn;                                   		// 0x0604 (0x0004) [0x0000000000000000]              
	class AYCamera*                                    m_playerCam;                                      		// 0x0608 (0x0004) [0x0000000000000000]              
	struct FName                                       m_meleeCamFocusBoneName;                          		// 0x060C (0x0008) [0x0000000000004000]              ( CPF_Config )
	struct FVector                                     m_meleeCamFocusInterpSpeed;                       		// 0x0614 (0x000C) [0x0000000000004000]              ( CPF_Config )
	int                                                m_meleeCamFocusPitchTolerance;                    		// 0x0620 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_meleeCamFocusYawTolerance;                      		// 0x0624 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_aimOverMirroredYawOffset;                       		// 0x0628 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< float >                                    m_lastEnemyKills;                                 		// 0x062C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AYWeapon*                                    m_currentWeapon;                                  		// 0x0638 (0x0004) [0x0000000000000000]              
	int                                                m_maxLaserSightAngle;                             		// 0x063C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UClass*                                      m_defaultPawnClass;                               		// 0x0640 (0x0004) [0x0000000000000000]              
	class AActor*                                      LastFrictionTarget;                               		// 0x0644 (0x0004) [0x0000000000000000]              
	float                                              LastFrictionTargetTime;                           		// 0x0648 (0x0004) [0x0000000000000000]              
	struct FYS_CamModeReplicationInfo                  m_camModeRepInfo;                                 		// 0x064C (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FYS_CamFixedViewTargetLocationReplicationInfo m_camFixedVTLocRepInfo;                           		// 0x0658 (0x0014) [0x0000000000000020]              ( CPF_Net )
	struct FYS_CamFixedViewTargetRotationReplicationInfo m_camFixedVTRotRepInfo;                           		// 0x066C (0x0014) [0x0000000000000020]              ( CPF_Net )
	struct FYS_CamOverriddenFOVReplicationInfo         m_camOverriddenFOVRepInfo;                        		// 0x0680 (0x0010) [0x0000000000000020]              ( CPF_Net )
	struct FYS_CamBaseOffsetReplicationInfo            m_camBaseOffsetRepInfo;                           		// 0x0690 (0x0010) [0x0000000000000020]              ( CPF_Net )
	struct FYS_CamFocusPointReplicationInfo            m_camFocusPointRepInfo;                           		// 0x06A0 (0x004C) [0x0000000000000020]              ( CPF_Net )
	float                                              m_transitionAlpha;                                		// 0x06EC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_currentTransitionAlpha;                         		// 0x06F0 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_viewTargetLocation;                             		// 0x06F4 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FRotator                                    m_viewTargetRotation;                             		// 0x0700 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FYS_SpectatedPawnCamState                   m_spectatedPawnCamState;                          		// 0x070C (0x0004) [0x0000000000000000]              
	int                                                m_lastCamBaseOffsetIndex;                         		// 0x0710 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_lastCamBaseOffset;                              		// 0x0714 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_originalRotation;                               		// 0x0720 (0x000C) [0x0000000000000000]              
	float                                              m_originalFov;                                    		// 0x072C (0x0004) [0x0000000000000000]              
	float                                              m_lastAimSnapOnTimeStamp;                         		// 0x0730 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_aimSnapOnActiveByUser;                          		// 0x0734 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_weaponQuickSelectionPrimary;                    		// 0x0735 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_weaponQuickSelectionGrenade;                    		// 0x0736 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_inputMovementDirection;                         		// 0x0737 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_preferredPeekDirection;                         		// 0x0738 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_pawnMovementDirection;                          		// 0x0739 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_speedAnimTransition;                            		// 0x073A (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_coverButtonAction;                              		// 0x073B (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_specialMoveButtonAction[ 0x4 ];                 		// 0x073C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_specialMoveAutoButtonAction[ 0x4 ];             		// 0x0740 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_fireButtonAction;                               		// 0x0744 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_debugCamMode;                                   		// 0x0745 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_bIgnoreMoveInputBeforeDebugSpectating;          		// 0x0746 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_bIgnoreLookInputBeforeDebugSpectating;          		// 0x0747 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_dfaCachedIgnoreMoveInput;                       		// 0x0748 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_sprintCamAnimation;                             		// 0x0749 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_combatSprintCamAnimation;                       		// 0x074A (0x0001) [0x0000000000000000]              
	unsigned char                                      IdentifiedTeam;                                   		// 0x074B (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentSelectedTacticalMarkableCheckIndex;      		// 0x074C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentSelectedTacticalMarkableCheckFailCount;  		// 0x074D (0x0001) [0x0000000000000000]              
	unsigned char                                      m_lastContextCommandAnimation;                    		// 0x074E (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_kickReason;                                     		// 0x074F (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_lastKickReason;                                 		// 0x0750 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_aimSnapOnDeltaRot;                              		// 0x0754 (0x0008) [0x0000000000000000]              
	struct FVector                                     m_aimSnapOnRealTargetLocation;                    		// 0x075C (0x000C) [0x0000000000000000]              
	float                                              m_sniperFov;                                      		// 0x0768 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_sprintCameraSpeed;                              		// 0x076C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sprintCameraSpeedThreshold;                     		// 0x0770 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lastRunTimestamp;                               		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_runCamModeStopTime;                             		// 0x0778 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lastStayTimestamp;                              		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastCombatSprintTimeStamp;                      		// 0x0780 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_walkCamStartTime;                               		// 0x0784 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              LastCameraTimeStamp;                              		// 0x0788 (0x0004) [0x0000000000000000]              
	struct FVector                                     CalcViewLocation;                                 		// 0x078C (0x000C) [0x0000000000000000]              
	struct FRotator                                    CalcViewRotation;                                 		// 0x0798 (0x000C) [0x0000000000000000]              
	class AYLookatCameraActor*                         m_deathCamera;                                    		// 0x07A4 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_killer;                                         		// 0x07A8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_focusedPoint;                                   		// 0x07AC (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      m_focusedActor;                                   		// 0x07B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_focusedNormal;                                  		// 0x07BC (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_maxViewTraceDistance;                           		// 0x07C8 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_highlightingMaterial;                           		// 0x07CC (0x0004) [0x0000000000000000]              
	int                                                m_showMidGameMenuCounter;                         		// 0x07D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_maxCoverDistance;                               		// 0x07D4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_maxCoverFov;                                    		// 0x07D8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_maxCoverHeightDifference;                       		// 0x07DC (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_pullAwayFromCoverDelay;                         		// 0x07E0 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_reenterCoverDelay;                              		// 0x07E4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_favorCoverForwardToCoverStrafeRatio;            		// 0x07E8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_peekDelay;                                      		// 0x07EC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_canLeanLeftDuration;                            		// 0x07F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_canLeanRightDuration;                           		// 0x07F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_blindfireKeepDurationAddition;                  		// 0x07F8 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_coverTaggingRadius;                             		// 0x07FC (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_reloadPressTimeStamp;                           		// 0x0800 (0x0004) [0x0000000000000000]              
	float                                              m_timeOfLastLeftStickInputChange;                 		// 0x0804 (0x0004) [0x0000000000000000]              
	float                                              m_leaveBlindfireToAimoutDelay;                    		// 0x0808 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< unsigned char >                            m_weaponQuickSelectionOutOfAmmoFallbacks;         		// 0x080C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_meleeAttackCoolDownTime;                        		// 0x0818 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lastMeleeAttackTimeStamp;                       		// 0x081C (0x0004) [0x0000000000000000]              
	struct FYS_MeleeEffectsDescription                 m_meleeFX;                                        		// 0x0820 (0x001C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_moveInputDirection;                             		// 0x083C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_sprintTurnSpeedModifier;                        		// 0x0848 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sprintTurnSpeedLimit;                           		// 0x084C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sprintMaxTime;                                  		// 0x0850 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sprintMinTime;                                  		// 0x0854 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sprintStartTime;                                		// 0x0858 (0x0004) [0x0000000000000000]              
	float                                              m_sprintEffortStartTime;                          		// 0x085C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sprintEffortDurationStopTimeMultiplier;         		// 0x0860 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sprintEffortDurationStopTimeExponent;           		// 0x0864 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sprintEffortDurationStopTimeMax;                		// 0x0868 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_turnSpeed;                                      		// 0x086C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lookUpSpeed;                                    		// 0x0870 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_sprintMaxAngle;                                 		// 0x0874 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_SmoothRotationInterpolator              m_smoothRotationInterpolator;                     		// 0x0878 (0x001C) [0x0000000000000000]              
	float                                              m_quickTurnRotationSpeed;                         		// 0x0894 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_quickTurnDelay;                                 		// 0x0898 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_quickTurnSmoothingExponent;                     		// 0x089C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_quickTurnAngleRange;                            		// 0x08A0 (0x0008) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_lastQuickTurnTime;                              		// 0x08A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_quickTurnTargetRotationYaw;                     		// 0x08AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_quickTurnMediumDistCamModeAngle;                		// 0x08B0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_quickTurnFarDistCamModeAngle;                   		// 0x08B4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_quickTurnMinTime;                               		// 0x08B8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_quickTurnMinTimeAngle;                          		// 0x08BC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_quickTurnMaxTime;                               		// 0x08C0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_quickTurnMaxTimeAngle;                          		// 0x08C4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lastQuickturnTriggerTime;                       		// 0x08C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_quickTurnDoubleTapMaxTime;                      		// 0x08CC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxPullAwayFromCoverAngle;                      		// 0x08D0 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FString                                     m_playerActionMessages[ 0x33 ];                   		// 0x08D4 (0x0264) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_waitToReviveMessage;                            		// 0x0B38 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	float                                              m_coverButtonActionTimeStamp;                     		// 0x0B44 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_specialMoveButtonActionTimeStamp[ 0x4 ];        		// 0x0B48 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_vaultTimeStamp;                                 		// 0x0B58 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UParticleSystemComponent*                    m_vaultHighlightParticleSystem;                   		// 0x0B5C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UParticleSystem*                             m_vaultHighlightTemplate;                         		// 0x0B60 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_vaultHighlightMaxDist;                          		// 0x0B64 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_vaultHighlightFOV;                              		// 0x0B68 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_fireButtonActionTimeStamp;                      		// 0x0B6C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_coverButtonActionInterval;                      		// 0x0B70 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_specialMoveButtonActionInterval;                		// 0x0B74 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_fireButtonActionInterval;                       		// 0x0B78 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_doSpecialMoveTapTime;                           		// 0x0B7C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_doContextMoveTapTime;                           		// 0x0B80 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_quickTurnDuration;                              		// 0x0B84 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYGamePawn*                                  m_specialMoveMeleeTarget;                         		// 0x0B88 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYGamePawn*                                  m_specialMoveExecutionTarget;                     		// 0x0B8C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_executionMaxCamPitchAngle;                      		// 0x0B90 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UYSpecialMove_Execute*                       m_specialMoveExecute;                             		// 0x0B94 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYGamePawn*                                  m_specialMoveTarget;                              		// 0x0B98 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYRopeActor*                                 m_specialMoveFastRopeActor;                       		// 0x0B9C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYTrigger_ZiplineInteraction*                m_specialMoveZiplineTrigger;                      		// 0x0BA0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYTrigger_TurretInteraction*                 m_specialMoveTurretTrigger;                       		// 0x0BA4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_turretPitchModifierWhenBased;                   		// 0x0BA8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_turretRollModifierWhenBased;                    		// 0x0BAC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_turretYawModifierWhenBased;                     		// 0x0BB0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_swatTurnMaxInputAngle;                          		// 0x0BB4 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FString                                     m_specialMoveMessage;                             		// 0x0BB8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_contextMoveMessage;                             		// 0x0BC4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_agileMoveMessage;                               		// 0x0BD0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_spawnMessage;                                   		// 0x0BDC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_pickupMessage;                                  		// 0x0BE8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_interactionMessage;                             		// 0x0BF4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FVector2D                                   m_slipOutInViewDirectionRange;                    		// 0x0C00 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_slipOutMaxInputAngle;                           		// 0x0C08 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxManualDropDownCoverDistance;                 		// 0x0C0C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxManualDropDownCoverFOV;                      		// 0x0C10 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxAutomaticDropDownCoverDistance;              		// 0x0C14 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxAutomaticDropDownCoverFOV;                   		// 0x0C18 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxDropDownRotationDifference;                  		// 0x0C1C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxAutoDropDownHeight;                          		// 0x0C20 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector                                     m_dropDownCoverLocation;                          		// 0x0C24 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_ControlRestrictions                     m_controlRestrictions;                            		// 0x0C30 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FYS_ControlRestrictions                     m_controlRestrictionsCode;                        		// 0x0C34 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FYS_ControlRestrictions                     m_noControlCR;                                    		// 0x0C38 (0x0004) [0x0000000000000000]              
	class AYHUD*                                       m_myHUD;                                          		// 0x0C3C (0x0004) [0x0000000000000000]              
	class AYAnnouncer*                                 Announcer;                                        		// 0x0C40 (0x0004) [0x0000000000000000]              
	TArray< struct FPostProcessInfo >                  PostProcessPresets;                               		// 0x0C44 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UYUIScene_UIMessage* >               m_currentUIMessageScene;                          		// 0x0C50 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UYUIScene_GameOver*                          m_gameoverScene;                                  		// 0x0C5C (0x0004) [0x0000000000000000]              
	class UUIScene*                                    m_clientGameoverScene;                            		// 0x0C60 (0x0004) [0x0000000000000000]              
	class UYUIScene_GameOver*                          m_openedUISceneGameover;                          		// 0x0C64 (0x0004) [0x0000000000000000]              
	class UYUIFrontEnd_DifficultyScreen*               m_difficultyScene;                                		// 0x0C68 (0x0004) [0x0000000000000000]              
	class AYPickup_Collectable*                        m_currentCollectiblePickup;                       		// 0x0C6C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_deathloopDelay;                                 		// 0x0C70 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< class UCameraAnim* >                       m_deathLoopCameraAnims;                           		// 0x0C74 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FReverbSettings                             m_deathLoopReverbSettings;                        		// 0x0C80 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_MoodSetting                             m_deathLoopMood;                                  		// 0x0C90 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathLoopSlomoFactor;                           		// 0x0C9C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_deathLoopHoldTriggerInterval;                   		// 0x0CA0 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathloopFadeoutDelay;                          		// 0x0CA8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathloopFadeoutTime;                           		// 0x0CAC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathloopSustainTime;                           		// 0x0CB0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_DeathLoopData                           m_deathLoopData;                                  		// 0x0CB4 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_debugCamHeight;                                 		// 0x0CBC (0x0004) [0x0000000000000000]              
	float                                              m_debugCamMovementSpeed;                          		// 0x0CC0 (0x0004) [0x0000000000000000]              
	float                                              m_debugCamRotationSpeed;                          		// 0x0CC4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_lockedDebugCamLocation;                         		// 0x0CC8 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_lockedDebugCamRotation;                         		// 0x0CD4 (0x000C) [0x0000000000000000]              
	float                                              m_lockedDebugCamFOV;                              		// 0x0CE0 (0x0004) [0x0000000000000000]              
	class APawn*                                       m_pawnBeforeDebugSpectating;                      		// 0x0CE4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_stateBeforeDebugSpectating;                     		// 0x0CE8 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class ULocalPlayer*                                m_secondCamera;                                   		// 0x0CF0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYCameraActorDeathFromAbove*                 m_dfaCamera;                                      		// 0x0CF4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYAIFakeTarget*                              m_dfaFakeTarget;                                  		// 0x0CF8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_dfaCameraOffset;                                		// 0x0CFC (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScene_Mortar*                            m_dfaUIScene;                                     		// 0x0D08 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_dfaCachedHudSafeZone;                           		// 0x0D0C (0x0008) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_dfaCamSpeed;                                    		// 0x0D14 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_camShakeFadeTime;                               		// 0x0D18 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< class UCameraAnim* >                       m_standNormalCamShakes;                           		// 0x0D1C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnim* >                       m_standAimCamShakes;                              		// 0x0D28 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_standNormalCamShakeInstances;                   		// 0x0D34 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_standAimCamShakeInstances;                      		// 0x0D40 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_standScopeCamShakeInstances;                    		// 0x0D4C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnim* >                       m_walkNormalCamShakes;                            		// 0x0D58 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnim* >                       m_walkAimCamShakes;                               		// 0x0D64 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_walkNormalCamShakeInstances;                    		// 0x0D70 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_walkAimCamShakeInstances;                       		// 0x0D7C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_walkScopeCamShakeInstances;                     		// 0x0D88 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnim* >                       m_sprintCamShakes;                                		// 0x0D94 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_sprintCamShakeInstances;                        		// 0x0DA0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnim* >                       m_combatSprintCamShakes;                          		// 0x0DAC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_combatSprintCamShakeInstances;                  		// 0x0DB8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnim* >                       m_explosionCamShakes;                             		// 0x0DC4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_explosionCamShakeModifier;                      		// 0x0DD0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_explosionCamShakeOcclusionModifier;             		// 0x0DD4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_lastExplosionCamShake;                          		// 0x0DD8 (0x0004) [0x0000000000000000]              
	TArray< class UCameraAnim* >                       m_flybyCamShakes;                                 		// 0x0DDC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_camShakeModifier;                               		// 0x0DE8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverShakeModifier;                             		// 0x0DEC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_crouchShakeModifier;                            		// 0x0DF0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverShakeModifierScoped;                       		// 0x0DF4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_crouchShakeModifierScoped;                      		// 0x0DF8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sandstormCoverCamShakeModifier;                 		// 0x0DFC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sandstormCamShakeModifier;                      		// 0x0E00 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sprintCamShakeModifier;                         		// 0x0E04 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_damageCamShakeStrength;                         		// 0x0E08 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_DCSFromStrength;                                		// 0x0E0C (0x0004) [0x0000000000000000]              
	float                                              m_DCSTargetStrength;                              		// 0x0E10 (0x0004) [0x0000000000000000]              
	float                                              m_DCSInterpolationTime;                           		// 0x0E14 (0x0004) [0x0000000000000000]              
	float                                              m_DCSCurrentInterpolationTime;                    		// 0x0E18 (0x0004) [0x0000000000000000]              
	TArray< class UCameraAnim* >                       m_sandStormCamShakes_Normal;                      		// 0x0E1C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_sandStormCamShakeInstances_Normal;              		// 0x0E28 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnim* >                       m_sandStormCamShakes_Zoomed;                      		// 0x0E34 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_sandStormCamShakeInstances_Zoomed;              		// 0x0E40 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_nextHitCamShakeTime;                            		// 0x0E4C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_lastHitCamShakeDamageType;                      		// 0x0E50 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_lastCamMode;                                    		// 0x0E54 (0x0004) [0x0000000000000000]              
	int                                                m_lastToCamMode;                                  		// 0x0E58 (0x0004) [0x0000000000000000]              
	class AYCameraActor*                               m_currSpectatorPoint;                             		// 0x0E5C (0x0004) [0x0000000000000000]              
	TArray< class UClass* >                            m_hitFeedbackClass;                               		// 0x0E60 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UYIHitFeedback* >                    m_hitDirectionIndicator;                          		// 0x0E6C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FPointer                                    m_kynapseConnector;                               		// 0x0E78 (0x0004) [0x0000000000001000]              ( CPF_Native )
	class AYAIPlayerSquad*                             m_squad;                                          		// 0x0E7C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_criticalHealth;                                 		// 0x0E80 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FName                                       m_acceptedPawnName;                               		// 0x0E84 (0x0008) [0x0000000000000000]              
	float                                              m_tacViewInnerFov;                                		// 0x0E8C (0x0004) [0x0000000000000000]              
	float                                              m_tacViewScreenGraceDist;                         		// 0x0E90 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_currentSelectedTacticalMarkableBestScreenDist;  		// 0x0E94 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      m_currentSelectedTacticalMarkable;                		// 0x0E98 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      m_currentSelectedTacticalMarkableBuffer;          		// 0x0E9C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      m_currentSelectedTacticalMarkableCheckTarget;     		// 0x0EA0 (0x0004) [0x0000000000000000]              
	float                                              m_currentSelectedTacticalMarkableCheckTargetDist; 		// 0x0EA4 (0x0004) [0x0000000000000000]              
	int                                                m_currentSelectedTacticalMarkableChecks[ 0x2 ];   		// 0x0EA8 (0x0008) [0x0000000000000000]              
	class UYContextCommands*                           m_contextCommands;                                		// 0x0EB0 (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	struct FName                                       m_currentPawnNameToAttack;                        		// 0x0EB4 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_currentSquadNameToAttack;                       		// 0x0EBC (0x0008) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_attackMarkingModeDelay;                         		// 0x0EC4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class AEmitter*                                    m_squadPositionMarker;                            		// 0x0EC8 (0x0004) [0x0000000000000000]              
	class UParticleSystem*                             m_squadPositionMarkerTemplate;                    		// 0x0ECC (0x0004) [0x0000000000000000]              
	class UDecalComponent*                             m_squadPositionMarkerDecal;                       		// 0x0ED0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class AEmitter*                                    m_squadSuppressionMarker;                         		// 0x0ED4 (0x0004) [0x0000000000000000]              
	class UParticleSystem*                             m_squadSuppressionMarkerTemplate;                 		// 0x0ED8 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_squadSuppressionMarkerDecalTemplate;            		// 0x0EDC (0x0004) [0x0000000000000000]              
	class UDecalComponent*                             m_squadSuppressionMarkerDecal;                    		// 0x0EE0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_uiAudio;                                        		// 0x0EE4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UYSeqEvt_Interaction*                        m_interactEvent;                                  		// 0x0EE8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      m_currentInteractiveObject;                       		// 0x0EEC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_currentStunTime;                                		// 0x0EF0 (0x0004) [0x0000000000000000]              
	float                                              m_currentStunFadeOutTime;                         		// 0x0EF4 (0x0004) [0x0000000000000000]              
	float                                              m_stunDuration;                                   		// 0x0EF8 (0x0004) [0x0000000000000000]              
	float                                              m_stunFadeOut;                                    		// 0x0EFC (0x0004) [0x0000000000000000]              
	float                                              m_stunCrosshairVisibleRate;                       		// 0x0F00 (0x0004) [0x0000000000000000]              
	float                                              m_stunDamageRatio;                                		// 0x0F04 (0x0004) [0x0000000000000000]              
	float                                              m_stunVRotDamp;                                   		// 0x0F08 (0x0004) [0x0000000000000000]              
	float                                              m_stunHRotDamp;                                   		// 0x0F0C (0x0004) [0x0000000000000000]              
	struct FString                                     m_SceneDifficulty;                                		// 0x0F10 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class AYGamePawn* >                        m_DBNOTeammates;                                  		// 0x0F1C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FGuid                                       MyGuid;                                           		// 0x0F28 (0x0010) [0x0000000000000000]              
	float                                              LastCheckpointSaveTime;                           		// 0x0F38 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_SquadSpatialData                        m_checkpointSquadSpatialData;                     		// 0x0F3C (0x0078) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             m_RetrieveSettingsFromProfileDelegate;            		// 0x0FB4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UYAchievementManager*                        m_achievementManager;                             		// 0x0FC0 (0x0004) [0x0000000000000000]              
	float                                              m_lowHealthLowpassCutoff;                         		// 0x0FC4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lowHealthLowpassResonance;                      		// 0x0FC8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lowHealthLowpassBlendInTime;                    		// 0x0FCC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lowHealthLowpassBlendOutTime;                   		// 0x0FD0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_MoodSetting                             m_moodHealthCritical;                             		// 0x0FD4 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_dbnoLowpassCutoff;                              		// 0x0FE0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_dbnoLowpassResonance;                           		// 0x0FE4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_dbnoLowpassBlendInTime;                         		// 0x0FE8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_dbnoLowpassBlendOutTime;                        		// 0x0FEC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_MoodSetting                             m_moodDBNO;                                       		// 0x0FF0 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_explosionLowpassCutoff;                         		// 0x0FFC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_explosionLowpassResonance;                      		// 0x1000 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_explosionHighpassCutoff;                        		// 0x1004 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_explosionHighpassResonance;                     		// 0x1008 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_explosionFiltersBlendInTime;                    		// 0x100C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_explosionFiltersBlendOutTime;                   		// 0x1010 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_MoodSetting                             m_moodExplosion;                                  		// 0x1014 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_explosionSFXMaxDist;                            		// 0x1020 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FString                                     m_currentPlayerActionSetName;                     		// 0x1024 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_reduceDifficultyThreshold;                      		// 0x1030 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FScriptDelegate                             __OnResult__Delegate;                             		// 0x1034 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnCleanupFinished__Delegate;                    		// 0x1040 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnRetrieveSettingsFromProfileFinished__Delegate;		// 0x104C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1506 ];

		return pClassPointer;
	};

	struct FString GetRequiredDLCSimpleName ( );
	void NotifyUserAboutRemovedDLC ( );
	struct FString GetLocalizedString ( unsigned char stringType );
	void SetConnectionErrorMissingPackageName ( struct FString* PackageName );
	void GetConnectionErrorMissingPackageName ( struct FString* PackageName );
	void ClientOnCoopDifficultyChanged ( int NewDifficulty );
	void ClientOnUI_Close_COOP_Counter ( );
	void ClientOnUI_COOP_Counter ( struct FString Description, int value_max, int value_current );
	void ClientOnUI_Close_COOP_Timer ( );
	void ClientOnUI_COOP_Timer ( int Value );
	void ClientOnUI_Close_COOP_Objective ( );
	void ClientOnUI_COOP_Objective ( struct FString Message, float Duration );
	void ClientHideLoadingMovie ( );
	void OnHideLoadingMovie ( class UYSeqAct_HideLoadingMovie* act );
	class ULocalPlayer* GetALocalPlayer ( );
	bool GetGameConfigFloat ( struct FString Section, struct FString Key, float* FloatValue );
	bool GetGameConfigBool ( struct FString Section, struct FString Key, int* boolValue );
	void QuitMatchMakingAndReturnToMainMenu ( );
	bool HasMatchingCRC ( class UOnlineGameSettings* InviteSettings );
	void ReturnPartyLeaderToMultiplayerMenu ( );
	void ReturnNonPartyLeaderToMultiplayerMenu ( );
	void ClearPersistentLineCheckStats ( );
	void SetMaxDistributedLineChecks ( int maxpertick );
	void SetTaskPoolThreadMaxCosts ( int maxcosts );
	void SetTaskPoolPS3Priority ( int prio );
	void SetTaskPoolSleepTime ( float Seconds );
	void SetAiTime ( float milliSeconds );
	bool IsDLCInstalled ( struct FString simpleDLCName );
	void GetFriendlyDLCNames ( struct FString simpleDLCName, TArray< struct FString >* friendlyDLCNames );
	void ClientCleanupFModRuntimeData ( );
	void ClientUpdateAllChatParticipants ( );
	void ClientRemoveLanChatParticipant ( struct FUniqueNetId PlayerID );
	void ServerRemoveLanChatParticipant ( );
	void ClientAddLanChatParticipant ( struct FUniqueNetId PlayerID, struct FString networkAddress, int Index );
	void ClientRemoveAllLanParticipants ( );
	void ServerAddLanChatParticipant ( );
	void UpdateLanParticipantList ( );
	int GetLanParticipantMemberID ( struct FUniqueNetId PlayerID );
	void RemoveAllLanParticipants ( );
	void RemoveLanParticipant ( struct FUniqueNetId PlayerID );
	int AddLanParticipant ( struct FUniqueNetId PlayerID, struct FString networkAddress, int Index );
	void OnTitleChanged ( );
	void OnBadgeChanged ( );
	void ToggleRevisionNumber ( );
	void SetPauseIconVisibility ( unsigned long vis );
	bool SetPause ( unsigned long bPause, struct FScriptDelegate CanUnpauseDelegate );
	void OnHitTaken ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void WarmupPause ( unsigned long bDesiredPauseState );
	void OnSetSquadEvolution ( class UYSeqAct_SetSquadEvolution* seqAct );
	void ResetPlayerSquad ( );
	void OnSetSpecialActionSetList ( class UYSeqAct_SetSpecialActionSetList* Action );
	void UploadProfileToMCP ( );
	void ResetParentalChatRestrictionWarning ( );
	void ToggleDBNO ( );
	void testintelmsg ( );
	void testobjective ( unsigned char O, int I, unsigned long C );
	void PlayStunnedEffect ( float Damage );
	void UpdateStunEffect ( float DeltaTime );
	void SetC4Launched ( unsigned long bC4Launched );
	void OnPawnChanged ( );
	void OnWeaponChanged ( );
	void SetCurrentGrenade ( unsigned char gt );
	void SetGrenadeType ( unsigned char eGrenade );
	bool OnWarnAboutParentalChatRestrictionAccepted ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void WarnAboutParentalChatRestriction ( );
	bool IsOnlineGame ( );
	void ClientTakeDownWaitingForHostScreen ( );
	void ServerClientFinishedLoading ( );
	void ShowWaitingForHostScreen ( );
	void ForceSetPresentDelay ( int nDelayFrames );
	void ClientShowLoadingMovie ( unsigned long bShowMovie, unsigned long bPauseAfterHide, float PauseDuration, float KeepPlayingDuration, unsigned long OverridePreviousDelays );
	void ClientKeepPlayingLoadingMovie ( );
	bool IsPlayingFullscreenMovie ( );
	bool IsPlayingLoadingMovie ( );
	void ServerVoiceHandshakeComplete ( );
	void CompleteVoiceHandshake ( );
	void StartClientVoiceHandshake ( );
	void ClientSetRichPresenceString ( int stringId );
	void SetRichPresenceString ( int stringId );
	void NotifyConnectionError ( struct FString Message, struct FString Title, unsigned long bAllowSecondAcceptInviteAttempt );
	int ClientGetProfileStat ( int StatId );
	void ClientSetProfileStat ( int StatId, int Value );
	void ClientAddProfileStat ( int StatId, int Value );
	class UYProfileSettings* GetProfile ( );
	void GetDeaths ( );
	bool IsPlayInEditorGame ( );
	void ServerChangeMap ( struct FString URL );
	void SetSoundVolume ( class AActor* A, class UYSeqAct_SetSoundVolume* Action );
	void ClientSetSoundVolume ( class AActor* A, class UYSeqAct_SetSoundVolume* Action );
	void OnSetSoundVolume ( class AActor* A, class UYSeqAct_SetSoundVolume* Action );
	void ClientDisableOverrideDuckingSettings ( class UYSeqAct_OverrideDuckingSettings* Action );
	void ClientEnableOverrideDuckingSettings ( class UYSeqAct_OverrideDuckingSettings* Action );
	void ClientInterpolateFMODParam ( class UYSeqAct_SetFMODParam* Action, class AActor* TargetActor, class USoundCue* Cue, struct FName ParamName, float TargetValue, float Duration );
	void ClientSetFMODParam ( class UAudioComponent* audioComp, struct FName ParamName, float TargetValue );
	void OnSetParamEQ ( class UYSeqAct_SetParamEQ* seqAct );
	void OnSetHighPassFilter ( class UYSeqAct_SetHighPassFilter* seqAct );
	void OnSetLowPassFilter ( class UYSeqAct_SetLowPassFilter* seqAct );
	void OnClearMoodOveride ( class UYSeqAct_ClearMoodOverride* seqAct );
	void OnSetMood ( class UYSeqAct_SetMood* seqAct );
	void OnStopOverrideReverb ( );
	void OnOverrideReverb ( struct FReverbSettings Settings );
	void StopOverrideReverb ( );
	void OverrideReverb ( struct FReverbSettings Settings );
	void ResetVolumes ( );
	void Volume ( struct FString categoryName, float Level );
	void TakeMood ( struct FString moodName );
	void SetMood ( class UYMoodSetup2* mood, float InterpolationTime, unsigned long useOverride );
	void StartSound ( struct FString SoundCueName );
	void ParamEQ ( unsigned long Activate, float centerFrequency, float bandwidth, float gain, float Time );
	void Highpass ( unsigned long Activate, float cutoff, float resonance, float Time );
	void Lowpass ( unsigned long Activate, float cutoff, float resonance, float Time );
	void StartSoundNative ( struct FString SoundCueName );
	void SetParamEQ ( unsigned long Activate, float centerFrequency, float bandwidth, float gain, float Time, unsigned long useSecondary );
	void SetHighPass ( unsigned long Activate, float cutoff, float resonance, float Time, unsigned long useSecondary );
	void SetLowPass ( unsigned long Activate, float cutoff, float resonance, float Time, unsigned long useSecondary );
	void DisableDBNOSFX ( unsigned long hardDisable );
	void EnableDBNOSFX ( );
	void DisableLowHealthSFX ( unsigned long hardDisable );
	void EnableLowHealthSFX ( );
	void DisableExplosionSFX ( unsigned long hardDisable );
	void EnableExplosionSFX ( float sfxDuration );
	void ClientFadeMusicVolume ( float targetVolume, float FadeTime );
	void ClientToggleMusicPause ( );
	void ClientStopMusicPlayback ( );
	void ClientConditionalStopMusicPart ( class UYMusicPart* track );
	void ClientUpdateMusicPart ( class UYMusicPart* track, float FadeIn, float FadeOut );
	bool GetKeyStringFromAliasMap ( struct FString ActionName, class ULocalPlayer* LocalPlayer, struct FString* KeyString );
	void ClientUpdateMusicPartInternal ( class UYMusicPart* track, float FadeIn, float FadeOut );
	void YKismet_ClientPlaySound ( class USoundCue* ASound, class AActor* SourceActor, float VolumeMultiplier, float PitchMultiplier, float rangeMultiplier, float FadeInTime, unsigned long bSuppressSubtitles, unsigned long bSuppressSpatialization );
	void ClientHearSound ( class USoundCue* ASound, class AActor* SourceActor, struct FVector SourceLocation, unsigned long bStopWhenOwnerDestroyed, unsigned long bIsOccluded );
	void TestSetLocation ( );
	void TestMarkerAnim ( );
	void PrintRevisionNumber ( );
	void ToggleFPSCounter ( );
	struct FString GetActorInScreenCenter ( );
	void ChangeInputStyle ( struct FString Style );
	struct FString GetCurrentInputStyle ( );
	void TravelMap ( struct FString Map );
	void ToggleAIDebugCharacter ( );
	void SaveObjConf ( struct FString ObjName );
	void TestFootPlacement ( unsigned long enableZSmoothing, unsigned long enableFootControls );
	void ToggleShowCoverTagging ( );
	void DebugDrawPerceivedCover ( );
	void DebugDraw_NearCover ( class AYHUD* HUD, float* out_YL, float* out_YPos );
	void ClientCommitMapChange ( );
	void ClientMeshFixupHack ( class AYGamePawn* P );
	void ApplyCheckpointRecord ( struct AYPlayerController_FCheckpointRecord* Record );
	void IncreaseDeathCounter ( unsigned long Ammo, unsigned long Difficulty );
	void ResetDeathCounter ( unsigned long Ammo, unsigned long Difficulty );
	void IncreaseAmmoAfterCheckpointReload ( class AYWeapon* Weapon, int increaseAmmoStage );
	void ApplyArsenalRecords ( TArray< struct FYWeaponRecord >* weaponRecords, TArray< struct FYGrenadeRecord >* grenadeRecords );
	void ServerCheckpointResetComplete ( );
	void ClientCheckpointReset ( );
	void ClientResetObjectPool ( unsigned long bClearActive );
	void CreateCheckpointRecord ( struct AYPlayerController_FCheckpointRecord* Record );
	void ClientLoadCheckpoint ( struct FYS_SquadSpatialData spatialData );
	void CheckpointStopAllVoiceovers ( );
	bool OnLoadCheckpointFailed ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void LoadCheckpointFailed ( );
	void DumpGameData ( struct FYS_GameDumpNode* Node );
	class UYGameDump* DumpGameCreateDump ( unsigned long focusedActorOnly );
	void DumpFocusedActorToLog ( unsigned long dumpObjects );
	void DumpGameToPropertyWindow ( );
	void DumpGameToLog ( unsigned long dumpObjects );
	void LoadCheckpoint ( unsigned long fadeToWhitePossible );
	void SetActiveSlot ( int Idx, unsigned long overwrite );
	void LoadSlot3 ( );
	void LoadSlot2 ( );
	void LoadSlot1 ( );
	void LoadSlot0 ( );
	void DisplayReselectStorageDevicePrompt ( );
	void OnDeviceSelectionComplete ( unsigned long bWasSuccessful );
	bool OnStorageDeviceLost_OptionChosen ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	bool OnStorageDeviceFull_OptionChosen ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void DisplayInvalidStorageDevicePrompt ( );
	void DisplayInsufficientStorageSpacePrompt ( );
	bool OpenStorageDevicePrompt ( struct FName SceneTag, struct FString Title, struct FString Message, TArray< struct FName > ButtonAliases, struct FScriptDelegate SelectionCallback );
	void testmessagebox ( );
	void ClientNotifySavingCheckpoint ( );
	void SaveCheckpointWorker ( );
	void SaveCheckpoint ( );
	bool OnCheckpoint ( class UYSeqAct_Checkpoint* Action );
	void UpdateMissionCompletedAchievement ( class UYProfileSettings* Profile );
	bool OnCheckpointMissionCompleted ( unsigned char mission, unsigned char Difficulty );
	void DelayedSaveCheckpoint ( );
	void ServerNotifyClientLoadedCheckpoint ( );
	void unfreeze ( );
	void freeze ( );
	void GetSeamlessTravelActorList ( unsigned long bToEntry, TArray< class AActor* >* ActorList );
	void LogRespawnDelay ( );
	float GetRespawnDelay ( );
	void EnableClearScreen ( unsigned long Enable );
	void ShowControllerDisconnectMessage ( );
	void OnControllerChanged ( int ControllerId, unsigned long bIsConnected );
	void OnExternalUIChanged ( unsigned long bIsOpening );
	void StartSpectate ( );
	void SetPreferredPeekDirection ( unsigned char NewDir );
	void DelayedReenableRaiseWeaponTest ( );
	void Raycast ( unsigned long hasExtent );
	void ClientPawnDied ( );
	void ClientRoundEnded ( class AActor* EndRoundFocus );
	void RoundHasEnded ( class AActor* EndRoundFocus );
	void ClientGameEnded ( class AActor* EndGameFocus, unsigned long bIsWinner );
	void GameHasEnded ( class AActor* EndGameFocus, unsigned long bIsWinner );
	void UpdateDBNOTeammates ( );
	void AddDBNOTeammate ( class AYGamePawn* P );
	bool IsDeadOrDown ( );
	void ServerCommitSuicideAfterDBNO ( );
	void ServerTryToReviveSelf ( );
	void ServerKickBan ( struct FString PlayerToKick, unsigned long bBan );
	void SetBinkVolume ( float vol );
	void FMODWRL ( );
	void ToggleFMODWeaponReverbLocation ( );
	void FMODMS ( );
	void FMODLM ( );
	void LogMoodChanges ( );
	void FreeEventData ( );
	void MoodDebug ( );
	void ToggleFMODMemStats ( );
	void ToggleFMODLevelMeterUpdate ( );
	void LowerAllFMODDebugFlags ( );
	void RaiseAllFMODDebugFlags ( );
	void ResetFMODDebugFlags ( );
	void LowerFMODDebugFlag ( struct FString flag );
	void RaiseFMODDebugFlag ( struct FString flag );
	void FMODDebug ( );
	void ToggleFMODDebugVis ( );
	void ToggleAudio ( );
	void ToggleAudioDevice ( );
	void RegisterJoinOnlineCallback ( );
	struct FRotator GetRotation ( );
	void CancelSmoothRotationInterpolator ( );
	void UpdateSmoothRotationInterpolator ( float DeltaTime, struct FRotator* Rot );
	bool IsSmoothRotationInterpolationActive ( );
	void RotateByOffset ( int Yaw, float Duration, float Delay, float smoothingExp );
	void UpdateRotation ( float DeltaTime );
	bool HasMoveInput ( );
	void UpdateLocation ( );
	void OnTogglePlayerStats ( class UYSeqAct_TogglePlayerStats* inAction );
	class AYPlayerReplicationInfo* GetViewTargetPRI ( );
	class AYPlayerReplicationInfo* GetPRI ( );
	void ResetSpectatedCamState ( );
	void ServerViewPrevSpectatorPoint ( unsigned long forceViewPlayer );
	void ServerViewNextSpectatorPoint ( unsigned long forceViewPlayer );
	void ServerViewFirstSpectatorPoint ( unsigned long forceSpectateView );
	void GetSpectatedPawnData ( class AYPlayerController* otherPawnController );
	void InitCamForSpectating ( );
	void EndViewTarget ( class APlayerController* PC );
	void BecomeViewTarget ( class APlayerController* PC );
	void SetViewTarget ( class AActor* NewViewTarget, struct FViewTargetTransitionParams TransitionParams );
	void ClientSetViewTarget ( class AActor* A, struct FViewTargetTransitionParams TransitionParams );
	void UnreliableClientSetViewTarget ( class AActor* A, struct FViewTargetTransitionParams TransitionParams );
	void ClientBecameActivePlayer ( );
	void BecomeActivePlayer ( );
	void ClientBecameSpectator ( unsigned long specOnly );
	void BecomeSpectator ( );
	void ClientPlayerWaiting ( );
	void ServerSpectate ( );
	void ClientSpectate ( );
	void ForceSpectating ( );
	void SpectateMode ( unsigned long spect );
	void unspec ( );
	void spec ( );
	void SetGamepadControls ( int scheme );
	void ShowGamepadControlsHelp ( );
	void DisableViewAcceleration ( );
	void EnableViewAcceleration ( );
	void ClearViewAcceleration ( );
	void SetCurrentInputScheme ( unsigned char inputScheme );
	class UYGamepadInputScheme* GetInputScheme ( );
	unsigned char GetCurrentInputScheme ( );
	void TogglePause ( );
	void ClientSetMoveCamShakes ( unsigned long Enable );
	void ServerSetMoveCamShakes ( unsigned long Enable );
	void ClientInterpolateDamageCamShakeStrength ( float TargetStrength, float InterpolationTime );
	void ServerInterpolateDamageCamShakeStrength ( float TargetStrength, float InterpolationTime );
	void OnSetDamageCamShakeStrength ( class UYSeqAct_SetDamageCamShakeStrength* Action );
	float GetCamShakeStrengthModifier ( );
	void PlayHitCamShake ( class UClass* dTypeClass );
	void PlayExecutionHitForceFeedback ( );
	void OnMeleeAttack ( struct FVector Dir, float Strength );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void OnExplosion ( struct FVector Loc, float Dist, float Damage, float Radius, float sfxDuration );
	bool DisableDeathFromAbove ( );
	bool EnableDeathFromAbove ( class AYCameraActorDeathFromAbove* Camera, class AYAIFakeTarget* fakeTarget );
	void OnDeathFromAbove ( class UYSeqAct_DeathFromAbove* Action );
	void OnCamOverrideFOV ( class UYSeqAct_CamOverrideFOV* Action );
	void OverrideCamMode ( class UYSeqAct_CamOverrideMode* Action );
	void ClientOverrideCamMode ( class UYSeqAct_CamOverrideMode* Action );
	void OnCamOverrideMode ( class UYSeqAct_CamOverrideMode* Action );
	void StopCamShake ( class UCameraAnimInst* cameraAnimInstance, unsigned long immediately );
	class UCameraAnimInst* PlayCamShake ( class UCameraAnim* Anim, float Rate, float Scale, float FadeInTime, float FadeOutTime, unsigned long looped, unsigned long randomStartTime );
	void UpdateSandstormCamshakesOnCoverChange ( );
	void StartSandstormCamshakes ( unsigned long zoomed );
	void ClearSandstormCamshakes ( );
	void ClearMoveCamShakes ( );
	void UpdateCamShakes ( );
	void SetMoveCamShakes ( unsigned long Enable );
	void OnSprintCamAnimationEnd ( );
	void StopSprintCamAnimation ( unsigned long combatSprint );
	void StartSprintCamAnimation ( unsigned long combatSprint );
	void StopSprintCamShakes ( unsigned long combatSprint );
	void StartSprintCamShakes ( unsigned long combatSprint );
	void StopWalkCamShakes ( );
	void StartWalkCamShakes ( unsigned long Crouched, unsigned long aiming, unsigned long scoping, unsigned long inCover );
	void StopStandCamShakes ( );
	void StartStandCamShakes ( unsigned long Crouched, unsigned long aiming, unsigned long scoping, unsigned long inCover );
	float GetScopingShakeModifier ( );
	void CamFocusDebug ( unsigned long Enable );
	void LogCurrentHealth ( );
	void DebugDrawHitFeedback ( class AYHUD* HUD, float out_YL, float out_YPos );
	void OnLastWarningChanged ( unsigned long Activated );
	void OnAboveCriticalHealth ( float Pct );
	void OnBelowCriticalHealth ( float Pct );
	void PlayStartUpMessage ( unsigned char StartUpStage, class UClass* statupMsgClass );
	void ClientCloseOpenedGameoverScene ( );
	void OnDifficultyLevelSelectedForReload ( unsigned char Difficulty );
	void OnCloseDifficultyScreen ( class UUIScene* Scene );
	void OpenSelectDifficultyMenu ( );
	bool ReduceDifficultyValidate ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void OpenReduceDifficultyQuestion ( );
	void OnGameoverDeactivate ( );
	void CancelDeathLoopEffects ( unsigned long hardDisable );
	void FinishDeathloop ( );
	void FadeMasterVolume ( float Volume, float Duration );
	void StopDeathLoopSoundFX ( float FadeTime, unsigned long noFadeOut );
	void ClientFinishCameraFadeInTime ( float NewTime );
	void AutoFinishDeathloop ( float FadeOutTime );
	void HitFeedbackInstantRecoverBuckets ( );
	void SetHitFeedbackOverallOpacity ( float Value );
	void OnClosedGameoverScene ( class UUIScene* DeactivatedScene );
	void StartDelayedDeathloopEffects ( );
	void DelayedStopFire ( );
	void StartDeathLoop ( );
	void ClientStartDeathloop ( );
	void GameOver ( );
	void OnToggleSPGameOver ( class UYSeqAct_ToggleSPGameOver* Action );
	void ToggleSPGameOver ( );
	void SetSPGameOver ( unsigned long Enable );
	void CancelCine ( float initialNoSkipTime );
	void CancelCineB ( );
	void CancelCineA ( );
	bool IsPS3UseCircleToAccept ( );
	class UUIScene* OpenUISceneByName ( struct FString TemplateString, unsigned char ForcedPriority, unsigned long ForcedCloseScene );
	class UUIScene* OpenUIScene ( class UUIScene* Template, unsigned char ForcedPriority, unsigned long ForcedCloseScene );
	void ResetGrenadeTutorialShown ( );
	bool ShowGrenadeTutorial ( );
	unsigned char GetSpecialActionMessage ( unsigned char Action );
	bool AppendMessage ( struct FString msgToAppend, struct FString* msg );
	void UpdateHUDActions ( float DeltaTime );
	struct FString GetSpecialHUDMessage ( struct FString msg );
	void GetSpecialMoveMessages ( );
	class UYUIScene_UIMessage* ClientOnUIMessage ( struct FString Message, struct FString headline, float Duration, class UYUIScene_UIMessage* SceneTemplate );
	void ClientCloseUIScene ( class UYUIScene_UIMessage* uiMsgScene );
	void OnUIMessageClosed ( class UUIScene* DeactivatedScene );
	void OnUIMessage ( class UYSeqAct_UIMessage* act );
	void OnChapterDisplay ( class UYSeqAct_ChapterDisplay* act );
	bool IsShowingFullScreenUI ( );
	bool IsShowingMessageBox ( );
	bool IsShowingScoreboard ( );
	bool IsShowingMidGameMenu ( );
	void HideMidGameMenu ( );
	class UYUIScene_MidGameMenu* ShowMidGameMenu ( struct FName TabTag, unsigned long bEnableInput );
	bool GamePad_SwitchTeams ( );
	bool GamePad_SkipKillCamera ( );
	bool GamePad_MPSpectateNextCamera ( );
	bool GamePad_MPSpectatePreviousCamera ( );
	bool GamePad_MPSkipChoreo ( );
	bool GamePad_MPOpenCharacterSelectionMenu ( );
	bool GamePad_MPCallForHelpOrRevive ( );
	bool GamePad_MPSuicide ( );
	bool GamePad_ShowShellMenu ( );
	class UUTGameViewportClient* GetGameViewportClient ( );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	float GetRelativeAngle2D ( struct FVector otherLoc );
	void DrawHUD ( class AHUD* H );
	void DrawHUDNative ( class AHUD* HUD );
	void SpawnDefaultHUD ( );
	void ClientSetHUD ( class UClass* newHUDType );
	void CheckForInteractionEvents ( );
	bool CanInteract ( );
	void ActivateReplicatedEvent ( struct FName EventName );
	void SetSquadStatus ( unsigned char squadState );
	void BroadCastSquadCommand ( struct FYS_ContextCommandInfo Command );
	void PlaceSuppressionMarker ( struct FVector Loc, struct FVector Normal );
	void PlaceGotoMarker ( struct FVector Loc, struct FVector Normal );
	void RemoveSuppressiveFireMarker ( );
	void RemoveGotoMarker ( );
	void OnSetGeneralCommand ( class UYSeqAct_SetGeneralCommand* Action );
	bool GamePad_EndAContextSensativeMove ( );
	bool GamePad_StartAContextSensativeMove ( );
	bool GamePad_OfficerSupplyDrop ( );
	bool GamePad_OfficerObjectiveRelease ( );
	bool GamePad_OfficerObjectivePress ( );
	bool GamePad_ToggleMinimapZoom ( );
	bool GamePad_ToggleMinimap ( );
	void ResetGrenadeBlockedByToggleReplication ( );
	bool GamePad_PrevGrenadeType ( );
	bool GamePad_NextGrenadeType ( );
	bool GamePad_NextWeaponIfNoPickup ( );
	void ConditionalStopContextCommandAnim ( );
	void IssueContextCommand ( struct FYS_ContextCommandInfo Command, unsigned long issuedFromKismet );
	void OnIssueScanCommand ( class UYSeqAct_IssueScanCommand* Action );
	void OnIssueSquadCommand ( class UYSeqAct_IssueSquadCommand* Action );
	void ActivateAttackMarkingMode ( );
	bool GamePad_QuickCommand ( );
	void StopCommandMode ( );
	bool IssuePointCommandReleasedInternal ( unsigned long cancelled );
	bool GamePad_IssuePointCommandReleased ( );
	bool GamePad_IssuePointCommand ( );
	bool GamePad_InjectAdrenaline ( );
	void SetAsAttackTargets ( class AYAISquad* squad );
	void SetAsAttackTarget ( class AActor* act );
	void ClearAttackTarget ( class AActor* act );
	void debugTacView ( );
	void ResetTacticalSelections ( );
	void SetAsCurrentSelectedMarkable ( class AActor* markable, float screenDistFromCenter );
	bool IsHealCommandRestricted ( );
	bool IsAttackCommandRestricted ( );
	class AYAISquad* SetSquadName ( struct FName NewSquadName, unsigned long bLeader );
	class AYAISquad* GetSquad ( );
	struct FName GetSquadName ( );
	class AYGamePawn* GetSquadLeader ( );
	bool IsLeader ( );
	void ServerBecomeLeader ( class AYPlayerController* C );
	void BecomeLeader ( );
	void PlayAnnouncement ( class UClass* InMessageClass, int MessageIndex, class APlayerReplicationInfo* PRI, class UObject* OptionalObject );
	void ClientPlayAnnouncement ( class UClass* msgClass, unsigned char MessageIndex );
	void announce ( );
	void ToggleAiming ( );
	void TestSpeakerMessage ( );
	void OnStopExecution ( );
	void OnStartExecution ( );
	void OnStopDownButNotOut ( );
	void OnStartDownButNotOut ( );
	void OnStopLeanOverCover ( );
	void OnStartLeanOverCover ( );
	void OnCoverLost ( unsigned char Reason );
	void EnableReenterCover ( );
	void SetReenterCoverPossible ( unsigned long Enable );
	void EnablePullAwayFromCover ( );
	void SetPullAwayFromCoverPossible ( unsigned long Enable );
	bool CamShouldMirrorOnCoverLeave ( );
	void OnLeaveCover ( );
	bool ShouldReturnToWalkingState ( );
	bool LeaveCoverInternal ( unsigned long noLeaveCoverSpecialMove );
	void ServerSetPawnRaiseWeapon ( unsigned long raise );
	void UpdateForceRaiseWeapon ( );
	void ForceRaiseWeapon ( unsigned long Force );
	void OnCombatSituationChanged ( unsigned long IsInCombat );
	void OnEnterCover ( );
	bool CheckConditionalEnterCover ( unsigned long byLocation, unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, struct FYS_CoverData* coverData );
	bool IsCoverLocationOccupied ( struct FVector coverLocation, unsigned long skipAI );
	bool ConditionalEnterCover ( unsigned long byLocation, unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, unsigned long checkIfOccupied, unsigned long skipAIForOccupation );
	bool EnterCover ( unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition );
	bool IsCloseToCover ( );
	bool FindAvailableTeleportSpot ( class APawn* TestPawn, class ANavigationPoint* TeleportAnchor, unsigned long bSkipRadiusSearch );
	void HandleTeleport ( class USeqAct_Teleport* Sequence, struct FVector inLoc, struct FRotator inRot, unsigned long abortBehavior );
	void GetMovementDirectionForStartSprint ( unsigned char* moveDir, struct FRotator* moveRot );
	unsigned char GetMovementDirection ( );
	bool DoDropDown ( );
	bool CheckDropDown ( struct FVector* coverLocation );
	bool AllowMoveOverLedge ( );
	void ResetHealthSystem ( );
	void DestroyTickingBombs ( );
	void OnToggleCinematicMode ( class USeqAct_ToggleCinematicMode* Action );
	void ServerClearControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	void ClearControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	void RestoreSquadControl ( );
	void ServerSetControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	void CheckSquadCommandCancelledByCR ( struct FYS_ControlRestrictions* controlRestrictions );
	void SetControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	bool IsLookInputIgnored ( );
	bool IsMoveInputIgnored ( );
	bool SprintCoverDashEnabled ( );
	bool AutoLookAtEnabled ( );
	bool AimDownLockEnabled ( );
	bool BlindfireRestricted ( );
	bool PeekingRestricted ( );
	bool AutoRaiseWeapon ( );
	void SetAutoTakeDownWeapon ( unsigned long Enable );
	bool AutoTakeDownWeapon ( );
	bool ShouldSynchronizeAIThread ( );
	void OnStateChangeFinished ( unsigned char lastMainState, unsigned char lastSubstate, unsigned char newMainState, unsigned char newSubstate );
	bool CheckForStep ( class APawn* P, struct FVector Direction, float MaxDistance, float MinHeight, float MaxHeight, unsigned long useDebugOutput, struct FVector* stepLocation, float* stepDistance );
	bool DoTurretUse ( unsigned char specialMove );
	unsigned char CheckTurretUse ( );
	void ClientEnableZipLine ( class AYTrigger_ZiplineInteraction* zipLine, unsigned long bEnable );
	bool DoZipline ( unsigned char specialMove );
	unsigned char CheckZipline ( );
	bool DoFastRope ( unsigned char specialMove );
	unsigned char CheckFastRope ( );
	void GetMovementOrientationForIntoCover ( unsigned char* movementDirection, struct FRotator* movementRotation );
	unsigned char DetermineSlipOutAction ( unsigned long Crouched, struct FRotator controllerRotation, unsigned long doMelee );
	unsigned char DetermineSwatTurnAction ( unsigned char coverStance );
	bool DoMoveIntoCover ( unsigned char specialMove );
	unsigned char CheckMoveIntoCover ( );
	unsigned char CheckMoveOverCover ( unsigned long sprintVault );
	void UpdateFireButtonAction ( unsigned long updateNow );
	void UpdateSpecialMoveAutoButtonAction ( unsigned char buttonType );
	void UpdateSpecialMoveButtonAction ( unsigned char buttonType, unsigned long updateNow );
	void UpdateEnterCoverButtonAction ( unsigned long updateNow );
	bool CanDoButtonAction ( );
	void ForceSpecialMoveButtonActionUpdate ( );
	void OnWeaponFired ( );
	void ReceivedNewEvent ( class USequenceEvent* Evt );
	void StopBlindfire ( );
	void StopReloadByInterrupt ( );
	bool StopSecondaryByInterrupt ( unsigned long noRefire, unsigned long forceInterrupt );
	bool StopSecondaryWeaponFunction ( );
	void StartSecondaryWeaponFunction ( );
	bool GamePad_StopSecondaryWeaponFunction ( );
	bool GamePad_StartSecondaryWeaponFunction ( );
	bool GamePad_StopPrimaryWeaponFunction ( );
	bool GamePad_StartPrimaryWeaponFunction ( );
	void OnEndReloadWeapon ( );
	void OnStartReloadWeapon ( );
	void AdviseReload ( );
	bool IsFireRestricted ( );
	void ReloadWeapon ( );
	void ReloadActionRelease ( );
	void WeaponQuickSelection ( );
	bool GamePad_StopPickup ( );
	bool GamePad_Pickup ( );
	void SwitchToWeaponCat ( unsigned char nextCat );
	void PrevWeapon ( );
	bool GamePad_NextWeapon ( );
	void ReleaseGrenade ( );
	void ThrowGrenade ( );
	class UPostProcessEffect* GetPostProcessEffect ( struct FName EffectName );
	class UMaterialEffect* EnablePostProcessEffect ( struct FName EffectName, unsigned long Enable );
	unsigned char GetCurrentPostProcessStyle ( );
	void StopPostProcess ( );
	void StartPostProcess ( unsigned char Style, float FadeInTime );
	void OnAimingSnapOnCompleted ( );
	bool TriggerAimingSnapOn ( );
	void OnDisableZoom ( );
	bool SupportsAimSnapOn ( );
	void OnEnableZoom ( );
	void ToggleZoomMode ( );
	void DisableZoomMode ( );
	bool GamePad_DisableZoomModeByZoomButton ( );
	bool EnableZoomMode ( );
	bool GamePad_EnableZoomModeByZoomButton ( );
	void UpdateSprinting ( float DeltaTime );
	float GetSprintMaxTime ( );
	void StopSprintInternal ( unsigned long doSlide );
	void StopSprintImmediately ( );
	void StopSprint ( );
	void StopSprintBySprintButton ( );
	bool GamePad_StopSprintIfSprinting ( );
	bool StartSprintInternal ( );
	bool StartSprint ( unsigned long combatSprint, unsigned long noStartSprintTransition );
	bool GamePad_StartCombatSprintAction ( );
	void OnFinishedSlipout ( );
	bool GamePad_SprintButtonReleased ( );
	bool GamePad_SprintButtonPressed ( );
	void HandleWalking ( );
	void StopWalk ( );
	void StartWalk ( );
	bool GamePad_ReleasePOI ( );
	bool GamePad_FocusPOI ( );
	bool GamePad_ToggleCameraSide ( );
	bool GamePad_ToggleCollectibleDetails ( );
	bool GamePad_TogglePauseOrScoreboard ( );
	bool GamePad_ToggleScndWeaponMode ( );
	bool GamePad_ToggleCrouch ( );
	bool DoCoverButtonAction ( unsigned long doMoveIntoCoverOnly );
	void EnableCoverInternal ( unsigned long wantsToCover );
	void EnableCover ( unsigned long wantsToCover );
	void EnableCrouchInternal ( unsigned long newCrouch );
	void ToggleCoverMode ( );
	void ClientOnMoveIntoCoverFailed ( );
	void OnMoveIntoCoverFailed ( );
	void DisableCover ( );
	void DisableCrouch ( );
	void EnableCrouch ( );
	bool GamePad_DisableCoverMode ( );
	bool GamePad_EnableCoverMode ( );
	bool IsInCoverOrMovingInto ( );
	bool GamePad_EnableSprintOrCoverMode ( );
	void EnableCrouchOrCoverMode ( );
	void ServerInteract ( );
	void OnStopPawnSprintEffort ( );
	void OnStartPawnSprintEffort ( );
	void StopSprintEffort ( unsigned long immediate );
	void StartSprintEffort ( );
	bool DoQuickTurn ( struct FVector moveInputDirection, int controllerTargetYaw, unsigned long camOnly );
	bool CheckQuickTurn ( struct FVector moveInputDir, unsigned long checkRange, int* rotationYaw, int* controllerTargetYaw, int* turnController );
	void OnCoverVaultFinished ( );
	void OnFinishedQuickturn ( );
	struct FVector GetMoveInputDirection ( );
	bool HasSprintStartInput ( );
	bool IsDoingCamQuickturn ( );
	void StartQuickTurn ( struct FVector inputMovementDir, unsigned long autoSlipOut );
	void StartQuickTurnAction ( );
	void StartContextSpecialMove ( );
	bool GamePad_StartQuickTurnOrAgileSpecialMoveOrCommand ( );
	bool GamePad_StopContextSpecialMove ( );
	bool GamePad_StartContextMove ( );
	bool GamePad_IncreaseDeathFromAboveFOV ( );
	bool GamePad_DecreaseDeathFromAboveFOV ( );
	bool GamePad_CheckBackButtonEnabled ( );
	bool GamePad_CheckSkipInputEnabled ( );
	bool GamePad_EnableSkipMessagePending ( );
	bool GamePad_InteractZoom ( );
	bool GamePad_InteractFire ( );
	void TogglePickupLogging ( );
	bool GamePad_InteractPickup ( );
	bool GamePad_InteractMelee ( );
	bool GamePad_InteractStandard ( );
	bool Interact ( unsigned char activationType );
	bool GamePad_Reload ( );
	void StopAgileSpecialMove ( );
	void StartAgileSpecialMove ( );
	bool CheckExecute ( class AYGamePawn** outVictim );
	bool StartMeleeAttack ( unsigned long noExecution );
	bool GamePad_StartMeleeAttack ( );
	bool GamePad_StartMeleeAttackIfHasEnemy ( );
	bool CheckImmediateMelee ( );
	bool GamePad_StopAgileMove ( );
	bool GamePad_StartAgileMoveIfCover ( );
	bool GamePad_StartAgileMoveAuto ( );
	bool GamePad_StartAgileMove ( );
	void StopCoverSpecialMove ( );
	bool HasQueuedSpecialMove ( );
	bool ShouldQueueSpecialMove ( );
	bool GamePad_SpawnPlayer ( );
	void ShowAnimProps ( );
	void ToggleEpicDebugCamera ( );
	void SetKiller ( class AActor* Killer );
	void StopKillerCamera ( );
	void StartKillerCamera ( class AActor* Killer );
	void ScreenshotMode ( );
	void Spectate ( );
	void SetDebugCamRotationSpeed ( float rotationSpeed );
	float GetDebugCamRotationSpeed ( );
	void SetDebugCamMovementSpeed ( float movementSpeed );
	float GetDebugCamMovementSpeed ( );
	void SetDebugCamLookAtPlayer ( unsigned long lookAtPlayer );
	bool GetDebugCamLookAtPlayer ( );
	void SetDebugCamHeight ( float debugCamHeight );
	float GetDebugCamHeight ( );
	void SetDebugCamMode ( unsigned char debugCamMode );
	unsigned char GetDebugCamMode ( );
	bool GetDebugCamInfo ( unsigned char camMode, struct FString* Description, int* Flags );
	void RefreshCamMode ( );
	void EditCamMode ( );
	void CamColl ( unsigned long Enable );
	void camMode ( int N );
	void CamFoc ( unsigned long Use );
	void UpdateSpectatingCamera ( );
	float ProcessAlphaTransition ( int camRight, int camMid, int camLeft, float Value, float gate, int* fromCam, int* toCam );
	void DisableTargetingZoom ( );
	void SniperScopeOn ( );
	void DoTargetingZoom ( );
	void EnableTargetingZoom ( float FOV, float Time );
	void ToggleAsyncCamCollMP ( );
	void ToggleAsyncCamCollSP ( );
	void BaseOffset ( struct FVector V );
	void TestCamOverride ( unsigned long Activate );
	void OnWeaponChangedSniperFov ( float sniperFOV );
	float determineCameraTransitionFactor ( unsigned long inZoomMode );
	void UpdateCameraMode ( );
	void CamCompensatePawnRootMotionReset ( struct FVector deltaLocation, struct FRotator deltaRotation );
	void SmoothServerBaseOffset ( struct FVector newBaseOffset, float smoothingTime );
	void SmoothResetServerFOV ( float timeToReach );
	void SmoothOverrideServerFOV ( float NewFOV, float timeToReach, unsigned long byWeaponFOVOverride );
	void SetServerFixedViewTargetRotation ( struct FVector targetRot );
	void DisableServerUseFixedViewTargetRotation ( float timeToReach );
	void EnableServerUseFixedViewTargetRotation ( struct FVector targetRot, float timeToReach );
	void SetServerFixedViewTargetPosition ( struct FVector Position );
	void DisableServerUseFixedViewTargetPosition ( float timeToReach );
	void EnableServerUseFixedViewTargetPosition ( struct FVector Position, float timeToReach );
	void SetServerTransitionAlpha ( float Alpha );
	void SetServerAlphaCamMode ( class UYPlayerCamMode* fromMode, class UYPlayerCamMode* alphaDestMode );
	void SetServerSimpleCamMode ( class UYPlayerCamMode* camMode, unsigned long mirrored, unsigned long useMirrorTransition );
	void SetServerUseFocusPoint ( unsigned long usePoint, unsigned long updateControllerRotFromFocusPoint, unsigned long checkLOS );
	void SetServerCamFocusPoint ( class AActor* TargetActor, struct FName lookAtBone, struct FVector lookAtPos, struct FVector Offset, unsigned char offsetSpace, struct FVector lookAtInterpSpeeds, float pitchTolerance, float yawTolerance, float kickInTime, float kickOutTime, unsigned long checkLOS, float LOSStopTime );
	void InitServerCam ( class UClass* dataProviderClass );
	bool ShouldCallCamera ( );
	void TriggerPOIEvents ( unsigned long startsLookAt );
	void ConditionalReleasePOI ( );
	void FocusPOI ( );
	void ClientSetPOI ( class AActor* Target, float FOV, unsigned long autoActivateLookAt );
	struct FString GetPOIMessage ( );
	void DeactivateCamFocusPoint ( );
	void ActivateCamFocusPoint ( struct FYS_FocusPoint FocusPoint, unsigned long turnController );
	void DeactivateMeleeCamFocusPoint ( );
	void EnableMeleeCamFocusPoint ( class AActor* TargetActor );
	void YProcessViewRotation ( float DeltaTime, struct FRotator DeltaRot, struct FRotator* out_ViewRotation );
	void ProcessViewRotation ( float DeltaTime, struct FRotator DeltaRot, struct FRotator* out_ViewRotation );
	struct FRotator GetCameraRotation ( );
	void FOV ( float F );
	float GetFOVAngle ( );
	void GetAimAdjustmentFor ( class AYWeapon* W, struct FVector* StartFireLoc, struct FVector* aimAtLoc );
	void UpdatePawnsAimPosition ( );
	void FindFocusedActor ( struct FVector Start, struct FVector End );
	void GetPlayerViewPoint ( struct FVector* povLocation, struct FRotator* povRotation );
	void UpdateCrouch ( );
	bool CanPrepareFastRope ( );
	void TogglePlayerFastRopePrepare ( );
	bool ExecuteButtonAction ( unsigned char buttonAction );
	void CheckJumpOrDuck ( );
	void OnCheckForStandToRunTransition ( );
	void OnSpeedAnimTransitionDone ( );
	void PlaySpeedAnimTransition ( unsigned char newTransition );
	void AbortSpeedAnimTransition ( );
	void UpdateSpeedAnimTransition ( unsigned char oldInputDirection, unsigned char newInputDirection );
	void OnMoveInputChanged ( unsigned char inputMovementDirection, unsigned long inputMovementDirChange );
	unsigned char GetInputMovementDirection ( );
	void UpdateMovementDirection ( );
	void ServerMove ( float TimeStamp, struct FVector InAccel, struct FVector ClientLoc, unsigned char MoveFlags, unsigned char ClientRoll, int View );
	void ForceServerAckGoodMove ( float TimeStamp );
	void RMServerMove ( float TimeStamp, struct FVector InAccel, struct FVector ClientLoc, unsigned char MoveFlags, unsigned char ClientRoll, int View );
	void SendServerMove ( class USavedMove* NewMove, struct FVector ClientLoc, unsigned char ClientRoll, int View, class USavedMove* OldMove );
	void CallServerMove ( class USavedMove* NewMove, struct FVector ClientLoc, unsigned char ClientRoll, int View, class USavedMove* OldMove );
	void ToggleCoverMaps ( );
	void CompSound ( );
	void ToggleDebugHUD ( );
	void PlayerInvisible ( );
	void ShowTargetInfo ( );
	void SetEntityDebugFlags ( struct FString args );
	void SelectEntity ( );
	void AIDebug ( struct FString args );
	void UnloadGraphAtPlayerPos ( );
	void LoadGraphAtPlayerPos ( );
	void DestroyKynapseEntity ( );
	void CreateKynapseEntity ( );
	void UpdateWeaponSystemNative ( );
	void PlayerTick ( float DeltaTime );
	class AYGamePawn* GetGamePawn ( );
	void SetName ( struct FString S );
	void ServerSuicide ( );
	void CleanUpOldPawn ( class AYGamePawn* NewPawn );
	void InstantFade ( struct FColor Col );
	void ResetControllerToInitialState ( );
	void ResetDirectInputState ( );
	void ResetInputState ( );
	void ClientReset ( );
	void UnPossess ( );
	void PawnDied ( class APawn* inPawn );
	void Destroyed ( );
	bool IsPotentiallyCoop ( );
	bool IsCoop ( );
	void UnlockMultiGrenadeAchievement ( );
	void ScoreWeaponKillAchieveCategory ( unsigned char achievementCategory );
	void ScoreKillForAchievements ( class AController* Killed, class AYGamePawn* KilledPawn );
	void ScoreCheapShooterKillForAchievements ( class AYCheapShooter* killedCS, class AActor* DamageCauser );
	void ClientUpdateAchievement ( unsigned char AchievementId, int Count );
	void ResetAchievement ( unsigned char AchievementId );
	void ResetAchievementsStats ( );
	void EnableAchievementDebugMode ( );
	void Achievements ( unsigned long Enable );
	void ApplySensitivityScaling ( unsigned long IsUsingMouse );
	void SaveProfile ( unsigned char Reason, struct FScriptDelegate OnSaveProfileDone );
	void TestSaveProfile ( );
	void StopMoviePlaying ( );
	bool IsMoviePlaying ( );
	void SetButtonLayout ( int ButtonLayout );
	void LoadProfileControlScheme ( );
	void SetControllerVibration ( unsigned long ControllerVibration );
	void SetAimSnapOn ( unsigned char aimSnapOnValue );
	void SetRotationSensitivity ( int SettingId, int Sensitivity );
	void SetControllerInversion ( unsigned long InversionValue );
	void SetMouseInversion ( unsigned long InversionValue );
	void ChangeCurrentSetting ( int ProfileSettingId, int SettingValue );
	void SetCurrentSafeZone ( struct FVector2D SafeZone, struct FVector2D SafeZoneOffset );
	void LoadSettingsFromProfile ( unsigned long bLoadCharacter );
	void ResetProfileToDefault ( class UOnlinePlayerStorage* Profile );
	void ResetSteamStatsAndAchievements ( );
	void TestVoiceOverVolume ( int Volume );
	void UpdateBrightness ( );
	void UpdateVolumesFromProfile ( );
	bool IsRetrievingSettingsFromProfileNextTick ( );
	void ClearRetrieveSettingsFromProfileDelegate ( );
	void SetRetrieveSettingsFromProfileDelegate ( struct FScriptDelegate RetrieveSettingsFromProfileDelegate );
	void OnRetrieveSettingsFromProfileFinished ( );
	void RetrieveSettingsFromProfile ( );
	void SetHardwarePhysicsEnabled ( unsigned long bEnabled );
	void SetPostFXPreset ( int Index );
	void SetGamma ( float GammaValue );
	int GetUIPlayerIndex ( );
	void PlayUID ( int Uid );
	void ToggleSpeaking ( unsigned long bNowOn );
	void ServerProcessSpeechRecognition ( struct FSpeechRecognizedWord* ReplicatedWords );
	void SpeechRecognitionComplete ( );
	void ClientSetSpeechRecognitionObject ( class USpeechRecognition* NewRecognitionData );
	void FinishQuitToMainMenu ( );
	bool ShouldExitReturnToOnlineMenu ( );
	void QuitToMainMenu ( unsigned long OnLoginChange );
	void OnConsoleCommand ( class USeqAct_ConsoleCommand* inAction );
	void CE ( struct FName EventName );
	void CauseEvent ( struct FName EventName );
	void Slomo ( float T );
	void StopMovie ( );
	bool OnQuitToMainMenuMessageBoxSelection ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	void OpenQuitToMainMenuConfirmationMessageBox ( struct FString Title, struct FString Message, struct FScriptDelegate SelectionCallback );
	void BackToMainMenu ( );
	void CancelMatchAndQuitToMainMenu ( struct FString ErrorTitle, struct FString ErrorMsg, unsigned long OnLoginChange, unsigned long forceMessageOnPS3 );
	bool HandleConnectionErrorMissingPackage ( );
	bool OnBackToMainMenuSelected ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	bool OnQuitToMainMenuSelected ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void DisplayErrorMessage ( struct FName ErrorMsgName, struct FString Title, struct FString Message, struct FScriptDelegate SelectionCallback );
	void DisplayReturningToMainMenuAfterDisconnectMessage ( );
	void DisplayReturningToMainMenuMessage ( );
	void DisplayWaitingForHostMessage ( );
	void CloseWaitingForHostMessage ( );
	bool ClearFrontEndError ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	bool CheckForFrontEndError ( );
	void SetFrontEndErrorMessage ( struct FString Title, struct FString Message );
	void ClientSetProgressMessage ( unsigned char MessageType, struct FString Message, struct FString Title, unsigned long bIgnoreFutureNetworkMessages );
	void PreClientTravel ( struct FString PendingURL, unsigned char TravelType, unsigned long bIsSeamlessTravel );
	void OnJoinTravelToSessionComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void ServerResendPRIUniqueIDs ( float ClientTime );
	void ClientPlayerTravelToGameSession ( unsigned char* PlatformInfo );
	void ServerPlayerTravelToGameSession ( );
	bool AttemptReconnectToServerAfterInviteFailed ( );
	void OnInviteJoinComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void NotifyNotAllPlayersCanJoinInvite ( );
	void NotifyNoMatchingCRC ( );
	void NotifyInviteFailedDueToLocalhostConnection ( );
	void NotifyInviteFailed ( );
	void NotifyInviteVersionMismatch ( );
	void NotifyInviteCoopGameStarted ( );
	void NotifyInviteError ( struct FString ErrorMessage );
	void CancelPendingMapChanges ( );
	void ProcessGameInvite ( );
	bool CanPlayerPlayOnline ( );
	void OnGameInviteAcceptedDelayed ( );
	void TriggerFinishJoinFriend ( );
	void OnLoginStatusChangeForInvite ( unsigned char NewStatus, struct FUniqueNetId NewId );
	void OnLoginUIChangeForInvite ( unsigned long Success );
	void CheckOnlineServiceReachableInGame ( );
	void OnWantsToAcceptGameInvite ( struct FString InAsyncTaskName );
	void MCPUpdatesFinished ( );
	void OnConfirmGameInvite ( unsigned long confirmed );
	void OnGameInviteAccepted ( struct FOnlineGameSearchResult* InviteResult );
	bool ProcessPendingInvite ( );
	bool AllowsToProcessPendingInvite ( );
	void OnReadProfileSettingsComplete ( unsigned char LocalUserNum, unsigned long bWasSuccessful );
	void CreateOnlineGameCompleteOnConnected ( struct FName SessionName, unsigned long bWasSuccessful );
	void CreateOnlineGameOnConnectedTimer ( );
	void OnConnectionStatusChange ( unsigned char ConnectionStatus );
	void ClearOnlineSystemCleanupDelegate ( struct FScriptDelegate CleanupFinishedDelegate );
	void TriggerOnlineSystemCleanup ( struct FScriptDelegate CleanupFinishedDelegate );
	void NotifyLinkStatusChanged ( unsigned long bIsConnected );
	void DebugFakeLinkDisconnected ( );
	void CallNotifyLinkStatusChanged ( unsigned long bIsConnected );
	void ClientSetKickReason ( unsigned char Reason );
	void ClientSetOnlineStatusToCampaign ( );
	void ClientSetOnlineStatus ( );
	void SetOnlineGameSettingsWasFromInvite ( class UOnlineGameSettings* GameSettings, unsigned long bIsFromInvite );
	void ClearOnlineDelegates ( );
	void RegisterOnlineDelegates ( );
	void OnReadChallengeCompleted ( unsigned long bSuccessful, unsigned char Challenge );
	void DelayedQuitToMainMenu ( );
	void DelayedSceneActivation ( );
	void OnGameInvite ( struct FString pendingCtrId, unsigned long bQuitToMainManu );
	void DoProfileSaveCheckWorker ( );
	void DoProfileSaveCheck ( );
	bool SceneStackNeedsOnlineService ( );
	void OnLoginStatusChange ( int userID, unsigned char NewStatus, struct FUniqueNetId NewId );
	void OnLoginStatusChange3 ( unsigned char NewStatus, struct FUniqueNetId NewId );
	void OnLoginStatusChange2 ( unsigned char NewStatus, struct FUniqueNetId NewId );
	void OnLoginStatusChange1 ( unsigned char NewStatus, struct FUniqueNetId NewId );
	void OnLoginStatusChange0 ( unsigned char NewStatus, struct FUniqueNetId NewId );
	void OnLoginChange ( unsigned char LocalUserNum );
	void ReadChallenges ( );
	void AddOnlineDelegates ( unsigned long bRegisterVoice );
	void OnStumbleWhiteOutFinished ( );
	void ForceOriginalAudio ( unsigned long forceFlag );
	void StumbleWhiteOut ( );
	void StumbleSandBomb ( );
	void StumbleSandPool ( int Num );
	void SetAudioVolume ( float Volume );
	void PlayPlayerBodyImpactSound ( );
	void PlayEnemyBodyImpactSound ( class AYGamePawn* Victim );
	void ClientHandleDeadlyHeadshotSound ( class AYGamePawn* Victim );
	void ClientHandleMPOnlyHeadshotSound ( class AYGamePawn* Victim );
	void OnJustDied ( class UClass* dmgType );
	void OnJustRespawned ( class AYGamePawn* pwn, unsigned long bResetPRI );
	void InitGenericPawnAudio ( class AYGamePawn* pwn );
	void InitDamageFeedbackCallbacks ( class AYGamePawn* pwn );
	void ReceivedPlayer ( );
	void OnReceivePlayer ( );
	void Possess ( class APawn* inPawn, unsigned long bVehicleTransition );
	void ClientRestart ( class APawn* NewPawn );
	void GivePawn ( class APawn* inPawn );
	void ClientGivePawnHelper ( class APawn* inPawn );
	void StopHitFeedback ( );
	void InitHitFeedback ( );
	void InitGuiSystem ( );
	void InitInputSystem ( );
	bool ShouldClearAchievementsOnStartup ( );
	void PostBeginPlay ( );
	class AActor* GetFrictionTarget ( float MaxDistance, float MaxAngleH, float MaxAngleV, float* distAngleH, float* distAngleV, struct FVector* TargetLoc );
	class AYWeapon* GetCurrentWeapon ( );
	void SetCurrentWeapon ( class AYWeapon* wp );
	class AController* GetController ( );
	class AYHUD* GetHUD ( );
	class AYCamera* GetPlayerCam ( );
	class AActor* GetFocusedActor ( );
	void openx ( struct FString Map );
	TArray< class UYIHitFeedback* > GetHitDirectionIndicator ( );
	void OnCleanupFinished ( );
	void OnResult ( int PlayerIndex, unsigned long bAcceptOk );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYPlayerController::pClassPointer = NULL;

// Class SRGame.YPlayerInput_Gamepad
// 0x0084 (0x0200 - 0x017C)
class UYPlayerInput_Gamepad : public UPlayerInput
{
public:
	unsigned char                                      m_currentInputSchemeConsole;                      		// 0x017C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_currentInputSchemePC;                           		// 0x017D (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UYGamepadInputScheme*                        m_inputSchemes[ 0xA ];                            		// 0x0180 (0x0028) [0x0000000000000000]              
	unsigned long                                      m_isSouthPaw : 1;                                 		// 0x01A8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_hasMoveInput : 1;                               		// 0x01A8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_hasLookInput : 1;                               		// 0x01A8 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_deadZoneAim;                                    		// 0x01AC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deadZoneScope;                                  		// 0x01B0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< float >                                    m_inputSmoothingValues;                           		// 0x01B4 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	float                                              m_aJoyLeftX;                                      		// 0x01C0 (0x0004) [0x0000000000000004]              ( CPF_Input )
	float                                              m_aJoyLeftY;                                      		// 0x01C4 (0x0004) [0x0000000000000004]              ( CPF_Input )
	float                                              m_aJoyRightX;                                     		// 0x01C8 (0x0004) [0x0000000000000004]              ( CPF_Input )
	float                                              m_aJoyRightY;                                     		// 0x01CC (0x0004) [0x0000000000000004]              ( CPF_Input )
	float                                              m_joyLeftX;                                       		// 0x01D0 (0x0004) [0x0000000000000000]              
	float                                              m_joyLeftY;                                       		// 0x01D4 (0x0004) [0x0000000000000000]              
	float                                              m_joyRightX;                                      		// 0x01D8 (0x0004) [0x0000000000000000]              
	float                                              m_joyRightY;                                      		// 0x01DC (0x0004) [0x0000000000000000]              
	float                                              m_aLeftTrigger;                                   		// 0x01E0 (0x0004) [0x0000000000000004]              ( CPF_Input )
	float                                              m_aRightTrigger;                                  		// 0x01E4 (0x0004) [0x0000000000000004]              ( CPF_Input )
	float                                              m_leftTrigger;                                    		// 0x01E8 (0x0004) [0x0000000000000000]              
	float                                              m_rightTrigger;                                   		// 0x01EC (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            m_pressedDPadButtons;                             		// 0x01F0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_runWalkTransitionThreshold;                     		// 0x01FC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1507 ];

		return pClassPointer;
	};

	void TestLeftShoulderRelease ( );
	void TestLeftShoulderPress ( );
	void TestRightShoulderRelease ( );
	void TestRightShoulderPress ( );
	void TestDPadLeftRelease ( );
	void TestDPadLeftPress ( );
	void TestDPadRightRelease ( );
	void TestDPadRightPress ( );
	void TestDPadDownRelease ( );
	void TestDPadDownPress ( );
	void TestDPadUpRelease ( );
	void TestDPadUpPress ( );
	void TestAHoldRelease ( );
	void TestAHold ( );
	void TestASingleTap ( );
	void TestARelease ( );
	void TestAPress ( );
	void Input_ThrowGrenadeReleased ( );
	void Input_ThrowGrenade ( );
	void Input_CommandReleased ( );
	void Input_Command ( );
	void Input_ChangeWeaponAndPickUpReleased ( );
	void Input_ChangeWeaponAndPickUp ( );
	void Input_MeleeReleased ( );
	void Input_Melee ( );
	void Input_SecondaryReleased ( );
	void Input_Secondary ( );
	void Input_ReloadReleased ( );
	void Input_Reload ( );
	void Input_SprintAndCoverReleased ( );
	void Input_SprintAndCover ( );
	void Input_ShowObjectivesReleased ( );
	void Input_ShowObjectives ( );
	void Input_StartGameReleased ( );
	void Input_StartGame ( );
	void Input_PointOfInterestReleased ( );
	void Input_PointOfInterest ( );
	void Input_CrouchReleased ( );
	void Input_Crouch ( );
	void Input_ZoomReleased ( );
	void Input_Zoom ( );
	void Input_FireWeaponReleased ( );
	void Input_FireWeapon ( );
	void DPadLeftReleased ( );
	void DPadLeftPressed ( );
	void DPadRightReleased ( );
	void DPadRightPressed ( );
	void DPadDownReleased ( );
	void DPadDownPressed ( );
	void DPadUpReleased ( );
	void DPadUpPressed ( );
	void RightTriggerReleased ( );
	void RightTriggerPressed ( );
	void LeftTriggerReleased ( );
	void LeftTriggerPressed ( );
	void RightShoulderReleased ( );
	void RightShoulderPressed ( );
	void LeftShoulderReleased ( );
	void LeftShoulderPressed ( );
	void YReleased ( );
	void YPressed ( );
	void XReleased ( );
	void XPressed ( );
	void BReleased ( );
	void BPressed ( );
	void AReleased ( );
	void APressed ( );
	void StartReleased ( );
	void StartPressed ( );
	void BackReleased ( );
	void BackPressed ( );
	void RightThumbstickReleased ( );
	void RightThumbstickPressed ( );
	void LeftThumbstickReleased ( );
	void LeftThumbstickPressed ( );
	void FireDPadButtonReleased ( unsigned char Button );
	void FireDPadButtonPressed ( unsigned char Button );
	void DPadButtonReleased ( unsigned char Button );
	void DPadButtonPressed ( unsigned char Button );
	void DisableViewAcceleration ( );
	void EnableViewAcceleration ( );
	void ClearViewAcceleration ( );
	bool HasButtonInput ( );
	void Tick ( float DeltaTime );
	void SetCurrentInputScheme ( unsigned char newInputScheme );
	unsigned char GetCurrentInputScheme ( );
	class UYGamepadInputScheme* GetInputScheme ( );
	void RefreshPlayerActionButtonDatastore ( );
	void InitCurrentInputScheme ( );
	void ResetButtonStates ( );
	void InitInputScheme ( );
	bool HasLookInput ( );
	bool HasMoveInput ( );
	void CheckWalkRun ( );
	void Destroyed ( );
	void PlayerInput ( float DeltaTime );
	void PreProcessInput ( float DeltaTime );
	void InitPlayerInput ( );
};

UClass* UYPlayerInput_Gamepad::pClassPointer = NULL;

// Class SRGame.YPlayerInput3
// 0x0214 (0x0414 - 0x0200)
class UYPlayerInput3 : public UYPlayerInput_Gamepad
{
public:
	float                                              LastInputTime;                                    		// 0x0200 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_inputStyle;                                     		// 0x0204 (0x0001) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned char                                      LastAdhesionDirFlip;                              		// 0x0205 (0x0001) [0x0000000000000000]              
	float                                              m_cameraQuadratureThreshold;                      		// 0x0208 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_turnVal;                                        		// 0x020C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lookVal;                                        		// 0x0210 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_turnSmoothVel;                                  		// 0x0214 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lookSmoothVel;                                  		// 0x0218 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_turnSprint;                                     		// 0x021C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_turnSprintVel;                                  		// 0x0220 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_unsmoothedTurn;                                 		// 0x0224 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_unsmoothedLook;                                 		// 0x0228 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_smoothingFactor;                                		// 0x022C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_smoothingFactorSprint;                          		// 0x0230 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sprintInputSpeedModifier;                       		// 0x0234 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sprintMinInput;                                 		// 0x0238 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sprintStopDelay;                                		// 0x023C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sprintStopMinInput;                             		// 0x0240 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sprintStopMinInputStrict;                       		// 0x0244 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_freeSprintTimeSinceNoInput;                     		// 0x0248 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_sprintX;                                        		// 0x024C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_sprintY;                                        		// 0x0250 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_viewAccelEnabled : 1;                           		// 0x0254 (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_autoCenterPitch : 1;                            		// 0x0254 (0x0004) [0x0000000000004001] [0x00000002] ( CPF_Edit | CPF_Config )
	unsigned long                                      bForcePitchCentering : 1;                         		// 0x0254 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      bAppliedFriction : 1;                             		// 0x0254 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_drawDebugStuff : 1;                             		// 0x0254 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_speedTest : 1;                                  		// 0x0254 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_smoothingCurveValuesOverridden : 1;             		// 0x0254 (0x0004) [0x0000000000000000] [0x00000040] 
	float                                              m_yawAccelMultiplier;                             		// 0x0258 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_yawAccelMultiplierTargeting;                    		// 0x025C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_yawAccelThreshold;                              		// 0x0260 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_yawAccelRampUpTime;                             		// 0x0264 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_yawAccelRampDownTime;                           		// 0x0268 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_yawAccelRampUpTimeTargeting;                    		// 0x026C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_yawAccelRampDownTimeTargeting;                  		// 0x0270 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              YawAccelPct;                                      		// 0x0274 (0x0004) [0x0000000000000000]              
	float                                              m_pitchAccelMultiplier;                           		// 0x0278 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAccelMultiplierTargeting;                  		// 0x027C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAccelThreshold;                            		// 0x0280 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAccelRampUpTime;                           		// 0x0284 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAccelRampDownTime;                         		// 0x0288 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAccelRampUpTimeTargeting;                  		// 0x028C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAccelRampDownTimeTargeting;                		// 0x0290 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              PitchAccelPct;                                    		// 0x0294 (0x0004) [0x0000000000000000]              
	float                                              m_pitchAutoCenterSpeed;                           		// 0x0298 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAutoCenterSpeedSprint;                     		// 0x029C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAutoCenterDelay;                           		// 0x02A0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_pitchAutoCenterTargetPitchWindow;               		// 0x02A4 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_forcePitchCenteringSpeed;                       		// 0x02AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              PitchAutoCenterDelayCount;                        		// 0x02B0 (0x0004) [0x0000000000000000]              
	float                                              PitchAutoCenterOffset;                            		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              LastDistToTarget;                                 		// 0x02B8 (0x0004) [0x0000000000000000]              
	float                                              LastDistMultiplier;                               		// 0x02BC (0x0004) [0x0000000000000000]              
	float                                              LastDistFromAimZ;                                 		// 0x02C0 (0x0004) [0x0000000000000000]              
	float                                              LastDistFromAimY;                                 		// 0x02C4 (0x0004) [0x0000000000000000]              
	float                                              LastFrictionMultiplier;                           		// 0x02C8 (0x0004) [0x0000000000000000]              
	float                                              LastAdhesionAmtY;                                 		// 0x02CC (0x0004) [0x0000000000000000]              
	float                                              LastAdhesionAmtZ;                                 		// 0x02D0 (0x0004) [0x0000000000000000]              
	float                                              LastMaxAdhesionAimDistY;                          		// 0x02D4 (0x0004) [0x0000000000000000]              
	float                                              LastMaxAdhesionAimDistZ;                          		// 0x02D8 (0x0004) [0x0000000000000000]              
	float                                              LastTargetRadius;                                 		// 0x02DC (0x0004) [0x0000000000000000]              
	float                                              LastTargetHeight;                                 		// 0x02E0 (0x0004) [0x0000000000000000]              
	float                                              LastDistFromAimYa;                                		// 0x02E4 (0x0004) [0x0000000000000000]              
	float                                              LastDistFromAimZa;                                		// 0x02E8 (0x0004) [0x0000000000000000]              
	float                                              LastAdjustY;                                      		// 0x02EC (0x0004) [0x0000000000000000]              
	float                                              LastAdjustZ;                                      		// 0x02F0 (0x0004) [0x0000000000000000]              
	struct FVector                                     LastCamLoc;                                       		// 0x02F4 (0x000C) [0x0000000000000000]              
	struct FVector                                     LastFrictionTargetLocation;                       		// 0x0300 (0x000C) [0x0000000000000000]              
	struct FVector                                     LastAdhesionTargetLocation;                       		// 0x030C (0x000C) [0x0000000000000000]              
	struct FVector2D                                   LastHotZone;                                      		// 0x0318 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   LastRelativeVel;                                  		// 0x0320 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   LastAngleDist;                                    		// 0x0328 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   LastAngleVel;                                     		// 0x0330 (0x0008) [0x0000000000000000]              
	struct FRotator                                    LastDeltaRot;                                     		// 0x0338 (0x000C) [0x0000000000000000]              
	struct FYS_AdhesionTargetData                      m_adhesionTargets[ 0x3 ];                         		// 0x0344 (0x00B4) [0x0000000000000000]              
	float                                              m_targetingModeGamepadViewScalePct;               		// 0x03F8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_targetingModeMouseViewScalePct;                 		// 0x03FC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_duration;                                       		// 0x0400 (0x0004) [0x0000000000000000]              
	int                                                m_progress;                                       		// 0x0404 (0x0004) [0x0000000000000000]              
	TArray< float >                                    m_smoothingCurveOverrideValues;                   		// 0x0408 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1508 ];

		return pClassPointer;
	};

	void inputspeedtest ( );
	bool IsIdle ( );
	void DrawStickInputBox ( class AYHUD* HUD, float stickX, float stickY );
	void DrawCurve ( class AYHUD* H, float Size, int steps, float indicatorPosX, float indicatorPosY, float smoothedX, float smoothedY, unsigned long withSmoothing );
	void DrawBox ( struct FVector Loc, struct FVector Width, struct FVector Height, int R, int G, int B );
	void DrawHUD ( class AHUD* H );
	void EditInput ( );
	void osc ( int Index, float Value );
	void DebugInput ( );
	void ViewAdhesion ( float DeltaTime, class AYWeapon* W, float* turnVal, float* upVal );
	bool ViewFrictionNative ( float DeltaTime, class AYWeapon* W );
	void AutoPitchCentering ( float DeltaTime );
	void ForcePitchCentering ( unsigned long bCenter );
	void DisableViewAcceleration ( );
	void EnableViewAcceleration ( );
	void ClearViewAcceleration ( );
	void ViewAcceleration ( float DeltaTime, unsigned long targeting, unsigned long sprinting );
	void ViewAccelerationNative ( float DeltaTime, unsigned long targeting, unsigned long sprinting );
	float GetFovScale ( float X );
	float GetResultingTurn ( float lowerInput, float upperInput );
	float CalcSensitivityScaling ( unsigned long IsUsingMouse, unsigned long turnOrUp, float X );
	float CurveSmootingPrimitive ( float X );
	float CurveSmootingNative ( float X, unsigned char Style );
	void DoSpeedTest ( float DeltaTime );
	void PlayerInput ( float DeltaTime );
	void PreProcessInput ( float DeltaTime );
	void PreProcessInputNative ( float DeltaTime );
};

UClass* UYPlayerInput3::pClassPointer = NULL;

// Class SRGame.YPlayerStart
// 0x0038 (0x0310 - 0x02D8)
class AYPlayerStart : public APlayerStart
{
public:
	unsigned char                                      m_team;                                           		// 0x02D8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_squadIndex;                                     		// 0x02D9 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_character;                                      		// 0x02DA (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class AYGamePawn*                                  m_playerPawnArchetype;                            		// 0x02DC (0x0004) [0x0000000020000001]              ( CPF_Edit | CPF_Deprecated )
	class UClass*                                      m_playerPawnClass;                                		// 0x02E0 (0x0004) [0x0000000020000001]              ( CPF_Edit | CPF_Deprecated )
	TArray< struct FYS_PlayerStartTypeInfo >           m_presetSpawnInfos;                               		// 0x02E4 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	struct FYS_PlayerStartSpawnInfo                    m_spawnInfo;                                      		// 0x02F0 (0x001C) [0x0000000000000000]              
	float                                              m_lastUsedTime;                                   		// 0x030C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1509 ];

		return pClassPointer;
	};

	void Destroyed ( );
	void PostBeginPlay ( );
};

UClass* AYPlayerStart::pClassPointer = NULL;

// Class SRGame.YPlayerStart_CP
// 0x0004 (0x0314 - 0x0310)
class AYPlayerStart_CP : public AYPlayerStart
{
public:
	class AYFightArea*                                 m_defautFightArea;                                		// 0x0310 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1510 ];

		return pClassPointer;
	};

};

UClass* AYPlayerStart_CP::pClassPointer = NULL;

// Class SRGame.YPointOfInterest
// 0x0000 (0x01F8 - 0x01F8)
class AYPointOfInterest : public AActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1511 ];

		return pClassPointer;
	};

};

UClass* AYPointOfInterest::pClassPointer = NULL;

// Class SRGame.YPostProcessComponent
// 0x000C (0x020C - 0x0200)
class UYPostProcessComponent : public UPrimitiveComponent
{
public:
	class UMaterialInstanceConstant*                   Material;                                         		// 0x0200 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   MaterialTransition;                               		// 0x0204 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   MaterialTransitionComplete;                       		// 0x0208 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1512 ];

		return pClassPointer;
	};

};

UClass* UYPostProcessComponent::pClassPointer = NULL;

// Class SRGame.YHUD
// 0x0251 (0x06D1 - 0x0480)
class AYHUD : public AHUD
{
public:
	unsigned long                                      bIsSplitscreen : 1;                               		// 0x0480 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bIsFirstPlayer : 1;                               		// 0x0480 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_hideEverythingForCutscene : 1;                  		// 0x0480 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_hideHitFeedbackScene : 1;                       		// 0x0480 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_hideWeaponsDisplayScene : 1;                    		// 0x0480 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_wantsToHideCrosshair : 1;                       		// 0x0480 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_hideCrosshair : 1;                              		// 0x0480 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_showPlayerStats : 1;                            		// 0x0480 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_debugHUDEnabled : 1;                            		// 0x0480 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_showObjectives : 1;                             		// 0x0480 (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	unsigned long                                      m_bShowPerfLights : 1;                            		// 0x0480 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bShowMemoryPS3 : 1;                             		// 0x0480 (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      m_showDebugInfo : 1;                              		// 0x0480 (0x0004) [0x0000000000044000] [0x00001000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      m_drawAnimTreeOverlay : 1;                        		// 0x0480 (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      m_bShowSpawnPoints : 1;                           		// 0x0480 (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      m_showMeleeArea : 1;                              		// 0x0480 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bHUDTeamInitialise : 1;                         		// 0x0480 (0x0004) [0x0000000000002000] [0x00010000] ( CPF_Transient )
	unsigned long                                      m_bShouldUpdateGrenades : 1;                      		// 0x0480 (0x0004) [0x0000000000002000] [0x00020000] ( CPF_Transient )
	unsigned long                                      m_markerRestrictedMode : 1;                       		// 0x0480 (0x0004) [0x0000000000002000] [0x00040000] ( CPF_Transient )
	int                                                m_team;                                           		// 0x0484 (0x0004) [0x0000000000000000]              
	float                                              m_resolutionScale;                                		// 0x0488 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   MessageOffset[ 0x8 ];                             		// 0x048C (0x0040) [0x0000000000000000]              
	class AYPlayerController*                          m_ctrl;                                           		// 0x04CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYPostProcessManager*                        m_postProcessManager;                             		// 0x04D0 (0x0004) [0x0000000000000000]              
	TArray< class UFont* >                             m_fonts;                                          		// 0x04D4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AActor* >                            m_postRenderedActors;                             		// 0x04E0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FColor                                      m_fadeColor;                                      		// 0x04EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_previousFadeAlpha;                              		// 0x04F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_desiredFadeAlpha;                               		// 0x04F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fadeAlpha;                                      		// 0x04F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fadeAlphaTime;                                  		// 0x04FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fadeAlphaDelay;                                 		// 0x0500 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_desiredFadeAlphaTime;                           		// 0x0504 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScenes*                                  ScoreboardSceneTemplate;                          		// 0x0508 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UYUIFrontEnd_IntelCollectibleDetails*        m_openedCollectibleDetailsScene;                  		// 0x050C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScenes*                                  m_setScoreSceneTemplate;                          		// 0x0510 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScenes*                                  m_openedScoreScene;                               		// 0x0514 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScenes*                                  m_HUD_Life_Template;                              		// 0x0518 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScene_HUD_Life_Base*                     m_HUD_Life_Scene;                                 		// 0x051C (0x0004) [0x0000000000000000]              
	class UYGreenRedDisplay*                           m_GFX_bar;                                        		// 0x0520 (0x0004) [0x0000000000000000]              
	class UYGreenRedDisplay*                           m_SysMem_bar;                                     		// 0x0524 (0x0004) [0x0000000000000000]              
	class UYGreenRedDisplay*                           m_GFXMem_bar;                                     		// 0x0528 (0x0004) [0x0000000000000000]              
	class UYGreenRedDisplay*                           m_TexPool_bar;                                    		// 0x052C (0x0004) [0x0000000000000000]              
	class UYGreenRedDisplay*                           m_GP_bar;                                         		// 0x0530 (0x0004) [0x0000000000000000]              
	float                                              m_MaxGFXTime;                                     		// 0x0534 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_MaxSysMem;                                      		// 0x0538 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_MaxGFXMem;                                      		// 0x053C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_MaxGPTime;                                      		// 0x0540 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_lastUpdateMemoryPS3;                            		// 0x0544 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_refreshMemoryPS3;                               		// 0x0548 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_MemoryPS3Info                           m_memoryPS3Info;                                  		// 0x054C (0x0060) [0x0000000000002000]              ( CPF_Transient )
	float                                              TimeOfLastCheckpoint;                             		// 0x05AC (0x0004) [0x0000000000000000]              
	float                                              MinTimeBeforeFadeForCheckpoint;                   		// 0x05B0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              FadeTimeForCheckpoint;                            		// 0x05B4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_debugTypeNames[ 0x16 ];                         		// 0x05B8 (0x00B0) [0x0000000000000000]              
	class AYGamePawn*                                  m_debugPawn;                                      		// 0x0668 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYPlayerController*                          m_debugController;                                		// 0x066C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_animTreeOverlayStartNode;                       		// 0x0670 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_animTreeOverlayOffset;                          		// 0x0678 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class APawn*                                       m_animTreeOverlayPawn;                            		// 0x0680 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_deltaTime;                                      		// 0x0684 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UYMarkerAnimationSeq* >              AnimSequencePool;                                 		// 0x0688 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UYMarkerBase* >                      AnimSubscribers;                                  		// 0x0694 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_sMessage;                                       		// 0x06A0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FVector2D                                   m_SafeZone;                                       		// 0x06AC (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_SafeZoneOffset;                                 		// 0x06B4 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_SafeZoneOld;                                    		// 0x06BC (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_SafeZoneOffsetOld;                              		// 0x06C4 (0x0008) [0x0000000000000000]              
	int                                                m_lastGrenadeCount;                               		// 0x06CC (0x0004) [0x0000000000000000]              
	unsigned char                                      m_lastSelectedGrenade;                            		// 0x06D0 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1513 ];

		return pClassPointer;
	};

	void NotifyShowMidGameMenu ( );
	void NotifyHideMidGameMenu ( );
	void UpdateGrenadeCounts ( );
	void UpdateWeaponAmmos ( );
	void UpdateGameHUD ( unsigned long bUpdateHUD );
	void SetC4Launched ( unsigned long bC4Launched );
	void SetPawn ( class APawn* Pawn );
	void SetGrenadeCount ( int iNbGrenade );
	void SetWeaponAmmos ( int iCurrentAmmo, int iStockAmmo );
	void SetCurrentGrenade ( unsigned char eGrenade );
	void SetCurrentWeapon ( unsigned char eWeapon );
	void NotifyTeamChange ( );
	void InitHUDTeam ( );
	void TurnOff ( );
	void AnimEnd ( class UYMarkerBase* AnimTarget, int AnimIndex, class UYMarkerAnimationSeq* AnimSeq );
	void TickAnims ( float dt );
	void AnimUnSubscribe ( class UYMarkerBase* Target );
	void AnimSubscribe ( class UYMarkerBase* Target );
	class UYMarkerAnimationSeq* AnimLookupSequence ( struct FName SequenceName );
	void PlayFX ( struct FString FXAnimPath );
	bool HasFocusPOICommand ( );
	void SetSquadStatus ( struct FString Status );
	void AddKillEventMessage ( class AYPlayerReplicationInfo* killerPRI, class AYPlayerReplicationInfo* victimPRI, class UYDeathMessageParams* Params );
	void AddRadioSpeakerEventMessage ( int numFound );
	void AddIntelEventMessage ( class AYPickup_Collectable* collectiblePickup );
	void AddObjectiveEventMessage ( struct FString Header, struct FString Objective, unsigned long complete );
	void AddPickupEventMessage ( struct FString Message, struct FString Icon, struct FString msg2 );
	void AddSquadEventMessage ( struct FString squadStatus );
	void AddEventMessage ( struct FString eventMsg );
	void ClearEventMessages ( );
	void PlayerOwnerDied ( );
	void SetCommandMessage ( struct FString msg );
	void SetActionMessage ( struct FString msg );
	void RemoveAllPostRenderedActor ( );
	void AddPostRenderedActor ( class AActor* A );
	void RemovePostRenderedActor ( class AActor* A );
	void YDrawActorOverlays ( );
	class UFont* GetFontForDistanceOverlays ( );
	class UFont* GetFontForActorOverlays ( );
	void SetShowScores ( unsigned long bNewValue );
	void PostRender ( );
	void SpectatorCameraFadeIn ( );
	void CheckSafezoneChange ( );
	void Tick ( float DeltaTime );
	void ColorFade ( struct FColor newFadeColor, unsigned char FromAlpha, unsigned char ToAlpha, float FadeTime );
	class APawn* GetAnimTreeOverlayPawn ( );
	void SetAnimTreeOverlayPawn ( class APawn* Pawn );
	struct FVector2D GetAnimTreeOverlayOffset ( );
	void SetAnimTreeOverlayOffset ( struct FVector2D Offset );
	struct FName GetAnimTreeOverlayStartNode ( );
	void SetAnimTreeOverlayStartNode ( struct FName startNode );
	bool IsAnimTreeOverlayEnabled ( );
	void EnableAnimTreeOverlay ( unsigned long Enable );
	void GetTeamColor ( int TeamIndex, struct FLinearColor* ImageColor, struct FColor* TextColor );
	void SetFont ( unsigned char FontSize );
	class UFont* GetFontPerSize ( unsigned char FontSize );
	class UFont* GetFont ( unsigned char FontSize );
	void GetScreenCoords ( float PosY, float* ScreenX, float* ScreenY, struct FHudLocalizedMessage* InMessage );
	void LocalizedMessage ( class UClass* InMessageClass, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, struct FString CriticalString, int Switch, float Position, float Lifetime, int FontSize, struct FColor DrawColor, class UObject* OptionalObject );
	void UpdateDBNOIndicators ( );
	void RestoreScoreScene ( );
	void CloseScoreScene ( );
	void ShowScoreScene ( unsigned long bShow, class UYUIScenes* Template );
	class UYUIScenes* OpenScene ( class UYUIScenes* Template, unsigned char ForcedPriority );
	class UUIInteraction* GetUIController ( class ULocalPlayer** LP );
	void DrawBar ( int X, int Y, float Value, float MaxValue, class UTexture2D* Tex, int R, int G, int B, float barrierValue );
	void DrawTargetInfo ( );
	void DrawPlayerHUD ( );
	void huddisplay ( struct FString Part, unsigned long show );
	void ClientSetCinematicMode ( unsigned long hideEverything, unsigned long hideHitFeedback, unsigned long hideWeaponDisplay, unsigned long hideCrosshair, unsigned long SuppressSilhouette );
	void SetCinematicMode ( class USeqAct_ToggleCinematicMode* Action, unsigned long cinematicMode );
	bool IsCrosshairVisible ( );
	void CrosshairVisibility ( unsigned long Enable );
	void DrawMeshPose ( class USkeletalMeshComponent* MeshComp, struct FLinearColor LineColor, unsigned long persistentLines );
	void DrawMemoryPS3 ( );
	void GetMemoryPS3Info ( struct FYS_MemoryPS3Info* MI );
	void DrawDebugHUD ( );
	void ShowSpawnPoints ( );
	void ShowMemoryPS3 ( float refreshInterval );
	void ShowPerfLights ( );
	void GetTexPool ( float* V, float* Size );
	void GetGPTime ( float* V );
	void GetGFXMem ( float* V );
	void GetSysMem360 ( float* V );
	void GetSysMem ( float* V );
	void GetGFXTime ( float* V );
	void DrawAudioDebugInfos ( );
	void EnableAIDebugInfos ( unsigned long Enable );
	void DrawAIDebugInfos ( );
	void SetDebugController ( class AYPlayerController* Player );
	class AYPlayerController* GetDebugController ( );
	void SetDebugPawnTrace ( );
	void SetDebugPawn ( class AYGamePawn* Pawn );
	class AYGamePawn* GetDebugPawn ( );
	bool ShouldDisplayDebugType ( unsigned char DebugType, unsigned long ignoreShowDebugInfo );
	void ShowDebugType ( unsigned char DebugType );
	void EnableDebugType ( unsigned char DebugType );
	void ShowDebug ( struct FName DebugType );
	void DrawHUD ( );
	void DrawPostGameHud ( float dt );
	bool AreTacticalMarkersVisible ( );
	void DrawTacticalInfos ( float dt );
	void DrawGameHud ( float dt );
	void PostBeginPlay ( );
	void Destroyed ( );
	class AYGameReplicationInfo* GetGRI ( );
	struct FString FormatDateTime ( int Year, int Month, int Day, int Seconds, struct FString Language );
	struct FString FormatTime ( int Seconds );
	unsigned char GetPS3DateFormat ( );
	void DrawLine3D ( struct FVector Start, struct FVector End, struct FColor LineColor, unsigned long bPersistentLines );
	void DrawLine2D ( struct FVector2D* StartPos, struct FVector2D* EndPos, struct FLinearColor* Col );
	void DrawCircle ( struct FVector Loc, struct FVector AxisX, struct FVector AxisY, float Radius, int Segments, struct FColor Col, unsigned long bPersistentLines );
	void DrawArc ( struct FVector Loc, struct FVector X, struct FVector Y, float Radius, float StartAngle, float EndAngle, struct FColor Col, unsigned long bPersistentLines );
	void DrawMaterialTileRotated ( class UMaterialInterface* MatInst, float XL, float YL, float U, float V, float UL, float VL, float rotationAngle, float PivotX, float PivotY );
	void DrawTileRotated ( class UTexture2D* Tex, float XL, float YL, float U, float V, float UL, float VL, float rotationAngle, float PivotX, float PivotY );
	void DrawDebugOrientedBox ( struct FVector Origin, struct FRotator Rot, struct FVector posExtent, struct FVector negExtent, unsigned char R, unsigned char G, unsigned char B, unsigned long bPersistentLines, unsigned char dpg );
	void DrawDebugCoordinateSystemEx ( struct FVector AxisLoc, struct FRotator AxisRot, float Scale, unsigned long bPersistentLines, unsigned char dpg );
	void DrawDebugLines ( unsigned long bPersistentLines, TArray< struct FYS_Line >* debugLines );
};

UClass* AYHUD::pClassPointer = NULL;

// Class SRGame.YPostProcessManager
// 0x0DF4 (0x0E30 - 0x003C)
class UYPostProcessManager : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x003C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPostProcessSettings                        m_postSettings[ 0xA ];                            		// 0x0040 (0x0D70) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	unsigned char                                      m_currentStyle;                                   		// 0x0DB0 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_stunFadeTo;                                     		// 0x0DB1 (0x0001) [0x0000000000000000]              
	class UMaterialEffect*                             m_currentEffect;                                  		// 0x0DB4 (0x0004) [0x0000000000000000]              
	struct FYS_MatFxFadeInfo                           m_currentFxFading;                                		// 0x0DB8 (0x002C) [0x0000000000000000]              
	float                                              m_lastFadeOpacity;                                		// 0x0DE4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FColor                                      m_whiteColor;                                     		// 0x0DE8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	unsigned long                                      m_useDebugColorMode : 1;                          		// 0x0DEC (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_useAimingDOF : 1;                               		// 0x0DEC (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_useScopeDOF : 1;                                		// 0x0DEC (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_aimDOFActive : 1;                               		// 0x0DEC (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_initialized : 1;                                		// 0x0DEC (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_bMidGameMenuShowed : 1;                         		// 0x0DEC (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              m_aimDOFFadeInDuration;                           		// 0x0DF0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_refocusMinTime;                                 		// 0x0DF4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_refocusMaxTime;                                 		// 0x0DF8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_refocusMinDist;                                 		// 0x0DFC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_refocusMaxDist;                                 		// 0x0E00 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_scopeDOFFadeInDuration;                         		// 0x0E04 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_scopeFocusDis;                                  		// 0x0E08 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_refocusTargetDist;                              		// 0x0E0C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_currentRefocusDist;                             		// 0x0E10 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYPlayerController*                          m_ctrl;                                           		// 0x0E14 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FLUTBlender                                 ColorGradingLUT;                                  		// 0x0E18 (0x0018) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1514 ];

		return pClassPointer;
	};

	void TurnOff ( );
	void StopPostProcessOverride ( );
	void StartPostProcessOverride ( unsigned char Style, float FadeInTime );
	float GetCurrentFadeOutDuration ( );
	class UPostProcessEffect* GetPostProcessEffect ( struct FName EffectName );
	class UMaterialEffect* EnablePostProcessEffect ( struct FName EffectName, unsigned long Enable );
	void StartPostEffect_CurrentDefault ( float FadeInTime, struct FPostProcessSettings* fx );
	struct FPostProcessSettings GetCurrentPostProcessSettings ( );
	void DisableCurrentFadeFx ( );
	void UpdateFadeFX ( float DeltaTime );
	void FadeFX ( struct FName fxChainName, struct FColor newFadeColor, float FromAlpha, float ToAlpha, float FadeTime );
	void Tick ( float DeltaTime );
	float CalculateFocusDistance ( float DeltaTime );
	void DetermineScopePPS ( float DeltaTime );
	void DetermineAimingPPS ( float DeltaTime );
	void StartPostEffect_ToDefault ( struct FPostProcessSettings* fx );
	void StartPostEffect_Scope ( float FadeInTime, struct FPostProcessSettings* fx );
	void StartPostEffect_Aiming ( float FadeInTime, struct FPostProcessSettings* fx );
	void StartPostEffect_StunLow ( struct FPostProcessSettings* fx );
	void StartPostEffect_StunMid ( struct FPostProcessSettings* fx );
	void StartPostEffect_StunFull ( struct FPostProcessSettings* fx );
	void StartPostEffect_Death ( struct FPostProcessSettings* fx );
	void StartPostEffect_Menu ( float FadeInTime, struct FPostProcessSettings* fx );
	struct FPostProcessSettings Copy ( struct FPostProcessSettings Template );
	bool SelectiveEquals ( unsigned char Style, struct FPostProcessSettings th, struct FPostProcessSettings Other );
	void Init ( );
};

UClass* UYPostProcessManager::pClassPointer = NULL;

// Class SRGame.YPostProcessVolumeActor
// 0x0194 (0x038C - 0x01F8)
class AYPostProcessVolumeActor : public AActor
{
public:
	float                                              Priority;                                         		// 0x01F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UExponentialHeightFogComponent*              ExponentialHeightFog;                             		// 0x01FC (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )
	struct FPostProcessSettings                        Settings;                                         		// 0x0200 (0x0158) [0x0000000000480001]              ( CPF_Edit | CPF_Component | CPF_NeedCtorLink )
	struct FAdvancedAntialiasingSettings               AAASettings;                                      		// 0x0358 (0x0018) [0x0000000000000001]              ( CPF_Edit )
	class AYPostProcessVolumeActor*                    NextLowerPriorityVolumeActor;                     		// 0x0370 (0x0004) [0x0000000001002002]              ( CPF_Const | CPF_Transient )
	unsigned long                                      bEnabled : 1;                                     		// 0x0374 (0x0004) [0x0000000000000021] [0x00000001] ( CPF_Edit | CPF_Net )
	float                                              FadingTime;                                       		// 0x0378 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   Material;                                         		// 0x037C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   MaterialTransition;                               		// 0x0380 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   MaterialTransitionComplete;                       		// 0x0384 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYPostProcessComponent*                      PPComponent;                                      		// 0x0388 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1515 ];

		return pClassPointer;
	};

	void GetCurrentPostFXSettings ( struct FVector ViewLocation, struct FPostProcessSettings* newSettings );
	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYPostProcessVolumeActor::pClassPointer = NULL;

// Class SRGame.YPPTransitionVolumeActor
// 0x0018 (0x0210 - 0x01F8)
class AYPPTransitionVolumeActor : public AActor
{
public:
	TArray< struct FTransitionData >                   Transitions;                                      		// 0x01F8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      bEnabled : 1;                                     		// 0x0204 (0x0004) [0x0000000000000021] [0x00000001] ( CPF_Edit | CPF_Net )
	float                                              Priority;                                         		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AYPPTransitionVolumeActor*                   NextLowerPriorityVolumeActor;                     		// 0x020C (0x0004) [0x0000000001002002]              ( CPF_Const | CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1516 ];

		return pClassPointer;
	};

	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYPPTransitionVolumeActor::pClassPointer = NULL;

// Class SRGame.YProfileSettings
// 0x0370 (0x0400 - 0x0090)
class UYProfileSettings : public UOnlineProfileSettings
{
public:
	TArray< struct FString >                           GenericInputButtonToCommand;                      		// 0x0090 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             KeyMappingArray;                                  		// 0x009C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_iDefaultEquipmentVersion;                       		// 0x00A8 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FYS_EquipmentDefault                        Specops[ 0x5 ];                                   		// 0x00AC (0x00DC) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FYS_EquipmentDefault                        SpecopsUnlocks[ 0x3 ];                            		// 0x0188 (0x0084) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FYS_EquipmentDefault                        Konrad[ 0x5 ];                                    		// 0x020C (0x00DC) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FYS_EquipmentDefault                        KonradUnlocks[ 0x3 ];                             		// 0x02E8 (0x0084) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned long                                      m_bIsDLC2Installed : 1;                           		// 0x036C (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_bIsDLC3Installed : 1;                           		// 0x036C (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	struct FString                                     SpecopsName[ 0x5 ];                               		// 0x0370 (0x003C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     KonradName[ 0x5 ];                                		// 0x03AC (0x003C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	TArray< struct FYS_ProfileStat >                   ProfileStats;                                     		// 0x03E8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_Challenge >                     Challenges;                                       		// 0x03F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1517 ];

		return pClassPointer;
	};

	void SetIsDefaultProfile ( unsigned long isDefault );
	bool IsDefaultProfile ( );
	void StoreKeysUsingPlayerInput ( class UPlayerInput* PInput );
	int FindKeyEnum ( struct FName KeyName );
	void SetKeyBindingFromName ( unsigned char genericButton, struct FName KeyBinding );
	void RemoveGenericInputButtonBindings ( class UPlayerInput* PInput );
	void ApplyAllKeyBindings ( class UPlayerInput* PInput );
	void ApplyKeyBinding ( class UPlayerInput* PInput, unsigned char KeyBinding );
	int GetProfileIDForButton ( unsigned char KeyAction );
	struct FName FindKeyName ( unsigned char KeyEnum );
	int GetStartingPrimaryWeaponNum ( unsigned char TeamID );
	int GetStartingCharacterNum ( unsigned char TeamID );
	struct FQWord GetFirstLoginTimeAfterPreorderInstall ( );
	void SetFirstLoginTimeAfterPreorderInstall ( struct FQWord loginTime );
	void SetLastCharacter ( unsigned char TeamID, int iCharacterIndex );
	int GetLastCharacter ( unsigned char TeamID );
	unsigned char GetLastTeamID ( );
	void UnmarkHardwareStatsAsUploaded ( );
	void MarkHardwareStatsAsUploaded ( );
	bool HaveHardwareStatsBeenUploaded ( );
	int GetPostFXPreset ( );
	bool SetPostFXPreset ( int Value );
	float GetGammaSetting ( );
	bool SetGammaSetting ( float Value );
	unsigned char GetSFXVolumeSetting ( );
	bool SetSFXVolumeSetting ( int Value );
	unsigned char GetVoiceoverVolumeSetting ( );
	bool SetVoiceoverVolumeSetting ( int Value );
	unsigned char GetSpeechVolumeSetting ( );
	bool SetSpeechVolumeSetting ( int Value );
	unsigned char GetMusicVolumeSetting ( );
	bool SetMusicVolumeSetting ( int Value );
	bool SetBeenAtMpMenu ( );
	bool HasBeenAtMpMenu ( );
	bool SetAdjustedBrightness ( );
	bool HasAdjustedBrightness ( );
	bool SetAdjustedZoneOption ( );
	bool HasAdjustedZoneOption ( );
	bool SetSafeZoneOption ( struct FVector2D SafeZone, struct FVector2D SafeZoneOffset );
	void GetSafeZoneOption ( struct FVector2D* SafeZone, struct FVector2D* SafeZoneOffset );
	void ClearAllUnlockedAchievements ( );
	void ClearAllCollectibles ( );
	bool IsAudioLanguageEnglish ( );
	bool GetSubtitlesOption ( );
	void ResetMissionProgress ( );
	void UnlockAllMissions ( );
	bool IsGameFinished ( unsigned char Difficulty );
	void SetMissionProgress ( unsigned char mission, unsigned char Difficulty );
	int GetMissionProgressByNumber ( );
	void GetMissionProgress ( TArray< struct FYS_MissionProgress >* missionProgress );
	bool GetForceFeedbackOption ( );
	unsigned char GetButtonLayoutSetting ( );
	unsigned char GetAimSnapOnOption ( );
	bool GetSouthPawOption ( );
	bool GetInvertMouseOption ( unsigned long IsMouse );
	unsigned char GetVerticalSensitivitySetting ( unsigned long IsMouse );
	unsigned char GetHorizontalSensitivitySetting ( unsigned long IsMouse );
	bool SetAchievementValue ( int AchievementId, int Value );
	bool GetAchievementValue ( int AchievementId, int* Value );
	void ClearModifierCards ( );
	void OnChallengeCompleted ( unsigned char ChallengeID );
	void CheckChallengesCompletion ( int TeamID, TArray< unsigned char >* ChallengeIDs );
	void GetNonCompletedChallenges ( int StatId, int TeamID, TArray< unsigned char >* ChallengeIDs );
	void GetChallenges ( unsigned char ChallengeSection, unsigned char TeamID, TArray< unsigned char >* out_Challenges );
	int GetChallengesNum ( unsigned char ChallengeSection, unsigned char TeamID );
	bool IsChallengeCompleted ( unsigned char ChallengeID, int TeamID );
	void GetChallengeIDsByStatID ( int StatId, TArray< unsigned char >* ChallengeIDArray );
	int GetChallengeXP ( unsigned char ChallengeID );
	void GetChallengeProgression ( unsigned char ChallengeID, int TeamID, int* Progress, int* Target );
	unsigned char GetChallengeSection ( unsigned char ChallengeID );
	unsigned char GetChallengeTeam ( unsigned char ChallengeID );
	bool GetChallengeDescriptionVariable ( unsigned char ChallengeID, int* DescriptionVariable );
	struct FString GetChallengeDescription ( unsigned char ChallengeID );
	struct FString GetChallengeName ( unsigned char ChallengeID );
	bool IsChallengeValid ( unsigned char ChallengeID );
	void SetVictoryStreak ( class UClass* GameClass, int TeamID, int GlobalStreak, int TeamStreak );
	void GetVictoryStreak ( class UClass* GameClass, int TeamID, int* GlobalStreak, int* TeamStreak );
	bool CanProfileStatBeUpdated ( int StatId, unsigned char UpdateCondition );
	void ResetStat ( int StatId, int TeamID );
	void AddStatValueFloat ( int StatId, float Value, int TeamID );
	void SetStatValueInt ( int StatId, int Value, int TeamID );
	void ForceAddStatValueINT ( int StatId, int Value, int TeamID );
	void AddStatValueInt ( int StatId, int Value, int TeamID );
	float GetStatValueFloat ( int StatId, int TeamID );
	int GetStatValueInt ( int StatId, int TeamID );
	bool IsStatDouble ( int StatId );
	bool IsStatValid ( int StatId );
	void WriteStats ( );
	void ReadStats ( );
	void SetStatsToDefault ( );
	void SetCurrentMissionData ( int NewMissionID, int bNewMissionResult );
	void NewGame ( );
	void SetVoiceChatSetting ( int NewSetting );
	int GetVoiceChatSetting ( );
	void SetCampaignSkillLevel ( int NewSkillLevel );
	int GetCampaignSkillLevel ( );
	void SetCharacterName ( unsigned char TeamID, int iCharacter, struct FString sCharacterName );
	struct FString GetCharacterName ( unsigned char TeamID, int iCharacter );
	void SetEquipmentClass ( unsigned char TeamID, int iCharacter, struct FYS_EquipmentClass equipment );
	void GetEquipmentClass ( unsigned char TeamID, int iCharacter, struct FYS_EquipmentClass* equipClass, struct FString* CharacterName );
	void SetMeshList ( unsigned char TeamID, int iCharacter, struct FYS_CharacterMeshList* meshList );
	void GetMeshList ( unsigned char TeamID, int iCharacter, struct FYS_CharacterMeshList* meshList );
	unsigned char GetEquipmentClassFromSlot ( unsigned char EqSlot );
	void ClearEquipmentUnavailableFor ( struct FYS_EquipmentDefault EquiClassDefault, int iMinorPerk1Index, int iMinorPerk2Index, int iMinorPerk3Index, int rankLevel, int prestigeLevel );
	void ClearEquipmentUnavailable ( int rankLevel, int prestigeLevel );
	void SetNativeClanTag ( struct FString ClanTag );
	struct FString GetNativeClanTag ( );
	void SetCharacterToDefault ( int PSI_CharacterBase, unsigned char TeamID, struct FYS_EquipmentDefault* ClassDefault );
	void SetCharacterDefault ( unsigned char TeamID, int iCharacter );
	void SetCharactersToDefault ( );
	void UpdateMajorPerkLevel ( );
	void ForceResetCharacterToDefault ( );
	bool NeedResetCharacterToDefault ( );
	void ClearUnlockedItem ( );
	void RemoveJustUnlockedItem ( unsigned char ItemType, int iItem );
	bool IsJustUnlockedItem ( unsigned char ItemType, int iItem );
	void AddJustUnlockedItem ( unsigned char ItemType, int iItem );
	bool IsUnlockedItem ( struct FName ProviderTag, class UYUIDataProvider_Equipment* EquipmentProvider );
	void RemoveLevelUnlockedByProvider ( struct FName ProviderTag, class UYUIDataProvider_Equipment* EquipmentProvider );
	void RemoveLevelUnlocked ( int TeamID, int iNewLevel );
	void AddLevelUnlocked ( int TeamID, int iNewLevel );
	bool GetItemInfos ( struct FName ProviderTag, class UYUIDataProvider_Equipment* EquipmentProvider, unsigned char* ItemType, int* iItemNumber );
	void SetUnlockedRank ( int iOldRankLevel, int iNewRankLevel );
	void UnComputeUnlockedItem ( int iValue, unsigned char* ItemType, int* iItem );
	int ComputeUnlockedItem ( unsigned char ItemType, int iItem );
	int GetFirstUnlockItemEmpty ( );
	bool IsJustUnlockItemEmpty ( int iProfileIndex );
	void SetExodusCoopProgressLevel ( int Level );
	int GetExodusCoopProgressLevel ( );
	void SetCommunityChallengeState ( int ChallengeID, unsigned long bAchieved );
	bool IsCommunityChallengeAchieved ( int ChallengeID );
	int GetAchievedCommunityChallenges ( );
	void SetExperienceData ( struct FYS_ExperienceData* InData );
	void GetExperienceData ( struct FYS_ExperienceData* OutData );
	int GetLastPlayedMission ( );
	void SetLastPlayedMission ( int Idx );
	int GetActiveSlot ( );
	void SetActiveSlot ( int Idx );
	void TouchProfileSaveCheckUID ( );
	void SetKilledDev ( );
	bool HasKilledDev ( );
	void SetClanTag ( struct FString ClanTag );
	struct FString GetClanTag ( );
	bool IsFUBARDLCInstalled ( );
	bool IsOfficerClassDLCInstalled ( );
	bool IsAK47DLCInstalled ( );
	void VerifyDLCProfileSettings ( );
	void SetToDefaults ( );
	void ResetKeysToDefault ( class ULocalPlayer* InPlayerOwner );
	bool IsSpeakerIDFound ( int Id );
	bool IsCollectableIDFound ( int Id );
	int GetNumSpeakersFound ( );
	bool GetAchievementUnlocked ( int Id );
	void SetAchievementUnlocked ( int Id );
	int GetNumCollectablesFound ( );
	int GetNumBit ( int integerValue );
	int SetBit ( int integerValue, int bitIndex );
	bool BitIsSet ( int integerValue, int bitIndex );
	void ResetToDefault ( int ProfileId );
	bool GetProfileSettingValueIdByName ( struct FName SettingName, int* OutValue );
	bool GetProfileSettingValueStringByName ( struct FName SettingName, struct FString* OutValue );
	bool GetProfileSettingValueFloatByName ( struct FName SettingName, float* OutValue );
	bool GetProfileSettingValueIntByName ( struct FName SettingName, int* OutValue );
	bool GetProfileSettingDefaultId ( int ProfileSettingId, int* DefaultId, int* ListIndex );
	bool GetProfileSettingValueId ( int ProfileSettingId, int* ValueId, int* ListIndex );
	bool SetProfileSettingValueId ( int ProfileSettingId, int Value );
	void OnUnlockCollectables ( int Level, unsigned char Challenge, TArray< struct FYS_UnlockedCollectable >* out_array );
	void SetCurrentSelectedBadge ( int Index );
	int GetCurrentSelectedBadge ( );
	void SetCurrentSelectedTitle ( int Index );
	int GetCurrentSelectedTitle ( );
};

UClass* UYProfileSettings::pClassPointer = NULL;

// Class SRGame.YProfileWriter
// 0x0024 (0x0060 - 0x003C)
class UYProfileWriter : public UObject
{
public:
	unsigned char                                      m_reason;                                         		// 0x003C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_delayedFailedProfileSave_lastError;             		// 0x003D (0x0001) [0x0000000000000000]              
	unsigned char                                      m_pendingReason;                                  		// 0x003E (0x0001) [0x0000000000000000]              
	int                                                m_delayedFailedProfileSave_ControllerId;          		// 0x0040 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_failedSaveRetry : 1;                            		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_profileReadFailedMessageShown : 1;              		// 0x0044 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_profileSavePending : 1;                         		// 0x0044 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_profileSaveRunning : 1;                         		// 0x0044 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_validationSavePending : 1;                      		// 0x0044 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_validationSaveRunning : 1;                      		// 0x0044 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	struct FScriptDelegate                             __OnSaveFinished__Delegate;                       		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __PendingOnSaveFinished__Delegate;                		// 0x0054 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1518 ];

		return pClassPointer;
	};

	void SetSavingFlagForIcon ( unsigned long flag, unsigned long keepAlive );
	bool OnFailedNotSavedSelect ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void DelayedFailedToSaveProfile ( );
	void FailedToSaveProfile ( int ControllerId, unsigned char savingError );
	void RaiseOnSaveDoneEvent ( );
	bool SetupCompleteDelegate ( unsigned long Enable, int userID );
	void ConditionalCloseStorageWarningScene ( );
	void CheckPendingSaves ( unsigned long succeeded );
	void OnSaveProfileComplete ( unsigned char LocalUserNum, unsigned long bWasSuccessful );
	void GetMyLocalPlayer ( class ULocalPlayer** LP );
	bool GetLocalPlayer ( class AYPlayerController** PC, class ULocalPlayer** LP );
	void PerformSave ( unsigned char Reason, struct FScriptDelegate SaveDoneDelegate );
	void PerformValidationSave ( );
	void PerformProfileSave ( unsigned char Reason, struct FScriptDelegate SaveDoneDelegate );
	void PendingOnSaveFinished ( );
	void OnSaveFinished ( );
};

UClass* UYProfileWriter::pClassPointer = NULL;

// Class SRGame.YRayTexture
// 0x000C (0x0180 - 0x0174)
class UYRayTexture : public UTexture2D
{
public:
	TArray< struct FYRayTextureRow >                   Rows;                                             		// 0x0174 (0x000C) [0x0000000000580000]              ( CPF_Component | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1519 ];

		return pClassPointer;
	};

};

UClass* UYRayTexture::pClassPointer = NULL;

// Class SRGame.YRB_Handle
// 0x0000 (0x00C0 - 0x00C0)
class UYRB_Handle : public URB_Handle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1520 ];

		return pClassPointer;
	};

	void GrabComponent ( class UPrimitiveComponent* Component, struct FName InBoneName, struct FVector GrabLocation, unsigned long bConstrainRotation );
};

UClass* UYRB_Handle::pClassPointer = NULL;

// Class SRGame.YRevision
// 0x0000 (0x003C - 0x003C)
class UYRevision : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1521 ];

		return pClassPointer;
	};

	struct FString GetAdditionalBuildInfo ( );
	struct FString GetBuildTimestamp ( );
	int GetChangelistNumber ( );
};

UClass* UYRevision::pClassPointer = NULL;

// Class SRGame.YSandstormExcludeVolume
// 0x0000 (0x0234 - 0x0234)
class AYSandstormExcludeVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1522 ];

		return pClassPointer;
	};

	void CountTouchingExcludeVolumes ( class AActor* pwn, int* Count );
	void UnTouch ( class AActor* Other );
	void Touch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* AYSandstormExcludeVolume::pClassPointer = NULL;

// Class SRGame.YSeqAct_AddEntityTarget
// 0x000E (0x0102 - 0x00F4)
class UYSeqAct_AddEntityTarget : public USequenceAction
{
public:
	TArray< class UObject* >                           m_targets;                                        		// 0x00F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_fakeTargetType;                                 		// 0x0100 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_visibility;                                     		// 0x0101 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1523 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_AddEntityTarget::pClassPointer = NULL;

// Class SRGame.YSeqAct_AddFightArea
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_AddFightArea : public USequenceAction
{
public:
	class UObject*                                     m_fightArea;                                      		// 0x00F4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_forceFightAreas : 1;                            		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1524 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_AddFightArea::pClassPointer = NULL;

// Class SRGame.YSeqAct_AdjustPathFinding
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_AdjustPathFinding : public USequenceAction
{
public:
	unsigned long                                      m_findPathAroundGrenades : 1;                     		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_findPathAroundDangerZones : 1;                  		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_findPathAroundEnemies : 1;                      		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1525 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_AdjustPathFinding::pClassPointer = NULL;

// Class SRGame.YSeqAct_BlockDynamicRegroupFightArea
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_BlockDynamicRegroupFightArea : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1526 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_BlockDynamicRegroupFightArea::pClassPointer = NULL;

// Class SRGame.YSeqAct_ChangeAIType
// 0x0008 (0x010C - 0x0104)
class UYSeqAct_ChangeAIType : public USeqAct_Latent
{
public:
	unsigned char                                      m_newType;                                        		// 0x0104 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_leader : 1;                                     		// 0x0108 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1527 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	bool IsAIChangeCompleted ( );
	bool Update ( float DeltaTime );
};

UClass* UYSeqAct_ChangeAIType::pClassPointer = NULL;

// Class SRGame.YSeqAct_ChangeStanding
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_ChangeStanding : public USequenceAction
{
public:
	unsigned char                                      ChangeStandingOf;                                 		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      ChangeStandingTowards;                            		// 0x00F5 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      NewStanding;                                      		// 0x00F6 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      ChangeInBothDirections : 1;                       		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      MakeAIForgetNonHostileTargets : 1;                		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1528 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ChangeStanding::pClassPointer = NULL;

// Class SRGame.YSeqAct_ChangeStunEnemiesCommand
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_ChangeStunEnemiesCommand : public USequenceAction
{
public:
	unsigned char                                      m_commandMode;                                    		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UObject*                                     m_forcedOnLocation;                               		// 0x00F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1529 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_ChangeStunEnemiesCommand::pClassPointer = NULL;

// Class SRGame.YSeqAct_Checkpoint
// 0x0034 (0x0138 - 0x0104)
class UYSeqAct_Checkpoint : public USeqAct_Latent
{
public:
	struct FName                                       m_checkpointLoadName;                             		// 0x0104 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              TeleportDistance;                                 		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class AVolume* >                           TeleportVolumes;                                  		// 0x0110 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_playerLoadsAtLocator : 1;                       		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_testWalkerRotation : 1;                         		// 0x011C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_isLevelstart : 1;                               		// 0x011C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_success : 1;                                    		// 0x011C (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_wasLoading : 1;                                 		// 0x011C (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	float                                              m_rotationTestAngle;                              		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_chapter;                                        		// 0x0124 (0x0001) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned char                                      m_mission;                                        		// 0x0125 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class AYLocator*                                   m_locatorWalker;                                  		// 0x0128 (0x0004) [0x0000000000000000]              
	class AYLocator*                                   m_locatorLugo;                                    		// 0x012C (0x0004) [0x0000000000000000]              
	class AYLocator*                                   m_locatorAdams;                                   		// 0x0130 (0x0004) [0x0000000000000000]              
	float                                              ActivationTime;                                   		// 0x0134 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1530 ];

		return pClassPointer;
	};

	bool Update ( float DeltaTime );
	int GetObjClassVersion ( );
	void Deactivated ( );
	void Activated ( );
};

UClass* UYSeqAct_Checkpoint::pClassPointer = NULL;

// Class SRGame.YSeqAct_ClearFightAreas
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ClearFightAreas : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1531 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ClearFightAreas::pClassPointer = NULL;

// Class SRGame.YSeqAct_ClearTargets
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_ClearTargets : public USequenceAction
{
public:
	unsigned long                                      m_clearNormalTargets : 1;                         		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_clearFakeTargets : 1;                           		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_changeForcedTargetsToNormalTargets : 1;         		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1532 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_ClearTargets::pClassPointer = NULL;

// Class SRGame.YSeqAct_DespawnPawn
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_DespawnPawn : public USequenceAction
{
public:
	unsigned long                                      m_mayCauseGameOver : 1;                           		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1533 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_DespawnPawn::pClassPointer = NULL;

// Class SRGame.YSeqAct_EnableGrenadeDirector
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_EnableGrenadeDirector : public USequenceAction
{
public:
	unsigned char                                      m_grenadeDirectorMode;                            		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_grenadeDirectorSettings;                        		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1534 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_EnableGrenadeDirector::pClassPointer = NULL;

// Class SRGame.YSeqAct_GlobalSuppressGenericVoiceOver
// 0x001C (0x0110 - 0x00F4)
class UYSeqAct_GlobalSuppressGenericVoiceOver : public USequenceAction
{
public:
	struct FYS_SuppressionSetting                      m_suppressionSettings;                            		// 0x00F4 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_affectedFractions;                              		// 0x0104 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1535 ];

		return pClassPointer;
	};

	void ClearAllSuppressionSettings ( );
	void SupressAllButThisTeam ( unsigned char Team );
	bool IsEventSuppressed ( unsigned char setType, class AYGamePawn* yPawn );
};

UClass* UYSeqAct_GlobalSuppressGenericVoiceOver::pClassPointer = NULL;

// Class SRGame.YSeqAct_LinkAttackCommandArea
// 0x000D (0x0101 - 0x00F4)
class UYSeqAct_LinkAttackCommandArea : public USequenceAction
{
public:
	TArray< class UObject* >                           m_fightAreas;                                     		// 0x00F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_commandType;                                    		// 0x0100 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1536 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_LinkAttackCommandArea::pClassPointer = NULL;

// Class SRGame.YSeqAct_RemoveFightArea
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_RemoveFightArea : public USequenceAction
{
public:
	class UObject*                                     m_fightArea;                                      		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1537 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_RemoveFightArea::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetCombatFallbackDirections
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_SetCombatFallbackDirections : public USequenceAction
{
public:
	class AActor*                                      m_coverDirectionActor;                            		// 0x00F4 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_attackDirectionActor;                           		// 0x00F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1538 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetCombatFallbackDirections::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetDefaultFightArea
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetDefaultFightArea : public USequenceAction
{
public:
	class UObject*                                     m_fightArea;                                      		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1539 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SetDefaultFightArea::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetFaceFXRegister
// 0x0014 (0x0108 - 0x00F4)
class UYSeqAct_SetFaceFXRegister : public USequenceAction
{
public:
	struct FString                                     m_regName;                                        		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      m_regOp;                                          		// 0x0100 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_faceFXRegisterDeclared : 1;                     		// 0x0104 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1540 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetFaceFXRegister::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetFakeTarget
// 0x000E (0x0102 - 0x00F4)
class UYSeqAct_SetFakeTarget : public USequenceAction
{
public:
	TArray< class UObject* >                           m_fakeTargets;                                    		// 0x00F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_fakeTargetType;                                 		// 0x0100 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_visibility;                                     		// 0x0101 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1541 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SetFakeTarget::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetFightArea
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_SetFightArea : public USequenceAction
{
public:
	TArray< class UObject* >                           m_fightAreas;                                     		// 0x00F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_forceFightAreas : 1;                            		// 0x0100 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1542 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SetFightArea::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetSandstormLevel
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_SetSandstormLevel : public USequenceAction
{
public:
	int                                                m_sandstormLevel;                                 		// 0x00F4 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	unsigned long                                      m_enabledForPawns : 1;                            		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_enabledForAI : 1;                               		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	class UAnimSet*                                    m_sandStormAnimSet;                               		// 0x00FC (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UYAssetReference*                            m_sandStormAnimsetReference;                      		// 0x0100 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1543 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_SetSandstormLevel::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetSquadCombatState
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetSquadCombatState : public USequenceAction
{
public:
	unsigned long                                      m_enterCombat : 1;                                		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1544 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetSquadCombatState::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetSquadToInfiltrateMode
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetSquadToInfiltrateMode : public USequenceAction
{
public:
	unsigned long                                      m_enable : 1;                                     		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_forceInfiltrateMode : 1;                        		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1545 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SetSquadToInfiltrateMode::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleCombatPos
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleCombatPos : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1546 ];

		return pClassPointer;
	};

	void DoKismetWarning ( );
};

UClass* UYSeqAct_ToggleCombatPos::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleSandStormAnimation
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_ToggleSandStormAnimation : public USequenceAction
{
public:
	class UAnimSet*                                    m_animSet;                                        		// 0x00F4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UYAssetReference*                            m_animSetReference;                               		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1547 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ToggleSandStormAnimation::pClassPointer = NULL;

// Class SRGame.YSeqAct_VideoTexture
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_VideoTexture : public USequenceAction
{
public:
	class UObject*                                     m_videoTexture;                                   		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1548 ];

		return pClassPointer;
	};

	void OnAction ( int inputLinkIndex );
};

UClass* UYSeqAct_VideoTexture::pClassPointer = NULL;

// Class SRGame.YSeqEvent_BehaviorStateChanged
// 0x0004 (0x0114 - 0x0110)
class UYSeqEvent_BehaviorStateChanged : public USequenceEvent
{
public:
	unsigned long                                      m_globalEvent : 1;                                		// 0x0110 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1549 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_BehaviorStateChanged::pClassPointer = NULL;

// Class SRGame.YSeqEvent_BehaviorTreeEvent
// 0x0010 (0x0120 - 0x0110)
class UYSeqEvent_BehaviorTreeEvent : public USequenceEvent
{
public:
	unsigned char                                      m_eventToListen;                                  		// 0x0110 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxTimeSinceLastTrigger;                        		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lastTime;                                       		// 0x0118 (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_eventHandler;                                   		// 0x011C (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1550 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_BehaviorTreeEvent::pClassPointer = NULL;

// Class SRGame.YSeqEvent_CapturePointControlled
// 0x000C (0x011C - 0x0110)
class UYSeqEvent_CapturePointControlled : public USequenceEvent
{
public:
	TArray< class APawn* >                             m_players;                                        		// 0x0110 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1551 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_CapturePointControlled::pClassPointer = NULL;

// Class SRGame.YSeqEvent_GenericPlayerSquadTrigger
// 0x0001 (0x0111 - 0x0110)
class UYSeqEvent_GenericPlayerSquadTrigger : public USequenceEvent
{
public:
	unsigned char                                      m_combatStartedOutput;                            		// 0x0110 (0x0001) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1552 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqEvent_GenericPlayerSquadTrigger::pClassPointer = NULL;

// Class SRGame.YSeqEvent_ScriptedPlayerSquadTrigger
// 0x0001 (0x0111 - 0x0110)
class UYSeqEvent_ScriptedPlayerSquadTrigger : public USequenceEvent
{
public:
	unsigned char                                      m_combatStartedOutput;                            		// 0x0110 (0x0001) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1553 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqEvent_ScriptedPlayerSquadTrigger::pClassPointer = NULL;

// Class SRGame.YSeqEvent_SeeEnemy
// 0x0008 (0x0118 - 0x0110)
class UYSeqEvent_SeeEnemy : public USequenceEvent
{
public:
	float                                              m_pulseFrequency;                                 		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lastPulseTime;                                  		// 0x0114 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1554 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqEvent_SeeEnemy::pClassPointer = NULL;

// Class SRGame.YSpecialActionSetTypes
// 0x00F4 (0x0130 - 0x003C)
class UYSpecialActionSetTypes : public UObject
{
public:
	unsigned char                                      m_standardEventPriorities[ 0xF4 ];                		// 0x003C (0x00F4) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1555 ];

		return pClassPointer;
	};

};

UClass* UYSpecialActionSetTypes::pClassPointer = NULL;

// Class SRGame.YSquadContextVolume
// 0x001C (0x0250 - 0x0234)
class AYSquadContextVolume : public AVolume
{
public:
	TArray< class UYSpecialActionSet* >                m_specialActionSets;                              		// 0x0234 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_priority;                                       		// 0x0240 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_pauseTime;                                      		// 0x0244 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lastTime;                                       		// 0x0248 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_active : 1;                                     		// 0x024C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1556 ];

		return pClassPointer;
	};

	void PreBeginPlay ( );
	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYSquadContextVolume::pClassPointer = NULL;

// Class SRGame.YStatsObject
// 0x0000 (0x01D8 - 0x01D8)
class UYStatsObject : public UOnlineGameplayEvents
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1557 ];

		return pClassPointer;
	};

	void LogMedicReviveEvent ( class APawn** MedicPawn, class APawn** TargetPawn );
	void LogMedicAdrenalineEvent ( class APawn** MedicPawn, class APawn** TargetPawn );
	void LogSupplyDropEvent ( struct FString OfficerName, struct FVector OfficerLocation, float ThrownTime, struct FVector* OrderLocation );
	void LogOrderGivenEvent ( struct FString OfficerName, struct FVector OfficerLocation, float ThrownTime, struct FVector* OrderLocation );
	void LogSandbombEvent ( class APawn** Pawn, struct FVector* SandbombLocation );
	void LogAvalancheEvent ( class APawn** Pawn, struct FVector* AvalancheLocation );
	void LogVPDestroyedEvent ( unsigned long IsHVT, class APawn** Pawn, struct FVector* VPLocation );
	void LogCOMDeactivationEvent ( class APawn** Pawn, struct FVector* COMLocation );
	void LogCOMActivationEvent ( class APawn** Pawn, struct FVector* COMLocation );
	void LogLootDroppedEvent ( int LootValue, unsigned long IsDeposit, class APawn** Pawn );
	void LogLootPickUpEvent ( int LootValue, unsigned long IsSteal, class APawn** Pawn );
	void LogAssistEvent ( int DeathId, int Damage, class APlayerReplicationInfo** PRI );
	void LogConnectionStats ( class APlayerReplicationInfo* PRI );
	void LogSandStormEvent ( float Time, unsigned long bStarting );
	void LogZipLineEvent ( class AController* Zipper );
	void LogVaultEvent ( class AController* Vaulter );
	void LogCoverEvent ( class AController* Coveree, unsigned long bEntering );
	void LogPickupEvent ( class AController* Picker, class AYPickupActor* PickupObject );
	void LogPlayerStateEvent ( class APlayerReplicationInfo* PRI, unsigned char State );
	void LogWeaponAccuracies ( class AYPlayerReplicationInfo_MP* PRI );
	void LogOutOfAmmoEvent ( class APlayerReplicationInfo* PRI, unsigned char Weapon );
	void LogHealEvent ( class APlayerReplicationInfo* Healer, class APlayerReplicationInfo* Healed );
	void LogPlayerLeaveEvent ( class AYPlayerController_MP* C );
	void LogChallengeEvent ( class APlayerReplicationInfo* PRI, int Id );
	void LogDeathEvent ( unsigned long bDBNO, class AController* Killed, class AController* Killer, class UClass* DamageType, int DeathId );
	void LogSpawnEvent ( class AYPlayerReplicationInfo_MP* PRI );
	void EndGameplaySession ( );
	void LogGameplayEvent ( class AController* Player, int EventID, int EventData );
	void UpdateFromGameSettings ( class UYGameSettingsMultiplayer* Settings );
	void BeginGameplaySession ( );
};

UClass* UYStatsObject::pClassPointer = NULL;

// Class SRGame.YTitle
// 0x0014 (0x0050 - 0x003C)
class UYTitle : public UObject
{
public:
	struct FString                                     m_titleName;                                      		// 0x003C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	unsigned char                                      m_ChallengeEnum;                                  		// 0x0048 (0x0001) [0x0000000000000000]              
	int                                                m_UnlockLevel;                                    		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1558 ];

		return pClassPointer;
	};

	struct FName StaticGetProviderTag ( );
	struct FString StaticGetTitleFriendlyName ( int Index );
};

UClass* UYTitle::pClassPointer = NULL;

// Class SRGame.YUIPostGameScoreboardHelper
// 0x0034 (0x0070 - 0x003C)
class UYUIPostGameScoreboardHelper : public UObject
{
public:
	class UYScoreboardPlayerInfo*                      m_OwnerPRI;                                       		// 0x003C (0x0004) [0x0000000000000000]              
	TArray< class UYScoreboardPlayerInfo* >            m_PRIList;                                        		// 0x0040 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATeamInfo* >                         m_teams;                                          		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_GameMode;                                       		// 0x0058 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_MatchType;                                      		// 0x0059 (0x0001) [0x0000000000000000]              
	int                                                m_numRounds;                                      		// 0x005C (0x0004) [0x0000000000000000]              
	int                                                m_NumCurrentRound;                                		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                m_SpecopsScore;                                   		// 0x0064 (0x0004) [0x0000000000000000]              
	int                                                m_KonradsScore;                                   		// 0x0068 (0x0004) [0x0000000000000000]              
	int                                                m_timeLeft;                                       		// 0x006C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1559 ];

		return pClassPointer;
	};

	void AddUsedPerks ( struct FYS_EquipmentClass equipment, int Time );
	void GetPRIArray ( TArray< class UYScoreboardPlayerInfo* >* PRIs );
	unsigned char GetMatchTypeId ( );
	unsigned char GetMultiplayerModeId ( );
	void SetInfo ( class AYGameReplicationInfo_MP* GRIMP, class AYPlayerReplicationInfo* OwnerPRI );
	class UYUIPostGameScoreboardHelper* GetHelper ( );
	void DestroyHelper ( );
	void CreateHelper ( );
};

UClass* UYUIPostGameScoreboardHelper::pClassPointer = NULL;

// Class SRGame.YVerletParticleCollisionActor
// 0x0064 (0x025C - 0x01F8)
class AYVerletParticleCollisionActor : public AActor
{
public:
	float                                              m_restitution;                                    		// 0x01F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class AActor* >                            m_influencedActors;                               		// 0x01FC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      UnknownData00[ 0x8 ];                             		// 0x0208 (0x0008) MISSED OFFSET
	struct FMatrix                                     m_worldToLocal;                                   		// 0x0210 (0x0040) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_planeNormal;                                    		// 0x0250 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1560 ];

		return pClassPointer;
	};

};

UClass* AYVerletParticleCollisionActor::pClassPointer = NULL;

// Class SRGame.YVerletParticleCollisionActor_Plane
// 0x000C (0x0268 - 0x025C)
class AYVerletParticleCollisionActor_Plane : public AYVerletParticleCollisionActor
{
public:
	float                                              m_height;                                         		// 0x025C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_width;                                          		// 0x0260 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UDrawBoxComponent*                           m_renderingComponent;                             		// 0x0264 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1561 ];

		return pClassPointer;
	};

};

UClass* AYVerletParticleCollisionActor_Plane::pClassPointer = NULL;

// Class SRGame.YVerletParticleManager
// 0x0000 (0x003C - 0x003C)
class UYVerletParticleManager : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1562 ];

		return pClassPointer;
	};

	void RenderDebug ( TArray< struct FYS_VerletParticle >* Particles, struct FMatrix* particleTransform );
	void SatisfyConstraints ( TArray< struct FYS_VerletConstraint >* Constraints );
	void Integrate ( float dt, float Damping, TArray< struct FYS_VerletParticle >* Particles );
	void ClearForce ( TArray< struct FYS_VerletParticle >* Particles );
	void AddForce ( struct FVector Force, TArray< struct FYS_VerletParticle >* Particles );
};

UClass* UYVerletParticleManager::pClassPointer = NULL;

// Class SRGame.YVisibilityVolume
// 0x000C (0x0240 - 0x0234)
class AYVisibilityVolume : public AVolume
{
public:
	int                                                m_inVolumeCamoModifier;                           		// 0x0234 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	int                                                m_seeThroughVolumeCamoModifier;                   		// 0x0238 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	unsigned long                                      m_influenceVisibility : 1;                        		// 0x023C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1563 ];

		return pClassPointer;
	};

	void Toggle ( class USeqAct_Toggle* Action );
};

UClass* AYVisibilityVolume::pClassPointer = NULL;

// Class SRGame.YAchievementManager
// 0x0018 (0x0054 - 0x003C)
class UYAchievementManager : public UObject
{
public:
	class AYPlayerController*                          m_pc;                                             		// 0x003C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bEnable : 1;                                    		// 0x0040 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_debugMode : 1;                                  		// 0x0040 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_disableChapterWideAchievements : 1;             		// 0x0040 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_startedNoDeathCheck : 1;                        		// 0x0040 (0x0004) [0x0000000000000000] [0x00000008] 
	int                                                m_MPWinLotPlayersThreshold;                       		// 0x0044 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FName >                             m_DevNames;                                       		// 0x0048 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1564 ];

		return pClassPointer;
	};

	void WarningToScreen ( struct FString Str );
	void LogToScreen ( struct FString Str );
	bool UpdateAchievement_INTEL ( int Id );
	bool UpdateAchievement_NODEATH ( int NewValue );
	void InvalidateNoDeathAchievement ( );
	void CheckChapterWideAchievements ( );
	void DisableChapterWideAchievements ( );
	void ResetChapterWideAchievements ( );
	bool UpdateAchievement_Counting ( unsigned char AchievementId, int Count );
	struct FString GetAchievementName ( unsigned char AchievementId );
	void TriggerAllUnlockedAchievements ( );
	bool IsDev ( struct FName UserName );
	int GetThreshold ( unsigned char AchievementId );
	int GetEventMessageIncrement ( unsigned char AchievementId );
	void ResetAchievement ( unsigned char AchievementId );
	void ResetAchievementCounting ( );
	void AchievementDone ( unsigned long bWasSuccessful );
	void UnlockAchievement ( int AchievementId );
	void UpdateAchievement ( unsigned char AchievementId, int Value );
};

UClass* UYAchievementManager::pClassPointer = NULL;

// Class SRGame.YControlRestrictions
// 0x0000 (0x003C - 0x003C)
class UYControlRestrictions : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1565 ];

		return pClassPointer;
	};

	void Clear ( struct FYS_ControlRestrictions Flags, struct FYS_ControlRestrictions* outFlags );
	void Set ( struct FYS_ControlRestrictions Flags, struct FYS_ControlRestrictions* outFlags );
	bool CheckSquadCommandRestriction ( struct FYS_ControlRestrictions Flags, unsigned char Command );
};

UClass* UYControlRestrictions::pClassPointer = NULL;

// Class SRGame.YDebugHelper
// 0x0000 (0x003C - 0x003C)
class UYDebugHelper : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1566 ];

		return pClassPointer;
	};

	bool ParseCommandLineParam ( struct FString Param );
};

UClass* UYDebugHelper::pClassPointer = NULL;

// Class SRGame.YGeometryUtils
// 0x0000 (0x003C - 0x003C)
class UYGeometryUtils : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1567 ];

		return pClassPointer;
	};

	struct FVector YLinePlaneIntersection ( struct FVector point1, struct FVector point2, struct FVector planeOrigin, struct FVector planeNormal );
	float PointPlaneDist2D ( struct FVector Point, struct FVector planeBase, struct FVector planeNormal, struct FVector* closestPoint );
	float PointPlaneDist ( struct FVector Point, struct FVector planeBase, struct FVector planeNormal, struct FVector* closestPoint );
	unsigned char LineSegmentIntersection2D ( struct FVector P0, struct FVector P1, struct FVector P2, struct FVector p3, struct FVector* intersection01, struct FVector* intersection23, struct FVector* closestPoint01, struct FVector* closestPoint23, float* pct01, float* pct23 );
	float ClosestPointPercentage2D ( struct FVector P0, struct FVector P1, struct FVector P );
	float ClosestPointPercentage ( struct FVector P0, struct FVector P1, struct FVector P );
};

UClass* UYGeometryUtils::pClassPointer = NULL;

// Class SRGame.YInterpolatorBase
// 0x000C (0x0048 - 0x003C)
class UYInterpolatorBase : public UObject
{
public:
	struct FScriptDelegate                             __OnInterpolationEndCallback__Delegate;           		// 0x003C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1568 ];

		return pClassPointer;
	};

	void CallEndCallback ( struct FScriptDelegate endCallback, unsigned long finished );
	void OnInterpolationEndCallback ( unsigned long finished );
};

UClass* UYInterpolatorBase::pClassPointer = NULL;

// Class SRGame.YFloatCurveInterpolator
// 0x0000 (0x0048 - 0x0048)
class UYFloatCurveInterpolator : public UYInterpolatorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1569 ];

		return pClassPointer;
	};

	float Finish ( struct FYS_InterpolatedFloatCurve* interpolator );
	bool IsActive ( struct FYS_InterpolatedFloatCurve* interpolator );
	float Update ( float DeltaTime, struct FYS_InterpolatedFloatCurve* interpolator );
	void InitNewCurve ( float Length, float TargetValue, float extremum, float inflection, float Scalar, float scalar2, float addend, struct FScriptDelegate endCallback, struct FYS_InterpolatedFloatCurve* interpolator );
};

UClass* UYFloatCurveInterpolator::pClassPointer = NULL;

// Class SRGame.YOffsetFloatInterpolator
// 0x0000 (0x0048 - 0x0048)
class UYOffsetFloatInterpolator : public UYInterpolatorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1570 ];

		return pClassPointer;
	};

	float Finish ( struct FYS_OffsetFloatInterpolator* interpolator );
	bool IsActive ( struct FYS_OffsetFloatInterpolator* interpolator );
	float Update ( float DeltaTime, struct FYS_OffsetFloatInterpolator* interpolator );
	void Init ( float Length, float Delay, float offsetValue, unsigned long smoothInterpolation, struct FScriptDelegate endCallback, struct FYS_OffsetFloatInterpolator* interpolator );
};

UClass* UYOffsetFloatInterpolator::pClassPointer = NULL;

// Class SRGame.YOffsetLocationInterpolator
// 0x0000 (0x0048 - 0x0048)
class UYOffsetLocationInterpolator : public UYInterpolatorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1571 ];

		return pClassPointer;
	};

	struct FVector Finish ( struct FYS_OffsetLocationInterpolator* interpolator );
	bool IsActive ( struct FYS_OffsetLocationInterpolator* interpolator );
	struct FVector Update ( float DeltaTime, struct FYS_OffsetLocationInterpolator* interpolator );
	void Init ( float Length, float Delay, struct FVector offsetLocation, struct FScriptDelegate endCallback, struct FYS_OffsetLocationInterpolator* interpolator );
};

UClass* UYOffsetLocationInterpolator::pClassPointer = NULL;

// Class SRGame.YOffsetRotationCurve
// 0x0000 (0x0048 - 0x0048)
class UYOffsetRotationCurve : public UYInterpolatorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1572 ];

		return pClassPointer;
	};

	struct FRotator Finish ( struct FYS_OffsetRotationCurve* interpolator );
	bool IsActive ( struct FYS_OffsetRotationCurve* interpolator );
	struct FRotator Update ( float DeltaTime, struct FYS_OffsetRotationCurve* interpolator );
	void Init ( float Length, struct FRotator offsetRotation, float extremum, float inflection, float Scalar, float scalar2, float addend, struct FScriptDelegate endCallback, struct FYS_OffsetRotationCurve* interpolator );
};

UClass* UYOffsetRotationCurve::pClassPointer = NULL;

// Class SRGame.YOffsetRotationInterpolator
// 0x0000 (0x0048 - 0x0048)
class UYOffsetRotationInterpolator : public UYInterpolatorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1573 ];

		return pClassPointer;
	};

	struct FRotator Finish ( struct FYS_OffsetRotationInterpolator* interpolator );
	bool IsActive ( struct FYS_OffsetRotationInterpolator* interpolator );
	struct FRotator Update ( float DeltaTime, struct FYS_OffsetRotationInterpolator* interpolator );
	void Init ( float Length, float Delay, struct FRotator offsetRotation, struct FScriptDelegate endCallback, struct FYS_OffsetRotationInterpolator* interpolator );
};

UClass* UYOffsetRotationInterpolator::pClassPointer = NULL;

// Class SRGame.YTargetFloatInterpolator
// 0x0000 (0x0048 - 0x0048)
class UYTargetFloatInterpolator : public UYInterpolatorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1574 ];

		return pClassPointer;
	};

	float Finish ( float CurrentValue, struct FYS_TargetFloatInterpolator* interpolator );
	bool IsActive ( struct FYS_TargetFloatInterpolator* interpolator );
	float Update ( float DeltaTime, float CurrentValue, struct FYS_TargetFloatInterpolator* interpolator );
	void Init ( float Length, float Delay, float TargetValue, struct FScriptDelegate endCallback, struct FYS_TargetFloatInterpolator* interpolator );
};

UClass* UYTargetFloatInterpolator::pClassPointer = NULL;

// Class SRGame.YTargetLocationInterpolator
// 0x0000 (0x0048 - 0x0048)
class UYTargetLocationInterpolator : public UYInterpolatorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1575 ];

		return pClassPointer;
	};

	struct FVector Finish ( struct FVector CurrentLocation, struct FYS_TargetLocationInterpolator* interpolator );
	bool IsActive ( struct FYS_TargetLocationInterpolator* interpolator );
	struct FVector Update ( float DeltaTime, struct FVector CurrentLocation, struct FYS_TargetLocationInterpolator* interpolator );
	void Init ( float Length, float Delay, struct FVector TargetLocation, unsigned long XAxis, unsigned long YAxis, unsigned long ZAxis, struct FScriptDelegate endCallback, struct FYS_TargetLocationInterpolator* interpolator );
};

UClass* UYTargetLocationInterpolator::pClassPointer = NULL;

// Class SRGame.YTargetRotationInterpolator
// 0x0000 (0x0048 - 0x0048)
class UYTargetRotationInterpolator : public UYInterpolatorBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1576 ];

		return pClassPointer;
	};

	struct FRotator Finish ( struct FRotator CurrentRotation, struct FYS_TargetRotationInterpolator* interpolator );
	bool IsActive ( struct FYS_TargetRotationInterpolator* interpolator );
	struct FRotator Update ( float DeltaTime, struct FRotator CurrentRotation, struct FYS_TargetRotationInterpolator* interpolator );
	void Init ( float Length, float Delay, struct FRotator TargetRotation, unsigned long useShortest, struct FScriptDelegate endCallback, struct FYS_TargetRotationInterpolator* interpolator );
};

UClass* UYTargetRotationInterpolator::pClassPointer = NULL;

// Class SRGame.YMathUtils
// 0x0000 (0x003C - 0x003C)
class UYMathUtils : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1577 ];

		return pClassPointer;
	};

	struct FLinearColor DesaturateColor ( float val, struct FLinearColor Col );
	float DegToDotProduct ( float Angle );
	float AimAngleToDotProduct ( float Angle );
	unsigned char LineLineIntersection3D ( struct FVector Pos1, struct FVector Dir1, struct FVector Pos2, struct FVector Dir2, struct FVector* Intersect, float* Distance );
	unsigned char LineLineIntersection2D ( struct FVector2D Pos1, struct FVector2D Dir1, struct FVector2D Pos2, struct FVector2D Dir2, struct FVector2D* Intersect, float* Distance, float* lambda1, float* lambda2 );
	float UnWindNormalizedAimAngle ( float Angle );
	float UnwindAngleDegree ( float Angle );
	float UseValueMapping ( float inValue, struct FYS_ValueMappingRule* rules );
	float LinearStep ( float X, float X1, float X2, float Y1, float Y2 );
	float SmoothStep ( float X, float X1, float X2, float Y1, float Y2 );
	float SmoothFloat ( float From, float to, float smoothingFactor, float dt, float* Velocity );
	float Converge ( float Value, float Dest, float dt, float Speed );
	void SmoothVector ( float Smoothing, float dt, struct FVector* From, struct FVector* to, struct FVector* vel, struct FVector* NewPos );
	float Sign ( float Value );
	int Ceil ( float Value );
	int Floor ( float Value );
	struct FRotator RInterpPerAxis ( struct FRotator From, struct FRotator to, float dt, struct FVector interpSpeeds );
};

UClass* UYMathUtils::pClassPointer = NULL;

// Class SRGame.YMovementDirection
// 0x0000 (0x003C - 0x003C)
class UYMovementDirection : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1578 ];

		return pClassPointer;
	};

	unsigned char RotationOffsetToDirection ( struct FRotator RotationOffset );
	struct FRotator DirectionToRotationOffset ( unsigned char movementDirection );
};

UClass* UYMovementDirection::pClassPointer = NULL;

// Class SRGame.YRecoverValue
// 0x0018 (0x0054 - 0x003C)
class UYRecoverValue : public UObject
{
public:
	struct FScriptDelegate                             __OnRecoverValueChanged__Delegate;                		// 0x003C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnRecoverModifierApplied__Delegate;             		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1579 ];

		return pClassPointer;
	};

	void ClearCallbacks ( struct FYS_RecoverValue* recoverValue );
	void RemoveAllCallbacks ( struct FScriptDelegate callback, struct FYS_RecoverValue* recoverValue );
	void RemoveCallback ( struct FScriptDelegate callback, struct FYS_RecoverValue* recoverValue );
	void AddCallback ( struct FScriptDelegate callback, unsigned char Type, float Threshold, struct FYS_RecoverValue* recoverValue );
	void ClearModifiers ( struct FYS_RecoverValue* recoverValue );
	void UnSuppressModifiers ( struct FYS_RecoverValue* recoverValue );
	void SuppressModifier ( struct FName modName, struct FYS_RecoverValue* recoverValue );
	void RemoveAllModifiers ( struct FName modName, struct FYS_RecoverValue* recoverValue );
	void RemoveModifier ( struct FName modName, struct FYS_RecoverValue* recoverValue );
	void AddModifier ( struct FName modName, float Value, float Time, unsigned char Priority, unsigned long infinite, float Delay, struct FScriptDelegate modifierAppliedCallback, struct FYS_RecoverValue* recoverValue );
	void Apply ( float replicatedValue, float smoothingTime, struct FYS_RecoverValue* recoverValue );
	bool Update ( float DeltaTime, struct FYS_RecoverValue* recoverValue, float* replicatedValue );
	void SetMaxValue ( float newMaxValue, struct FYS_RecoverValue* recoverValue );
	void Init ( float MaxValue, float InitialValue, struct FYS_RecoverValue* recoverValue );
	void OnRecoverModifierApplied ( float contribution );
	void OnRecoverValueChanged ( float percentage );
};

UClass* UYRecoverValue::pClassPointer = NULL;

// Class SRGame.YRemoteSpeakerBase
// 0x0050 (0x0248 - 0x01F8)
class AYRemoteSpeakerBase : public AReplicationInfo
{
public:
	unsigned long                                      m_speaking : 1;                                   		// 0x01F8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_speakLineCancelledByKismetStop : 1;             		// 0x01F8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_enabled : 1;                                    		// 0x01F8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_allowSpatialization : 1;                        		// 0x01F8 (0x0004) [0x0000000000000002] [0x00000008] ( CPF_Const )
	unsigned long                                      m_forcedUISounds : 1;                             		// 0x01F8 (0x0004) [0x0000000000000000] [0x00000010] 
	struct FYS_RemoteSpeakerData                       m_speakLineData;                                  		// 0x01FC (0x0028) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FScriptDelegate                             m_speakLineEndCallback;                           		// 0x0224 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UAudioComponent*                             m_currentlySpeakingLine;                          		// 0x0230 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_speechFadeDuration;                             		// 0x0234 (0x0004) [0x0000000000000000]              
	float                                              m_noSoundSubtitleDuration;                        		// 0x0238 (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __OnSpeakLineFinished__Delegate;                  		// 0x023C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1580 ];

		return pClassPointer;
	};

	void OnToggle ( class USeqAct_Toggle* Action );
	void SpeakLineFinished ( );
	void FaceFXAudioFinished ( class UAudioComponent* AC );
	void StopTalkingByKismet ( );
	void StopTalking ( unsigned long immediately );
	void PlayQueuedSpeakLine ( );
	bool SpeakLine ( class AActor* addressee, class USoundCue* Audio, struct FString DebugText, struct FScriptDelegate speakLineEndCallback, float DelaySec, unsigned char SubtitlePriority );
	bool SpeakLineDirect ( struct FYS_RemoteSpeakerData speakLineData, struct FScriptDelegate speakLineEndCallback );
	bool CanSpeakLine ( class USoundCue* Audio );
	void OnSpeakLineFinished ( );
	void ReplicatedEvent ( struct FName VarName );
	class USoundCue* ClientGetSoundCue ( int Uid );
};

UClass* AYRemoteSpeakerBase::pClassPointer = NULL;

// Class SRGame.YRemoteSpeaker_Generic
// 0x0000 (0x0248 - 0x0248)
class AYRemoteSpeaker_Generic : public AYRemoteSpeakerBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1581 ];

		return pClassPointer;
	};

};

UClass* AYRemoteSpeaker_Generic::pClassPointer = NULL;

// Class SRGame.YRemoteSpeaker_Team
// 0x0001 (0x0249 - 0x0248)
class AYRemoteSpeaker_Team : public AYRemoteSpeaker_Generic
{
public:
	unsigned char                                      m_teamID;                                         		// 0x0248 (0x0001) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1582 ];

		return pClassPointer;
	};

	void PlayQueuedSpeakLine ( );
};

UClass* AYRemoteSpeaker_Team::pClassPointer = NULL;

// Class SRGame.YSampler
// 0x0000 (0x003C - 0x003C)
class UYSampler : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1583 ];

		return pClassPointer;
	};

	bool InitDistributionVector ( class UDistributionVector* Distribution, class UCurveEdPresetCurve* curveX, class UCurveEdPresetCurve* curveY, class UCurveEdPresetCurve* curveZ );
	bool InitDistributionFloat ( class UDistributionFloat* Distribution, class UCurveEdPresetCurve* Curve );
	float GetDistributionVectorLength ( class UDistributionVector* Distribution );
	float GetDistributionFloatLength ( class UDistributionFloat* Distribution );
	struct FVector GetVector ( class UDistributionVector* Distribution, float sampleTime );
	float GetFloat ( class UDistributionFloat* Distribution, float sampleTime );
};

UClass* UYSampler::pClassPointer = NULL;

// Class SRGame.YScriptDelegate
// 0x000C (0x0048 - 0x003C)
class UYScriptDelegate : public UObject
{
public:
	struct FScriptDelegate                             __GenericDelegate__Delegate;                      		// 0x003C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1584 ];

		return pClassPointer;
	};

	void SetDelegateObject ( class UObject* delegateObj, struct FScriptDelegate* delegateObject );
	struct FString DelegateToString ( struct FScriptDelegate delegateObject );
	bool DelegateIsSet ( struct FScriptDelegate delegateObject );
	struct FName GetDelegateFunctionName ( struct FScriptDelegate delegateObject );
	void GenericDelegate ( );
};

UClass* UYScriptDelegate::pClassPointer = NULL;

// Class SRGame.YSpeakLineSystem
// 0x0000 (0x003C - 0x003C)
class UYSpeakLineSystem : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1585 ];

		return pClassPointer;
	};

};

UClass* UYSpeakLineSystem::pClassPointer = NULL;

// Class SRGame.YStringUtils
// 0x000C (0x0048 - 0x003C)
class UYStringUtils : public UObject
{
public:
	struct FString                                     m_rotatorString;                                  		// 0x003C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1586 ];

		return pClassPointer;
	};

	struct FString FormatFloat ( float val, int decDig );
	struct FString Vector2DToString ( struct FVector2D V );
	struct FString RotatorToString ( struct FRotator R );
	int SubString ( struct FString S, struct FString T, unsigned long startRight );
};

UClass* UYStringUtils::pClassPointer = NULL;

// Class SRGame.YTribool
// 0x0000 (0x003C - 0x003C)
class UYTribool : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1587 ];

		return pClassPointer;
	};

};

UClass* UYTribool::pClassPointer = NULL;

// Class SRGame.YTypeUtils
// 0x0000 (0x003C - 0x003C)
class UYTypeUtils : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1588 ];

		return pClassPointer;
	};

};

UClass* UYTypeUtils::pClassPointer = NULL;

// Class SRGame.YBoxComponent
// 0x0058 (0x0258 - 0x0200)
class UYBoxComponent : public UPrimitiveComponent
{
public:
	struct FKBoxElem                                   m_kBoxElem;                                       		// 0x0200 (0x0050) [0x0000000000000000]              
	struct FColor                                      m_boxColor;                                       		// 0x0250 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FColor                                      m_boxColorSelected;                               		// 0x0254 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1589 ];

		return pClassPointer;
	};

};

UClass* UYBoxComponent::pClassPointer = NULL;

// Class SRGame.YDrawBoxComponent
// 0x0014 (0x0214 - 0x0200)
class UYDrawBoxComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      m_color;                                          		// 0x0200 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_boxExtent;                                      		// 0x0204 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_onlyVisibleWhenSelected : 1;                    		// 0x0210 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1590 ];

		return pClassPointer;
	};

};

UClass* UYDrawBoxComponent::pClassPointer = NULL;

// Class SRGame.YDrawCoordinateSystemComponent
// 0x0020 (0x0220 - 0x0200)
class UYDrawCoordinateSystemComponent : public UPrimitiveComponent
{
public:
	struct FVector                                     m_location;                                       		// 0x0200 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_rotation;                                       		// 0x020C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_absolutePosition : 1;                           		// 0x0218 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_drawOnlyWhenSelected : 1;                       		// 0x0218 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_visible : 1;                                    		// 0x0218 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	float                                              m_scale;                                          		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1591 ];

		return pClassPointer;
	};

};

UClass* UYDrawCoordinateSystemComponent::pClassPointer = NULL;

// Class SRGame.YDrawCylinderComponent
// 0x0004 (0x0224 - 0x0220)
class UYDrawCylinderComponent : public UDrawCylinderComponent
{
public:
	unsigned long                                      m_showOnlyWhenOwnerSelected : 1;                  		// 0x0220 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1592 ];

		return pClassPointer;
	};

};

UClass* UYDrawCylinderComponent::pClassPointer = NULL;

// Class SRGame.YDrawPatchSplineComponent
// 0x0054 (0x0254 - 0x0200)
class UYDrawPatchSplineComponent : public UPrimitiveComponent
{
public:
	class UMaterialInterface*                          m_material;                                       		// 0x0200 (0x0004) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )
	TArray< struct FVector >                           m_points;                                         		// 0x0204 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FVector >                           m_points2;                                        		// 0x0210 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FVector >                           m_points3;                                        		// 0x021C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FVector                                     m_direction;                                      		// 0x0228 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_thickness;                                      		// 0x0234 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_angle;                                          		// 0x0238 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_mode;                                           		// 0x023C (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bMergeStart : 1;                                		// 0x0240 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	float                                              m_interpolationStrength;                          		// 0x0244 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FVector                                     m_interpolatedEndPosition;                        		// 0x0248 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1593 ];

		return pClassPointer;
	};

	void SwapArray ( );
	void Reset ( );
	void ClearPoints ( );
};

UClass* UYDrawPatchSplineComponent::pClassPointer = NULL;

// Class SRGame.YDrawRectangleComponent
// 0x0010 (0x0210 - 0x0200)
class UYDrawRectangleComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      m_color;                                          		// 0x0200 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_width;                                          		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_height;                                         		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_boundary;                                       		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1594 ];

		return pClassPointer;
	};

};

UClass* UYDrawRectangleComponent::pClassPointer = NULL;

// Class SRGame.YSkelMeshCmp_MultiPass
// 0x0014 (0x0600 - 0x05EC)
class UYSkelMeshCmp_MultiPass : public USkeletalMeshComponent
{
public:
	TArray< class UMaterialInterface* >                m_multipassMaterials;                             		// 0x05EC (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	int                                                m_passes;                                         		// 0x05F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_materialsPerPass;                               		// 0x05FC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1595 ];

		return pClassPointer;
	};

	void SetPasses ( int passes );
};

UClass* UYSkelMeshCmp_MultiPass::pClassPointer = NULL;

// Class SRGame.YVolumetricLight
// 0x0018 (0x024C - 0x0234)
class AYVolumetricLight : public AVolume
{
public:
	unsigned long                                      m_showRanges : 1;                                 		// 0x0234 (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_dirty : 1;                                      		// 0x0234 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_invalid : 1;                                    		// 0x0234 (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                m_lightCount;                                     		// 0x0238 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UPointLightComponent*                        m_lightPreset;                                    		// 0x023C (0x0004) [0x000000000408000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class UActorComponent* >                   m_saveComponents;                                 		// 0x0240 (0x000C) [0x0000000004480008]              ( CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1596 ];

		return pClassPointer;
	};

	void PostBeginPlay ( );
};

UClass* AYVolumetricLight::pClassPointer = NULL;

// Class SRGame.YAICombatPosSet_CombatPosEditorData
// 0x0028 (0x0064 - 0x003C)
class UYAICombatPosSet_CombatPosEditorData : public UObject
{
public:
	struct FVector                                     m_localPosition;                                  		// 0x003C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_hasError : 1;                                   		// 0x0048 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	TArray< unsigned long >                            m_errorFlags;                                     		// 0x004C (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FString >                           m_errorMessages;                                  		// 0x0058 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1597 ];

		return pClassPointer;
	};

};

UClass* UYAICombatPosSet_CombatPosEditorData::pClassPointer = NULL;

// Class SRGame.YAICombatPosSet_CoverSlotEditorData
// 0x0040 (0x007C - 0x003C)
class UYAICombatPosSet_CoverSlotEditorData : public UObject
{
public:
	struct FVector                                     m_localPosition;                                  		// 0x003C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_localRotation;                                  		// 0x0048 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_couldNotBuildClimbEdge : 1;                     		// 0x0054 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_couldNotBuildDropDownEdge : 1;                  		// 0x0054 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	TArray< unsigned long >                            m_errorFlags;                                     		// 0x0058 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FString >                           m_errorMessages;                                  		// 0x0064 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FYS_EditorViewPortScenePoint >      m_errorPositions;                                 		// 0x0070 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1598 ];

		return pClassPointer;
	};

};

UClass* UYAICombatPosSet_CoverSlotEditorData::pClassPointer = NULL;

// Class SRGame.YCoverGizmo
// 0x00E4 (0x0120 - 0x003C)
class UYCoverGizmo : public UObject
{
public:
	float                                              m_maxAdjust;                                      		// 0x003C (0x0004) [0x0000000000000000]              
	float                                              m_maxMantleDistance;                              		// 0x0040 (0x0004) [0x0000000000000000]              
	float                                              m_toleranceValue;                                 		// 0x0044 (0x0004) [0x0000000000000000]              
	float                                              m_heightTolerance;                                		// 0x0048 (0x0004) [0x0000000000000000]              
	float                                              m_traceHeights[ 0x3 ];                            		// 0x004C (0x000C) [0x0000000000000000]              
	float                                              m_maxCoverThickness;                              		// 0x0058 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_position;                                       		// 0x005C (0x000C) [0x0000000000000000]              
	struct FVector2D                                   m_extent;                                         		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_standardSlotExtent;                             		// 0x0070 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_peekSlotExtent;                                 		// 0x0078 (0x0008) [0x0000000000000000]              
	float                                              m_multiSlotEdgeOffset;                            		// 0x0080 (0x0004) [0x0000000000000000]              
	class UYDynCover*                                  m_dynCover;                                       		// 0x0084 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_leftBack;                                       		// 0x0088 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_midBack;                                        		// 0x0094 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_rightBack;                                      		// 0x00A0 (0x000C) [0x0000000000000000]              
	float                                              baseZ;                                            		// 0x00AC (0x0004) [0x0000000000000000]              
	struct FYS_TraceResults                            m_traces;                                         		// 0x00B0 (0x006C) [0x0000000000000000]              
	class UYCoverInfo*                                 m_tmpInfo;                                        		// 0x011C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1599 ];

		return pClassPointer;
	};

	bool FindCoverEdges ( class UYCoverInfo* curCover, unsigned long differentCoverTypes, class UYCoverInfo** leftEdge, class UYCoverInfo** rightEdge );
	bool PlaceGizmo ( struct FYS_PossibleCover possibleCover, unsigned long autoAdjust, unsigned long CheckPeeks, unsigned long temporary, class UYCoverInfo** coverInfo );
	struct FVector FindBase ( struct FVector pos, struct FVector coverNormal, unsigned long simple, struct FVector* baseNormal );
	void Init ( class UYDynCover* dynCover );
};

UClass* UYCoverGizmo::pClassPointer = NULL;

// Class SRGame.YCoverInfo
// 0x0064 (0x00A0 - 0x003C)
class UYCoverInfo : public UObject
{
public:
	unsigned char                                      m_type;                                           		// 0x003C (0x0001) [0x0000000000000002]              ( CPF_Const )
	struct FYS_CoverFlags                              m_flags;                                          		// 0x0040 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_coverHeight;                                    		// 0x0044 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FVector                                     m_posOnPlane;                                     		// 0x0048 (0x000C) [0x0000000000000002]              ( CPF_Const )
	struct FVector                                     m_planeNormal;                                    		// 0x0054 (0x000C) [0x0000000000000002]              ( CPF_Const )
	struct FRotator                                    m_rotation;                                       		// 0x0060 (0x000C) [0x0000000000000002]              ( CPF_Const )
	struct FVector                                     m_coverPlane;                                     		// 0x006C (0x000C) [0x0000000000000002]              ( CPF_Const )
	struct FVector                                     m_targetPositions[ 0x3 ];                         		// 0x0078 (0x0024) [0x0000000000000002]              ( CPF_Const )
	float                                              m_coverThickness;                                 		// 0x009C (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1600 ];

		return pClassPointer;
	};

};

UClass* UYCoverInfo::pClassPointer = NULL;

// Class SRGame.YDynCover
// 0x0028 (0x0064 - 0x003C)
class UYDynCover : public UObject
{
public:
	class AYPlayerController*                          m_playerController;                               		// 0x003C (0x0004) [0x0000000000000000]              
	class UYCoverGizmo*                                m_gizmo;                                          		// 0x0040 (0x0004) [0x0000000000000000]              
	float                                              m_maxTraceDist;                                   		// 0x0044 (0x0004) [0x0000000000000000]              
	int                                                m_numTraces;                                      		// 0x0048 (0x0004) [0x0000000000000000]              
	float                                              m_updateInterval;                                 		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              m_lastUpdate;                                     		// 0x0050 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_playerStopped : 1;                              		// 0x0054 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_selectCoverInMoveDir : 1;                       		// 0x0054 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_usePlayerInputDirectly : 1;                     		// 0x0054 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FVector                                     m_lastPlayerInput;                                		// 0x0058 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1601 ];

		return pClassPointer;
	};

	void BuildSortedCollisionList ( struct FVector playerPos, struct FVector startDir, float maxTraceDistance, int numRays, float MaxAngle, TArray< struct FYS_PossibleCover >* sortedCollisions );
	bool CheckForPossibleCover ( struct FVector playerPos, struct FVector moveDir, float maxTraceDist, int numRays, unsigned long TakeFirst, unsigned long check360deg, unsigned long PlaceGizmo, struct FYS_PossibleCover* res );
	bool UpdateCover ( unsigned long IsInCover, unsigned long ForceUpdate, class UYCoverInfo** coverInfo );
	void CalculateStandardSlot ( );
	void SetSlotType ( unsigned char slotType );
	void Initialize ( class AYPlayerController* ctrl );
};

UClass* UYDynCover::pClassPointer = NULL;

// Class SRGame.YAICombatPosSetEditorData
// 0x003C (0x0098 - 0x005C)
class UYAICombatPosSetEditorData : public UYGameplayMultiSpotEditorData
{
public:
	TArray< class UYAssetReference* >                  m_editorMeshes;                                   		// 0x005C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FRotator                                    m_meshRotOffset;                                  		// 0x0068 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UYAssetReference*                            m_errorMeshMaterial;                              		// 0x0074 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAssetReference*                            m_aiMeshMaterial;                                 		// 0x0078 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAssetReference*                            m_noCoverMesMaterial;                             		// 0x007C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAssetReference*                            m_aiSVBlockUpMaterial;                            		// 0x0080 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAssetReference*                            m_aiSelectedMaterial;                             		// 0x0084 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAssetReference*                            m_aiSMBlockedByDynamicFireLinkVolume;             		// 0x0088 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_CpsSlotCoverMapsError >         m_incorrectCoverMaps;                             		// 0x008C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1602 ];

		return pClassPointer;
	};

};

UClass* UYAICombatPosSetEditorData::pClassPointer = NULL;

// Class SRGame.YAICombatPosSet
// 0x0078 (0x0288 - 0x0210)
class AYAICombatPosSet : public AYGameplayMultiSpot
{
public:
	class UArrowComponent*                             m_arrow;                                          		// 0x0210 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< struct FYS_CombatPos >                     m_combatPositions;                                		// 0x0214 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FYS_CoverSlot >                     m_coverSlots;                                     		// 0x0220 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_coverIsCircular : 1;                            		// 0x022C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_isWorldSpace : 1;                               		// 0x022C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_SetUsedByAI : 1;                                		// 0x022C (0x0004) [0x0000000000002001] [0x00000004] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_hasPrecomputedFightAreas : 1;                   		// 0x022C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_isToggleable : 1;                               		// 0x022C (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_isToggledOff : 1;                               		// 0x022C (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_beginToggledOff : 1;                            		// 0x022C (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	float                                              m_maxSlotDistance;                                		// 0x0230 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYAICombatPosSet*                            m_leftNeighbor;                                   		// 0x0234 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AYAICombatPosSet*                            m_rightNeighbor;                                  		// 0x0238 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_CoverSphereData                         m_coverSphereData;                                		// 0x023C (0x0014) [0x0000000000000001]              ( CPF_Edit )
	struct FPointer                                    m_leftSlot;                                       		// 0x0250 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_rightSlot;                                      		// 0x0254 (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                m_objInstanceVersion;                             		// 0x0258 (0x0004) [0x0000000000000000]              
	int                                                m_classVersion;                                   		// 0x025C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_MaxFightAreaMemberships;                        		// 0x0260 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< class AActor* >                            m_fightAreas;                                     		// 0x0264 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_fightAreaMemberships;                           		// 0x0270 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     m_defaultStackingOffset;                          		// 0x027C (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1603 ];

		return pClassPointer;
	};

	bool IsRightSlot ( struct FYOctreeDataHndl Handle );
	bool IsLeftSlot ( struct FYOctreeDataHndl Handle );
	class AYAICombatPosSet* GetCombatPosSet ( struct FYOctreeDataHndl Handle );
	bool GetCombatPos ( struct FYOctreeDataHndl Handle, struct FYS_CombatPos* combatpos );
	bool GetCoverSlot ( struct FYOctreeDataHndl Handle, struct FYS_CoverSlot* coverslot );
	void ToggleCombatPos ( );
	void OnToggleCombatPos ( class UYSeqAct_ToggleCombatPos* act );
};

UClass* AYAICombatPosSet::pClassPointer = NULL;

// Class SRGame.YSceneCaptureCoverMapActor
// 0x0014 (0x0218 - 0x0204)
class AYSceneCaptureCoverMapActor : public ASceneCaptureCubeMapActor
{
public:
	int                                                m_renderTargetSize;                               		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_uuQuantization;                                 		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_coverMapWidth;                                  		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_coverMapHeight;                                 		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_verticalFov;                                    		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1604 ];

		return pClassPointer;
	};

};

UClass* AYSceneCaptureCoverMapActor::pClassPointer = NULL;

// Class SRGame.YStaticCover
// 0x0030 (0x006C - 0x003C)
class UYStaticCover : public UObject
{
public:
	float                                              m_edgeTolerance;                                  		// 0x003C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_convexEdgeTolerance;                            		// 0x0040 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_aiFlagFuzziness;                                		// 0x0044 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_singleSlotCoverEdgeExpansion;                   		// 0x0048 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FColor                                      m_coverSlotColor;                                 		// 0x004C (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FColor                                      m_stackingPosColor;                               		// 0x0050 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FColor                                      m_coverSlotColorMarked;                           		// 0x0054 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FColor                                      m_coverSlotTextColor;                             		// 0x0058 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FColor                                      m_nonCoverSlotColor;                              		// 0x005C (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FColor                                      m_nonCoverSlotColorMarked;                        		// 0x0060 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FColor                                      m_nonCoverSlotTextColor;                          		// 0x0064 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FColor                                      m_errorTextColor;                                 		// 0x0068 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1605 ];

		return pClassPointer;
	};

	struct FName GetCombatPosName ( struct FYS_CoverData* coverData );
	void DebugDrawCoverTagging ( float Radius, class AYHUD* HUD, struct FVector* Location );
	void DebugDrawCover ( struct FYS_CoverData* coverData );
	struct FVector GetMeshTranslationFromCoverRotation ( struct FRotator* Rot );
	struct FVector GetCoverLocationFromPawnLocation ( float pawnCollisionRadius, float additionalPushout, struct FYS_CoverData* coverData, struct FVector* pawnLoc );
	struct FVector GetPawnLocationFromCoverLocation ( float pawnCollisionRadius, float additionalPushout, struct FYS_CoverData* coverData, struct FVector* coverLoc );
	bool GetCurrentCoverSlotInfos ( struct FYS_CoverData* coverData, struct FYS_CoverSlotInfo* leftCoverSlotInfo, unsigned char* leftCoverType, struct FYS_CoverSlotInfo* rightCoverSlotInfo, unsigned char* rightCoverType );
	bool GetSwatTargetSlotInfo ( struct FYS_CoverData coverData, unsigned long isLeft, struct FYS_CoverData* swatTargetCover );
	bool GetCorrectedCoverSlotInfoFromHandle ( struct FYOctreeDataHndl coverSlotHandle, float pawnCollisionRadius, float additionalPushout, struct FYS_CoverSlotInfo* coverSlotInfo );
	bool GetCoverSlotInfoFromHandle ( struct FYOctreeDataHndl coverSlotHandle, struct FYS_CoverSlotInfo* coverSlotInfo, unsigned char* coverType );
	float CalcAABBCorrectionFactor ( struct FRotator* Rot );
	bool UpdateCoverEnds ( unsigned long ignoreCrouchCover, struct FYS_CoverData* coverData );
	bool UpdateConvexEdges ( unsigned long ignoreCrouchCover, struct FYS_CoverData* coverData, struct FVector* ViewLocation, struct FYS_CoverSlotInfo* leftConvexEdge, struct FYS_CoverSlotInfo* rightConvexEdge, struct FYS_CoverSlotInfo* leftSlotInfo, struct FYS_CoverSlotInfo* rightSlotInfo );
	void Invalidate ( struct FYS_CoverData* coverData );
	bool FindCoverFromLocation ( float MaxDistance, unsigned long isAI, unsigned char purpose, float maxCloseToEdgeDistance, unsigned long backfacingTop, struct FYS_CoverData* coverData, struct FVector* fromLoc );
	bool FindCoverFromLocAndDir ( float FOV, float fovCorrectionOffset, float MaxDistance, unsigned long isAI, unsigned char purpose, float maxCloseToEdgeDistance, float coverEndExpansion, unsigned long backfacingTop, struct FYS_CoverData* coverData, struct FVector* fromLoc, struct FVector* Direction );
};

UClass* UYStaticCover::pClassPointer = NULL;

// Class SRGame.YTextureRenderTargetCoverMap
// 0x0000 (0x00FD - 0x00FD)
class UYTextureRenderTargetCoverMap : public UTextureRenderTargetCube
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1606 ];

		return pClassPointer;
	};

};

UClass* UYTextureRenderTargetCoverMap::pClassPointer = NULL;

// Class SRGame.YIController
// 0x0000 (0x003C - 0x003C)
class UYIController : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1607 ];

		return pClassPointer;
	};

	void OnCombatSituationChanged ( unsigned long IsInCombat );
	void OnStopExecution ( );
	void OnStartExecution ( );
	void StopCamShake ( class UCameraAnimInst* cameraAnimInstance, unsigned long immediately );
	class UCameraAnimInst* PlayCamShake ( class UCameraAnim* Anim, float Rate, float Scale, float FadeInTime, float FadeOutTime, unsigned long looped, unsigned long randomStartTime );
	void HandleTeleport ( class USeqAct_Teleport* Sequence, struct FVector inLoc, struct FRotator inRot, unsigned long abortBehavior );
	unsigned char GetMovementDirection ( );
	bool DoDropDown ( );
	bool AllowMoveOverLedge ( );
	void ClearControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	void SetControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	bool SprintCoverDashEnabled ( );
	bool AutoLookAtEnabled ( );
	bool AimDownLockEnabled ( );
	bool BlindfireRestricted ( );
	bool PeekingRestricted ( );
	bool AutoRaiseWeapon ( );
	bool AutoTakeDownWeapon ( );
	void OnStateChangeFinished ( unsigned char lastMainState, unsigned char lastSubstate, unsigned char newMainState, unsigned char newSubstate );
	class AYAISquad* SetSquadName ( struct FName NewSquadName, unsigned long bLeader );
	class AYAISquad* GetSquad ( );
	struct FName GetSquadName ( );
	bool IsLookInputIgnored ( );
	void IgnoreLookInput ( unsigned long bNewLookInput );
	bool IsMoveInputIgnored ( );
	void IgnoreMoveInput ( unsigned long bNewMoveInput );
	void DisableDBNOSFX ( unsigned long hardDisable );
	void EnableDBNOSFX ( );
	void DisableLowHealthSFX ( unsigned long hardDisable );
	void EnableLowHealthSFX ( );
	void OnEndReloadWeapon ( );
	void OnStartReloadWeapon ( );
	void AdviseReload ( );
	void DisableZoomMode ( );
	void OnDisableZoom ( );
	void OnEnableZoom ( );
	void OnWeaponFired ( );
	class AYWeapon* GetCurrentWeapon ( );
	void SetCurrentGrenade ( unsigned char gt );
	void SetCurrentWeapon ( class AYWeapon* wp );
	bool IsDeadOrDown ( );
	void OnStopDownButNotOut ( );
	void OnStartDownButNotOut ( );
	void OnStopLeanOverCover ( );
	void OnStartLeanOverCover ( );
	void OnMoveIntoCoverFailed ( );
	void DisableCover ( );
	void DisableCrouch ( );
	bool CheckConditionalEnterCover ( unsigned long byLocation, unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, struct FYS_CoverData* coverData );
	bool ConditionalEnterCover ( unsigned long byLocation, unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, unsigned long checkIfOccupied, unsigned long skipAIForOccupation );
	void OnLeaveCover ( );
	void OnEnterCover ( );
	void OnCoverLost ( unsigned char Reason );
	void SetKiller ( class AActor* Killer );
	void OnExplosion ( struct FVector Loc, float Dist, float Damage, float Radius, float sfxDuration );
	void GetAimAdjustmentFor ( class AYWeapon* W, struct FVector* StartFireLoc, struct FVector* aimAtLoc );
	void InitDamageFeedbackCallbacks ( class AYGamePawn* pwn );
	void OnJustDied ( class UClass* dmgType );
	struct FRotator GetRotation ( );
	class AYGamePawn* GetGamePawn ( );
	class AController* GetController ( );
	class AYHUD* GetHUD ( );
	class AYPlayerReplicationInfo* GetPRI ( );
	class AYCamera* GetPlayerCam ( );
	class AActor* GetFocusedActor ( );
	TArray< class UYIHitFeedback* > GetHitDirectionIndicator ( );
};

UClass* UYIController::pClassPointer = NULL;

// Class SRGame.YICustomAnimationCallbackHandler
// 0x0000 (0x003C - 0x003C)
class UYICustomAnimationCallbackHandler : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1608 ];

		return pClassPointer;
	};

	void OnInitializeCustomAnimation ( );
	void OnFailedCustomAnimation ( );
	void OnSucceededCustomAnimation ( );
	void OnStartedCustomAnimation ( );
	void OnStartFailedCustomAnimation ( );
};

UClass* UYICustomAnimationCallbackHandler::pClassPointer = NULL;

// Class SRGame.YInterfaceManager
// 0x0000 (0x003C - 0x003C)
class UYInterfaceManager : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1609 ];

		return pClassPointer;
	};

	void VisibleImplementers ( unsigned char InterfaceName, class UClass* BaseClass, float Radius, class AActor* fromActor, struct FVector Loc, unsigned long ignoreHidden, class AActor** Actor );
	void AllImplementers ( unsigned char InterfaceName, class AActor** Actor );
};

UClass* UYInterfaceManager::pClassPointer = NULL;

// Class SRGame.YShootableTags
// 0x0000 (0x003C - 0x003C)
class UYShootableTags : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1610 ];

		return pClassPointer;
	};

};

UClass* UYShootableTags::pClassPointer = NULL;

// Class SRGame.YCamera
// 0x0410 (0x0988 - 0x0578)
class AYCamera : public ACamera
{
public:
	unsigned long                                      m_useAsyncLineCheckInSP : 1;                      		// 0x0578 (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_useAsyncLineCheckInMP : 1;                      		// 0x0578 (0x0004) [0x0000000000004001] [0x00000002] ( CPF_Edit | CPF_Config )
	unsigned long                                      yUseCollisionDetection : 1;                       		// 0x0578 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_useFuehlerigelInMP : 1;                         		// 0x0578 (0x0004) [0x0000000000004001] [0x00000008] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_useMeshXYTranslation : 1;                       		// 0x0578 (0x0004) [0x0000000000004001] [0x00000010] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_isSpectatingRemotePawn : 1;                     		// 0x0578 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_startRecoilDistortion : 1;                      		// 0x0578 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_startRecoilReset : 1;                           		// 0x0578 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_fixedViewTargetPosNeedsResynch : 1;             		// 0x0578 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_baseOffsetNeedsResynch : 1;                     		// 0x0578 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_camMirroringNeedsResynch : 1;                   		// 0x0578 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_forceUseBlendTime : 1;                          		// 0x0578 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_FOVResetPending : 1;                            		// 0x0578 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_allowInvisiblePawns : 1;                        		// 0x0578 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_camModeLocked : 1;                              		// 0x0578 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_camLockUseVTLocation : 1;                       		// 0x0578 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_camLockUseVTRotation : 1;                       		// 0x0578 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_camLockCollDetectionDisabled : 1;               		// 0x0578 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_forceOwnerPawnInvisible : 1;                    		// 0x0578 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_negXPushed : 1;                                 		// 0x0578 (0x0004) [0x0000000000002000] [0x00080000] ( CPF_Transient )
	unsigned long                                      m_posXPushed : 1;                                 		// 0x0578 (0x0004) [0x0000000000002000] [0x00100000] ( CPF_Transient )
	unsigned long                                      m_negYPushed : 1;                                 		// 0x0578 (0x0004) [0x0000000000002000] [0x00200000] ( CPF_Transient )
	unsigned long                                      m_posYPushed : 1;                                 		// 0x0578 (0x0004) [0x0000000000002000] [0x00400000] ( CPF_Transient )
	unsigned long                                      m_negZPushed : 1;                                 		// 0x0578 (0x0004) [0x0000000000002000] [0x00800000] ( CPF_Transient )
	unsigned long                                      m_posZPushed : 1;                                 		// 0x0578 (0x0004) [0x0000000000002000] [0x01000000] ( CPF_Transient )
	unsigned long                                      m_recoilResetPushingCamLimit : 1;                 		// 0x0578 (0x0004) [0x0000000000002000] [0x02000000] ( CPF_Transient )
	unsigned long                                      m_ignoreYawLimit : 1;                             		// 0x0578 (0x0004) [0x0000000000002000] [0x04000000] ( CPF_Transient )
	unsigned long                                      m_reenableRotationInterpolation : 1;              		// 0x0578 (0x0004) [0x0000000000002000] [0x08000000] ( CPF_Transient )
	unsigned long                                      m_showImmediateCollisionTest : 1;                 		// 0x0578 (0x0004) [0x0000000000000001] [0x10000000] ( CPF_Edit )
	unsigned long                                      m_showAnticipatingCollisionTest : 1;              		// 0x0578 (0x0004) [0x0000000000000001] [0x20000000] ( CPF_Edit )
	unsigned long                                      m_showCamLocation : 1;                            		// 0x0578 (0x0004) [0x0000000000000001] [0x40000000] ( CPF_Edit )
	unsigned long                                      m_showViewCone : 1;                               		// 0x0578 (0x0004) [0x0000000000000001] [0x80000000] ( CPF_Edit )
	unsigned long                                      m_showTargetPos : 1;                              		// 0x057C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_showTransitionRayHitPos : 1;                    		// 0x057C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_showViewLimits : 1;                             		// 0x057C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_showTargetOffsetPitchAdaption : 1;              		// 0x057C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_showViewTargetPos : 1;                          		// 0x057C (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_showBaseOffset : 1;                             		// 0x057C (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_showCamSafePos : 1;                             		// 0x057C (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_showDebugLogs : 1;                              		// 0x057C (0x0004) [0x0000000000004001] [0x00000080] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_anticipatingCollTestHit : 1;                    		// 0x057C (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	int                                                m_asyncLineCheck;                                 		// 0x0580 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastLineCheckHitDist;                           		// 0x0584 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYPlayerCamMode*                             m_currentCamMode;                                 		// 0x0588 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYPlayerCamMode*                             m_targetCamMode;                                  		// 0x058C (0x0004) [0x0000000000000000]              
	class UYPlayerCamMode*                             m_alphaTargetCamMode;                             		// 0x0590 (0x0004) [0x0000000000000000]              
	class UYPlayerCamMode*                             m_alphaFromCamMode;                               		// 0x0594 (0x0004) [0x0000000000000000]              
	struct FYS_TransitionState                         m_alphaTransitionState;                           		// 0x0598 (0x0020) [0x0000000000000000]              
	struct FYS_TransitionState                         m_simpleTransitionState;                          		// 0x05B8 (0x0020) [0x0000000000000000]              
	struct FYS_TransitionFromState                     m_fromTransitionState;                            		// 0x05D8 (0x0100) [0x0000000000000000]              
	struct FYS_CameraModifierResult                    m_camModifierResult;                              		// 0x06D8 (0x0020) [0x0000000000000000]              
	class UYPlayerCamMode*                             m_overrideCamMode;                                		// 0x06F8 (0x0004) [0x0000000000000000]              
	class UYCameraSpring*                              m_camSpring;                                      		// 0x06FC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_cameraMass;                                     		// 0x0700 (0x0004) [0x0000000000000000]              
	float                                              m_tiltMaxStrafeSpeed;                             		// 0x0704 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_tiltMaxZRotSpeed;                               		// 0x0708 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_collDetectionDisableCount;                      		// 0x070C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_globalRotationSpeedFactor;                      		// 0x0710 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fuehlerigelUpdateInterval;                      		// 0x071C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_collDetectionExtent;                            		// 0x0720 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_smoothingBlendInDamping;                        		// 0x0724 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_smoothingBlendOutDamping;                       		// 0x0728 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AYPlayerController*                          m_playerController;                               		// 0x072C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_dataProviderClass;                              		// 0x0730 (0x0004) [0x0000000000000000]              
	struct FYS_CamPhysicsState                         m_camPhysicsState;                                		// 0x0734 (0x0060) [0x0000000000000000]              
	struct FYS_CamTempState                            m_camTempState;                                   		// 0x0794 (0x00AC) [0x0000000000000000]              
	float                                              m_alphaTransitionValue;                           		// 0x0840 (0x0004) [0x0000000000000000]              
	struct FYS_FocusPoint                              m_focusPoint;                                     		// 0x0844 (0x0078) [0x0000000000080001]              ( CPF_Edit | CPF_Component )
	struct FRotator                                    m_lastUnmodifiedRotation;                         		// 0x08BC (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_lastRecoilDistortionDelta;                      		// 0x08C8 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_currentRecoilDistortion;                        		// 0x08D4 (0x000C) [0x0000000000000000]              
	int                                                m_recoilMinimumPitch;                             		// 0x08E0 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_lastFrameBase;                                  		// 0x08E4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_lastRelativeCorrection;                         		// 0x08E8 (0x000C) [0x0000000000000000]              
	float                                              m_synchTimeStamp;                                 		// 0x08F4 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_camLockReferenceViewTarget;                     		// 0x08F8 (0x0004) [0x0000000000000000]              
	float                                              m_camLockNormalFOV;                               		// 0x08FC (0x0004) [0x0000000000000000]              
	float                                              m_camLockAimFOV;                                  		// 0x0900 (0x0004) [0x0000000000000000]              
	float                                              m_camLockFOVToggleTime;                           		// 0x0904 (0x0004) [0x0000000000000000]              
	float                                              m_camLockFOVToggleCurrentTime;                    		// 0x0908 (0x0004) [0x0000000000000000]              
	float                                              m_camLockFOVToggleFromFOV;                        		// 0x090C (0x0004) [0x0000000000000000]              
	float                                              m_camLockFOVToggleToFOV;                          		// 0x0910 (0x0004) [0x0000000000000000]              
	float                                              m_pawnMeshSmoothingInfluenceTime;                 		// 0x0914 (0x0004) [0x0000000000000000]              
	float                                              m_pawnMeshSmoothingInfluenceCurrentTime;          		// 0x0918 (0x0004) [0x0000000000000000]              
	float                                              m_pawnMeshSmoothingInfluenceTarget;               		// 0x091C (0x0004) [0x0000000000000000]              
	float                                              m_pawnMeshSmoothingInfluenceFrom;                 		// 0x0920 (0x0004) [0x0000000000000000]              
	float                                              m_pawnMeshSmoothingInfluenceCurrent;              		// 0x0924 (0x0004) [0x0000000000000000]              
	float                                              m_forceOwnerPawnInvisibleDelay;                   		// 0x0928 (0x0004) [0x0000000000000000]              
	float                                              m_camOverrideTransitionTime;                      		// 0x092C (0x0004) [0x0000000000000000]              
	float                                              m_transitionTimeOverride;                         		// 0x0930 (0x0004) [0x0000000000000000]              
	struct FYS_CamBrakeAxisInfo                        m_camBrakeInfos[ 0x3 ];                           		// 0x0934 (0x0024) [0x0000000000000000]              
	class UYCameraModifier_CamBone*                    m_camModCamBone;                                  		// 0x0958 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_immediateCollActor;                             		// 0x095C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UPrimitiveComponent*                         m_immediateCollComponent;                         		// 0x0960 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class AYCameraFXEmitter* >                 m_cameraFXEmitters;                               		// 0x0964 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnUpdate__Delegate;                             		// 0x0970 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnTransitionFinishedDelegate__Delegate;         		// 0x097C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1611 ];

		return pClassPointer;
	};

	void ClearAllCameraShakes ( );
	bool PositionIsInFrustum ( struct FMatrix* worldViewProjection, struct FVector* Position );
	void GetWorldViewProjection ( struct FMatrix* wvp );
	void SetPawnInvisibilityTests ( unsigned long Enable );
	void DisableCamBoneModifier ( struct FScriptDelegate fadedOutCallback, struct FYS_CameraTransitionParams* TransitionParams );
	void EnableCamBoneModifier ( unsigned char cameraAnimOption, struct FYS_CameraTransitionParams* TransitionParams );
	void InitCameraModifiers ( );
	void AddImpulseToSpring ( struct FVector Impulse, float Damage );
	void SetViewTarget ( class AActor* NewViewTarget, struct FViewTargetTransitionParams TransitionParams );
	struct FString GetTransitionName ( class UYPlayerCamTransition* T );
	struct FString GetTransitionNameByIdx ( int mode1, int mode2 );
	struct FString GetAlphaTransitionNameByCamMode ( class UYPlayerCamMode* mode1, class UYPlayerCamMode* mode2, unsigned long checkActive );
	struct FString GetSimpleTransitionNameByCamMode ( class UYPlayerCamMode* mode1, class UYPlayerCamMode* mode2, unsigned long checkActive );
	struct FString GetCameraModeName ( class UYPlayerCamMode* Mode );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	struct FRotator LimitDeltaRot ( struct FRotator currentRot, struct FRotator DeltaRot, float dt );
	struct FRotator LimitRotation ( struct FRotator currentRot, struct FRotator DeltaRot, unsigned long forceLimit, unsigned long resetPushTime );
	void ApplyViewLimits ( float DeltaTime, struct FRotator* out_ViewRotation, struct FRotator* out_DeltaRot );
	void ProcessViewRotation ( float DeltaTime, struct FRotator* out_ViewRotation, struct FRotator* out_DeltaRot );
	bool IsHittingLimitZ ( );
	bool IsHittingLimitY ( );
	bool IsHittingLimitX ( );
	void ResetLimitActivations ( );
	void OnTransitionFinishedDelegate ( );
	void OnUpdate ( );
	void DisableCollisionDetection ( );
	void EnableCollisionDetection ( );
	void SetTransitionAlpha ( float Alpha, unsigned long noServerCall );
	bool DidCamModeChange ( int simpleIndex, int alphaFromIndex, int alphaToIndex, unsigned long useAlpha, unsigned long cameraMirrored, int* mirrorChange );
	void OnTransitionFinished ( );
	void SetAlphaCamMode ( class UYPlayerCamMode* fromMode, class UYPlayerCamMode* toMode, unsigned long noServerCall );
	float GetRemainingSimpleTransitionTime ( );
	void SetSimpleCamMode ( class UYPlayerCamMode* camMode, unsigned long noServerCall, unsigned long mirrored, unsigned long useMirrorTransition, float transitionFactor );
	void SetUsePawnMeshSmoothing ( unsigned long useSmoothing, float InterpTime );
	void ResetCamModeOverride ( );
	void OverrideCamMode ( class UYSeqAct_CamOverrideMode* Action );
	void SetOverrideCamModeAimingFOV ( unsigned long aiming );
	void OnZoom ( unsigned long Enable );
	class UYPlayerCamMode* GetOverrideCamMode ( );
	class UYPlayerCamTransition* GetTransition ( class UYPlayerCamMode* fromMode, class UYPlayerCamMode* toMode );
	void InitTransitionFromValues ( unsigned long useBlendTime );
	void DoTransitionRaycast ( );
	struct FVector GetBaseOffset ( int Index );
	class UYPlayerCamMode* GetCamMode ( int Index );
	void ForceCurrentCamMode ( );
	void DisableAllOverrides ( unsigned long serverCall, unsigned long ResetFOV, float Time );
	void ResetCamera ( unsigned long disableOverrides );
	void CreateCamSpring ( );
	void CreateCamModesAndTransitions ( );
	void CompensateRootMotionReset ( struct FVector deltaLocation, struct FRotator deltaRotation );
	void SmoothBaseOffset ( struct FVector newBaseOffset, float smoothingTime, unsigned long noServerCall );
	void SetBaseOffsetTarget ( struct FVector Target );
	bool AllowsWeaponTargetingZoom ( );
	void UpdateFOVReset ( );
	void SmoothResetFOV ( float timeToReach, unsigned long noServerCall, unsigned long setPending );
	void SmoothOverrideFOV ( float NewFOV, float timeToReach, unsigned long byWeaponOverride, unsigned long noServerCall );
	void SetFixedViewTargetRotation ( struct FVector targetRot, unsigned long noServerCall );
	void DisableUseFixedViewtargetRotation ( float timeToReach, unsigned long noServerCall );
	struct FRotator GetFixedViewTargetRotation ( );
	void EnableUseFixedViewTargetRotation ( struct FVector NewRotation, float timeToReach, unsigned long noServerCall );
	void SetFixedViewTargetPosition ( struct FVector Position, unsigned long noServerCall );
	void DisableUseFixedViewTargetPosition ( float timeToReach, unsigned long noServerCall );
	void EnableUseFixedViewTargetPosition ( struct FVector Position, float timeToReach, unsigned long noServerCall );
	bool IsMirrored ( );
	void ReenableRotationInterpolation ( );
	void SuppressRotationInterpolation ( );
	bool IsUsingFocusPoint ( );
	void SetDrawFocusPoint ( unsigned long DrawDebug );
	void SetUseFocusPoint ( unsigned long usePoint, unsigned long updateControllerRotFromFocusPoint, unsigned long checkLOS, unsigned long noServerCall );
	void SetCamFocusPoint ( class AActor* TargetActor, struct FName lookAtBone, struct FVector lookAtPos, struct FVector Offset, unsigned long noServerCall, unsigned char offsetSpace, struct FVector lookAtInterpSpeeds, float pitchTolerance, float yawTolerance, float kickInTime, float kickOutTime, unsigned long checkLOS, float LOSStopTime );
	void SetCamFocusActor ( class AActor* TargetActor );
	void SetCamFocusLocation ( struct FVector lookAtPos );
	bool ShouldCallServerFunction ( unsigned long noServerCall );
	void ComputeCamera ( float DeltaTime, struct FTViewTarget* OutVT );
	void UpdateSynchRequests ( float dt, unsigned long Force );
	void UpdateViewTarget ( float DeltaTime, struct FTViewTarget* OutVT );
	void UpdateCamera ( float DeltaTime );
	void PlayInitTransition ( );
	void InitCam ( class UClass* dataProviderClass );
	void InitializeFor ( class APlayerController* PC );
	void PostBeginPlay ( );
	void ClearCameraFXEmitter ( );
	void RemoveCameraFXEmitter ( class AYCameraFXEmitter* Emitter );
	class AYCameraFXEmitter* AddCameraFXEmitter ( class UClass* emitClass );
	class AYCameraFXEmitter* FindCameraFXEmitter ( class UClass* emitClass );
	void PlayEffect ( class UClass* emitClass, float Rot );
	class AYCameraFXEmitter* PlayEffectOffset ( class UClass* emitClass, float Rot, float XOffset, float YOffset );
};

UClass* AYCamera::pClassPointer = NULL;

// Class SRGame.YCameraModifier_CamBone
// 0x006C (0x00C4 - 0x0058)
class UYCameraModifier_CamBone : public UCameraModifier
{
public:
	struct FName                                       m_cameraBoneName;                                 		// 0x0058 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FName                                       m_cameraRootBoneName;                             		// 0x0060 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class APlayerController*                           m_playerController;                               		// 0x0068 (0x0004) [0x0000000000000000]              
	class APawn*                                       m_pawn;                                           		// 0x006C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_cameraAnimOption;                               		// 0x0070 (0x0001) [0x0000000000000000]              
	float                                              m_alpha;                                          		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              m_startAlpha;                                     		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              m_targetAlpha;                                    		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              m_blendTimeToGo;                                  		// 0x0080 (0x0004) [0x0000000000000000]              
	struct FYS_CameraTransitionParams                  m_transitionParams;                               		// 0x0084 (0x000C) [0x0000000000000000]              
	struct FScriptDelegate                             m_fadedOutCallback;                               		// 0x0090 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FTPOV                                       m_cachedPOV;                                      		// 0x009C (0x001C) [0x0000000000000000]              
	struct FScriptDelegate                             __OnFadedOutCallback__Delegate;                   		// 0x00B8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1612 ];

		return pClassPointer;
	};

	void CallFadedOutCallback ( struct FScriptDelegate fadedOutCallback );
	void EnableModifier ( );
	void DisableModifier ( unsigned long bImmediate );
	void FadeOut ( struct FScriptDelegate fadedOutCallback, struct FYS_CameraTransitionParams* TransitionParams );
	void FadeIn ( unsigned char cameraAnimOption, struct FYS_CameraTransitionParams* TransitionParams );
	bool ModifyCamera ( class ACamera* Camera, float DeltaTime, struct FTPOV* OutPOV );
	bool AddCameraModifier ( class ACamera* Camera );
	void OnFadedOutCallback ( );
};

UClass* UYCameraModifier_CamBone::pClassPointer = NULL;

// Class SRGame.YCameraSpring
// 0x0023 (0x0078 - 0x0055)
class UYCameraSpring : public UActorComponent
{
public:
	struct FPointer                                    m_collActorData;                                  		// 0x0058 (0x0004) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	struct FPointer                                    m_jointData;                                      		// 0x005C (0x0004) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	float                                              m_springForce;                                    		// 0x0060 (0x0004) [0x0000000000000000]              
	float                                              m_dampingConstant;                                		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              m_angularSpringForce;                             		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              m_angularSpringDamping;                           		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              m_cameraMass;                                     		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              m_impulseScale;                                   		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1613 ];

		return pClassPointer;
	};

	void ApplyImpulse ( struct FVector Impulse, struct FVector Location );
	void SetCameraMass ( float Mass );
	void SetAngularSpringParams ( float spring, float Damping );
	void SetSpringParams ( float spring, float Damping );
	void Clear ( );
	struct FRotator GetLocalRotation ( );
	struct FVector GetLocalPosition ( );
	void InitCamSpring ( class AActor* InOwner );
};

UClass* UYCameraSpring::pClassPointer = NULL;

// Class SRGame.YFocusPoint
// 0x0078 (0x00B4 - 0x003C)
class UYFocusPoint : public UObject
{
public:
	struct FYS_FocusPoint                              m_defaultFocusPoint;                              		// 0x003C (0x0078) [0x0000000000080000]              ( CPF_Component )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1614 ];

		return pClassPointer;
	};

	void SetUseFocusPoint ( unsigned long newUse, float currentTimeSeconds, struct FRotator CamRot, struct FYS_FocusPoint* FocusPoint );
	struct FRotator GetLookAtRotation ( struct FRotator currentRot, struct FVector currentLoc, float dt, struct FRotator originalRot, struct FVector RotOffset, struct FYS_FocusPoint* FocusPoint );
};

UClass* UYFocusPoint::pClassPointer = NULL;

// Class SRGame.YPlayerCamDataProvider
// 0x0024 (0x0060 - 0x003C)
class UYPlayerCamDataProvider : public UObject
{
public:
	TArray< class UYPlayerCamMode* >                   m_cameraModes;                                    		// 0x003C (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	TArray< class UYPlayerCamTransition* >             m_camTransitions;                                 		// 0x0048 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	TArray< struct FVector >                           m_baseOffsets;                                    		// 0x0054 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1615 ];

		return pClassPointer;
	};

	int GetSideChangeTransitionIndex ( );
	int GetInitTransitionIndex ( );
	int GetDefaultTransitionIndex ( );
	class UYPlayerCamTransition* GetCamTransition ( int Index );
	int GetNumCamTransitions ( );
	int GetNumBaseOffsets ( );
	struct FVector GetBaseOffset ( int Index );
	int GetDefaultCamModeIndex ( );
	int GetAnyCamModeIndex ( );
	class UYPlayerCamMode* GetCamMode ( int Index );
	int GetNumCamModes ( );
};

UClass* UYPlayerCamDataProvider::pClassPointer = NULL;

// Class SRGame.YPlayerCamMode
// 0x00F4 (0x0130 - 0x003C)
class UYPlayerCamMode : public UObject
{
public:
	int                                                m_modeIndex;                                      		// 0x003C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_targetOffset;                                   		// 0x0040 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_targetOffsetMirrored;                           		// 0x004C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_safeOffset;                                     		// 0x0058 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_distance;                                       		// 0x0064 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_FOV;                                            		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_rotationSpeed;                                  		// 0x006C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_rotationDamping;                                		// 0x0078 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_posTranslationDamping;                          		// 0x0084 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_negTranslationDamping;                          		// 0x0090 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_smoothingStartTime;                             		// 0x009C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_collAvoidanceSmoothingForw;                     		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              m_collAvoidanceSmoothingBack;                     		// 0x00A4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_posRotationLimits;                              		// 0x00A8 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_negRotationLimits;                              		// 0x00B4 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_useRotationLimits : 1;                          		// 0x00C0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_useFuehlerIgel : 1;                             		// 0x00C0 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	struct FVector                                     m_posRotLimitsSoftRegion;                         		// 0x00C4 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_negRotLimitsSoftRegion;                         		// 0x00D0 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_rotationLimitDeactivationTimes;                 		// 0x00DC (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleDistanceAdaptionStartAngle;               		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleDistanceAdaptionMaxValue;                 		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleDistanceAdaptionSmoothing;                		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleForwardMovementUp;                        		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleForwardMovementDown;                      		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleForwardMovementUpStartAngle;              		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleForwardMovementDownStartAngle;            		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_angleHor;                                       		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_angleVer;                                       		// 0x0108 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_numRaysHor;                                     		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_numRaysVer;                                     		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fuehlerIgelCollSmoothingFactor;                 		// 0x0114 (0x0004) [0x0000000000000000]              
	float                                              m_defaultRoll;                                    		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxTiltStrafe;                                  		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxTiltZRot;                                    		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_tiltStrafeFactor;                               		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_tiltZRotFactor;                                 		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxTiltSum;                                     		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1616 ];

		return pClassPointer;
	};

	void CopyCamModeSettings ( class UYPlayerCamMode* inMode, unsigned long mirrored );
};

UClass* UYPlayerCamMode::pClassPointer = NULL;

// Class SRGame.YPlayerCamTransition
// 0x0040 (0x007C - 0x003C)
class UYPlayerCamTransition : public UObject
{
public:
	int                                                m_fromModeIndex;                                  		// 0x003C (0x0004) [0x0000000000000000]              
	int                                                m_toModeIndex;                                    		// 0x0040 (0x0004) [0x0000000000000000]              
	float                                              m_transitionTime;                                 		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_rotInterpolationMode;                           		// 0x0048 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_interpolationMode;                              		// 0x0049 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_initialRotation;                                		// 0x004C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_stayOnTargetMinDist;                            		// 0x0058 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_stayOnPawns : 1;                                		// 0x005C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_disableCamSmoothing : 1;                        		// 0x005C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bidirectional : 1;                              		// 0x005C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	struct FYS_TransitionSubStep                       m_subStep;                                        		// 0x0060 (0x0018) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_priority;                                       		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1617 ];

		return pClassPointer;
	};

	void SelectivelyCopyCamTransitionSettings ( class UYPlayerCamTransition* inTransition );
	void CopyCamTransitionSettings ( class UYPlayerCamTransition* inTransition );
};

UClass* UYPlayerCamTransition::pClassPointer = NULL;

// Class SRGame.YDeathAnimTriggerComponent
// 0x0000 (0x0258 - 0x0258)
class UYDeathAnimTriggerComponent : public UYBoxComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1618 ];

		return pClassPointer;
	};

};

UClass* UYDeathAnimTriggerComponent::pClassPointer = NULL;

// Class SRGame.YSlopeVolumeComponent
// 0x0000 (0x0258 - 0x0258)
class UYSlopeVolumeComponent : public UYBoxComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1619 ];

		return pClassPointer;
	};

};

UClass* UYSlopeVolumeComponent::pClassPointer = NULL;

// Class SRGame.YDeathAnimTrigger
// 0x000C (0x0204 - 0x01F8)
class AYDeathAnimTrigger : public AActor
{
public:
	float                                              m_priority;                                       		// 0x01F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYDeathAnimTriggerComponent*                 m_triggerComponent;                               		// 0x01FC (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class AYDeathAnimTrigger*                          NextLowerPriorityTrigger;                         		// 0x0200 (0x0004) [0x0000000001002002]              ( CPF_Const | CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1620 ];

		return pClassPointer;
	};

	void TriggerSpecialDeathKismet ( class AYGamePawn* diedPawn );
	bool Encompasses ( struct FVector Loc );
	void GetAnimStartPlane ( struct FVector* pos, struct FVector* Normal );
};

UClass* AYDeathAnimTrigger::pClassPointer = NULL;

// Class SRGame.YEffectsActorComponent
// 0x0004 (0x0204 - 0x0200)
class UYEffectsActorComponent : public UPrimitiveComponent
{
public:
	unsigned long                                      m_drawOnlyWhenSelected : 1;                       		// 0x0200 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_visible : 1;                                    		// 0x0200 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1621 ];

		return pClassPointer;
	};

};

UClass* UYEffectsActorComponent::pClassPointer = NULL;

// Class SRGame.YFastRopeActorComponent
// 0x003C (0x023C - 0x0200)
class UYFastRopeActorComponent : public UPrimitiveComponent
{
public:
	struct FVector                                     m_location;                                       		// 0x0200 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rotation;                                       		// 0x020C (0x000C) [0x0000000000000000]              
	unsigned long                                      m_drawOnlyWhenSelected : 1;                       		// 0x0218 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_visible : 1;                                    		// 0x0218 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FColor                                      m_lineColor;                                      		// 0x021C (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FVector                                     m_edgeOffset;                                     		// 0x0220 (0x000C) [0x0000000000000002]              ( CPF_Const )
	struct FVector                                     m_arrowOffset;                                    		// 0x022C (0x000C) [0x0000000000000002]              ( CPF_Const )
	float                                              m_arrowLength;                                    		// 0x0238 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1622 ];

		return pClassPointer;
	};

};

UClass* UYFastRopeActorComponent::pClassPointer = NULL;

// Class SRGame.YFastRopeInteractionComponent
// 0x0020 (0x0220 - 0x0200)
class UYFastRopeInteractionComponent : public UPrimitiveComponent
{
public:
	struct FVector                                     m_location;                                       		// 0x0200 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rotation;                                       		// 0x020C (0x000C) [0x0000000000000000]              
	unsigned long                                      m_drawOnlyWhenSelected : 1;                       		// 0x0218 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_visible : 1;                                    		// 0x0218 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FColor                                      m_lineColor;                                      		// 0x021C (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1623 ];

		return pClassPointer;
	};

};

UClass* UYFastRopeInteractionComponent::pClassPointer = NULL;

// Class SRGame.YSlopeVolume
// 0x0010 (0x0208 - 0x01F8)
class AYSlopeVolume : public AActor
{
public:
	class UYSlopeVolumeComponent*                      m_component;                                      		// 0x01F8 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_pushBackBarrier;                                		// 0x01FC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_maxPushBackVelocity;                            		// 0x0200 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_movementScale;                                  		// 0x0204 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1624 ];

		return pClassPointer;
	};

	void UnTouch ( class AActor* Other );
	void Touch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	struct FVector GetForceDirection ( );
	struct FVector CalcNearestFarEdgePosition ( struct FVector pawnPos );
	float CalcPushBackAlpha ( struct FVector pawnPos );
	float CalcMovementModifier ( struct FVector pawnPos, struct FVector pawnDir );
	void GetAnimStartPlane ( struct FVector* pos, struct FVector* Normal );
};

UClass* AYSlopeVolume::pClassPointer = NULL;

// Class SRGame.YTrigger_EffectsInteraction
// 0x0028 (0x022C - 0x0204)
class AYTrigger_EffectsInteraction : public ATrigger
{
public:
	float                                              m_untriggerDelay;                                 		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_triggerAction;                                  		// 0x0208 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FYS_EffectInteractionItem >         m_effectInteractionItems;                         		// 0x020C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_humanOnly : 1;                                  		// 0x0218 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_triggered : 1;                                  		// 0x0218 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                m_maxTriggerCount;                                		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UYEffectInteractionItem* >           m_pendingEffectInteractionItems;                  		// 0x0220 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1625 ];

		return pClassPointer;
	};

	void StopEffects ( class UYEffectInteractionItem* effectInteractionItem );
	void StartEffects ( class UYEffectInteractionItem* effectInteractionItem );
	void MarkAsNotTriggered ( );
	void MarkAsTriggered ( );
	void Touch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void PostBeginPlay ( );
	void PreBeginPlay ( );
};

UClass* AYTrigger_EffectsInteraction::pClassPointer = NULL;

// Class SRGame.YTrigger_FastRopeInteraction
// 0x0038 (0x023C - 0x0204)
class AYTrigger_FastRopeInteraction : public ATrigger
{
public:
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x0204 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class AYRopeActor*                                 m_ropeActor;                                      		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_enabled : 1;                                    		// 0x020C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FVector                                     m_edgeOffset;                                     		// 0x0210 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_defaultRotOffset;                               		// 0x021C (0x000C) [0x0000000000000002]              ( CPF_Const )
	class USpriteComponent*                            m_spriteComponent;                                		// 0x0228 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UYMarkerBase*                                m_tacIcon;                                        		// 0x022C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_tacIconClass;                                   		// 0x0230 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYTacticalMarkerConnector*                   m_connector;                                      		// 0x0234 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_contextCommandExtent;                           		// 0x0238 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1626 ];

		return pClassPointer;
	};

	void NativePostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void UnregisterToPostRender ( );
	void RegisterToPostRender ( );
	class UYTacticalMarkerConnector* GetMarkerConnector ( );
	void Destroyed ( );
	void PostBeginPlay ( );
	void OnDetected ( unsigned long detected );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	struct FBoxSphereBounds GetBounds ( );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool IsEnabledForTacView ( );
	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYTrigger_FastRopeInteraction::pClassPointer = NULL;

// Class SRGame.YTrigger_TurretInteraction
// 0x0040 (0x0244 - 0x0204)
class AYTrigger_TurretInteraction : public ATrigger
{
public:
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x0204 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned long                                      m_enabled : 1;                                    		// 0x0208 (0x0004) [0x0000000000000021] [0x00000001] ( CPF_Edit | CPF_Net )
	struct FRotator                                    m_rotOffset;                                      		// 0x020C (0x000C) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	struct FVector                                     m_locOffset;                                      		// 0x0218 (0x000C) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	class AYTurretActor*                               m_turretActor;                                    		// 0x0224 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	class USpriteComponent*                            m_spriteComponent;                                		// 0x0228 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned char                                      m_currentUsersCount;                              		// 0x022C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_weaponEnumBefore;                               		// 0x022D (0x0001) [0x0000000000000000]              
	class UYMarkerBase*                                m_tacIcon;                                        		// 0x0230 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_tacIconClass;                                   		// 0x0234 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_contextCommandExtent;                           		// 0x0238 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYTacticalMarkerConnector*                   m_connector;                                      		// 0x023C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAITurretDefinition*                        m_aiTurretDefinition;                             		// 0x0240 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1627 ];

		return pClassPointer;
	};

	void NativePostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void UnregisterToPostRender ( );
	void RegisterToPostRender ( );
	class UYTacticalMarkerConnector* GetMarkerConnector ( );
	void PostBeginPlay ( );
	void Destroyed ( );
	void OnDetected ( unsigned long detected );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	struct FBoxSphereBounds GetBounds ( );
	bool GetEntryPoint ( struct FVector* outLoc, struct FRotator* outRot );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool IsEnabledForTacView ( );
	void SetAimAtLocation ( struct FVector Loc );
	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYTrigger_TurretInteraction::pClassPointer = NULL;

// Class SRGame.YTrigger_ZiplineInteraction
// 0x003C (0x0240 - 0x0204)
class AYTrigger_ZiplineInteraction : public ATrigger
{
public:
	unsigned long                                      m_enabled : 1;                                    		// 0x0204 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_drawOnlyWhenSelected : 1;                       		// 0x0204 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_showInPIE : 1;                                  		// 0x0204 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	class AYZiplineTarget*                             m_ziplineTarget;                                  		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_startOffset;                                    		// 0x020C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_endOffset;                                      		// 0x0218 (0x000C) [0x0000000000000000]              
	float                                              m_ropeHeightOffset;                               		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USpriteComponent*                            m_spriteComponent;                                		// 0x0228 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UYZiplineInteractionComponent*               m_interactionComponent;                           		// 0x022C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_timeOfLastUse;                                  		// 0x0230 (0x0004) [0x0000000000000000]              
	int                                                m_currentUserCount;                               		// 0x0234 (0x0004) [0x0000000000000000]              
	int                                                m_maxConcurrentUserCount;                         		// 0x0238 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxSpeed;                                       		// 0x023C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1628 ];

		return pClassPointer;
	};

	struct FRotator GetZiplineRotation ( );
	bool GetRopeEnd ( struct FVector* outLoc );
	bool GetRopeStart ( struct FVector* outLoc );
	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYTrigger_ZiplineInteraction::pClassPointer = NULL;

// Class SRGame.YZiplineInteractionComponent
// 0x0020 (0x0220 - 0x0200)
class UYZiplineInteractionComponent : public UPrimitiveComponent
{
public:
	struct FVector                                     m_location;                                       		// 0x0200 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rotation;                                       		// 0x020C (0x000C) [0x0000000000000000]              
	unsigned long                                      m_visible : 1;                                    		// 0x0218 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FColor                                      m_lineColor;                                      		// 0x021C (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1629 ];

		return pClassPointer;
	};

};

UClass* UYZiplineInteractionComponent::pClassPointer = NULL;

// Class SRGame.YZiplineTarget
// 0x0004 (0x01FC - 0x01F8)
class AYZiplineTarget : public AActor
{
public:
	class AYTrigger_ZiplineInteraction*                m_ziplineInteraction;                             		// 0x01F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1630 ];

		return pClassPointer;
	};

};

UClass* AYZiplineTarget::pClassPointer = NULL;

// Class SRGame.PawnCollisionEffectsTrigger
// 0x0004 (0x02F0 - 0x02EC)
class APawnCollisionEffectsTrigger : public AKActorSpawnable
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x02EC (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1631 ];

		return pClassPointer;
	};

	void SetScale ( float Scale );
	void EnableCollision ( unsigned long Enable );
	void SetPhysicalCollisionProperties ( );
};

UClass* APawnCollisionEffectsTrigger::pClassPointer = NULL;

// Class SRGame.YAnimstateManager
// 0x0015 (0x0051 - 0x003C)
class UYAnimstateManager : public UObject
{
public:
	struct FYS_PawnState                               m_currentPawnState;                               		// 0x003C (0x0008) [0x0000000000000000]              
	unsigned long                                      m_crouchModifier : 1;                             		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_coverModifier : 1;                              		// 0x0044 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_zoomModifier : 1;                               		// 0x0044 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_sprintModifier : 1;                             		// 0x0044 (0x0004) [0x0000000000000000] [0x00000008] 
	class AYGamePawn*                                  m_pawn;                                           		// 0x0048 (0x0004) [0x0000000000000000]              
	class UYAnimtreeManager*                           m_animtreeManager;                                		// 0x004C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_ReplicatedAnim;                                 		// 0x0050 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1632 ];

		return pClassPointer;
	};

	struct FYS_AnimID DetermineAttackCommandAnimation ( );
	struct FYS_AnimID DetermineRegroupCommandAnimation ( );
	struct FYS_AnimID DetermineGotoCommandAnimation ( );
	struct FYS_AnimID DetermineEquipScndModeAnimation ( );
	struct FYS_AnimID DetermineHeadCoverAnimation ( );
	struct FYS_AnimID DeterminePickUpAnimation ( );
	struct FYS_AnimID DetermineRefireAnimation ( );
	struct FYS_AnimID DetermineReloadEndAnimation ( );
	struct FYS_AnimID DetermineReloadLoopAnimation ( );
	struct FYS_AnimID DetermineReloadAnimation ( );
	struct FYS_AnimID DetermineModeAnimation ( unsigned char replicatedAnim, unsigned char* loop );
	struct FYS_AnimID DetermineWeaponSwitchAnimation ( unsigned long equip );
	struct FYS_AnimID DetermineGrenadeThrowAnimation ( unsigned long longThrow );
	bool ProcessSprintModifier ( unsigned long sprintModifier, unsigned long forceModifier );
	bool ProcessZoomModifier ( unsigned long zoomModifier, unsigned long forceModifier );
	bool ProcessCoverModifier ( unsigned long coverModifier, unsigned long forceModifier );
	bool ProcessCrouchModifier ( unsigned long crouchModifier, unsigned long forceModifier, unsigned long disablePostureTransition );
	bool ProcessSubstate ( unsigned char substate, unsigned long forceSubstate, unsigned long disablePostureTransition );
	bool ProcessMainState ( unsigned char mainState, unsigned char substate, unsigned long forceState, unsigned long disableTransition );
	bool GetReplicatedAnimationToStop ( unsigned char replicatedAnim, struct FYS_AnimID* outAnimID );
	bool GetReplicatedAnimationToPlay ( unsigned char replicatedAnim, struct FYS_AnimID* outAnimID, float* BlendInTime, unsigned char* looped, struct FScriptDelegate* animStartCallback, struct FScriptDelegate* animEndCallback );
	bool StopReplicatedAnimation ( unsigned char replicatedAnim );
	bool CanStopReplicatedAnimation ( unsigned char replicatedAnim );
	bool PlayReplicatedAnimation ( unsigned char replicatedAnim, float playRateFactor );
	void OnReplicatedAnimFinished ( );
	bool CanPlayReplicatedAnimation ( unsigned char replicatedAnim );
	void ApplyReplicatedSprintModifier ( unsigned long sprintModifier );
	void ApplyReplicatedZoomModifier ( unsigned long zoomModifier );
	void ApplyReplicatedCoverModifier ( unsigned long coverModifier );
	void ApplyReplicatedCrouchModifier ( unsigned long crouchModifier );
	void ApplyReplicatedPawnState ( struct FYS_PawnState pawnState );
	void Init ( class AYGamePawn* GamePawn, class UYAnimtreeManager* animtreeManager );
};

UClass* UYAnimstateManager::pClassPointer = NULL;

// Class SRGame.YDBNORule
// 0x002C (0x0068 - 0x003C)
class UYDBNORule : public UObject
{
public:
	TArray< struct FYS_DBNORuleSet >                   m_dbnoRuleSets;                                   		// 0x003C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	TArray< struct FYS_PawnDBNOInfo >                  m_dbnoPawnInfos;                                  		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_PendingPawnDBNOInfo >           m_pendingEnterDBNOPawnInfos;                      		// 0x0054 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_downButNotOutMinDuration;                       		// 0x0060 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_dbnoInvulnerabilityTime;                        		// 0x0064 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1633 ];

		return pClassPointer;
	};

	bool GetDBNOInfo ( class AYGamePawn* pwn, struct FYS_PawnDBNOInfo* pwnInfo, int* pwnInfoIndex );
	void OnPawnIsDBNO ( class AYGamePawn* pwn, unsigned char enterCondition );
	void OnPawnKilled ( class AYGamePawn* pwn );
	float GetPawnCurrentHealth ( class AYGamePawn* pwn );
	float GetPawnMaxHealth ( class AYGamePawn* pwn );
	int GetDBNORuleSet ( class AYGamePawn* pwn, struct FYS_DBNORuleSet* Ruleset );
	bool HasExitCondition ( class AYGamePawn* pwn, unsigned char exitCondition );
	bool UseMinDurationForTeamRevive ( );
	bool UseMinDurationForSuicide ( );
	bool CanCommitSuicide ( class AYGamePawn* pwn, struct FYS_DBNORuleSet Ruleset, struct FYS_PawnDBNOInfo pwnInfo, unsigned long pwnInfoValid );
	bool CanBeExecuted ( class AYGamePawn* pwn, struct FYS_DBNORuleSet Ruleset, struct FYS_PawnDBNOInfo pwnInfo, unsigned long pwnInfoValid );
	bool CanBeDamaged ( class AYGamePawn* pwn, struct FYS_DBNORuleSet Ruleset, struct FYS_PawnDBNOInfo pwnInfo, unsigned long pwnInfoValid );
	bool CanBeRevivedByTeammate ( class AYGamePawn* pwn, struct FYS_DBNORuleSet Ruleset, struct FYS_PawnDBNOInfo pwnInfo, unsigned long pwnInfoValid );
	bool CanSelfRevive ( class AYGamePawn* pwn, struct FYS_DBNORuleSet Ruleset, struct FYS_PawnDBNOInfo pwnInfo, unsigned long pwnInfoValid );
	float GetBleedoutDuration ( struct FYS_DBNORuleSet Ruleset, class AYPlayerReplicationInfo* PRI );
	void UpdateBleedoutStatusForPRI ( struct FYS_PawnDBNOInfo pwnInfo, unsigned long Start );
	void UpdatePawnDBNOCapabilitiesForPRI ( class AYGamePawn* pwn );
	void RestoreHealth ( struct FYS_PawnDBNOInfo pwnInfo, unsigned long enteringDBNO );
	bool LeaveDBNO_ToDeath ( struct FYS_PawnDBNOInfo pwnInfo );
	bool LeaveDBNO_ToAlive ( struct FYS_PawnDBNOInfo pwnInfo );
	bool RevivePawn ( class AYGamePawn* pwn );
	void ProcessExitChecks ( int pwnInfoIndex, unsigned char Result );
	unsigned char CheckForExitingDBNO ( int dbnoInfoIndex );
	unsigned char CheckForEnteringDBNO ( class AYGamePawn* pwn, class UClass* dmgTypeClass, struct FVector Momentum, float Damage, struct FTraceHitInfo HitInfo, class AController* Instigator, unsigned long wasHeadshot, unsigned long makesHeadExplode, unsigned char* enterCondition );
	void PrintRuleSettings ( );
	void Reset ( );
	void PendingEnterDBNO ( class AYGamePawn* pwn, unsigned char enterCondition, class AController* Instigator, class UClass* dmgTypeClass );
	bool TemporaryPreventDBNO ( class AYGamePawn* pwn );
	void Tick ( float DeltaTime );
};

UClass* UYDBNORule::pClassPointer = NULL;

// Class SRGame.YDeathAnimPlayer
// 0x0000 (0x003C - 0x003C)
class UYDeathAnimPlayer : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1634 ];

		return pClassPointer;
	};

	void SetSleepEnergyThreshold ( class AYGamePawn* Target, float Threshold );
	void SetDamping ( class AYGamePawn* Target, float LinearDamping, float AngularDamping );
	void SetNormalMaterial ( class AYGamePawn* Target );
	void SetPhysAnimMaterial ( class AYGamePawn* Target );
	void SetJointStrengthScale ( class AYGamePawn* Target, float Scale );
	void SetNamedJointVelocityDrives ( class AYGamePawn* Target, unsigned long Enable, TArray< struct FName >* jointNames );
	void SetJointVelocityDrives ( class AYGamePawn* Target, unsigned long Enable );
	void SetJointPositionDrives ( class AYGamePawn* Target, unsigned long Enable );
	void SetSpringStrengthScale ( class AYGamePawn* Target, float Scale );
	void LoosenBone ( class AYGamePawn* Target, struct FName BoneName );
	void LoosenBones ( class AYGamePawn* Target, TArray< struct FName >* BoneNames );
	void EnableBoneSpring ( class AYGamePawn* Target, struct FName BoneName );
	void EnableBoneSprings ( class AYGamePawn* Target, TArray< struct FName >* BoneNames );
	void FixBone ( class AYGamePawn* Target, struct FName BoneName );
	void FixBones ( class AYGamePawn* Target, TArray< struct FName >* BoneNames );
	void SetAllBoneSprings ( class AYGamePawn* Target );
	void FixAllBones ( class AYGamePawn* Target );
	void LoosenAllBones ( class AYGamePawn* Target );
	void FixHipBoneSpring ( class AYGamePawn* Target, unsigned long fixLinear, unsigned long fixAngular, float spring, float Damping, unsigned long disableOnOverextension );
	bool SetPhysicalProperties ( class AYGamePawn* Target, struct FYS_DeathAnimProperty* dap );
};

UClass* UYDeathAnimPlayer::pClassPointer = NULL;

// Class SRGame.YDemoPlayerController
// 0x0000 (0x05B0 - 0x05B0)
class AYDemoPlayerController : public AGamePlayerController
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1635 ];

		return pClassPointer;
	};

	void InitPlayerReplicationInfo ( );
	void ReceivedPlayer ( );
	void PostBeginPlay ( );
};

UClass* AYDemoPlayerController::pClassPointer = NULL;

// Class SRGame.YGamePawn
// 0x1D40 (0x21B4 - 0x0474)
class AYGamePawn : public AGamePawn
{
public:
	struct FPointer                                    VfTable_IYIScanable;                              		// 0x0474 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_IYShootable;                              		// 0x0478 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x047C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_FCallbackEventDevice;                     		// 0x0480 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned char                                      m_modeAnimState;                                  		// 0x0484 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_configTypeLoaded;                               		// 0x0485 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_replicatedHitReactionAnimID;                    		// 0x0486 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_replicatedExecutionAnimID;                      		// 0x0487 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_replicatedHitByExplosionReactionAnimID;         		// 0x0488 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_jointMotorState;                                		// 0x0489 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_deathDBNOState;                                 		// 0x048A (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_prevMainState;                                  		// 0x048B (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_prevSubState;                                   		// 0x048C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_standardAnimSetCount;                           		// 0x048D (0x0001) [0x0000000000000000]              
	unsigned char                                      m_movementState;                                  		// 0x048E (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_animModifier;                                   		// 0x048F (0x0001) [0x0000000000000000]              
	unsigned char                                      m_replicatedAnimModifier;                         		// 0x0490 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_specialMove;                                    		// 0x0491 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_previousSpecialMove;                            		// 0x0492 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_fallingType;                                    		// 0x0493 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_landingType;                                    		// 0x0494 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_fallingState;                                   		// 0x0495 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_lastFallingState;                               		// 0x0496 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_landingState;                                   		// 0x0497 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_coverFaceState;                                 		// 0x0498 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_weaponRaised;                                   		// 0x0499 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_currentRaiseWeaponAnimation;                    		// 0x049A (0x0001) [0x0000000000000000]              
	unsigned char                                      m_footPlacementLOD;                               		// 0x049B (0x0001) [0x0000000000000000]              
	unsigned char                                      m_footPlacementAimOverHandling;                   		// 0x049C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_sandPhysMatType;                                		// 0x049D (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_presetGrenadeTypes[ 0x8 ];                      		// 0x049E (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned char                                      m_reloadAnimState;                                		// 0x04A6 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_takeUpWeaponState;                              		// 0x04A7 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_currentlyRunningGrenadeAnim;                    		// 0x04A8 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_ReplicatedGrenadeAnim;                          		// 0x04A9 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_currentGrenadeAnimStyle;                        		// 0x04AA (0x0001) [0x0000000000000000]              
	unsigned char                                      m_canChangeToBlindfire;                           		// 0x04AB (0x0001) [0x0000000000000000]              
	unsigned char                                      m_canChangeToAimOut;                              		// 0x04AC (0x0001) [0x0000000000000000]              
	unsigned char                                      m_zoomWithoutFire;                                		// 0x04AD (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentCoverMovementDirection;                  		// 0x04AE (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_currentBehaviorState;                           		// 0x04AF (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentEffortStatus;                            		// 0x04B0 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_pendingEffortStatus;                            		// 0x04B1 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_simpleRefSpecialActionAnimID;                   		// 0x04B2 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_scanAppearance;                                 		// 0x04B3 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_tempScanAppearance;                             		// 0x04B4 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_kismetForcedSilhouette;                         		// 0x04B5 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_oldScanAppearance;                              		// 0x04B6 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      lastFinishedMainState;                            		// 0x04B7 (0x0001) [0x0000000000000000]              
	unsigned char                                      lastFinishedSubstate;                             		// 0x04B8 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_killshotFXis2play;                              		// 0x04B9 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentSpecialActionPriority;                   		// 0x04BA (0x0001) [0x0000000000000000]              
	unsigned char                                      m_forceSandStormAnims;                            		// 0x04BB (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_squadMemberType;                                		// 0x04BC (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_NPCCategory;                                    		// 0x04BD (0x0001) [0x0000000000000000]              
	unsigned char                                      m_forcedVaporizationType;                         		// 0x04BE (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_initializationState;                            		// 0x04BF (0x0001) [0x0000000000000000]              
	unsigned char                                      m_attractionType;                                 		// 0x04C0 (0x0001) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned char                                      m_animNotifyInterpolateOverrideRootMotionMode;    		// 0x04C1 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentSpecialIdleAnim;                         		// 0x04C2 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_previousSpecialIdleAnim;                        		// 0x04C3 (0x0001) [0x0000000000000000]              
	struct FVector                                     m_displayOffset;                                  		// 0x04C4 (0x000C) [0x0000000000000000]              
	class AYWeapon*                                    m_blowtorch;                                      		// 0x04D0 (0x0004) [0x0000000000000000]              
	class AYWeapon*                                    m_PDA;                                            		// 0x04D4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_setHighRagdollDampingCallbackName;              		// 0x04D8 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_startPhysicsWeightBlendCallbackName;            		// 0x04E0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_disableRagdollGravityCallbackName;              		// 0x04E8 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_setupPhysicsComponentsForRagdollCallbackName;   		// 0x04F0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	int                                                m_asyncLineChecks[ 0xA ];                         		// 0x04F8 (0x0028) [0x0000000000000000]              
	struct FYS_GamePawnAsyncCheckResult                m_asyncLineCheckResults[ 0xA ];                   		// 0x0520 (0x00C8) [0x0000000000000000]              
	unsigned long                                      m_materialBelowFeetTestUpToDate : 1;              		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_meshTranslationDataUpToDate : 1;                		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_meshTranslationUseAsyncLineChecks : 1;          		// 0x05E8 (0x0004) [0x0000000000004001] [0x00000004] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_leanSoundActive : 1;                            		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_coverWalkActive : 1;                            		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_hadDangerousFlyBys : 1;                         		// 0x05E8 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_useDirectFireCamShakes : 1;                     		// 0x05E8 (0x0004) [0x0000000000004003] [0x00000040] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_isInDirectFire : 1;                             		// 0x05E8 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_detectAudioFlyBy : 1;                           		// 0x05E8 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_pushDownwards : 1;                              		// 0x05E8 (0x0004) [0x0000000000004000] [0x00000200] ( CPF_Config )
	unsigned long                                      m_useCollCylinderExtentDownwards : 1;             		// 0x05E8 (0x0004) [0x0000000000004000] [0x00000400] ( CPF_Config )
	unsigned long                                      m_effectTriggerSystemActive : 1;                  		// 0x05E8 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_disableDeathAnimSystem : 1;                     		// 0x05E8 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_blockDeathAnim : 1;                             		// 0x05E8 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_blendPhysicsWeight : 1;                         		// 0x05E8 (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      m_updatePhysicsWeightStartOnBlendStart : 1;       		// 0x05E8 (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	unsigned long                                      m_scaleJointLimits : 1;                           		// 0x05E8 (0x0004) [0x0000000000002000] [0x00010000] ( CPF_Transient )
	unsigned long                                      m_fadeMuscleStrength : 1;                         		// 0x05E8 (0x0004) [0x0000000000002000] [0x00020000] ( CPF_Transient )
	unsigned long                                      m_hipSpringFixed : 1;                             		// 0x05E8 (0x0004) [0x0000000000002000] [0x00040000] ( CPF_Transient )
	unsigned long                                      m_blendPhysicalHitReaction : 1;                   		// 0x05E8 (0x0004) [0x0000000000002000] [0x00080000] ( CPF_Transient )
	unsigned long                                      m_useRagdollGravity : 1;                          		// 0x05E8 (0x0004) [0x0000000000002000] [0x00100000] ( CPF_Transient )
	unsigned long                                      m_isPlayingSpecialMoveDeathAnim : 1;              		// 0x05E8 (0x0004) [0x0000000000002000] [0x00200000] ( CPF_Transient )
	unsigned long                                      m_playingHitReactionAnim : 1;                     		// 0x05E8 (0x0004) [0x0000000000002000] [0x00400000] ( CPF_Transient )
	unsigned long                                      m_allowHitReactionAnimations : 1;                 		// 0x05E8 (0x0004) [0x0000000000004021] [0x00800000] ( CPF_Edit | CPF_Net | CPF_Config )
	unsigned long                                      m_playBigHitReaction : 1;                         		// 0x05E8 (0x0004) [0x0000000000002000] [0x01000000] ( CPF_Transient )
	unsigned long                                      m_hitReactionAnimAllowsDeathAnimPlayback : 1;     		// 0x05E8 (0x0004) [0x0000000000002000] [0x02000000] ( CPF_Transient )
	unsigned long                                      m_keepRunningDuringHitReaction : 1;               		// 0x05E8 (0x0004) [0x0000000000002000] [0x04000000] ( CPF_Transient )
	unsigned long                                      m_playedHitReactionFirstHit : 1;                  		// 0x05E8 (0x0004) [0x0000000000002000] [0x08000000] ( CPF_Transient )
	unsigned long                                      m_playBigReactionOnFirstHitIfNoSmallIsFound : 1;  		// 0x05E8 (0x0004) [0x0000000000004001] [0x10000000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_ragdollIsDisabled : 1;                          		// 0x05E8 (0x0004) [0x0000000000002000] [0x20000000] ( CPF_Transient )
	unsigned long                                      bCheckKnockdownFall : 1;                          		// 0x05E8 (0x0004) [0x0000000000002000] [0x40000000] ( CPF_Transient )
	unsigned long                                      bScalingToZero : 1;                               		// 0x05E8 (0x0004) [0x0000000000002000] [0x80000000] ( CPF_Transient )
	unsigned long                                      m_supportsDeathDBNO : 1;                          		// 0x05EC (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_deathDBNOSuppressedByAIFactory : 1;             		// 0x05EC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_crouchModifier : 1;                             		// 0x05EC (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_coverModifier : 1;                              		// 0x05EC (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      m_zoomModifier : 1;                               		// 0x05EC (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      m_sprintModifier : 1;                             		// 0x05EC (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned long                                      m_playEnemyAnimations : 1;                        		// 0x05EC (0x0004) [0x0000000000024021] [0x00000040] ( CPF_Edit | CPF_Net | CPF_Config | CPF_EditConst )
	unsigned long                                      m_playSquadAnimations : 1;                        		// 0x05EC (0x0004) [0x0000000000024021] [0x00000080] ( CPF_Edit | CPF_Net | CPF_Config | CPF_EditConst )
	unsigned long                                      m_bDirtyAnimationAndAnimSet : 1;                  		// 0x05EC (0x0004) [0x0000000000020021] [0x00000100] ( CPF_Edit | CPF_Net | CPF_EditConst )
	unsigned long                                      m_mirrored : 1;                                   		// 0x05EC (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_reversedMovementLeft : 1;                       		// 0x05EC (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      m_reversedMovementRight : 1;                      		// 0x05EC (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      m_rotationFixed : 1;                              		// 0x05EC (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_faceRotationWithBody : 1;                       		// 0x05EC (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_rotateWithAnimRoot : 1;                         		// 0x05EC (0x0004) [0x0000000000004003] [0x00004000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_useFreeturnCamera : 1;                          		// 0x05EC (0x0004) [0x0000000000004001] [0x00008000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_alignVelocityAnimationsToRootMotion : 1;        		// 0x05EC (0x0004) [0x0000000000002000] [0x00010000] ( CPF_Transient )
	unsigned long                                      m_justHitObject : 1;                              		// 0x05EC (0x0004) [0x0000000000002000] [0x00020000] ( CPF_Transient )
	unsigned long                                      m_justHitPawn : 1;                                		// 0x05EC (0x0004) [0x0000000000002000] [0x00040000] ( CPF_Transient )
	unsigned long                                      m_isDoingPhysWalkingCalulcations : 1;             		// 0x05EC (0x0004) [0x0000000000002000] [0x00080000] ( CPF_Transient )
	unsigned long                                      m_disableLookAtWhenAiming : 1;                    		// 0x05EC (0x0004) [0x0000000000004003] [0x00100000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_raiseWeaponWhenPossible : 1;                    		// 0x05EC (0x0004) [0x0000000000000020] [0x00200000] ( CPF_Net )
	unsigned long                                      m_preventNetworkPositionCorrection : 1;           		// 0x05EC (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      m_forceSprinting : 1;                             		// 0x05EC (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_blockMovement : 1;                              		// 0x05EC (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      m_isTakingPickup : 1;                             		// 0x05EC (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      m_combatSprintModifier : 1;                       		// 0x05EC (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      m_extendedSprintEnabled : 1;                      		// 0x05EC (0x0004) [0x0000000000002000] [0x08000000] ( CPF_Transient )
	unsigned long                                      m_sprintSlideEnabled : 1;                         		// 0x05EC (0x0004) [0x0000000000004002] [0x10000000] ( CPF_Const | CPF_Config )
	unsigned long                                      m_playingRunToIdleAnim : 1;                       		// 0x05EC (0x0004) [0x0000000000002000] [0x20000000] ( CPF_Transient )
	unsigned long                                      m_targetLocationInterpolatorMayNotFail : 1;       		// 0x05EC (0x0004) [0x0000000000002000] [0x40000000] ( CPF_Transient )
	unsigned long                                      m_leanToCover : 1;                                		// 0x05EC (0x0004) [0x0000000000004001] [0x80000000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_idleNodeHasFullWeight : 1;                      		// 0x05F0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_preventLandingFX : 1;                           		// 0x05F0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_crouched : 1;                                   		// 0x05F0 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_dropdown : 1;                                   		// 0x05F0 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_ignoreCollision : 1;                            		// 0x05F0 (0x0004) [0x0000000000002001] [0x00000010] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_ignorePawnCollision : 1;                        		// 0x05F0 (0x0004) [0x0000000000002001] [0x00000020] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_useSecondCylinder : 1;                          		// 0x05F0 (0x0004) [0x0000000000004002] [0x00000040] ( CPF_Const | CPF_Config )
	unsigned long                                      m_ignoreSecondCylinderForAI : 1;                  		// 0x05F0 (0x0004) [0x0000000000004002] [0x00000080] ( CPF_Const | CPF_Config )
	unsigned long                                      m_secondCylinderActive : 1;                       		// 0x05F0 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_headCoverJustOccured : 1;                       		// 0x05F0 (0x0004) [0x0000000000002001] [0x00000200] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_headCoverPlaying : 1;                           		// 0x05F0 (0x0004) [0x0000000000002001] [0x00000400] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_aimingReplicated : 1;                           		// 0x05F0 (0x0004) [0x0000000000000020] [0x00000800] ( CPF_Net )
	unsigned long                                      m_commandAnimationRunning : 1;                    		// 0x05F0 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_backAiming : 1;                                 		// 0x05F0 (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      m_aimoutBlockedByCollision : 1;                   		// 0x05F0 (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      m_facingCover : 1;                                		// 0x05F0 (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	unsigned long                                      m_coverParameterLock : 1;                         		// 0x05F0 (0x0004) [0x0000000000002000] [0x00010000] ( CPF_Transient )
	unsigned long                                      m_aimCamLineBlocked : 1;                          		// 0x05F0 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_raiseWeaponTestingEnabled : 1;                  		// 0x05F0 (0x0004) [0x0000000000000001] [0x00040000] ( CPF_Edit )
	unsigned long                                      m_useSimpleRaiseWeaponTest : 1;                   		// 0x05F0 (0x0004) [0x0000000000000001] [0x00080000] ( CPF_Edit )
	unsigned long                                      m_footPlacementEnabled : 1;                       		// 0x05F0 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_useSkelControlLowUpdateRate : 1;                		// 0x05F0 (0x0004) [0x0000000000002000] [0x00200000] ( CPF_Transient )
	unsigned long                                      m_forceLowRateSkelControlUpdate : 1;              		// 0x05F0 (0x0004) [0x0000000000002000] [0x00400000] ( CPF_Transient )
	unsigned long                                      m_meshTranslationLocked : 1;                      		// 0x05F0 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_meshTranslationHasBeenUnlocked : 1;             		// 0x05F0 (0x0004) [0x0000000000002000] [0x01000000] ( CPF_Transient )
	unsigned long                                      m_keepUpdatingSmoothing : 1;                      		// 0x05F0 (0x0004) [0x0000000000002000] [0x02000000] ( CPF_Transient )
	unsigned long                                      m_sandMovementEnabled : 1;                        		// 0x05F0 (0x0004) [0x0000000000004003] [0x04000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_tossWeapon : 1;                                 		// 0x05F0 (0x0004) [0x0000000000004001] [0x08000000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_wantsToReload : 1;                              		// 0x05F0 (0x0004) [0x0000000000002000] [0x10000000] ( CPF_Transient )
	unsigned long                                      m_reloading : 1;                                  		// 0x05F0 (0x0004) [0x0000000000002000] [0x20000000] ( CPF_Transient )
	unsigned long                                      m_aimingRestrictedByWeaponFunction : 1;           		// 0x05F0 (0x0004) [0x0000000000002000] [0x40000000] ( CPF_Transient )
	unsigned long                                      m_wantsAimoutAfterFinishWeaponFunction : 1;       		// 0x05F0 (0x0004) [0x0000000000002000] [0x80000000] ( CPF_Transient )
	unsigned long                                      m_consumesNoAmmunition : 1;                       		// 0x05F4 (0x0004) [0x0000000000004003] [0x00000001] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_isInSandstormExcludeVolume : 1;                 		// 0x05F4 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_isSandStormAnimSetLoaded : 1;                   		// 0x05F4 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_grenadeRaiseAnimHardStopped : 1;                		// 0x05F4 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_wantsToFire : 1;                                		// 0x05F4 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      m_oldWantsToFire : 1;                             		// 0x05F4 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_isFiring : 1;                                   		// 0x05F4 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      m_isPlayingRefireAnim : 1;                        		// 0x05F4 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_isPlayingReactionAnim : 1;                      		// 0x05F4 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_isHoldingGrenade : 1;                           		// 0x05F4 (0x0004) [0x0000000000000020] [0x00000200] ( CPF_Net )
	unsigned long                                      m_grenadeInPawnHand : 1;                          		// 0x05F4 (0x0004) [0x0000000000000020] [0x00000400] ( CPF_Net )
	unsigned long                                      m_preparesBlindFiring : 1;                        		// 0x05F4 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_forceStandardCrosshair : 1;                     		// 0x05F4 (0x0004) [0x0000000000002000] [0x00001000] ( CPF_Transient )
	unsigned long                                      m_mayFireThisTick : 1;                            		// 0x05F4 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_shootingBlockedByFacingCover : 1;               		// 0x05F4 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_forceWeaponFire : 1;                            		// 0x05F4 (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	unsigned long                                      m_supportsCover : 1;                              		// 0x05F4 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_allowCoverDbno : 1;                             		// 0x05F4 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_allowRagdollDBNO : 1;                           		// 0x05F4 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_useAICoverOnly : 1;                             		// 0x05F4 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      m_coverLocked : 1;                                		// 0x05F4 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_ignoreInnerCoverEdges : 1;                      		// 0x05F4 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_aimAroundEnabled : 1;                           		// 0x05F4 (0x0004) [0x0000000000004003] [0x00400000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_wantsToChangeAimOverSide : 1;                   		// 0x05F4 (0x0004) [0x0000000000002000] [0x00800000] ( CPF_Transient )
	unsigned long                                      m_stateChangeDueToSideChange : 1;                 		// 0x05F4 (0x0004) [0x0000000000002000] [0x01000000] ( CPF_Transient )
	unsigned long                                      m_useImprovedAimout : 1;                          		// 0x05F4 (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      m_aimOutLockedByPlayerController : 1;             		// 0x05F4 (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      m_blindfireEdgeOnlyWhenFacingCover : 1;           		// 0x05F4 (0x0004) [0x0000000000004003] [0x08000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_coverEdgePoseEnabled : 1;                       		// 0x05F4 (0x0004) [0x0000000000004003] [0x10000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_coverEdgePoseIgnoreCameraRotation : 1;          		// 0x05F4 (0x0004) [0x0000000000004003] [0x20000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_cancelCoverStateTransitions : 1;                		// 0x05F4 (0x0004) [0x0000000000004003] [0x40000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_keepAimingOutWhenPeeking : 1;                   		// 0x05F4 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      m_lockSubstateChange : 1;                         		// 0x05F8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_despawnedByKismetNode : 1;                      		// 0x05F8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_destroyedByKismetNode : 1;                      		// 0x05F8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_canHealthRecover : 1;                           		// 0x05F8 (0x0004) [0x0000000000004001] [0x00000008] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_immortal : 1;                                   		// 0x05F8 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_healthRegenerationInCoverOnly : 1;              		// 0x05F8 (0x0004) [0x0000000000004000] [0x00000020] ( CPF_Config )
	unsigned long                                      m_IDAActive : 1;                                  		// 0x05F8 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_IDAMayTrigger : 1;                              		// 0x05F8 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_IDADisabled : 1;                                		// 0x05F8 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_suppressGenericVoiceOver : 1;                   		// 0x05F8 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_useEffortSystemForAutoSprint : 1;               		// 0x05F8 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_genericGrenadeUsage : 1;                        		// 0x05F8 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_useAIGrenadeReaction : 1;                       		// 0x05F8 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_blockCamera : 1;                                		// 0x05F8 (0x0004) [0x0000000000000001] [0x00002000] ( CPF_Edit )
	unsigned long                                      m_stumbleWhenHitByGrenade : 1;                    		// 0x05F8 (0x0004) [0x0000000000004001] [0x00004000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_allowRagdollWhenMeleed : 1;                     		// 0x05F8 (0x0004) [0x0000000000004001] [0x00008000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_allowMeleeHitReaction : 1;                      		// 0x05F8 (0x0004) [0x0000000000004001] [0x00010000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_allowMeleeBloodEffect : 1;                      		// 0x05F8 (0x0004) [0x0000000000004001] [0x00020000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_disableCollisionOnMeleeHitReaction : 1;         		// 0x05F8 (0x0004) [0x0000000000004001] [0x00040000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_stumbleWhenHitBySand : 1;                       		// 0x05F8 (0x0004) [0x0000000000004001] [0x00080000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_playSeparatedTakeHitAnim : 1;                   		// 0x05F8 (0x0004) [0x0000000000004001] [0x00100000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_hasPerformedMeleeCheck : 1;                     		// 0x05F8 (0x0004) [0x0000000000002000] [0x00200000] ( CPF_Transient )
	unsigned long                                      m_canBeMeleedByAI : 1;                            		// 0x05F8 (0x0004) [0x0000000000004001] [0x00400000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_isHoldingAHumanShield : 1;                      		// 0x05F8 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_isAboutToBeExecuted : 1;                        		// 0x05F8 (0x0004) [0x0000000000002000] [0x01000000] ( CPF_Transient )
	unsigned long                                      m_lootAmmoFromExecuted : 1;                       		// 0x05F8 (0x0004) [0x0000000000004003] [0x02000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_lootGrenadesFromExecuted : 1;                   		// 0x05F8 (0x0004) [0x0000000000004003] [0x04000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_lootDroppingAllowed : 1;                        		// 0x05F8 (0x0004) [0x0000000000004003] [0x08000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_canBeExecutedDuringMelee : 1;                   		// 0x05F8 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      m_executionSpecialMoveHasJustEnded : 1;           		// 0x05F8 (0x0004) [0x0000000000002000] [0x20000000] ( CPF_Transient )
	unsigned long                                      m_isBeingRevived : 1;                             		// 0x05F8 (0x0004) [0x0000000000000000] [0x40000000] 
	unsigned long                                      m_tacticalViewEnabled : 1;                        		// 0x05F8 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      m_suppressSilhouette : 1;                         		// 0x05FC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_wasScanned : 1;                                 		// 0x05FC (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_showSelectionSilhouette : 1;                    		// 0x05FC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_markedAsAttackTarget : 1;                       		// 0x05FC (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_silhouetteIsFadedOut : 1;                       		// 0x05FC (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_oldShowSelectionSilhouette : 1;                 		// 0x05FC (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_oldAffectedByMortar : 1;                        		// 0x05FC (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_oldMarkedAsAttackTarget : 1;                    		// 0x05FC (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_isInCombatSituation : 1;                        		// 0x05FC (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_forceRadioFilterInCombat : 1;                   		// 0x05FC (0x0004) [0x0000000000004001] [0x00000200] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_forceRadioFilterInSandstorm : 1;                		// 0x05FC (0x0004) [0x0000000000004001] [0x00000400] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_speaking : 1;                                   		// 0x05FC (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      m_isTooDeadToSpeak : 1;                           		// 0x05FC (0x0004) [0x0000000000002000] [0x00001000] ( CPF_Transient )
	unsigned long                                      m_speakLineCancelledByKismetStop : 1;             		// 0x05FC (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      m_useSPDebugDBNORule : 1;                         		// 0x05FC (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_supportsDBNO : 1;                               		// 0x05FC (0x0004) [0x0000000000000020] [0x00008000] ( CPF_Net )
	unsigned long                                      m_isKnockedDown : 1;                              		// 0x05FC (0x0004) [0x0000000000000020] [0x00010000] ( CPF_Net )
	unsigned long                                      m_isTakenDown : 1;                                		// 0x05FC (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_isDownButNotOut : 1;                            		// 0x05FC (0x0004) [0x0000000000000020] [0x00040000] ( CPF_Net )
	unsigned long                                      m_bReplicateBloodPool : 1;                        		// 0x05FC (0x0004) [0x0000000000000020] [0x00080000] ( CPF_Net )
	unsigned long                                      m_isInDemiGod : 1;                                		// 0x05FC (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_isPlayingSandStormAnims : 1;                    		// 0x05FC (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_canPlaySandStormAnimations : 1;                 		// 0x05FC (0x0004) [0x0000000000004000] [0x00400000] ( CPF_Config )
	unsigned long                                      m_isBurning : 1;                                  		// 0x05FC (0x0004) [0x0000000000002000] [0x00800000] ( CPF_Transient )
	unsigned long                                      m_isBurningByFlamethrower : 1;                    		// 0x05FC (0x0004) [0x0000000000002000] [0x01000000] ( CPF_Transient )
	unsigned long                                      m_explodedHead : 1;                               		// 0x05FC (0x0004) [0x0000000000000020] [0x02000000] ( CPF_Net )
	unsigned long                                      m_goreCensor : 1;                                 		// 0x05FC (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      m_bDelayedInitialization : 1;                     		// 0x05FC (0x0004) [0x0000000000004000] [0x08000000] ( CPF_Config )
	unsigned long                                      m_isSpawningAIFactory : 1;                        		// 0x05FC (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      m_spawnAttractionActor : 1;                       		// 0x05FC (0x0004) [0x0000000000000001] [0x20000000] ( CPF_Edit )
	unsigned long                                      m_attractorStrengthByDistance : 1;                		// 0x05FC (0x0004) [0x0000000000004001] [0x40000000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_attractorAffectBaseVelocity : 1;                		// 0x05FC (0x0004) [0x0000000000004001] [0x80000000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_bStunned : 1;                                   		// 0x0600 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_shouldAlwaysDieFromStickyGrenade : 1;           		// 0x0600 (0x0004) [0x0000000000004002] [0x00000002] ( CPF_Const | CPF_Config )
	unsigned long                                      m_animNotifyInterpolateLocationEnabled : 1;       		// 0x0600 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_animNotifyInterpolateRotationEnabled : 1;       		// 0x0600 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_animNotifyInterpolateOverrideRootMotion : 1;    		// 0x0600 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_animNotifyInterpolateOverrideRootMotionRotation : 1;		// 0x0600 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_playingLoopingSpecialIdle : 1;                  		// 0x0600 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_playingReactiveSpecialIdle : 1;                 		// 0x0600 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_playSpecialIdles : 1;                           		// 0x0600 (0x0004) [0x0000000000004001] [0x00000100] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_enableContextualSlomo : 1;                      		// 0x0600 (0x0004) [0x0000000000004001] [0x00000200] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_ignoreContextualVoiceSlomo : 1;                 		// 0x0600 (0x0004) [0x0000000000000001] [0x00000400] ( CPF_Edit )
	unsigned long                                      m_hasVaporizedHead : 1;                           		// 0x0600 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_isVaporized : 1;                                		// 0x0600 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_isPlayingDeathFade : 1;                         		// 0x0600 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_NeverCleanUpWhenDead : 1;                       		// 0x0600 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_isTeleporting : 1;                              		// 0x0600 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_forceStayInCover : 1;                           		// 0x0600 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_bGrenadeBlockedByToggleReplication : 1;         		// 0x0600 (0x0004) [0x0000000000000000] [0x00020000] 
	float                                              m_meshTranslationTestInterval;                    		// 0x0604 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lastMeshTranslationTimeStamp;                   		// 0x0608 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_coverMeshXOffset;                               		// 0x060C (0x0004) [0x0000000000000000]              
	struct FGuid                                       MyGuid;                                           		// 0x0610 (0x0010) [0x0000000000000000]              
	float                                              m_increaseAmmoRate;                               		// 0x0620 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_maxIncreaseSteps;                               		// 0x0624 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_startPrimaryIncrease;                           		// 0x0628 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_startSecondaryIncrease;                         		// 0x062C (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UPhysicalMaterial*                           m_materialBelowLeftFeet;                          		// 0x0630 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UPhysicalMaterial*                           m_materialBelowRightFeet;                         		// 0x0634 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_lastFeetDown;                                   		// 0x0638 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYPhysicalMaterialProperty*                  m_materialPropertyBelowLeftFeet;                  		// 0x063C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYPhysicalMaterialProperty*                  m_materialPropertyBelowRightFeet;                 		// 0x0640 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_movementSoundMaxDist;                           		// 0x0644 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UAudioComponent*                             m_movementSoundComponent;                         		// 0x0648 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_coverSlideAC;                                   		// 0x064C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_sprintSlideAC;                                  		// 0x0650 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FVector2D                                   m_leanSoundMinSpeed;                              		// 0x0654 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanSoundMinSpeedThreshold;                     		// 0x065C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverWalkMinSpeed;                              		// 0x0660 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverMovementSoundFadeOutTime;                  		// 0x0664 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UAudioComponent*                             m_coverWalkAC;                                    		// 0x0668 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_leanSoundAC;                                    		// 0x066C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	struct FRotator                                    m_lastControllerRotation;                         		// 0x0670 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_controllerAngularVelocity;                      		// 0x067C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UAudioComponent*                             m_criticalHealthAC;                               		// 0x0688 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_nearbyExplosionBeepAC;                          		// 0x068C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FYS_GenericSoundInfo                        m_genericSoundInfos;                              		// 0x0690 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class AYGamePawn*                                  m_stickyGrenadePawn;                              		// 0x06A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_dangerousFlyByThreshold;                        		// 0x06A4 (0x0004) [0x0000000000024003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_EditConst )
	float                                              m_flyByMaxProjectileDist;                         		// 0x06A8 (0x0004) [0x0000000000024003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_EditConst )
	float                                              m_dangerousFlybyDistance;                         		// 0x06AC (0x0004) [0x0000000000024003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_EditConst )
	int                                                m_flyByMaxPlays;                                  		// 0x06B0 (0x0004) [0x0000000000000000]              
	struct FYS_FlyByAudioInformation                   m_flyByInformation[ 0x2 ];                        		// 0x06B4 (0x0010) [0x0000000000000000]              
	TArray< struct FYS_ProjectileFlyBy >               m_projectileFlyBys;                               		// 0x06C4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_ShotgunFlyBy >                  m_shotgunFlyBys;                                  		// 0x06D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_ExplosionFlyBy >                m_explosiveFlyBys;                                		// 0x06DC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_directFireBlendInTime;                          		// 0x06E8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_directFireBlendOutTime;                         		// 0x06EC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_directFireFlybyDistance;                        		// 0x06F0 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_directFireFlybyDistanceCover;                   		// 0x06F8 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_directFireFlybyIntensity;                       		// 0x0700 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_directFireFlybyIntensityZoomed;                 		// 0x0708 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_directFireCoverOffset;                          		// 0x0710 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_directFireTimeRecheckTime;                      		// 0x0714 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_currentDirectFireInterval;                      		// 0x0718 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_currentDirectFireIntensity;                     		// 0x071C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UCameraAnimInst*                             m_currentDirectFireCamShake;                      		// 0x0720 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_numDangerousFlyBys;                             		// 0x0724 (0x0004) [0x0000000000000000]              
	float                                              m_nextDangerousFlybyApplianceTimeStamp;           		// 0x0728 (0x0004) [0x0000000000000000]              
	float                                              m_zeroExtentDownwardsTraceLength;                 		// 0x072C (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< float >                                    m_actorMasses;                                    		// 0x0730 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_massSum;                                        		// 0x073C (0x0004) [0x0000000000000000]              
	TArray< struct FYS_PawnEffectTriggerAttachmentInformation > m_effectTriggerData;                              		// 0x0740 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	TArray< struct FYS_PawnRagdollImpactFXDefinition > m_impactFXDefinitions;                            		// 0x074C (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )
	class UYPawnKinematicRBCollider*                   m_kinematicCollider;                              		// 0x0758 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_deathAnimTriggerTriggeredFrameCounter;          		// 0x075C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_deathHitBoneName;                               		// 0x0760 (0x0008) [0x0000000000000000]              
	class UYPawnSpringyRBCollider*                     m_springyCollider;                                		// 0x0768 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_springyCollRadius;                              		// 0x076C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_springyCollHeight;                              		// 0x0770 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_springyCollHeightOffset;                        		// 0x0774 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_springyCollMass;                                		// 0x0778 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_springyCollHorSpring;                           		// 0x077C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_springyCollHorDamping;                          		// 0x0780 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_springyCollVertSpring;                          		// 0x0784 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_springyCollVertDamping;                         		// 0x0788 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_physicsWeightBlendStartTime;                    		// 0x078C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_physicsWeightBlendTime;                         		// 0x0790 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_physicsWeightStart;                             		// 0x0794 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_physicsWeightTarget;                            		// 0x0798 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_jointLimitScaleStartTime;                       		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_jointLimitScaleTime;                            		// 0x07A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_jointLimitScaleStart;                           		// 0x07A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_jointLimitScaleTarget;                          		// 0x07A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_jointLimitScaleCurrent;                         		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_muscleStrengthFadeStartTime;                    		// 0x07B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_muscleStrengthFadeTime;                         		// 0x07B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_muslceStrengthFadeStart;                        		// 0x07B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_muscleStrengthFadeTarget;                       		// 0x07BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_muscleStrengthFadeCurrent;                      		// 0x07C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_jointDriveScale;                                		// 0x07C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_springStrengthScale;                            		// 0x07C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_physAnimMatRestitution;                         		// 0x07CC (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_physAnimMatFriction;                            		// 0x07D0 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_physAnimMassScale;                              		// 0x07D4 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_physicalHitReactionBlendStartTime;              		// 0x07D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_physicalHitReactionBlendInTime;                 		// 0x07DC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_physicalHitReactionBlendOutTime;                		// 0x07E0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_physicalHitReactionsImpulseScale;               		// 0x07E4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_physicalHitReactionsImpulseScaleRagdoll;        		// 0x07E8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_physicalHitReactionsMotorStrength;              		// 0x07EC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_physicalHitReactionsSpringStrength;             		// 0x07F0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_physicalHitReactionMassEffectScale;             		// 0x07F4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_physicalHitReactionPhysicsWeight;               		// 0x07F8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_grenadeImpulseScale;                            		// 0x07FC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathShotImpulseScale;                          		// 0x0800 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathHeadShotImpulseScale;                      		// 0x0804 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_ragdollGravityScale;                            		// 0x0808 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_ragdollGravityTime;                             		// 0x080C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_physicalHitReactionsDelayBetweenReactions;      		// 0x0810 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_nextPhysicalHitReactionDelay;                   		// 0x0818 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_physicalHitReactionsNumImpulsesPerFrame;        		// 0x081C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_physicalHitReactionsCurrentNumImpulses;         		// 0x0820 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_nextHitReactionAnimTime;                        		// 0x0824 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_hitReactionAnimLength;                          		// 0x0828 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_hitReactionDeathAnimBlockPctStart;              		// 0x082C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_hitReactionTimeInterval;                        		// 0x0830 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_hitReactionProbability;                         		// 0x0838 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_hitReactionProbabilityBig;                      		// 0x083C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_hitReactionFirstHitResetTime;                   		// 0x0840 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_hitReactionMinHealthPct;                        		// 0x0844 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_hitReactionAnimStartTime;                       		// 0x0848 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_healthBeforeLastHit;                            		// 0x084C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_jointMotorStrengthScale;                        		// 0x0850 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_boneSpringStrengthScale;                        		// 0x0854 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_PhysicsImpactRBRemap >          m_physicalHitReactionsRBRemapTable;               		// 0x0858 (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )
	TArray< struct FName >                             m_physicalHitReactionsSpringList;                 		// 0x0864 (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )
	TArray< struct FName >                             m_physicalHitReactionFixedList;                   		// 0x0870 (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )
	TArray< struct FName >                             m_physicalHitReactionIgnoreList;                  		// 0x087C (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )
	float                                              m_ragRecoveryTime;                                		// 0x0888 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_ragRecoveryTimeDBNO;                            		// 0x088C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_ragRecoveryBlendInTime;                         		// 0x0890 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_ragRecoveryFailTime;                            		// 0x0894 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     KnockdownStartingPosition;                        		// 0x0898 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_preKnockDownVelocity;                           		// 0x08A4 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_knockDownDeadlyVelChange;                       		// 0x08B0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_knockDownDeadlyFallHeight;                      		// 0x08B4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_freefallDeathStopVelChange;                     		// 0x08B8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              TimeOfDeath;                                      		// 0x08BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AController*                                 m_lastControllerWhoDestroyedMyBase;               		// 0x08C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FMatrix >                           m_lastBoneTransforms1;                            		// 0x08C4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FMatrix >                           m_lastBoneTransforms2;                            		// 0x08D0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_lastFrameTime1;                                 		// 0x08DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastFrameTime2;                                 		// 0x08E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      UnknownData00[ 0xC ];                             		// 0x08E4 (0x000C) MISSED OFFSET
	struct FMatrix                                     m_lastMeshLocalToWorld1;                          		// 0x08F0 (0x0040) [0x0000000000002000]              ( CPF_Transient )
	struct FMatrix                                     m_lastMeshLocalToWorld2;                          		// 0x0930 (0x0040) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_currentBoneTransformSet;                        		// 0x0970 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_maxBoneVelocityWhenGoingToRagdoll;              		// 0x0974 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_DBNOCalloutInitialTime;                         		// 0x0978 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_DBNOCalloutLoopingTime;                         		// 0x097C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_deathDBNOBleedoutTime;                          		// 0x0980 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathDBNOStartTime;                             		// 0x0984 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_deathDBNOChance;                                		// 0x0988 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_numDeathDBNOSlots;                              		// 0x098C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathDBNOShortcutTime;                          		// 0x0990 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_deathDBNOShortcutDamage;                        		// 0x0994 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_deathDBNOCurrentDamage;                         		// 0x0998 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_deathDBNOExpressiveAnimChance;                  		// 0x099C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_deathDBNOExpressiveAnimTimeFrame;               		// 0x09A0 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_maxNumDeathDBNOExpressiveAnims;                 		// 0x09A8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_currentNumDeathDBNOExpressiveAnims;             		// 0x09AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< unsigned char >                            m_ddeaAnimsFront;                                 		// 0x09B0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_ddeaAnimsBack;                                  		// 0x09BC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_deathDBNOPickupAmmoModifier;                    		// 0x09C8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathDBNOPickupSpawnDistance;                   		// 0x09CC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minDistForDeathDBNO;                            		// 0x09D0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathDBNOMaxBoneHeightDiff;                     		// 0x09D4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_deathDBNOGroundNormalMinZ;                      		// 0x09D8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UYIController*                               m_myController;                                   		// 0x09DC (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData01[ 0x4 ];                             		// 0x09E0 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	float                                              m_ledgeSlidingFactor;                             		// 0x09E4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_minWallSlideAngleAI;                            		// 0x09E8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UClass*                                      m_camDataProviderClass;                           		// 0x09EC (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FYS_PawnState                               m_pawnState;                                      		// 0x09F0 (0x0008) [0x0000000000000020]              ( CPF_Net )
	struct FYS_ReplicatedAnimationInfo                 m_replicatedAnimsToPlay[ 0x19 ];                  		// 0x09F8 (0x012C) [0x0000000000000020]              ( CPF_Net )
	float                                              m_lastReplicatedAnimStartTime;                    		// 0x0B24 (0x0004) [0x0000000000000000]              
	class UYAnimstateManager*                          m_animstateManager;                               		// 0x0B28 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_animStateManagerClass;                          		// 0x0B2C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UYAnimtreeManager*                           m_animtreeManager;                                		// 0x0B30 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_animtreeManagerClass;                           		// 0x0B34 (0x0004) [0x0000000000000000]              
	TArray< struct FYS_AnimSet >                       m_animSets;                                       		// 0x0B38 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_AnimSet >                       m_pistolSpecificAdditionalAnimSets;               		// 0x0B44 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_AnimSetInfo >                   m_currentAnimSets;                                		// 0x0B50 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UClass*                                      m_animInfoClass;                                  		// 0x0B5C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UYAnimInfo*                                  m_animInfo;                                       		// 0x0B60 (0x0004) [0x0000000004000003]              ( CPF_Edit | CPF_Const | CPF_EditInline )
	TArray< struct FYS_AimingSet >                     m_aimingSets;                                     		// 0x0B64 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UYAimingSet* >                       m_currentAimingSets;                              		// 0x0B70 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_replicatedSkeletalMeshName;                     		// 0x0B7C (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	class UMaterialInterface*                          m_replicatedMaterial;                             		// 0x0B88 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_replicatedCoverMeshXOffset;                     		// 0x0B8C (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FYS_AnimSet                                 m_replicatedAnimSet[ 0xA ];                       		// 0x0B90 (0x00C8) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FYS_AimingSet                               m_replicatedAimingSet[ 0x5 ];                     		// 0x0C58 (0x0064) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	class UClass*                                      m_replicatedShyfflerClass;                        		// 0x0CBC (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FYS_AttachmentReplicationData               m_replicatedHeadAttachment;                       		// 0x0CC0 (0x0010) [0x0000000000000020]              ( CPF_Net )
	struct FYS_AttachmentReplicationData               m_replicatedFaceAttachment;                       		// 0x0CD0 (0x0010) [0x0000000000000020]              ( CPF_Net )
	struct FYS_AttachmentReplicationData               m_replicatedBreastAttachment;                     		// 0x0CE0 (0x0010) [0x0000000000000020]              ( CPF_Net )
	float                                              m_peekSpeedModifier;                              		// 0x0CF0 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	float                                              m_aiPeekSpeedModifierMin;                         		// 0x0CF4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aiPeekSpeedModifierMax;                         		// 0x0CF8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_transitionAllowDeathAnimationStartTime;         		// 0x0CFC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_transitionAllowDeathAnimationEndTime;           		// 0x0D00 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	class UYAnimInfoSnippet*                           m_animInfoSnippet;                                		// 0x0D04 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_defaultGroundSpeed;                             		// 0x0D08 (0x0004) [0x0000000000024003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_EditConst )
	float                                              m_pawnSpeedModifier;                              		// 0x0D0C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_aiPawnSpeedModifierMin;                         		// 0x0D10 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aiPawnSpeedModifierMax;                         		// 0x0D14 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_minSpeedConstraint;                             		// 0x0D18 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FYS_DirectionalAnimRatios                   m_directionalAnimRatios[ 0x2 ];                   		// 0x0D1C (0x0020) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_walkSpeedPct;                                   		// 0x0D3C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_runSpeedPct;                                    		// 0x0D40 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_crouchWalkSpeedPct;                             		// 0x0D44 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_crouchRunSpeedPct;                              		// 0x0D48 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sprintSpeedPct;                                 		// 0x0D4C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_combatSprintSpeedPct;                           		// 0x0D50 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_coverVaultSpeedPct;                             		// 0x0D54 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aimedWalkSpeedPct;                              		// 0x0D58 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxWalkSpeedModifier;                           		// 0x0D5C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxRunSpeedModifier;                            		// 0x0D60 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxSprintSpeedModifier;                         		// 0x0D64 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxCoverSpeedModifier;                          		// 0x0D68 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_runSpeedMultiplier;                             		// 0x0D6C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_sprintSpeedMultiplier;                          		// 0x0D70 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_armorMultiplier;                                		// 0x0D74 (0x0004) [0x0000000000000000]              
	float                                              m_lastSlipOutTime;                                		// 0x0D78 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_slipOutFrontFwdDuration;                        		// 0x0D7C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_damageModifierSlipOut;                          		// 0x0D80 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_damageModifierSlipOutDuration;                  		// 0x0D84 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_damageModifierCombatSprint;                     		// 0x0D88 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_damageModifierCover;                            		// 0x0D8C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_damageModifierCoverExplosive;                   		// 0x0D90 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_damageModifierVaulting;                         		// 0x0D94 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_standCoverWalkSpeedPct;                         		// 0x0D98 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_standCoverRunSpeedPct;                          		// 0x0D9C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_crouchCoverWalkSpeedPct;                        		// 0x0DA0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_crouchCoverRunSpeedPct;                         		// 0x0DA4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_crouchCoverAimOverWalkSpeedPct;                 		// 0x0DA8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_crouchCoverAimOverRunSpeedPct;                  		// 0x0DAC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sandMovementWalkSpeedModifier;                  		// 0x0DB0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sandMovementRunSpeedModifier;                   		// 0x0DB4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sandMovementWalkSpeedModifierUphill;            		// 0x0DB8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sandMovementRunSpeedModifierUphill;             		// 0x0DBC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sandMovementWalkSpeedModifierDownhill;          		// 0x0DC0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_sandMovementRunSpeedModifierDownhill;           		// 0x0DC4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_fullSlopeAnimationZ;                            		// 0x0DC8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxRotationSpeed;                               		// 0x0DCC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxRotationSpeedAIIdle;                         		// 0x0DD0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxRotationSpeedAIMoving;                       		// 0x0DD4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FRotator                                    m_turnInPlaceRotationOffset;                      		// 0x0DD8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_rotateDespiteRootMotionCount;                   		// 0x0DE4 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_rotationToFace;                                 		// 0x0DE8 (0x000C) [0x0000000000000000]              
	float                                              m_freecamAimRotationSpeed;                        		// 0x0DF4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_idleRotationEnableCount;                        		// 0x0DF8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastIdleMovementTime;                           		// 0x0DFC (0x0004) [0x0000000000000000]              
	float                                              m_lastRunMovementTime;                            		// 0x0E00 (0x0004) [0x0000000000000000]              
	TArray< class AYSlopeVolume* >                     m_enteredSlopeVolumes;                            		// 0x0E04 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AYSlopeVolume* >                     m_leftSlopeVolumes;                               		// 0x0E10 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AActor*                                      m_actorIJustHit;                                  		// 0x0E1C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSkelControlLookAt*                         m_headSkelCtrl;                                   		// 0x0E20 (0x0004) [0x0000000000000000]              
	struct FName                                       m_headSkelCtrlName;                               		// 0x0E24 (0x0008) [0x0000000000000000]              
	float                                              m_minLookAtDistance;                              		// 0x0E2C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_minLookAtDistanceThreshold;                     		// 0x0E30 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_maxLookAtAdjust;                                		// 0x0E34 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_lookAtAdjustRatio;                              		// 0x0E3C (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_lookAtAdjustMaxPitch;                           		// 0x0E44 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_maxPawnTurnLookAt;                              		// 0x0E48 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FYS_AIViewOffsetInfo                        m_headViewOffsets;                                		// 0x0E4C (0x00C0) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_AIViewOffsetInfo                        m_breastViewOffsets;                              		// 0x0F0C (0x00C0) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ReplicatedHeadLookAtPosition            m_replicatedHeadLookAtPosition;                   		// 0x0FCC (0x0010) [0x0000000000000000]              
	struct FYS_ReplicatedHeadLookAtActor               m_replicatedHeadLookAtActor;                      		// 0x0FDC (0x0018) [0x0000000000000020]              ( CPF_Net )
	TArray< struct FYS_AnimModifierInfo >              m_animModifierInfos;                              		// 0x0FF4 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	struct FVector2D                                   m_banking;                                        		// 0x1000 (0x0008) [0x0000000000000000]              
	struct FName                                       m_bankingProfileName;                             		// 0x1008 (0x0008) [0x0000000000000002]              ( CPF_Const )
	class UYAimingSet*                                 m_bankingAimingSet;                               		// 0x1010 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FVector                                     m_angularVelocity;                                		// 0x1014 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_lastRotation;                                   		// 0x1020 (0x000C) [0x0000000000000000]              
	struct FVector2D                                   m_bankingPawnSpeedRange;                          		// 0x102C (0x0008) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector2D                                   m_bankingAngularSpeedRange;                       		// 0x1034 (0x0008) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector2D                                   m_bankingScale;                                   		// 0x103C (0x0008) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_bankingSmoothingFactor;                         		// 0x1044 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	TArray< class UClass* >                            m_specialMoveClasses;                             		// 0x1048 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< class UYSpecialMove* >                     m_specialMoves;                                   		// 0x1054 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	int                                                m_specialMoveCounter;                             		// 0x1060 (0x0004) [0x0000000000000000]              
	struct FYS_SpecialMoveDataReplicated               m_specialMoveDataReplicated;                      		// 0x1064 (0x0058) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_specialMovesOverCoverFromStandardMove;          		// 0x10BC (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_specialMovesOverCoverFromCover;                 		// 0x10C8 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_specialMovesIntoCover;                          		// 0x10D4 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_specialMovesMelee;                              		// 0x10E0 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< class AYTrigger_Interaction* >             m_interactionTriggers;                            		// 0x10EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AYTrigger_FastRopeInteraction* >     m_fastRopeTriggers;                               		// 0x10F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_ropeCollisionCheckRadius;                       		// 0x1104 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_ropeCollisionCheckHeightOffset;                 		// 0x1108 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< class AYTrigger_ZiplineInteraction* >      m_ziplineTriggers;                                		// 0x110C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AYTrigger_TurretInteraction* >       m_turretTriggers;                                 		// 0x1118 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FRotator                                    m_turretRelativeRotation;                         		// 0x1124 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_turretRelativeLocation;                         		// 0x1130 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_lastBaseRotation;                               		// 0x113C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UYSeqAct_SpecialMove*                        m_specialMoveSeqAct;                              		// 0x1148 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_coverMoveHeightRange;                           		// 0x114C (0x0008) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_maxDropDownHeight;                              		// 0x1154 (0x0004) [0x0000000000000000]              
	struct FYS_SpecialMoveDetectionParams              m_dropKickDetectionParams;                        		// 0x1158 (0x0018) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_dropKickMinFallHeightFall;                      		// 0x1170 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_dropKickMinFallHeightDrop;                      		// 0x1174 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_dropKickMinFallHeightVaultDrop;                 		// 0x1178 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_landingTimeStamp;                               		// 0x117C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_landingCamTime;                                 		// 0x1180 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class AYTrigger_TurretInteraction*                 m_turretInteraction;                              		// 0x1184 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       m_turretHandleLSocketName;                        		// 0x1188 (0x0008) [0x0000000000000000]              
	struct FName                                       m_turretHandleRSocketName;                        		// 0x1190 (0x0008) [0x0000000000000000]              
	float                                              m_combatSprintMaxTime;                            		// 0x1198 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_combatSprintStartTime;                          		// 0x119C (0x0004) [0x0000000000000000]              
	float                                              m_stopSprintBumpHitAngle;                         		// 0x11A0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_slipOutBumpIgnoreTime;                          		// 0x11A4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_TargetRotationInterpolator              m_targetRotationInterpolator;                     		// 0x11A8 (0x0028) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_TargetLocationInterpolator              m_targetLocationInterpolator;                     		// 0x11D0 (0x0028) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_OffsetLocationInterpolator              m_offsetLocationInterpolator;                     		// 0x11F8 (0x0024) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_TargetLocationInterpolator              m_targetMeshTranslationXYInterpolator;            		// 0x121C (0x0028) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_OffsetFloatInterpolator                 m_offsetMeshTranslationZInterpolator;             		// 0x1244 (0x0024) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_leanToCoverScaleCrouch;                         		// 0x1268 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverScaleStand;                          		// 0x126C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestHeightCrouch;                    		// 0x1270 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestHeightStand;                     		// 0x1274 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestSideOffsetCrouch;                		// 0x1278 (0x0004) [0x0000000000000000]              
	float                                              m_leanToCoverTestMidOffsetCrouch;                 		// 0x127C (0x0004) [0x0000000000000000]              
	float                                              m_leanToCoverTestOffsetRightCrouchMove;           		// 0x1280 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestOffsetLeftCrouchMove;            		// 0x1284 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestOffsetMidRightCrouchMove;        		// 0x1288 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestOffsetMidLeftCrouchMove;         		// 0x128C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestOffsetRightCrouchStay;           		// 0x1290 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestOffsetLeftCrouchStay;            		// 0x1294 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestSideOffsetStand;                 		// 0x1298 (0x0004) [0x0000000000000000]              
	float                                              m_leanToCoverTestMidOffsetStand;                  		// 0x129C (0x0004) [0x0000000000000000]              
	float                                              m_leanToCoverTestOffsetRightStandMove;            		// 0x12A0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestOffsetLeftStandMove;             		// 0x12A4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestOffsetMidRightStandMove;         		// 0x12A8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestOffsetMidLeftStandMove;          		// 0x12AC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestOffsetRightStandStay;            		// 0x12B0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leanToCoverTestOffsetLeftStandStay;             		// 0x12B4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_currentMeshPitch;                               		// 0x12B8 (0x0004) [0x0000000000000000]              
	float                                              m_meshPitchVel;                                   		// 0x12BC (0x0004) [0x0000000000000000]              
	float                                              m_meshPitchSmoothingIn;                           		// 0x12C0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_meshPitchSmoothingOut;                          		// 0x12C4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_ReplicatedIdleAnimation                 m_currentIdleAnimation;                           		// 0x12C8 (0x0018) [0x0000000000000020]              ( CPF_Net )
	struct FYS_IdleSpecialActionInfo                   m_overrideIdleSpecialActionInfo;                  		// 0x12E0 (0x000C) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	class UYSpecialActionsDefinition*                  m_recentIdleSpecialActionDefinition;              		// 0x12EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_SpecialActionDebugInfo                  m_specialActionDebugInfo;                         		// 0x12F0 (0x00A8) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UYShyfflr*                                   m_voiceShyfflr;                                   		// 0x1398 (0x0004) [0x0000000000000000]              
	float                                              m_fallingStartHeight;                             		// 0x139C (0x0004) [0x0000000000000000]              
	float                                              m_superSoftLandingFallingHeight;                  		// 0x13A0 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_softLandingFallingHeight;                       		// 0x13A4 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_hardLandingFallingHeight;                       		// 0x13A8 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_fatalFallingHeight;                             		// 0x13AC (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_superSoftLandingMeshTranslationOffset;          		// 0x13B0 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_superSoftLandingPushDownDuration;               		// 0x13B4 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_superSoftLandingPushUpDuration;                 		// 0x13B8 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_fallingGravityModifier;                         		// 0x13BC (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_crushingEnemyPawnDamage;                        		// 0x13C0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_crushingFriendlyPawnDamage;                     		// 0x13C4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_crouchLockCount;                                		// 0x13C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_relativeCollisionCylinderSize;                  		// 0x13CC (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class UCylinderComponent*                          m_secondCylinder;                                 		// 0x13D4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_moveOverCoverMaxDistance;                       		// 0x13D8 (0x0004) [0x0000000000000000]              
	float                                              m_moveOverCoverTargetTolerance;                   		// 0x13DC (0x0004) [0x0000000000000000]              
	float                                              m_moveOverCoverMaxFov;                            		// 0x13E0 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_moveOverCoverMaxHeightDifference;               		// 0x13E4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_moveIntoCoverMaxDistance;                       		// 0x13E8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_moveIntoCoverMaxFov;                            		// 0x13EC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxIntoCoverMovementOrientation;                		// 0x13F0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_moveIntoCoverMaxHeightDifference;               		// 0x13F4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_sprintMinTimeForDashing;                        		// 0x13F8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_minHeadCoverInterval;                           		// 0x13FC (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_headCoverAnimLength;                            		// 0x1404 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector                                     m_aimAtPosition;                                  		// 0x140C (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_aimAtPosIpol;                                   		// 0x1418 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_aimAtPosIpolV;                                  		// 0x1424 (0x000C) [0x0000000000000000]              
	class AActor*                                      m_aimAtActor;                                     		// 0x1430 (0x0004) [0x0000000000000000]              
	struct FName                                       m_conditionalTakeDownWeaponCallbackName;          		// 0x1434 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_onTossWeaponCallbackName;                       		// 0x143C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_disableJointDrivesCallbackName;                 		// 0x1444 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_timedUnblockEffortStatusBySpeaklineCallbackName;		// 0x144C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FVector2D                                   m_relativeCoverRotation;                          		// 0x1454 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_backAimingAngle;                                		// 0x145C (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_backAimingThreshold;                            		// 0x1464 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_aimoutBlockedCheckExtentScale_thisTouchingOther;		// 0x1468 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_aimoutBlockedCheckExtentScale_otherWillBlockThis;		// 0x146C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_aimoutBlockedCheckExtentScale_otherBlocksWayBack;		// 0x1470 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_aimoutBlockedCheckOffset_aimOut;                		// 0x1474 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_aimoutBlockedCheckOffset_aimAround;             		// 0x1480 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverEdgeToleranceDistance;                     		// 0x148C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_facingCoverThreshold;                           		// 0x1490 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverPushOutDistance;                           		// 0x1494 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_coverStateLockCount;                            		// 0x1498 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_unforcedValidCoverLocationCount;                		// 0x149C (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_aimOffsetPct;                                   		// 0x14A0 (0x0008) [0x0000000000000000]              
	struct FRotator                                    m_aimTargetRotation;                              		// 0x14A8 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FRotator                                    m_aimTargetRotIpol;                               		// 0x14B4 (0x000C) [0x0000000000000000]              
	float                                              m_aimInterpSpeed;                                 		// 0x14C0 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_aimInterpSpeedTurret;                           		// 0x14C4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FVector                                     m_raiseWeaponTestOffsetStand;                     		// 0x14C8 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_raiseWeaponTestOffsetCrouched;                  		// 0x14D4 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_raiseWeaponTestLengthThreshold;                 		// 0x14E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_raiseWeaponTestHeightModifier;                  		// 0x14E4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_zSmoothingDisableCount;                         		// 0x14E8 (0x0004) [0x0000000000000000]              
	int                                                m_footControlsDisableCount;                       		// 0x14EC (0x0004) [0x0000000000000000]              
	float                                              m_FPFullMaxDist;                                  		// 0x14F0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_FPVelDependentMaxDist;                          		// 0x14F4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_FPSimpleMaxDist;                                		// 0x14F8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_FPSuperSimpleMaxDist;                           		// 0x14FC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_skelControlLowUpdateRate;                       		// 0x1500 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_leftSkelControlDefaultUpdateRate;               		// 0x1504 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_rightSkelControlDefaultUpdateRate;              		// 0x1508 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_skelControlLowUpdateRateTimer;                  		// 0x150C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSkelControlFootPlacement*                  m_leftFootControl;                                		// 0x1510 (0x0004) [0x0000000000000000]              
	class UYSkelControlFootPlacement*                  m_rightFootControl;                               		// 0x1514 (0x0004) [0x0000000000000000]              
	struct FName                                       m_leftFootControlName;                            		// 0x1518 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_rightFootControlName;                           		// 0x1520 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_leftFootBoneName;                               		// 0x1528 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_rightFootBoneName;                              		// 0x1530 (0x0008) [0x0000000000000002]              ( CPF_Const )
	float                                              m_oldLocationZ;                                   		// 0x1538 (0x0004) [0x0000000000000000]              
	float                                              m_currentLocationZ;                               		// 0x153C (0x0004) [0x0000000000000000]              
	float                                              m_zVelocity;                                      		// 0x1540 (0x0004) [0x0000000000000000]              
	float                                              m_lastBaseHeight;                                 		// 0x1544 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_lastFrameBase;                                  		// 0x1548 (0x0004) [0x0000000000000000]              
	float                                              m_lastTracedFloorDiff;                            		// 0x154C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_maxCrouchFeetDownAdjustment;                    		// 0x1550 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxCrouchFeetDownAdjustmentMoving;              		// 0x1554 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minValidMeshHeightZ;                            		// 0x1558 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_crouchMinZOffset;                               		// 0x155C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_zSmoothingFactorStand;                          		// 0x1560 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_zSmoothingFactorCrouch;                         		// 0x1564 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_smoothingFactorVelocityDependence;              		// 0x1568 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_downwardsSmoothingFactorSpeed;                  		// 0x156C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_downwardsSmoothingFactorModifier;               		// 0x1570 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_meshTranslationOffset;                          		// 0x1574 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USkelControlLimb*                            m_leftLimbControl;                                		// 0x1578 (0x0004) [0x0000000000000000]              
	class USkelControlLimb*                            m_rightLimbControl;                               		// 0x157C (0x0004) [0x0000000000000000]              
	struct FName                                       m_leftLimbControlName;                            		// 0x1580 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_rightLimbControlName;                           		// 0x1588 (0x0008) [0x0000000000000002]              ( CPF_Const )
	class AYArsenalManager*                            m_arsenalManager;                                 		// 0x1590 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYWeapon*                                    m_currentWeapon;                                  		// 0x1594 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_currentGrenadeClass;                            		// 0x1598 (0x0004) [0x0000000000000000]              
	TArray< struct FYS_WeaponClass >                   m_presetWeaponClasses;                            		// 0x159C (0x000C) [0x0000000000404003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_NeedCtorLink )
	float                                              m_muzzleToShootPositionOffset;                    		// 0x15A8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_shootingThoughWallTraceDistance;                		// 0x15AC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lowerWeaponTraceDistance;                       		// 0x15B0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_reenableAimoutAfterFinishWeaponFunctionCount;   		// 0x15B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_AnimID                                  m_currentReloadAnim;                              		// 0x15B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_AnimID                                  m_currentEquipScndModeAnim;                       		// 0x15BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_currentSandStormForce;                          		// 0x15C0 (0x0004) [0x0000000000000000]              
	class UAnimSet*                                    m_sandStormAnimSet;                               		// 0x15C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_weaponTakeDownDelay;                            		// 0x15C8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_toAimingBlendTime;                              		// 0x15CC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_toAimingBlendTimeAI;                            		// 0x15D0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_toAimingShootBlendTime;                         		// 0x15D4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_toAimingShootBlendTimeAI;                       		// 0x15D8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_fromAimingBlendTime;                            		// 0x15DC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_takeUpWeaponStartTime;                          		// 0x15E0 (0x0004) [0x0000000000000000]              
	float                                              m_takeUpWeaponBlendTime;                          		// 0x15E4 (0x0004) [0x0000000000000000]              
	struct FYS_AnimID                                  m_currentlyRunningGrenadeAnimIdleID;              		// 0x15E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             m_grenadeThrowEndedCallback;                      		// 0x15EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_HitTargetSocketInfo >           m_hitTargetSockets;                               		// 0x15F8 (0x000C) [0x0000000000404003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_NeedCtorLink )
	TArray< struct FYS_MaterialDamageInfo >            m_materialDmgInfo;                                		// 0x1604 (0x000C) [0x0000000000404003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_NeedCtorLink )
	float                                              m_shootThruFleshDamageReduction;                  		// 0x1610 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_lastHideLaserPointerTimeStamp;                  		// 0x1614 (0x0004) [0x0000000000000000]              
	struct FYS_AnimID                                  m_currentRefireAnim;                              		// 0x1618 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastTimePlayerKilledAPawn;                      		// 0x161C (0x0004) [0x0000000000000000]              
	float                                              m_timeOfLastShot;                                 		// 0x1620 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_CoverData                               m_coverData;                                      		// 0x1624 (0x0084) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_CoverReplicationData                    m_coverReplicated;                                		// 0x16A8 (0x0010) [0x0000000000000020]              ( CPF_Net )
	int                                                m_coverRotationYaw;                               		// 0x16B8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_maxAcquireCoverByLocationDistance;              		// 0x16BC (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_maxAlignToCoverDistance;                        		// 0x16C0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_coverOffset;                                    		// 0x16C4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_minCrouchCoverHeight;                           		// 0x16C8 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_alwaysShootInCoverAngle;                        		// 0x16CC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_coverLeftRightChangeThreshold;                  		// 0x16D0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_coverLeaveAimDownThreshold;                     		// 0x16D4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_coverLeftRightChangeThresholdAimOver;           		// 0x16D8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_coverLeftRightChangeThresholdAimDown;           		// 0x16DC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_coverLeftRightChangeOffsetAimDown;              		// 0x16E0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_coverLeftRightChangeThresholdBackAiming;        		// 0x16E4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_coverLeftRightChangeThresholdEdge;              		// 0x16E8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector                                     m_aimAroundAngleRange;                            		// 0x16EC (0x000C) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aimAroundThreshold;                             		// 0x16F8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aimAroundSlipoutMaxAngle;                       		// 0x16FC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aimDownMinAngle;                                		// 0x1700 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aimDownMinAngleAI;                              		// 0x1704 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aimDownThreshold;                               		// 0x1708 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aimDownEnterModifier;                           		// 0x170C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aimDownChangeBackThreshold;                     		// 0x1710 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aimDownChangeMaxAngleH;                         		// 0x1714 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_forceFacingCoverAngleRange;                     		// 0x1718 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_aimOverCoverAnglesCamLeft;                      		// 0x1720 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_blindFireOverCoverAnglesCamLeft;                		// 0x1728 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_aimOverCoverAnglesCamRight;                     		// 0x1730 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_blindFireOverCoverAnglesCamRight;               		// 0x1738 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_aimOverCoverAnglesModifierInLeanOver;           		// 0x1740 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_aimOverCoverAngleThreshold;                     		// 0x1748 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_blindfireOverCoverAngleThreshold;               		// 0x174C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_fireOutOfCoverAngleRange;                       		// 0x1750 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_blindFireOutOfCoverAngleRange;                  		// 0x1758 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_improvedAimoutAngle;                            		// 0x1760 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_improvedBlindfireAngle;                         		// 0x1764 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_improvedAimoutAfterReloadAngle;                 		// 0x1768 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_improvedAimoutAfterReloadAimedAngle;            		// 0x176C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_fireOutOfCoverAngleThreshold;                   		// 0x1770 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_blindFireOutOfCoverAngleThreshold;              		// 0x1774 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_leavePopupToSidesAngles;                        		// 0x1778 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_leavePopupToSidesAnglesSingleSlot;              		// 0x1780 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_extendedAimOverOnBlockedSideAngles;             		// 0x1788 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_extendedAimOverOnBlockedSideThreshold;          		// 0x1790 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_minBlindfireEdgeAngle;                          		// 0x1794 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_improvedAimoutAngleModifier;                    		// 0x1798 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_improvedBlindFireAngleModifier;                 		// 0x179C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxCloseToEdgeDistance;                         		// 0x17A0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FYS_FireFlags                               m_mayPeekOrAimOut;                                		// 0x17A4 (0x0004) [0x0000000000000000]              
	struct FYS_FireFlags                               m_peek;                                           		// 0x17A8 (0x0004) [0x0000000000000000]              
	struct FYS_FireFlags                               m_wantsToPeek;                                    		// 0x17AC (0x0004) [0x0000000000000000]              
	struct FYS_FireFlags                               m_aimOut;                                         		// 0x17B0 (0x0004) [0x0000000000000000]              
	struct FYS_FireFlags                               m_wantsToAimOut;                                  		// 0x17B4 (0x0004) [0x0000000000000000]              
	struct FYS_FireFlags                               m_wantsToAimOutWhenPeeking;                       		// 0x17B8 (0x0004) [0x0000000000000000]              
	struct FYS_FireFlags                               m_mayBlindfire;                                   		// 0x17BC (0x0004) [0x0000000000000000]              
	struct FYS_FireFlags                               m_blindfire;                                      		// 0x17C0 (0x0004) [0x0000000000000000]              
	struct FYS_FireFlags                               m_wantsToBlindfire;                               		// 0x17C4 (0x0004) [0x0000000000000000]              
	float                                              m_lastWeaponStickingThroughDestructibleActorCheckTime;		// 0x17C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_weaponStickingThroughDestructibleActorCheckInterval;		// 0x17CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_savedLocation;                                  		// 0x17D0 (0x000C) [0x0000000000000002]              ( CPF_Const )
	struct FRotator                                    m_savedRotation;                                  		// 0x17DC (0x000C) [0x0000000000000002]              ( CPF_Const )
	struct FYS_ShootableTags                           m_shootableTags;                                  		// 0x17E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FYS_SpecialBoneInfo >               m_specialBones;                                   		// 0x17EC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FVector                                     m_fireStartLoc;                                   		// 0x17F8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UDynamicLightEnvironmentComponent*           m_lightEnvironment;                               		// 0x1804 (0x0004) [0x000000000408000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_faceFXAudioComponent;                           		// 0x1808 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FYS_FaceFXRegisterInfo                      m_faceFXRegisterInfos[ 0x8 ];                     		// 0x180C (0x0120) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_FaceFXRegisterInfo                      m_currentFaceFXRegisterInfos[ 0x8 ];              		// 0x192C (0x0120) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_FaceFXRegisterUsage                     m_faceFXRegisterUsage[ 0x8 ];                     		// 0x1A4C (0x00C0) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_faceFXRegisterUsageExtraTime;                   		// 0x1B0C (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_updateFaceFXRegisterUsageCallbackName;          		// 0x1B10 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FString                                     m_playingFaceFXAnim;                              		// 0x1B18 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_RecoverValue                            m_health;                                         		// 0x1B24 (0x0028) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_lastReplicatedHealth;                           		// 0x1B4C (0x0004) [0x0000000000000000]              
	float                                              m_defaultHealth;                                  		// 0x1B50 (0x0004) [0x0000000000024001]              ( CPF_Edit | CPF_Config | CPF_EditConst )
	float                                              m_permanentDamagePct;                             		// 0x1B54 (0x0004) [0x0000000000024001]              ( CPF_Edit | CPF_Config | CPF_EditConst )
	float                                              m_tempMaxHealth;                                  		// 0x1B58 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_healthRecoverDuration;                          		// 0x1B5C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_healthRecoverDelay;                             		// 0x1B60 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxHealthRecoveryMultiplier;                    		// 0x1B64 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class AKActorSpawnable*                            m_currentlyUsedHealingSyringe;                    		// 0x1B68 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_healingSyringeSocketName;                       		// 0x1B6C (0x0008) [0x0000000000000000]              
	struct FName                                       m_healingSyringeSocketNameLeft;                   		// 0x1B74 (0x0008) [0x0000000000000000]              
	struct FName                                       m_delayedBeginDyingStateCallbackName;             		// 0x1B7C (0x0008) [0x0000000000000000]              
	float                                              m_IDADuration;                                    		// 0x1B84 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_IDATriggerHealth;                               		// 0x1B88 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_IDAReactivateHealth;                            		// 0x1B8C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_GroundBloodDecalData                    m_groundBloodDecals[ 0x3 ];                       		// 0x1B90 (0x0018) [0x0000000000000000]              
	float                                              m_groundBloodDecalSize;                           		// 0x1BA8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_groundBloodDecalLifetime;                       		// 0x1BAC (0x0004) [0x0000000000000000]              
	float                                              m_groundBloodDecalThickness;                      		// 0x1BB0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_GroundBloodDecalData                    m_wallBloodDecals[ 0x3 ];                         		// 0x1BB4 (0x0018) [0x0000000000000000]              
	float                                              m_wallBloodDecalSize;                             		// 0x1BCC (0x0004) [0x0000000000000000]              
	float                                              m_wallBloodDecalLifetime;                         		// 0x1BD0 (0x0004) [0x0000000000000000]              
	float                                              m_maxMultiplayerLifeSpan;                         		// 0x1BD4 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	TArray< class AYVisibilityVolume* >                m_touchedVisVolumes;                              		// 0x1BD8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_PawnEffortChangeTimeDefinition          m_effortChangeTimes;                              		// 0x1BE4 (0x0018) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_effortChangeSoundFadeoutTime;                   		// 0x1BFC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_effortChangeStartTime;                          		// 0x1C00 (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             m_effortAudioComponent;                           		// 0x1C04 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FVector2D                                   m_nonViewTargetCamInvisibilityCylinderStand;      		// 0x1C08 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_viewTargetCamInvisibilityCylinderStand;         		// 0x1C10 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_nonViewTargetCamInvisibilityCylinderCrouch;     		// 0x1C18 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_viewTargetCamInvisibilityCylinderCrouch;        		// 0x1C20 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_camInvisibilityModWhenHidden;                   		// 0x1C28 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_pawnAlias;                                      		// 0x1C30 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FCylinder                                   m_frictionCylinderFactor;                         		// 0x1C38 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_takeHitDBNODuration;                            		// 0x1C40 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class AYGamePawn*                                  m_currentMeleeTarget;                             		// 0x1C44 (0x0004) [0x0000000000000000]              
	int                                                m_meleeDamagePawns;                               		// 0x1C48 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_meleeDamageDestructibles;                       		// 0x1C4C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_meleeDamageMaxDist;                             		// 0x1C50 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	class UClass*                                      m_meleeDamageClass;                               		// 0x1C54 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_kickDamageClass;                                		// 0x1C58 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_MeleeHitFXReplicationData               m_genericHitReplicationInfo;                      		// 0x1C5C (0x0010) [0x0000000000000020]              ( CPF_Net )
	struct FYS_PawnMeleeHitFXReplicationData           m_pawnHitReplicationInfo;                         		// 0x1C6C (0x0014) [0x0000000000000020]              ( CPF_Net )
	float                                              m_receivedMeleeDamageMultiplier;                  		// 0x1C80 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_SpecialMoveDetectionParams              m_meleeDetectionParams;                           		// 0x1C84 (0x0018) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverMeleeRangeModifier;                        		// 0x1C9C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_worldMeleeRangeModifier;                        		// 0x1CA0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_vaultKickPreCheckTestLength;                    		// 0x1CA4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_vaultKickPreCheckTestWidth;                     		// 0x1CA8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class AYGamePawn*                                  m_currentHumanShield;                             		// 0x1CAC (0x0004) [0x0000000000000000]              
	class AYGamePawn*                                  m_currentHumanShieldCaptor;                       		// 0x1CB0 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_humanShieldHoldingOffset;                       		// 0x1CB4 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_humanShieldCurrentOffsetVel;                    		// 0x1CC0 (0x000C) [0x0000000000000000]              
	float                                              m_humanShieldOffsetInterpolationSmoothing;        		// 0x1CCC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FRotator                                    m_humanShieldRotationOffset;                      		// 0x1CD0 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_humanShieldRotationOffsetInterpolationSpeed;    		// 0x1CDC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_humanShieldSpeedModifierForward;                		// 0x1CE0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_humanShieldSpeedModifierSideways;               		// 0x1CE4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_humanShieldSpeedModifierBackwards;              		// 0x1CE8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UYSpecialActionSetList*                      m_specialActionSetList;                           		// 0x1CEC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSpecialActionSetList*                      m_additionalSpecialActionSetList;                 		// 0x1CF0 (0x0004) [0x0000000000000000]              
	TArray< class UYSpecialActionEventFilterSet* >     m_specialActionFilterSets;                        		// 0x1CF4 (0x000C) [0x0000000000402001]              ( CPF_Edit | CPF_Transient | CPF_NeedCtorLink )
	class UYSpecialActionInstance*                     m_runningSpecialActionInstance;                   		// 0x1D00 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_SpecialActionSetTypeRep                 m_specialActionSetTypeRep;                        		// 0x1D04 (0x0008) [0x0000000000000020]              ( CPF_Net )
	class UYSpecialActionInstance*                     m_baseSpecialActionInstance;                      		// 0x1D0C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSAI_SimpleAction*                          m_simpleSpecialActionInstance;                    		// 0x1D10 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSAI_SimpleRef*                             m_simpleRefSpecialActionInstance;                 		// 0x1D14 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_voiceLocationBone;                              		// 0x1D18 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UAudioComponent*                             m_specialActionAudioComponent;                    		// 0x1D20 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	struct FName                                       m_nonVoiceSpecialActionSoundBone;                 		// 0x1D24 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UYSpecialActionUseRestrictionOD* >   m_specialActionUseRestrictions;                   		// 0x1D2C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FScriptDelegate                             m_specialActionFinishedCallback;                  		// 0x1D38 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_radiusForNearbyPawns;                           		// 0x1D44 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FYS_SpecialMoveDetectionParams              m_executionDetectionParams;                       		// 0x1D48 (0x0018) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_damageModifierExecuting;                        		// 0x1D60 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_debugExecutionVariation;                        		// 0x1D64 (0x0004) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )
	float                                              m_chanceToGrantGrenadeToExecutor;                 		// 0x1D68 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_executionRotationOffset;                        		// 0x1D6C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_AnimSet                                 m_executionAnimSets[ 0x3 ];                       		// 0x1D70 (0x003C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FYS_SpecialMoveDetectionParams              m_reviveDetectionParams;                          		// 0x1DAC (0x0018) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_damageModifierReviving;                         		// 0x1DC4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	class UClass*                                      m_tacIconClass[ 0x7 ];                            		// 0x1DC8 (0x001C) [0x0000000000000000]              
	class UYMarkerBase*                                m_tacIcon[ 0x7 ];                                 		// 0x1DE4 (0x001C) [0x0000000000000000]              
	class UMaterialInterface*                          m_scanSilhouetteMaterials[ 0x5 ];                 		// 0x1E00 (0x0014) [0x0000000000000000]              
	class UParticleSystem*                             m_scanRadiusFx;                                   		// 0x1E14 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_currentSilhouetteMaterial;                      		// 0x1E18 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_scanDeviceSound;                                		// 0x1E1C (0x0004) [0x0000000000000000]              
	float                                              m_squadSilhouetteDurationAfterCombat;             		// 0x1E20 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_squadSilhouetteDurationAfterCommand;            		// 0x1E24 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_squadSilhouetteDurationAfterFeedback;           		// 0x1E28 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_attackCommandSilhouetteFadeTime;                		// 0x1E2C (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_SpeakLineData                           m_speakLineData;                                  		// 0x1E30 (0x0028) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_SpeakLineData                           m_replicatedSpeakLineData;                        		// 0x1E58 (0x0028) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FScriptDelegate                             m_speakLineEndCallback;                           		// 0x1E80 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UAudioComponent*                             m_currentlySpeakingLine;                          		// 0x1E8C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_speechFadeDuration;                             		// 0x1E90 (0x0004) [0x0000000000000000]              
	float                                              m_scriptedLineSubtitlePriorityBoost;              		// 0x1E94 (0x0004) [0x0000000000000000]              
	float                                              m_noSoundSubtitleDuration;                        		// 0x1E98 (0x0004) [0x0000000000000000]              
	class AController*                                 m_controllerWhoPutMeIntoDBNOOrKilledMe;           		// 0x1E9C (0x0004) [0x0000000000000000]              
	struct FYS_LastDamageInfo                          m_lastDamageinfo;                                 		// 0x1EA0 (0x0048) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	float                                              m_sneakFootstepNoiseDistance;                     		// 0x1EE8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_walkFootstepNoiseDistance;                      		// 0x1EEC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sprintFootstepNoiseDistance;                    		// 0x1EF0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_infiltrateFootstepNoiseModifer;                 		// 0x1EF4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FYS_DelayedSpecialActionData >      m_delayedSpecialActionCalls;                      		// 0x1EF8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             m_scanReportCallback;                             		// 0x1F04 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_ShotGunProjectileHitInfo >      m_shotgunHitInfos;                                		// 0x1F10 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             m_execCommandDelegate;                            		// 0x1F1C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_squadName;                                      		// 0x1F28 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FColor                                      m_teamColor;                                      		// 0x1F34 (0x0004) [0x0000000000000000]              
	struct FColor                                      m_shadowColor;                                    		// 0x1F38 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_squadNameScreenPos;                             		// 0x1F3C (0x000C) [0x0000000000000000]              
	float                                              m_squadNameCurrentFade;                           		// 0x1F48 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_squadNameFadeTarget;                            		// 0x1F4C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_deltaTime;                                      		// 0x1F50 (0x0004) [0x0000000000000000]              
	float                                              m_squadNameFadeInTime;                            		// 0x1F54 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_squadNameFadeOutTime;                           		// 0x1F58 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_squadFontScale;                                 		// 0x1F5C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_squadNameShadowOffsetX;                         		// 0x1F60 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_squadNameShadowOffsetY;                         		// 0x1F64 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UClass*                                      m_burnDamageType;                                 		// 0x1F68 (0x0004) [0x0000000000000000]              
	TArray< class UParticleSystemComponent* >          m_mortarBurnFx;                                   		// 0x1F6C (0x000C) [0x0000000004480008]              ( CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	class UYSoundCueFMOD*                              m_burningBodySound;                               		// 0x1F78 (0x0004) [0x0000000000000000]              
	class UTexture*                                    m_mortarTex;                                      		// 0x1F7C (0x0004) [0x0000000000000000]              
	TArray< class UParticleSystemComponent* >          m_flamethrowerBurnFx;                             		// 0x1F80 (0x000C) [0x0000000004480008]              ( CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	class UYSoundCueFMOD*                              m_burningFlamethrowerBodySound;                   		// 0x1F8C (0x0004) [0x0000000000000000]              
	float                                              m_damagePerBurnInterval;                          		// 0x1F90 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_grenadeEquipAnimSpeed;                          		// 0x1F94 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_weaponSwitchAnimSpeed;                          		// 0x1F98 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_dropDownAnimSpeed;                              		// 0x1F9C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_swatTurnAnimSpeed;                              		// 0x1FA0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_vaporizeModifier;                               		// 0x1FA4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_headExplodeModifier;                            		// 0x1FA8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delayedInitializationTimer;                     		// 0x1FAC (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_delayedInitializationTimerStartFrame;           		// 0x1FB0 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_attractionDrawScale3D;                          		// 0x1FB4 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_attractorStrength;                              		// 0x1FC0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_attractorVelocityInfluence;                     		// 0x1FC4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_attractorCollisionDamping;                      		// 0x1FC8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_upperAttractorRelativeOffset;                   		// 0x1FCC (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_lowerAttractorRelativeOffset;                   		// 0x1FD8 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_stickyGrenadesStuckToPawn;                      		// 0x1FE4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_animNotifyInterpolateLocation;                  		// 0x1FE8 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_animNotifyInterpolateRotation;                  		// 0x1FF4 (0x000C) [0x0000000000000000]              
	int                                                m_rootMotionOverrideCount;                        		// 0x2000 (0x0004) [0x0000000000000000]              
	int                                                m_rootMotionRotationOverrideCount;                		// 0x2004 (0x0004) [0x0000000000000000]              
	float                                              m_overrideNetUpdateFrequency;                     		// 0x2008 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< class AYFracturedSMActorMovable* >         m_fracturedAttachments;                           		// 0x200C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class AKActorSpawnable* >                  m_detachableAttachments;                          		// 0x2018 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class AKActorSpawnable* >                  m_otherAttachments;                               		// 0x2024 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_detachProbability;                              		// 0x2030 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maxDetachVelocity;                              		// 0x2034 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UYDrawPatchSplineComponent*                  m_grenadeArcComp;                                 		// 0x2038 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class AYEmitter*                                   m_grenadeArcEndEmitter;                           		// 0x203C (0x0004) [0x0000000000000000]              
	float                                              m_stumbleBlindfireAngle;                          		// 0x2040 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_stumbleBlindfireChance;                         		// 0x2044 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_damageModifierSwatTurning;                      		// 0x2048 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_lastActivityTime;                               		// 0x204C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastMovingActivityTime;                         		// 0x2050 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_minInactivityTimeForSpecialIdle;                		// 0x2054 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_minInactivityTimeForSpecialIdleReactive;        		// 0x2058 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_minInactivityTimeForSpecialIdleRange;           		// 0x205C (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_minInactivityTimeForSpecialIdleReactiveRange;   		// 0x2064 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_reactiveSpecialIdleTimeOut;                     		// 0x206C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_ContextualSlomoTriggerData              m_currentContextualSlomoDataSet;                  		// 0x2070 (0x001C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_vaporizeMomentum;                               		// 0x208C (0x000C) [0x0000000000000000]              
	float                                              m_vaporizedPawnHatMomentumScale;                  		// 0x2098 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_vaporizedHeadHatMomentumScale;                  		// 0x209C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_vaporizeDecalDestDir[ 0x6 ];                    		// 0x20A0 (0x0048) [0x0000000000000000]              
	class UMaterialInterface*                          m_vaporizeDecal;                                  		// 0x20E8 (0x0004) [0x0000000000000000]              
	TArray< struct FDecalJobInfo >                     m_pendingVaporizeDecalJob;                        		// 0x20EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_AmmoDropMultiplier;                             		// 0x20F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYBoneData*                                  m_boneData;                                       		// 0x20FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FString >                           m_faceFXRegisterNames;                            		// 0x2100 (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )
	float                                              m_faceFXFeedbackDuration;                         		// 0x210C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_faceFXMaxHealthModifier;                        		// 0x2110 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lastTimePawnDidTurretQuickLeave;                		// 0x2114 (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __StopSpecialMoveCallback__Delegate;              		// 0x2118 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnSpeakLineFinished__Delegate;                  		// 0x2124 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnSpecialActionFinished__Delegate;              		// 0x2130 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __ExecCommandDelegate__Delegate;                  		// 0x213C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __GrenadeThrowEnded__Delegate;                    		// 0x2148 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnRopeGrabbed__Delegate;                        		// 0x2154 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnRopeGrabbedFeet__Delegate;                    		// 0x2160 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnRopeReleased__Delegate;                       		// 0x216C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnRopeReleasedFeet__Delegate;                   		// 0x2178 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnFastRopeGroundReached__Delegate;              		// 0x2184 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnFastRopeStartSound__Delegate;                 		// 0x2190 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnFastRopeEndSound__Delegate;                   		// 0x219C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnFastRopeEnableCollision__Delegate;            		// 0x21A8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1636 ];

		return pClassPointer;
	};

	void OnHideLoadingMovie ( class UYSeqAct_HideLoadingMovie* act );
	void SetCurrentlyRunningGrenadeAnim ( unsigned char newGrenadeAnim );
	void OnC4Defused ( );
	bool IsInDemiGod ( );
	void ToggleDemiGod ( );
	void SetDemiGod ( unsigned long demiGod );
	void DumpGameData ( struct FYS_GameDumpNode* Node );
	void ReturnAllAttachmentsToPool ( unsigned long removeMeshes );
	void DetachDetachableAttachment ( int Index, struct FVector Momentum );
	void UpdateHitAttachments ( class AController* attacker, struct FVector HitLocation, int Damage, struct FVector Momentum );
	void OnEndSpecialIdleAnim ( );
	void GetSpecialAnimEndCallback ( struct FScriptDelegate* callback );
	void SetSquadEvolutionFromEvoStateObject ( class UClass* evoStateInfo );
	bool FindAndSetCharacterMesh ( struct FString meshName );
	void OnSetSquadEvolution ( class UYSeqAct_SetSquadEvolution* seqAct );
	void OnSetPawnSpeeds ( class UYSeqAct_SetPawnSpeeds* seqAct );
	void OnAnimNotifyInterpolate ( class UYAnimNotify_Interpolate* interpolator, class UAnimNodeSequence* AnimNodeSequence );
	void OnAnimNotifyInterpolateRotationFinished ( unsigned long finished );
	void OnAnimNotifyInterpolateLocationFinished ( unsigned long finished );
	void GenericAnimationFinished ( );
	void PostSpawnPreAttachComponents ( );
	unsigned char ScriptGetTeamNum ( );
	unsigned char GetStanding ( class AYGamePawn* pwn );
	class AYTeamInfo* GetYTeam ( );
	float GetMaxAmmoPickupMultiplier ( );
	float GetMaxAmmoMultiplier ( );
	void PlayScanEffect ( float Time );
	bool ShouldPlayScanEffect ( );
	bool HasHeavyWeaponAmmoLimitation ( );
	void OnJustRespawned ( class AYPlayerController* PC );
	float GetLandingAnimSpeedMultiplier ( );
	float GetSprintAnimSpeedMultiplier ( );
	float GetRappelSpeedModifier ( );
	float GetCoverSpeedMultiplier ( );
	void OnToggleAIGrenadeReaction ( class UYSeqAct_ToggleAIGrenadeReaction* inAction );
	void OnToggleGenericGrenadeUsage ( class UYSeqAct_ToggleGenericGrenadeUsage* inAction );
	void OnToggleSuppressGenericVoiceOver ( class UYSeqAct_ToggleSuppressGenericVoiceOver* inAction );
	void ToggleSuppressGenericVoiceOver ( );
	void OnToggleSandStormAnimations ( class UYSeqAct_ToggleSandStormAnimation* act );
	void OnToggleWeaponJamming ( class UYSeqAct_ToggleAI_WeaponJamming* act );
	void OnToggleDemigod ( class UYSeqAct_ToggleDemigod* act );
	void OnToggleDeathDBNO ( class UYSeqAct_ToggleDeathDBNO* act );
	void OnToggleDBNO ( class UYSeqAct_ToggleDBNO* act );
	void OnSetNPCCategory ( class UYSeqAct_SetNPCCategory* act );
	void OnAddWeaponToArsenal ( class AYWeapon* NewWeapon );
	void OnRemoveWeaponFromArsenal ( class AYWeapon* NewWeapon );
	float GetExplosiveDamageReductionFactor ( );
	float GetDamageReductionFactor ( );
	float GetNonExplosiveDamageReductionFactor ( );
	float GetRefireRateFactor ( );
	float GetWeaponSwitchAnimSpeed ( );
	float GetWeaponRaiseAnimSpeed ( );
	float GetRecoilModifier ( );
	float GetAccuracyModifier ( );
	void StopBurning ( );
	void TakeBurningDamage ( );
	void Burn ( class UClass* DamageType );
	void HideNondetachableHeadAttachments ( );
	void DetachDetachableHeadAttachments ( struct FVector Momentum );
	void VaporizeHead ( struct FVector Momentum, class UClass* dmgType );
	class UYBoneData* GetBoneData ( );
	void TossHealingSyringe ( );
	void SpawnHealingSyringe ( unsigned long useLefthand );
	void SpawnBodyPartInternal ( class AYObjectPool* objectPool, class UStaticMesh* StaticMesh, struct FVector Momentum );
	void SpawnBodyParts ( struct FVector Momentum );
	void UpdateVaporizeDecals ( );
	void SpawnVaporizeDecal ( struct FVector testStart, struct FVector testDir );
	bool CheckLineData ( struct FVector testStart, struct FVector testDir, struct FVector* HitLocation, struct FVector* HitNormal, class UPrimitiveComponent** HitComponent, unsigned char* onSand );
	void HideMesh ( );
	void Vaporize ( struct FVector Momentum, class UClass* dmgType );
	void ChangeAIType ( unsigned char newType, unsigned long Leader );
	void ClearAsyncCollisionTasks ( );
	bool TeleportPawn ( struct FVector inLoc, struct FRotator inRot, unsigned long abortBehavior );
	void ResetZSmoothingValues ( );
	void RefreshLightEnvironment ( );
	bool HandleTeleportByCheckpoint ( struct FVector inLoc, struct FRotator inRot, unsigned long abortBehavior );
	void OnTeleport ( class USeqAct_Teleport* Action );
	void OnModifyHealth ( class USeqAct_ModifyHealth* Action );
	bool BeginSwitchWeapon ( unsigned long quickDraw );
	void SpawnGrenadeBloodEffect ( struct FVector SourceLocation, class UClass* dmgType, int numBloodEffects );
	void ShowBloodMaterialAtIndex ( int matDmgIdx, float dmgPct );
	void ShowBloodMaterial ( struct FName BoneName, float dmgPct );
	void OnSingleDamageItem ( int Damage, struct FVector Momentum, struct FVector Position, struct FTraceHitInfo HitInfo, class UClass* dmgTypeClass );
	void LeaveADecal ( struct FVector HitLoc, struct FVector HitNorm );
	void BloodPool ( );
	void LeaveHeadBloodFXDecal ( class AActor* HitActor, struct FVector HitLoc, struct FVector HitNormal, struct FTraceHitInfo HitInfo, struct FVector headVel );
	void LeaveMovementDecal ( struct FVector Loc, struct FRotator Dir, class AActor* HitActor, class UMaterialInstance* Mat );
	void PlayFootstepParticleEffect ( struct FName SocketName, class UParticleSystem* ps );
	void PlayMovementParticleEffect ( struct FVector Loc, struct FRotator Dir, class AActor* HitActor, class UParticleSystem* ps );
	void SetAimInterpSpeedTurret ( float Speed );
	void SetSpring ( float sh, float dh, float sv, float dv, float M, float O );
	void TestRenderInForeground ( );
	void testsa ( unsigned char Type );
	void StopCoverMoveSound ( );
	void StartCoverMoveSound ( );
	void StopLeanSound ( );
	void StartLeanSound ( unsigned long isLeanOver );
	void PlayToggleCrouchSound ( unsigned long goingToCrouch );
	void PlayQuickturnSound ( );
	float GetCombatSprintMaxTime ( );
	void StopSprintSlideSound ( );
	void StartSprintSlideSound ( class UYSoundCueFMOD* slideCue );
	void StopZiplineOrRappelSound ( );
	void StartZiplineOrRappelSound ( unsigned char moveType );
	void StopIntoCoverSlideFX ( );
	void PlayIntoCoverSlideFX ( unsigned char dashType );
	void PlayDashIntoCoverSounds ( unsigned char dashType );
	void PlaySpecialMoveSound ( unsigned char Move, unsigned char Phase );
	void PlayLandingSound ( unsigned long isHardLanding );
	void PlayJumpSound ( unsigned long isLongJump );
	void PlaySprintSound ( int FootDown, unsigned long playGearSound, class UYSoundCueFMOD* gearSoundCue );
	void PlayFootStepSound ( int FootDown );
	bool DoReviveSelf ( );
	bool DoRevival ( );
	void StopDBNOMoaningSound ( );
	void PlayDBNOMoaningSound ( );
	void DisableMeshUpdates ( );
	bool PawnPoseAllowsDeathDBNO ( );
	void TimedSetFastSleepValues ( );
	void TimedSetLowDamping ( );
	void SetupDeathDBNODampingAndFriction ( unsigned long setHighStartFriction );
	void GetPersistentWeaponTossPos ( struct FVector* Loc, struct FRotator* Rot );
	void DiedDuringDeathDBNO ( );
	void HandleDeathDBNOExecution ( );
	bool ShouldPlayExecutionOnFront ( );
	void LootAmmoFromExecuted ( float grenadeChance );
	void BeginBeingExecuted ( );
	unsigned char PickExpressiveAnimFromList ( TArray< unsigned char > animList, unsigned char* globalAnimIndex );
	void StartDeathDBNOExpressiveAnim ( );
	void CheckStartDeathDBNOExpressiveAnim ( );
	void FinishedRagRecoveryToDeathDBNO ( unsigned long getupFromBack );
	void StartingRagRecoveryToDeathDBNO ( );
	bool IsPawnReadyForWeaponInit ( );
	void DestructibleBaseWillBeDestroyed ( class AController* EventInstigator );
	void ConditionalReanimateRagdoll ( );
	void StopDeathDBNOSounds ( );
	bool MayFreezeMesh ( );
	void ReattachMeshWithoutBeingSeen ( );
	void ReattachMesh ( );
	void UpdateShadowSettings ( unsigned long bInWantShadow );
	void StopGrenadeFire ( );
	void OnEndRevive ( unsigned long Success );
	void ReviveSelf ( );
	unsigned char GetLastSpecialMoveType ( );
	void ShowAnimProps ( );
	class AYGamePawn* GetDebugPawn ( );
	void DumpHandPoses ( );
	void DumpAimingSets ( );
	void DumpAnimSets ( );
	void DumpPlayingAnimations ( );
	void DumpAnimChannels ( );
	void DumpPostureTransitionInfo ( );
	void CheckAnimInfo ( );
	void TestHeadCover ( );
	void TestIgnoreInnerCoverEdges ( );
	void TestRootMotionCallback ( );
	void TestRootMotion ( );
	void ServerTestPickupAnimation ( );
	void TestPickupAnimation ( );
	void TestDynamicAnimationCallback ( );
	void TestDynamicAnimation ( );
	void UpdateSandStormAnimSet ( );
	bool IsInSandstorm ( );
	void SetMovementPhysicsExplicit ( unsigned char newPhysics );
	void SetMovementPhysics ( );
	void RetrieveSettingsFromPC ( );
	void ServerEnableHitReactionAnimations ( unsigned long Enable );
	void EnableHitReactionAimations ( unsigned long Enable );
	bool IsAnimDrivenKnockedDownIdling ( );
	bool IsBeingKnockedDown ( );
	void OnTakeDown ( class UYSeqAct_TakeDown* Seq );
	void AddToLocalDBNOList ( );
	void ServerReviveTeamMate ( class AYGamePawn* revivedPawn );
	void ReviveTeamMate ( class AYGamePawn* P );
	void OnStopDownButNotOut ( );
	void ClientStopDownButNotOut ( unsigned long skipTransition );
	bool StopDownButNotOut ( unsigned long skipTransition );
	void OnStartDownButNotOut ( );
	bool GotoRagdollDBNO ( );
	unsigned char DetermineDBNOSubState ( unsigned long bExcludeRagdollDBNO );
	void ServerStartDownButNotOut ( );
	void ClientStartDownButNotOut ( unsigned char enterCondition, unsigned char substate, unsigned long noPostureTransition );
	bool StartDownButNotOut ( unsigned char enterCondition );
	bool IsInDBNOMainState ( );
	void PlayDownButNotOutCriticalCallout ( );
	void DownButNotOutCalloutTimer ( );
	void StartDownButNotOutCalloutTimer ( );
	void KnockDownStateChange ( unsigned long knockDown );
	void StopBeingKnockedDown ( );
	void StartBeingKnockedDown ( );
	void OnSniperSpotted ( struct FYS_SpecialActionData* Data );
	void OnFirstEnemyContact ( struct FYS_SpecialActionData* Data );
	void OnEnemyContact ( struct FYS_SpecialActionData* Data );
	void YTriggerEventClass ( class UClass* cl, class AActor* Inst, int ActivateIndex );
	void SpeakLineFinished ( );
	void FaceFXAudioFinished ( class UAudioComponent* AC );
	void StopSoundByType ( unsigned char SoundType );
	void StopTalkingByKismet ( );
	void StopTalking ( unsigned long immediately );
	void PlayQueuedSpeakLine ( );
	void ConditionalFinishSpeakLine ( );
	void SetSpeakerSoundCueForFaceFX ( class UAudioComponent* speakComponent, struct FString AnimName, unsigned long useDucking );
	bool ShouldFilterOutSpeech ( unsigned char Filter );
	bool ShouldSuppressSubtitlesForQueuedSpeakLine ( unsigned long versusMulti );
	void StopSpeakLine ( );
	void StopSpecificSpeakLine ( class USoundCue* lineToStop );
	bool SpeakLine ( class AActor* addressee, class USoundCue* Audio, struct FString DebugText, struct FScriptDelegate speakLineEndCallback, float DelaySec, unsigned long noReplication, unsigned long noLookAt, unsigned long noTurnTo, unsigned char broadcastFilter, unsigned char SubtitlePriority );
	bool SpeakLineDirect ( struct FYS_SpeakLineData speakLineData, struct FScriptDelegate speakLineEndCallback, unsigned long noReplication );
	void DisableFadedSilhouette ( );
	void SetSilhouetteFading ( unsigned long Start );
	void UpdateSilhouetteRendering ( );
	class UMaterialInterface* GetSilhouetteMaterial ( );
	bool DontRenderSilhouette ( );
	void SuppressSilhouette ( unsigned long Suppress );
	bool IsInStealthMode ( );
	bool IsInCombatSituation ( );
	void OnStopFeedbackSilhouette ( float Duration );
	void OnStartFeedbackSilhouette ( float Duration );
	void EnableSilhouette ( class UMaterialInterface* Material );
	void GetPawnLightingColor ( struct FLinearColor* lightingColor );
	unsigned char GetScanableType ( int m_scanningTeamIdx );
	void OnScanEnded ( );
	void DoScanEffects ( );
	void PlayScanDetectionSound ( );
	void OnScanned ( class AYPlayerController* PC, unsigned char Appearance, float Delay, unsigned long PlaySound );
	void OnDetected ( unsigned long detected );
	unsigned char GetHealCommand ( class AYPlayerController* PC );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	struct FBoxSphereBounds GetBounds ( );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool IsEnabledForTacView ( );
	void OnToggleHidden ( class USeqAct_ToggleHidden* Action );
	void FinishedToggleHidden ( unsigned long hide );
	void PrepareForToggleHidden ( unsigned long hide );
	void OnToggle ( class USeqAct_Toggle* Action );
	void OnSetCombatFallbackDirections ( class UYSeqAct_SetCombatFallbackDirections* act );
	void OnForceLODWorker ( int ForcedLodModel );
	void OnStartFlanking ( class UYSeqAct_StartFlanking* act );
	void ClearFightAreas ( );
	void OnLinkAttackCommandArea ( class UYSeqAct_LinkAttackCommandArea* act );
	void OnClearFightAreas ( class UYSeqAct_ClearFightAreas* act );
	void OnRemoveFightArea ( class UYSeqAct_RemoveFightArea* act );
	void OnAddFightArea ( class UYSeqAct_AddFightArea* act );
	void OnSetFightArea ( class UYSeqAct_SetFightArea* act );
	void InformBrainOnSpeaklineFinished ( );
	void InformBrainOnWeaponjamming ( class UYSeqAct_ToggleAI_WeaponJamming* act );
	void InformBrainOnDead ( class AController* Killer );
	void AbortBehaviorTree ( struct FString Reason );
	void OnAbortBehaviorTree ( class UYSeqAct_AbortBehaviorTree* act );
	void OnClearAndRunBehaviorTree_NonLatent ( class UYSeqAct_RunBehaviorTree_NonLatent* act );
	void OnClearAndRunBehaviorTree ( class UYSeqAct_RunBehaviorTree* act );
	void TestSpecialActionFinished ( class UYSpecialActionsDefinition* finishedSpecialAction, unsigned long hasBeenStopped );
	void OnRunSpecialActionFromKismet ( class UYSeqAct_RunSpecialAction* Action );
	void OnRunSpecialActionByType ( class UYSeqAct_RunSpecialActionByType* Action );
	void OnRunAnimFromSpecialActionFinished ( );
	bool StopCustomAnimationDataFromSimpleRefSpecialAction ( );
	bool PlayCustomAnimationDataFromSimpleRefSpecialAction ( struct FYS_AnimInfo AnimInfo, struct FYS_AnimSet AnimSet, unsigned char looped, class UObject* Requestor );
	void SetSpecialActionSoundCue ( class UAudioComponent* sa_component, class USoundCue* sa_soundCue );
	bool StopCurrentSpecialAction ( );
	bool RunSpecialAction ( class UYSpecialActionsDefinition* sa_def, unsigned char Priority, unsigned long logFailure, struct FScriptDelegate finishedCallback, struct FYS_SpecialActionData* Data );
	void OnSquadMateFinishedScanReport ( class UYSpecialActionsDefinition* finishedSpecialAction, unsigned long hasBeenStopped );
	bool RunSpecialActionDel ( class UYSpecialActionsDefinition* sa_def, unsigned char Priority, struct FScriptDelegate specialActionFinished, unsigned long logFailure, struct FYS_SpecialActionData* Data );
	bool RunSpecialActionFromSetDel ( class UYSpecialActionSet* Set, class UYSpecialActionSet* addSet, struct FScriptDelegate specialActionFinished, unsigned char Priority, struct FYS_SpecialActionData* Data );
	bool RunSpecialActionFromSet ( class UYSpecialActionSet* Set, class UYSpecialActionSet* addSet, unsigned char Priority, struct FScriptDelegate endCallback, struct FYS_SpecialActionData* Data );
	void RunSpecialActionFromSetDelayed ( float Delay, class UYSpecialActionSet* Set, class UYSpecialActionSet* addSet, unsigned char Priority, struct FScriptDelegate endCallback, struct FYS_SpecialActionData* Data );
	bool RunSpecialActionFromSetType ( unsigned char setType, unsigned char Priority, struct FScriptDelegate endCallback, unsigned long replicateEvent, struct FYS_SpecialActionData* Data );
	void RunSpecialActionFromSetTypeOnCallback ( float Delay, unsigned char setType, unsigned char Priority, struct FScriptDelegate endCallback, struct FYS_SpecialActionData* Data );
	void RunSpecialActionFromSetTypeDelayed ( float Delay, unsigned char setType, unsigned char Priority, struct FScriptDelegate endCallback, struct FYS_SpecialActionData* Data );
	bool MayRunSpecialActionEvent ( unsigned char Event, struct FYS_SpecialActionData* Data );
	void UnleashWaitingSpecialActions ( );
	void SendDelayedSpecialActions ( float DeltaTime );
	bool RunSpecialActionFromSetTypeDel ( unsigned char setType, struct FScriptDelegate specialActionFinished, unsigned char Priority, struct FYS_SpecialActionData* Data );
	void ResetSpecialAction ( );
	void SetSpecialActionPriority ( unsigned char newPriority );
	bool SpeaklineHasHigherPriority ( unsigned char newPriority );
	bool SpecialActionHasHigherPriority ( unsigned char newPriority );
	void DisplaySpecialActionInfos ( class AYHUD* HUD );
	bool ShouldDrawSpecialActionOutput ( );
	void AddToSpecialActionDisplay ( struct FString Text );
	int NumSpecialActionSets ( unsigned char setType );
	void CurrentSpecialActionFinished ( unsigned long hasBeenStopped );
	void ReportSpecialActionFinishedToYAIController ( );
	void OnAudioFinishedSpecialAction ( class UAudioComponent* AC );
	void OnRunSoundFromSpecialActionFinished ( );
	bool RunSoundFromSpecialAction ( class USoundCue* SoundCue, unsigned long useVoice, int Uid );
	void OnSetAdditionalSASetList ( class UYSeqAct_SetAdditionalSASetList* saSet );
	void ReplicatedSetSpecialActionSetList ( class UYSpecialActionSetList* saSetList );
	void OnSetSpecialActionSetList ( class UYSeqAct_SetSpecialActionSetList* Action );
	void InitSpecialActionSystem ( );
	void FinishedMeleeAttack ( );
	void PlayDelayedMeleeBloodSplatter ( );
	void PlayMeleeBloodEffects ( class AYGamePawn* Pawn );
	void PlaySpecialMeleeCamFX ( );
	void ConditionalIncreaseVaultKillProfileStats ( );
	bool PerformMeleeAttack ( unsigned char attackType, class UClass* DamageType, struct FVector Momentum, int Damage, unsigned long playFeedback );
	void DoSpecialMoveTakeHit ( unsigned char moveDir, struct FRotator TargetRotation, class AYGamePawn* attacker, unsigned long replicate, struct FVector hitMomentum );
	bool DoSpecialMoveStumbleSandBomb ( struct FScriptDelegate stopCallback );
	void DoSpecialMoveStumbleSandPool ( int victimNumber, class AYGamePawn* instPwn );
	void HandleMeleeAttack ( class AYGamePawn* attacker, struct FVector Momentum, int Damage, class UClass* DamageType, unsigned long doResetPawn, struct FVector ResetLocation );
	void DrawSpecialMoveTargetDetectionZone ( class AYHUD* HUD, unsigned long persistent, struct FYS_SpecialMoveDetectionParams* Params );
	bool IsInDetectionArea ( class AYGamePawn* testObject, unsigned long computeTargetScore, unsigned long DisplayDebug, struct FYS_SpecialMoveDetectionParams* Params, float* targetScore );
	bool PerformRangeKick ( unsigned char attackType, unsigned long kickFriendlies, struct FYS_SpecialMoveDetectionParams* Params );
	class AYGamePawn* GetSpecialMoveTarget_NoControllerNeeded ( unsigned char specialMove, unsigned long skipReachabilityCheck, unsigned long DisplayDebug, struct FYS_SpecialMoveDetectionParams* Params );
	class AYGamePawn* GetSpecialMoveTarget ( unsigned char specialMove, unsigned long skipReachabilityCheck, unsigned long DisplayDebug, struct FYS_SpecialMoveDetectionParams* Params );
	void OnEndMeleeAttack ( unsigned long Success );
	bool DoAIMeleeAttack ( class AYGamePawn* TargetPawn, struct FScriptDelegate stopCallback );
	float GetMeleeRange ( );
	bool IsBeingMeleeAttacked ( );
	bool IsDoingMeleeAttack ( );
	void PlayMeleeCameraBloodSplatter ( );
	void PlayPawnMeleeFX ( struct FVector HitLocation, class USoundCue* hitSound, unsigned long replicateToOwningClient );
	void PlayGenericMeleeFX ( struct FVector HitLocation );
	struct FName FindClosestCollidingBone ( struct FVector TestLocation );
	bool FindMeleeTarget ( struct FVector attackLocation, unsigned long onlyCheckPawns, unsigned long useRotationOverride, struct FRotator rotationOverride, unsigned long mayDisplayDebug, class AYGamePawn** hitPawn, class AYDestructibleObject** hitDestructible, class ASkeletalMeshActor** hitSkelMeshActor, struct FVector* HitLocation, struct FVector* HitNormal );
	void OnNotifyMeleeAttack ( unsigned char attackType );
	bool IsASlipoutSpecialMove ( unsigned char Move );
	bool PlayMeleeAttack ( );
	void OnBeingReleasedAsHumanShield ( unsigned long alive );
	void OnBeingTakenAsHumanShield ( class AYGamePawn* captor );
	void PushHumanShield ( unsigned long alive );
	void ReleaseKilledHumanShield ( );
	void ReleaseHumanShield ( );
	void GrabHumanShield ( );
	void OnLostHumanShield ( );
	void TakeHumanShield ( class AYGamePawn* TargetPawn );
	unsigned char GetRelativeDirBasedOnPelvis ( struct FVector Dir );
	unsigned char GetRelativeDir ( struct FVector Dir, unsigned long doAdjust );
	bool CheckForStumble ( float checkDistMoveDir, float checkDistVoid, unsigned long checkVoid, unsigned long checkCustimDirection, struct FVector customDirection );
	void GetCamInvisibilityCylinder ( unsigned long isViewTarget, float* Radius, float* Height );
	void GetHandToWorldPosition ( struct FVector* leftHandLocation, struct FVector* rightHandLocation, struct FRotator* leftHandRotation, struct FRotator* rightHandRotation );
	void SetHandToWorldPosition ( struct FVector leftHandLocation, struct FVector rightHandLocation, struct FRotator leftHandRotation, struct FRotator rightHandRotation );
	void EnableHandToWorldPositionControls ( unsigned char NewMode );
	void SetRightHandToWeaponControlOffset ( struct FVector LocationOffset, struct FRotator RotationOffset );
	void SetLeftHandToWeaponControlOffset ( struct FVector LocationOffset, struct FRotator RotationOffset );
	void DisableRightHandToWeaponControls ( unsigned long Disable );
	void DisableLeftHandToWeaponControls ( unsigned long Disable );
	void EnableHandToWeaponControls ( unsigned long Enable );
	void DelayedLockMeshZOffset ( );
	void LockMeshZOffset ( unsigned long Lock );
	unsigned char IsLeftFootInFront ( float tolerance );
	void SetMeshZSmoothing ( unsigned long Enable );
	void SetFootControls ( unsigned long Enable );
	void EnableFootPlacement ( unsigned long Enable );
	bool IsFootPlacementEnabled ( );
	bool EnableAimingThisTick ( unsigned long currentAimingEnabled, unsigned char* immediateTakeDown );
	void UpdateAiming ( );
	void ConditionalTakeDownWeapon ( );
	void TakeDownWeapon ( unsigned long delayed );
	void TakeUpWeapon ( unsigned long forShooting );
	void ClientAimingReplicated ( );
	bool IsAimingEnabled ( );
	void EnableAiming ( unsigned long Enable, float BlendTime );
	struct FString FireFlagsToString ( struct FYS_FireFlags Flags );
	void DrawStandingDebugInfo ( class AHUD* HUD );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	class UYAimingSet* FindAimOffsetProfileAimingSet ( struct FName ProfileName );
	int CalculateAlphaFromFadingTime ( );
	void DoPlayerNameDrawing ( class APlayerController* PC, int currentAlpha, struct FVector playerNameScreenPos, struct FColor TeamColor );
	struct FString GetNameAboveHead ( class AYGamePawn* localPawn );
	void DrawPlayerName ( class APlayerController* PC );
	void RenderPawnNames ( class APlayerController* PC, class UCanvas* Canvas, struct FVector* CameraPosition, struct FVector* CameraDir );
	void PostRender ( class APlayerController* PC, class UCanvas* Canvas, struct FVector* CameraPosition, struct FVector* CameraDir );
	void NativePostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	struct FString GetHumanReadableName ( );
	struct FColor GetCrosshairColor ( float maxTraceRange, unsigned long noColorChange );
	bool HasToHideCrossHair ( );
	bool MayPeekOverWithLeftOrRightStickInput ( );
	void ForceWantsAim ( );
	bool MayBlindfire ( );
	bool MayBlindfireRight ( );
	bool MayBlindfireLeft ( );
	bool MayBlindfireOver ( );
	bool MayPeekOrAimRight ( );
	bool MayPeekOrAimLeft ( );
	bool MayPeekOrAimOver ( );
	void OnForceCrosshair ( class UYSeqAct_ForceCrosshair* Action );
	void DrawHUD ( class AHUD* H );
	void UpdateMeshRotation ( float DeltaTime );
	void UpdateMeshTranslation ( float DeltaTime );
	void UpdateAutoLookAt ( );
	void DisableHeadLookAt ( unsigned long Disable );
	class AActor* GetHeadLookAt ( );
	void SetHeadLookAt ( class AActor* Target, struct FName BoneName, struct FVector localOffset );
	void ClearHeadLookAtPosition ( );
	void SetHeadLookAtPosition ( struct FVector Target );
	bool IsHeadLookAtEnabled ( );
	void EnableHeadLookAt ( unsigned long Enabled );
	void InitHeadLookAt ( );
	void ExecRegisteredCommand ( );
	bool RegisterExecCommand ( struct FScriptDelegate ExecCommand );
	bool GetSpecialMoveTargetLocation ( struct FVector* Loc );
	void CSM ( );
	void ClearSpecialMoves ( );
	bool OnCancelSpecialMove ( );
	void ClientCancelSpecialMove ( unsigned char moveToCancel );
	void ServerCancelSpecialMove ( unsigned char moveToCancel );
	bool CancelSpecialMove ( );
	bool CancelCustomAnimationSpecialMove ( );
	void OnStopSpecialMove ( unsigned char recentMove, struct FScriptDelegate stopCallback, unsigned long Success );
	bool OnStartSpecialMove ( unsigned char NewMove, unsigned char recentMove, struct FScriptDelegate stopCallback, unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool GetSpecialMoveCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	bool IsDoingASpecialMove ( unsigned long ignoreInterruptableSpecialMoves );
	bool IsDoingSpecialMove ( unsigned char specialMove );
	void PlayReplicateCustomAnimation ( class UYCustomAnimation* Anim );
	void ClientReplicateCustomAnimation ( class AYGamePawn* Pawn, class UYCustomAnimation* Anim, struct FVector alignPosition, struct FVector alignDirection );
	void ServerReplicateCustomAnimation ( class UYCustomAnimation* Anim );
	void ReplicateSpecialMove ( unsigned char NewMove, struct FYS_SpecialMoveData Data, struct FScriptDelegate stopCallback );
	void ServerDoSpecialMove ( unsigned char NewMove, struct FYS_SpecialMoveData Data, struct FScriptDelegate stopCallback );
	void CreateSpecialMoveData ( unsigned char movementDirection, struct FRotator desiredRot, struct FYS_SpecialMoveData* Data );
	bool DoSpecialMoveInternal ( unsigned char NewMove, struct FScriptDelegate stopCallback, unsigned long forceSpecialMove, unsigned long replicate, struct FYS_SpecialMoveData* Data );
	bool DoSpecialMove ( unsigned char NewMove, unsigned char movementDirection, struct FRotator desiredRot, struct FScriptDelegate stopCallback );
	bool CanDoSpecialMoveInternal ( unsigned char specialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMove ( unsigned char specialMove, unsigned char movementDirection, struct FRotator desiredRot );
	class UYSpecialMove* GetSpecialMove ( unsigned char moveType );
	void InitSpecialMoves ( );
	void UpdateFaceFXRegisterUsage ( );
	void TrackFaceFXRegisterUsage ( struct FString RegName, unsigned char RegOp, float RegVal, float InterpDuration );
	bool GetFaceFXAllowNonAnimTick ( );
	void SetFaceFXAllowNonAnimTick ( unsigned long allowNonAnimTick );
	void SetReplicatedFaceFXRegisters ( );
	void ReplicateFaceFXRegister ( struct FString RegName, unsigned char RegOp, float FirstValue, float FirstInterpDuration, float NextValue, float NextInterpDuration, unsigned long useNextValue );
	void ServerSetFaceFXRegisterEx ( struct FString RegName, unsigned char RegOp, float FirstValue, float FirstInterpDuration, float NextValue, float NextInterpDuration );
	void SetFaceFXRegisterExUnreplicated ( struct FString RegName, unsigned char RegOp, float FirstValue, float FirstInterpDuration, float NextValue, float NextInterpDuration );
	void SetFaceFXRegisterEx ( struct FString RegName, unsigned char RegOp, float FirstValue, float FirstInterpDuration, float NextValue, float NextInterpDuration );
	void ServerSetFaceFXRegister ( struct FString RegName, float RegVal, unsigned char RegOp, float InterpDuration );
	void SetFaceFXRegisterUnreplicated ( struct FString RegName, float RegVal, unsigned char RegOp, float InterpDuration );
	void SetFaceFXRegister ( struct FString RegName, float RegVal, unsigned char RegOp, float InterpDuration );
	float GetOriginalFaceFXRegisterValue ( struct FString* RegName );
	float GetFaceFXRegister ( struct FString* RegName );
	void DeclareFaceFXRegister ( struct FString RegName );
	bool IsPlayingFaceFXAnim ( struct FString* GroupName, struct FString* SeqName );
	bool IsActorPlayingFaceFXAnim ( );
	class UFaceFXAsset* GetActorFaceFXAsset ( );
	void OnPlayFaceFXAnim ( class USeqAct_PlayFaceFXAnim* inAction );
	bool CanActorPlayFaceFXAnim ( );
	class UAudioComponent* GetFaceFXAudioComponent ( );
	void StopActorFaceFXAnim ( );
	bool PlayActorFaceFXAnim ( class UFaceFXAnimSet* AnimSet, struct FString GroupName, struct FString SeqName, class USoundCue* SoundCueToPlay );
	bool IsBeingExecutedOrRevived ( );
	bool GetCrosshairColorType ( class AYGamePawn* shootingPawn, unsigned char* colorType );
	bool IsDead ( );
	bool IsExecutable ( class AYGamePawn* executor );
	bool IsRevivable ( class AYGamePawn* Reviver );
	bool IsMeleeAttackable ( class AYGamePawn* attacker, unsigned long checkStanding, unsigned char specificAttackType );
	bool IsHostile ( class AYGamePawn* attacker );
	bool IsSameTeam ( class APawn* Other );
	bool SupportsAutoAiming ( class AYGamePawn* shootingPawn );
	bool IsMissileLocked ( );
	void UpdateMissileLockingStatus ( );
	void ServerSetMissileLock ( unsigned long newLockingStatus );
	void SetMissileLocked ( unsigned long newLockingStatus );
	bool IsMissileLockable ( );
	void DebugShowCalcAiming ( );
	void GetAimAdjustmentFor ( class AYWeapon* W, struct FVector* StartFireLoc, struct FVector* aimAtLoc );
	void CalculateAiming ( float DeltaTime );
	struct FVector GetAimPosition ( );
	void UpdateAimPosition ( struct FVector focusedPoint, class AActor* focusedActor );
	void ReliableUpdateAimPositionServerEvent ( struct FVector newAimPos );
	void UpdateAimPositionServer ( struct FVector newAimPos );
	void ReliableUpdateAimPositionServer ( struct FVector newAimPos );
	void CrushedBy ( class APawn* OtherPawn );
	bool CanBeBaseForPawn ( class APawn* aPawn );
	void DoHeadJumpMeleeAttack ( class AYGamePawn* Pawn );
	void JumpOffPawn ( );
	void EncroachedBy ( class AActor* Other );
	bool DebugAreHandIKControlsEnabled ( );
	void DebugEnableHandIKControls ( unsigned long Enable );
	bool DebugIsRecoilEnabled ( );
	void DebugEnableRecoil ( unsigned long Enable );
	struct FName GetSpecialBoneName ( unsigned char BoneType );
	bool GetSpecialBoneInfos ( unsigned char BoneType, unsigned char dirAxis, struct FVector* Loc, struct FVector* Dir );
	void InitSpecialBones ( );
	float GetDamageModifier ( struct FName BoneName, float headShotModifier, class UClass* dmgType, unsigned char* deadlyHeadShot );
	struct FVector GetHeadBoneLocation ( );
	void GetMeshCenteredPosition ( struct FVector* OutLocation, struct FRotator* OutRotation );
	void StopCamShake ( class UCameraAnimInst* cameraAnimInstance, unsigned long immediately );
	class UCameraAnimInst* PlayCamShake ( class UCameraAnim* Anim, float Rate, float Scale, float FadeInTime, float FadeOutTime, unsigned long looped, unsigned long randomStartTime );
	class AYCamera* GetPlayerCam ( );
	void SmoothCameraBaseOffset ( struct FVector newBaseOffset, float smoothingTime );
	struct FRotator GetViewRotation ( );
	void GetHeadAndBreastByOffset ( struct FVector* headPos, struct FVector* breastPos );
	void GetViewLocationAndDirection_Internal ( struct FVector* vHeadLoc, struct FVector* vBrestLoc, struct FVector* VDir );
	void GetViewLocationAndDirection ( struct FVector* vLoc, struct FVector* VDir );
	void UpdateHeadCoverAnimation ( unsigned long postureChange, unsigned long crouchChange );
	void ReenableHeadCover ( );
	void StopHeadCoverAnimation ( );
	bool DoHeadCover ( unsigned long forceHeadCover );
	bool ReactOnExplosion ( );
	void OnChangeCoverSubstate ( unsigned char oldState, unsigned char NewState );
	void OnStopLeanOverCover ( );
	void OnStartLeanOverCover ( );
	bool WasLeaningOverCover ( );
	bool IsLeaningOverCover ( );
	bool CanLeanOverCover ( );
	bool IsAimingAround ( );
	bool CanAimAroundRight ( );
	bool CanAimAroundLeft ( );
	void OnLeaveSlopeVolume ( class AYSlopeVolume* Volume );
	void OnEnterSlopeVolume ( class AYSlopeVolume* Volume );
	bool CheckStartQuickturn ( );
	bool IsDoingQuickturn ( );
	void DoQuickTurn ( unsigned char moveDir, struct FRotator TargetRotation, float Duration );
	void StopRunToIdleMeleeTransition ( );
	void StopRunToIdleTransition ( );
	void PlayRunToIdleTransition ( unsigned long attackVariation );
	bool IsSprintSliding ( );
	bool IsStoppingSprint ( );
	bool DoStopSprint ( unsigned char moveDir, struct FRotator TargetRotation, unsigned long Crouched, unsigned long doSlide, struct FScriptDelegate stopCallback );
	bool IsStartingSprint ( );
	bool DoStartSprint ( unsigned char moveDir, struct FRotator TargetRotation, unsigned long Crouched, struct FScriptDelegate stopCallback );
	bool CheckStartSprint ( );
	bool IsLeavingPeeking ( );
	bool DoLeavePeeking ( unsigned char coverStance, unsigned char Direction, struct FScriptDelegate stopCallback );
	void InitPhysicsForCustomDeathAnim ( float AnimLength, float physicsBlendTime, float physicsBlendStartTime );
	void OnDeathAnimationFinished ( unsigned long Success );
	void OnDeathAnimationFailed ( );
	void OnDeathAnimStarted ( );
	void OnCancelDeathAnimationAction ( class UYSeqAct_DeathAnimation* seqAct );
	void OnStartDeathAnimationAction ( class UYSeqAct_DeathAnimation* seqAct );
	void ResetCustomAnimationParameters ( struct FYS_CustomAnimationParameters Params );
	void ApplyCustomAnimationParameters ( struct FYS_CustomAnimationParameters Params );
	bool StopCustomAnimationData ( unsigned char animID );
	bool PlayCustomAnimationData ( struct FYS_AnimInfo AnimInfo, struct FYS_AnimSet AnimSet, unsigned char looped, unsigned char mirrorMode, struct FYS_AnimSet cameraAnimSet, struct FScriptDelegate animEndCallback, class UObject* Requestor, unsigned char* outAnimID );
	bool CanPlayCustomAnimationData ( struct FYS_AnimInfo AnimInfo, struct FYS_AnimSet AnimSet, struct FYS_AnimSet cameraAnimSet, class UObject* Requestor );
	bool StopCustomAnimation ( );
	void OnStopCustomAnimation ( class UYSeqAct_StopCustomAnimation* seqAct );
	void CancelCustomAnimation ( class UYCustomAnimationBase* customAnimation );
	void StartCustomAnimation ( class UYCustomAnimationBase* customAnimation, class UObject* callbackObject );
	void OnCancelCustomAnimation ( class UYSeqAct_CustomAnimation* seqAct );
	void OnStartCustomAnimation ( class UYSeqAct_CustomAnimation* seqAct );
	void OnKismetAnimNotify ( class UYAnimNotify_Kismet* AnimNotify, class UAnimNodeSequence* AnimSeqInstigator );
	void OnStopSpecialMoveAction ( unsigned long Success );
	void OnCancelSpecialMoveAction ( class UYSeqAct_SpecialMove* seqAct );
	void kismetentercoverdone ( );
	void OnStartSpecialMoveAction ( class UYSeqAct_SpecialMove* seqAct );
	void OnSandFogBlinding ( );
	bool IsDroppingDown ( );
	bool DoDropDown ( unsigned char movementDirection, struct FRotator TargetRotation, struct FVector coverLocation, struct FScriptDelegate stopCallback );
	bool CheckDropDownLocation ( struct FRotator TargetRotation, float maxDropDownCoverDistance, float maxDropDownCoverFOV, unsigned long isLedgeCheck, struct FYS_CoverData* coverData );
	bool CheckDropDown ( unsigned char movementDirection, struct FRotator TargetRotation, float maxDropDownCoverDistance, float maxDropDownCoverFOV, float maxDropDownRotationDifference, unsigned long checkForPawnsAtTargetLocation, struct FYS_CoverData* coverData );
	bool PickUpWeaponInstantly ( );
	bool IsPickingUpWeapon ( );
	bool CheckPickup ( );
	bool DoPickup ( struct FScriptDelegate stopCallback );
	bool IsCurrentWeaponLimitedUse ( );
	bool StopFailedIntelOp ( );
	bool StopSucceededIntelOp ( );
	bool CanStopIntelOp ( );
	class UYSpecialMove_IntelOp* GetIntelOpSpecialMove ( );
	bool IsDoingIntelOp ( );
	bool DoIntelOp ( unsigned char movementDirection, class UYSeqAct_IntelOp* intelOpSeqAct, struct FScriptDelegate stopCallback );
	void OnStopFailedIntelOp ( class UYSeqAct_IntelOp* seqAct );
	void OnStopSucceededIntelOp ( class UYSeqAct_IntelOp* seqAct );
	void OnCancelIntelOp ( class UYSeqAct_IntelOp* seqAct );
	void OnIntelOp ( class UYSeqAct_IntelOp* seqAct );
	void LeaveTruckRide ( );
	void EnterTruckRide ( );
	void UpdateTurretAiming ( float DeltaTime );
	bool IsUsingTurret ( );
	void LeaveTurretWeapon ( class AYTrigger_TurretInteraction* turretInteraction, unsigned long uponDeath );
	void LeaveTurretState ( unsigned long uponDeath );
	void LeaveTurret ( unsigned long uponDeath );
	void OnLostReplicatedTurret ( );
	void EnterTurret ( );
	bool DoTurretUse ( unsigned char movementDirection, struct FRotator TargetRotation, unsigned char specialMove, class AYTrigger_TurretInteraction* turretTrigger, struct FScriptDelegate stopCallback );
	bool CheckTurretLeaveQuick ( unsigned char inputDirection );
	bool CheckTurretUse ( unsigned char movementDirection, struct FRotator TargetRotation, unsigned char* specialMove, class AYTrigger_TurretInteraction** turretTrigger );
	bool IsOnFastRope ( );
	bool IsZiplining ( );
	bool DoZipline ( unsigned char movementDirection, struct FRotator TargetRotation, unsigned char specialMove, class AYTrigger_ZiplineInteraction* ziplineInteraction, struct FScriptDelegate stopCallback );
	bool CheckZipline ( unsigned char movementDirection, struct FRotator TargetRotation, unsigned char* specialMove, class AYTrigger_ZiplineInteraction** ziplineInteraction );
	void OnFastRopeEnableCollision ( );
	void OnFastRopeEndSound ( );
	void OnFastRopeStartSound ( );
	void OnFastRopeGroundReached ( );
	void OnRopeReleasedFeet ( );
	void OnRopeReleased ( );
	void OnRopeGrabbedFeet ( );
	void OnRopeGrabbed ( );
	void FastRopeEnableCollision ( );
	void FastRopeEndSound ( );
	void FastRopeStartSound ( );
	void FastRopeGroundReached ( );
	void ReleaseRopeFeet ( );
	void ReleaseRope ( );
	void GrabRopeFeet ( );
	void GrabRope ( );
	bool IsFastRoping ( );
	bool DoFastRope ( unsigned char movementDirection, struct FRotator TargetRotation, unsigned char specialMove, class AYRopeActor* ropeActor, struct FScriptDelegate stopCallback );
	unsigned char DetermineFastRopeMove ( class AYRopeActor* rope );
	bool CheckFastRope ( unsigned char movementDirection, struct FRotator TargetRotation, unsigned char* specialMove, class AYRopeActor** ropeActor );
	float GetDropDownSpeed ( );
	float GetReviveAnimationSpeed ( );
	float GetSwatTurnAnimSpeed ( );
	bool IsReviving ( );
	void HandleBeingRevived ( class AYGamePawn* Healer, int variationIndex, struct FVector victimLocation );
	void DoSpecialMoveBeingRevived ( class AYGamePawn* Healer, unsigned long replicate, int variationIndex, struct FVector victimLocation );
	bool DoReviveFromDeath ( class AYGamePawn* pawnToRevive, struct FScriptDelegate stopCallback );
	bool DoRevive ( class AYGamePawn* pawnToRevive, struct FScriptDelegate stopCallback );
	struct FVector GetHealingVictimLocation ( class AYGamePawn* instPawn );
	bool CheckReviveDeadPlayer ( class AYGamePawn** pawnToRevive );
	bool CheckRevive ( class AYGamePawn** pawnToRevive );
	void HandleBeingExecuted ( class AYGamePawn* attacker, int variationIndex, struct FVector victimLocation );
	void DoSpecialMoveBeingExecuted ( class AYGamePawn* attacker, unsigned long replicate, int variationIndex, struct FVector victimLocation );
	struct FVector GetExecutionVictimLocation ( class AYGamePawn* instPawn );
	bool IsBeingExecuted ( );
	bool IsExecuting ( );
	void OnExecutionMoveEnded ( );
	void DebugExecutionVariation ( int variation );
	void DecodeExecutionVariation ( int variationValue, unsigned char* executionWeaponType, int* animVariation );
	int EncodeExecutionVariation ( class AYWeapon* attackerWeapon );
	bool DoExecution ( class AYGamePawn* pawnToExecute, struct FScriptDelegate stopCallback );
	bool CheckExecute ( class AYGamePawn** pawnToExecute );
	bool IsSlippingOut ( );
	bool IsSlippingOutFront ( );
	bool DoSlipOut ( unsigned char coverMovementDirection, unsigned char slipSpecialMove, unsigned long doMeleeAttack, struct FScriptDelegate stopCallback );
	bool CheckSlipOut ( unsigned char slipOutDirection, struct FRotator controllerRotation, int minAngle, int MaxAngle, unsigned long doMeleeAttack, unsigned char* coverMovementDirection, unsigned char* slipSpecialMove );
	bool IsSwatTurning ( );
	bool DoSwatTurn ( unsigned char coverMovementDirection, unsigned char coverStance, struct FScriptDelegate stopCallback );
	bool CheckSwatTurn ( unsigned char coverMovementDirection, unsigned char coverStance );
	bool DoLeaveCoverMove ( struct FRotator TargetRotation, struct FScriptDelegate stopCallback );
	bool IsLeavingCover ( );
	void OnMoveIntoCoverFailed ( );
	void OnMoveIntoCoverSprintSuccess ( );
	bool IsMovingIntoCover ( );
	bool DoMoveIntoCover ( unsigned char movementDirection, struct FRotator TargetRotation, unsigned char specialMove, struct FScriptDelegate stopCallback );
	bool CheckMoveIntoCover ( unsigned char movementDirection, struct FRotator TargetRotation, unsigned char* specialMove );
	bool CheckSnapToCover ( unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, struct FYS_CoverData* coverData );
	bool SnapToCover ( unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, unsigned long checkIfOccupied, unsigned long skipAIForOccupation );
	bool PreCheckVaultKick ( float Radius, float Length, struct FVector StartPos, struct FRotator moveDir, class AYGamePawn** TargetPawn );
	bool DoMoveOverCover ( struct FRotator TargetRotation, unsigned char specialMove, unsigned long doDrop, struct FScriptDelegate stopCallback );
	void OnBecomeVaultKickTarget ( class AYGamePawn* instigtr );
	bool IsMovingOverCover ( );
	bool CheckMoveOverCover ( unsigned char movementDirection, struct FRotator TargetRotation, unsigned long onlyAutoMove, unsigned char* specialMove, unsigned char* isDropDown );
	bool TestAcquireCoverForMoveOverCover ( unsigned char movementDirection, struct FVector targetDirection, struct FYS_CoverData* coverData );
	void GetAdhesionLoc ( struct FVector* headLoc, struct FVector* breastLoc );
	void GetFrictionCylinder ( float* CylRad, float* cylHeight, struct FVector* CylLoc );
	void AdjustMeshTranslation ( float translationZ );
	void EndCrouch ( float HeightAdjust );
	void StartCrouch ( float HeightAdjust );
	void ResetCollisionCylinderSize ( unsigned long dontFindSpotInZ );
	void SetRelativeCollisionCylinderSize ( float heightFactor, float radiusFactor, unsigned long dontFindSpotInZ );
	void SetCollisionCylinderSize ( float Height, float Radius, float HeightAdjust, unsigned long dontFindSpotInZ );
	void GetCollisionCylinderSize ( float* outHeight, float* outRadius );
	struct FVector GetDefaultCollisionExtent ( unsigned long crouch );
	float GetDefaultCollisionCylinderRadius ( unsigned long crouch );
	float GetDefaultCollisionCylinderHeight ( unsigned long crouch );
	void GetDefaultCollisionCylinderSize ( unsigned long crouch, float* outHeight, float* outRadius );
	struct FVector GetFloorBasedLocation ( );
	bool YFindSpot ( struct FVector Extent, struct FVector preferredDir, float offsetFactor, unsigned long traceFloor, unsigned long doReachabilityTest, struct FVector reachabilityExtent, struct FVector* Loc );
	bool EncroachingPawns ( struct FVector Loc, struct FVector Extent, unsigned long useComplexCollision, struct FVector* HitLocation, struct FVector* HitNormal );
	bool EncroachingGeometry ( struct FVector Loc, struct FVector Extent, unsigned long useComplexCollision, struct FVector* HitLocation, struct FVector* HitNormal );
	bool EncroachingWorldGeometry ( struct FVector Loc, struct FVector Extent, unsigned long useComplexCollision, struct FVector* HitLocation, struct FVector* HitNormal );
	bool FitCollision ( float oldCollisionHeight, float oldCollisionRadius, unsigned long dontFindSpotInZ );
	void PlayZoomOutAnimation ( unsigned long toAiming );
	void PlayZoomInAnimation ( unsigned long fromAiming );
	void EnableZoomPostures ( unsigned long Enabled );
	void OnZoomChanged ( unsigned long zooming );
	void ServerEnableZooming ( unsigned long zooming );
	void EnableZooming ( unsigned long zooming );
	bool IsScopeInUse ( );
	void DisableZoomMode ( );
	bool MayZoom ( );
	bool IsPreventingNetworkPositionCorrection ( );
	void PreventNetworkPositionCorrection ( unsigned long Enable );
	void OnMovementStateChanged ( );
	void UpdateMovementState ( );
	void UpdateSprinting ( );
	bool MayDoAgileSpecialMove ( );
	void ServerStopCombatSprint ( );
	void StopCombatSprint ( );
	void ServerStartCombatSprint ( );
	void StartCombatSprint ( );
	void DisableForceSprinting ( );
	void StopForcedSprint ( );
	void StartForcedSprint ( );
	void ForceSprinting ( unsigned long Enable );
	void OnSprintStop ( unsigned long doSlide );
	void OnSprintStart ( );
	void ServerStopSprint ( unsigned long doSlide );
	void ServerStartSprint ( );
	bool StopSprint ( unsigned long doSlide );
	bool StartSprint ( );
	bool IsSprinting ( unsigned long includingCoolDown, unsigned long includingForcedSprinting );
	bool IsChangingSprint ( unsigned long includingCoolDown );
	bool HasRunSpeed ( float tolerance );
	bool IsFasterThan ( float Speed );
	bool IsRunning ( );
	bool IsMoving ( );
	unsigned char GetCurrentMovementSpeed ( );
	void UpdateWeaponAnimModifier ( unsigned char oldAnimModifier, class AYWeapon* OldWeapon, unsigned char newAnimModifier, class AYWeapon* NewWeapon );
	void SetAnimModifierInternal ( unsigned char newAnimModifier );
	void ServerSetAnimModifier ( unsigned char animModifier );
	void SetAnimModifier ( unsigned char animModifier );
	void OnSetAnimationModifier ( class UYSeqAct_SetAnimationModifier* seqAct );
	void OnClearOverrideIdleSA ( class UYSeqAct_ClearOverrideIdleSA* seqAct );
	void OnOverrideIdleSA ( class UYSeqAct_OverrideIdleSA* seqAct );
	void ClearOverrideIdleSpecialActionSet ( class UYSpecialActionSet* Set );
	void SetOverrideIdleSpecialActionSet ( class UYSpecialActionSet* Set, float minInterval, float maxInterval );
	void RandomIdleSpecialActionFinished ( class UYSpecialActionsDefinition* finishedSpecialAction, unsigned long hasBeenStopped );
	void PlayRandomIdleAnimationInternal ( );
	void PlayRandomIdleAnimation ( );
	void UpdateRandomIdleAnimation ( );
	void OnIdleFullWeightLost ( );
	void OnIdleFullWeightGained ( );
	void DisableCrouch ( );
	void UnlockCrouchCylinder ( );
	void LockCrouchCylinder ( unsigned char ForceCrouch );
	void OnCrouch ( unsigned long crouch );
	bool CanCrouchInternal ( unsigned long crouch );
	bool CanCrouch ( unsigned long crouch );
	void ServerEnableCrouch ( unsigned long crouch );
	bool EnableCrouch ( unsigned long crouch );
	void ManualUpdateCrouch ( );
	bool CanAutoAdjustCrouch ( );
	void TakeFallingDamage ( );
	void AdjustDamage ( class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, struct FTraceHitInfo HitInfo, int* inDamage, struct FVector* Momentum );
	void ResetMeshTranslationOffset ( );
	void InterpolateMeshTranslationOffsetToDefault ( unsigned long finished );
	void PlaySuperSoftLanding ( );
	void PlayLanded ( float ImpactVel );
	void Landed ( struct FVector HitNormal, class AActor* FloorActor );
	void Prefalling ( );
	void Falling ( );
	void ResetFallingState ( );
	void SetFallingState ( unsigned char newFallingState );
	void StopLandingAnim ( struct FYS_AnimID playingID );
	struct FYS_AnimID GetHardLandingAnim ( );
	struct FYS_AnimID GetSoftLandingAnim ( );
	bool IsFallingOrLandingAfterDropdown ( );
	unsigned char GetFallingState ( );
	bool CheckFloorWithinDistance ( float maxCheckDistance, float* hitDistance );
	void UpdateFallingAnimation ( );
	bool IsFalling ( );
	bool CanDoASpecialMove ( );
	void ConditionalEnableImprovedAimout ( );
	void UnlockSubstateDetermination ( );
	void LockSubstateDetermination ( );
	void KeepAimingOutWhenPeeking ( unsigned long Enable );
	void AimOutWhenPeeking ( unsigned long enableLeft, unsigned long enableRight, unsigned long enableOver );
	bool IsInRightEdgeState ( );
	bool IsInLeftEdgeState ( );
	bool IsInSideOutState ( );
	bool IsAimingOutOverInternal ( );
	bool IsAimingOutRightInternal ( );
	bool IsAimingOutLeftInternal ( );
	bool IsAimingOutInternal ( );
	bool IsAtEdge ( );
	bool WasAimingOutOver ( );
	bool IsAimingOutOver ( );
	bool IsAimingOutSidewaysNoAimAround ( );
	bool WasAimingOutRight ( );
	bool IsAimingOutRight ( );
	bool WasAimingOutLeft ( );
	bool IsAimingOutLeft ( );
	bool WasAimingOut ( );
	bool IsAimingOut ( );
	bool WantsToAimOut ( );
	bool CanAimOutLeftOrRight ( );
	void AimOut ( unsigned long enableLeft, unsigned long enableRight, unsigned long enableOver );
	bool IsBlindfiringOverInternal ( );
	bool IsBlindfiringRightInternal ( );
	bool IsBlindfiringLeftInternal ( );
	bool IsBlindfiringInternal ( );
	bool IsBlindfiringOver ( );
	bool IsBlindfiringRight ( );
	bool IsBlindfiringLeft ( );
	bool WasBlindfiringOver ( );
	bool WasBlindfiringRight ( );
	bool WasBlindfiringLeft ( );
	bool WasBlindfiring ( );
	bool IsBlindfiring ( );
	void Blindfire ( unsigned long enableLeft, unsigned long enableRight, unsigned long enableOver );
	bool IsPeekingOverInternal ( );
	bool IsPeekingRightInternal ( );
	bool IsPeekingLeftInternal ( );
	bool IsPeekingInternal ( );
	bool WasPeekingOver ( );
	bool IsPeekingOver ( );
	bool WasPeekingRight ( );
	bool IsPeekingRight ( );
	bool WasPeekingLeft ( );
	bool IsPeekingLeft ( );
	bool IsPeeking ( );
	void Peek ( unsigned long enableLeft, unsigned long enableRight, unsigned long enableOver );
	bool IsInLeftCamState ( );
	bool IsInRightState ( );
	bool IsInLeftState ( );
	void ServerSetSubstate ( unsigned char mainState, unsigned char substate, unsigned long disablePostureTransition );
	bool SetSubstate ( unsigned char substate, unsigned long disablePostureTransition );
	bool DetermineCoverStance ( unsigned char coverType, unsigned char coverStance, unsigned char* outMainState, unsigned char* outSubstate );
	bool BlockSlimCoverStrafe ( );
	bool CanBlindfire ( );
	void UpdateBlindfire ( );
	void UpdateMayBlindfire ( );
	void UpdatePeekAndAimOut ( );
	void UpdateMayPeekOrAimOut ( );
	bool CanMoveRight ( );
	bool CanMoveLeft ( );
	bool IsAtRightEdgeInternal ( struct FYS_CoverData coverData, unsigned long withTolerance );
	bool IsAtLeftEdgeInternal ( struct FYS_CoverData coverData, unsigned long withTolerance );
	bool IsInSlimCover ( );
	bool WasAtEdge ( );
	bool IsAtRightEdge ( unsigned long withTolerance );
	bool IsAtLeftEdge ( unsigned long withTolerance );
	bool CanLeanRightInternal ( struct FYS_CoverData coverData, unsigned long withTolerance );
	bool CanLeanLeftInternal ( struct FYS_CoverData coverData, unsigned long withTolerance );
	bool CanLeanRight ( );
	bool CanLeanLeft ( );
	bool DetermineCoverSubstate ( unsigned char currentSubstate, unsigned char movementDirection, unsigned char* newSubstate );
	void OnUpdateCoverStance ( );
	void ServerUpdateCoverStance ( unsigned char coverType, unsigned char coverStance, unsigned long disablePostureTransition );
	void UpdateCoverStance ( unsigned char coverType, unsigned char coverStance, unsigned long disablePostureTransition );
	void ServerSetLocation ( struct FVector NewLocation );
	void ApplyPositionCorrectionForSubstate ( unsigned char newSubstate, unsigned long Force );
	bool IsPositionBlockedByPawn ( struct FVector pos, struct FVector Extent );
	void UpdateCoverState ( unsigned char movementDirection, unsigned char coverStance, unsigned long disablePostureTransition );
	bool CanMoveInCurrentState ( );
	bool WasInBackwardCoverState ( );
	bool IsInBackwardCoverState ( );
	bool IsInOverCoverState ( );
	bool SetCurrentSubstateDirection ( unsigned char Direction );
	unsigned char GetSubstateDirection ( unsigned char substate );
	unsigned char GetCurrentSubstateDirection ( );
	void blowupcover ( );
	void OnCoverInvalidated ( struct FVector coverNormal );
	bool DetachFromCover ( );
	void PushOutOfCover ( class AYGamePawn* pusher );
	void OnLeaveCover ( unsigned char lastSubstate );
	bool CanLeaveCover ( );
	void ServerLeaveCover ( unsigned long disablePostureTransition );
	bool LeaveCover ( unsigned long disablePostureTransition, unsigned long forceLeaveCover );
	void OnEnterCover ( );
	bool CanEnterCover ( unsigned char coverStance );
	bool EnterCover ( unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition );
	unsigned char GetCoverEnterDirection ( struct FYS_CoverData coverData );
	bool DetermineEnterCoverStates ( unsigned char coverStance, unsigned char coverDirection, unsigned char* outMainState, unsigned char* outSubstate );
	bool IsUnderWindow ( unsigned char Direction );
	bool AreInnerCoverEdgesIgnored ( );
	void IgnoreInnerCoverEdges ( unsigned long ignoreEdges );
	void UnlockCover ( );
	bool LockCover ( struct FVector coverPosition );
	bool TestDropDownCoverByLocation ( struct FVector coverLocation, float MaxDistance, struct FYS_CoverData* coverData );
	bool TestDropDownCover ( struct FVector pawnLocation, struct FVector Direction, float MaxDistance, float maxFov, float maxHeightDifference, unsigned long isLedgeCheck, struct FYS_CoverData* coverData );
	void ReleaseCover ( );
	bool AcquireCoverByCover ( struct FYOctreeDataHndl Handle );
	bool AcquireCoverByLocationInternal ( struct FVector coverLocation, unsigned char purpose, float MaxDistance, struct FYS_CoverData* coverData );
	bool TestAcquireCoverByLocation ( struct FVector coverLocation, unsigned char purpose, float MaxDistance, struct FYS_CoverData* coverData );
	bool AcquireCoverByLocation ( struct FVector coverLocation, unsigned char purpose, float MaxDistance );
	bool AcquireCoverInternal ( struct FVector pawnLocation, struct FVector Direction, unsigned char purpose, float MaxDistance, float maxFov, float maxHeightDifference, struct FYS_CoverData* coverData );
	bool TestAcquireCover ( struct FVector pawnLocation, struct FVector Direction, unsigned char purpose, float MaxDistance, float maxFov, float maxHeightDifference, struct FYS_CoverData* coverData );
	float GetCollisionHeightNative ( );
	void SetCoverNormal ( struct FVector Normal );
	bool AcquireCover ( struct FVector Direction, unsigned char purpose, float MaxDistance, float maxFov, float maxHeightDifference );
	bool IsValidCoverLocationForced ( );
	void ForceValidCoverLocation ( unsigned long Force );
	bool IsCoverStateLocked ( );
	void LockCoverState ( unsigned long locked );
	void LockCoverParameters ( unsigned long enableLock );
	bool UpdateCoverFacingFlags2 ( struct FVector ViewLocation, struct FRotator ViewRotation, unsigned char* coverFaceState );
	bool UpdateCoverFacingFlags ( struct FVector ViewLocation, struct FRotator ViewRotation, unsigned char* coverFaceState );
	void UpdateCoverParameters2 ( );
	void UpdateCoverParameters ( );
	bool CurrentCoverHitTest ( struct FVector* shootPos, struct FVector* targetPos );
	void SetCoverRotation ( struct FRotator coverRotation );
	void OnCoverLost ( unsigned char Reason );
	void UpdateStaticCover ( );
	bool StopStackingStepOut ( );
	bool StartStackingStepOut ( );
	bool StopStacking ( );
	bool StartStackingRight ( );
	bool StartStackingLeft ( );
	bool WasStackedRight ( );
	bool WasStackedLeft ( );
	bool WasStacked ( );
	bool IsSteppingOutInternal ( );
	bool IsStackedRight ( );
	bool IsStackedLeft ( );
	bool IsStacked ( );
	bool IsInSingleSlotCover ( );
	bool IsCrouchedOutsideOfCover ( );
	bool IsInCrouchCover ( );
	bool IsInStandCover ( );
	bool WasInCover ( );
	bool IsInCover ( );
	void ServerEnableCover ( unsigned long Cover );
	bool EnableCover ( unsigned long Cover );
	bool IsInStandardMove ( );
	bool ProcessSprintModifier ( unsigned long sprintModifier );
	bool ProcessZoomModifier ( unsigned long zoomModifier );
	bool ProcessCoverModifier ( unsigned long coverModifier );
	bool ProcessCrouchModifier ( unsigned long crouchModifier, unsigned long disablePostureTransition );
	void SetInitialCoverSubstate ( unsigned char substate );
	bool ProcessSubstate ( unsigned char substate, unsigned long forceSubstate, unsigned long disablePostureTransition );
	void GetOnFinishRefireAnimationCallback ( struct FScriptDelegate* onFinishRefireAnimationCallback );
	void GetOnFinishReloadAnimationCallback ( struct FScriptDelegate* onFinishReloadAnimationCallback );
	void UpdatePostureDependingAnimations ( );
	void UpdateEquipScndModeAnimation ( );
	void UpdateRefireAnimation ( );
	void UpdateReloadAnimation ( );
	bool ProcessMainState ( unsigned char mainState, unsigned char substate, unsigned long forceMainState, unsigned long disablePostureTransition );
	void SetDeadMainState ( );
	void CheckWeaponStickingThroughDestructibleActor ( unsigned long stateChange );
	void CheckFinishedStateChangeCallback ( );
	bool IsControlledByRootMotionOrRootMotionRotation ( );
	bool IsControlledByRootMotionRotation ( );
	void OnControlledByRootMotionRotation ( unsigned long newControlledByRootMotionRotation );
	void EnableRootMotionRotation ( unsigned long Enable );
	unsigned char GetRootMotionMode ( );
	bool IsControlledByRootMotion ( );
	void OnControlledByRootMotion ( unsigned long newControlledByRootMotion );
	void EnableRootMotion ( unsigned long Enable, unsigned char RootMotionMode );
	bool IsMoveOrLookInputIgnored ( );
	void IgnoreMoveAndLookInput ( unsigned long bNewMoveAndLookInput );
	bool IsLookInputIgnored ( );
	void IgnoreLookInput ( unsigned long bNewLookInput );
	bool IsMoveInputIgnored ( );
	void IgnoreMoveInput ( unsigned long bNewMoveInput );
	bool MayBeMoved ( );
	void EnableIdleRotation ( );
	void PlayReplicatedIdleAnimation ( struct FYS_ReplicatedIdleAnimation* idleAnimation );
	void ReplicateIdleAnimation ( struct FName Animation, unsigned long looped, float Rate, int initialRotationYaw, int targetAngle );
	bool PreventIdleRotation ( );
	void EnableRotationDespiteRootMotion ( unsigned long Enable );
	struct FRotator CalcRotation ( struct FRotator controllerRotation, float DeltaTime );
	void UpdateRotationSimulated ( float DeltaTime );
	void FaceRotationWithBodyNative ( struct FRotator NewRot, float deltaT );
	void FaceRotationNative ( struct FRotator NewRot, float deltaT );
	void FaceRotationWithBody ( struct FRotator NewRot, float DeltaTime );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	unsigned char GetBehaviorState ( );
	void SetBehaviorState ( unsigned char behaviorState );
	void UpdateMovementBlocking ( );
	void CreateOneShotSound ( struct FVector soundLoc, struct FVector soundRot, class UYSoundCueFMOD* Cue );
	void PlayFlyBySound ( struct FVector worldRotation, unsigned long leftToRight, unsigned long isProjectile );
	void AddFlyBy ( struct FVector worldRotation, unsigned long leftToRight, unsigned long isProjectile );
	void UpdatePawnLocation ( float DeltaTime );
	void TickNative ( float DeltaTime );
	void UpdateHealthBasedFaceFX ( );
	void Tick ( float DeltaTime );
	void AddMeshZOffset ( float Offset );
	void StopAllInterpolations ( );
	void StopOffsetMeshTranslationInterpolation ( );
	void InterpolateByMeshTranslationOffset ( float Length, float Delay, float offsetValue, unsigned long smoothInterpolation, struct FScriptDelegate endCallback );
	void StopOffsetLocationInterpolation ( );
	void InterpolateByLocationOffset ( float Length, float Delay, struct FVector offsetLocation, struct FScriptDelegate endCallback );
	void StopMeshTranslationXYInterpolation ( );
	void InterpolateToMeshTranslationXY ( float Length, float Delay, float targetTranslationX, float targetTranslationY, struct FScriptDelegate endCallback );
	void StopTargetLocationInterpolation ( );
	struct FVector GetInterpolationTargetLocation ( );
	void SetInterpolationTargetLocation ( struct FVector TargetLocation );
	void InterpolateToTargetLocation ( float Length, float Delay, struct FVector TargetLocation, unsigned long XAxis, unsigned long YAxis, unsigned long ZAxis, struct FScriptDelegate endCallback );
	void StopTargetRotationInterpolation ( );
	float GetTargetRotationTime ( );
	struct FRotator GetTargetRotation ( );
	void SetTargetRotation ( struct FRotator TargetRotation );
	void InterpolateToTargetRotation ( float Length, float Delay, struct FRotator TargetRotation, unsigned long useShortest, struct FScriptDelegate endCallback );
	void PlayReplicatedAnimations ( );
	bool StopReplicatedAnimation ( unsigned char replicatedAnimID );
	bool PlayReplicatedAnimation ( unsigned char replicatedAnimID, float playRateFactor );
	void StartReplicatedAnimation ( unsigned char replicatedAnimID, float playRateFactor, unsigned long ignoreDBNO );
	void OnSprintModifierReplicated ( );
	void OnZoomModifierReplicated ( );
	void OnCoverModifierReplicated ( );
	void OnCrouchModifierReplicated ( );
	void OnSubstateReplicated ( unsigned char oldSubstate );
	void OnMainStateReplicated ( unsigned char oldMainState, unsigned char oldSubstate );
	void ApplyReplicatedSprintModifier ( );
	void ApplyReplicatedZoomModifier ( );
	void ApplyReplicatedCoverModifier ( );
	void ApplyReplicatedCrouchModifier ( );
	void ApplyReplicatedPawnState ( );
	void NotifyMirrored ( unsigned long mirrored );
	bool IsPeekPosture ( unsigned char posture );
	float GetPeekSpeedModifier ( unsigned char fromPosture, unsigned char toPosture );
	bool IsMirrored ( );
	unsigned char GetCurrentPosture ( );
	bool StopAnimationsByPriority ( unsigned char Priority );
	bool StopAllAnimations ( );
	bool FinishPostureTransition ( );
	bool GetUpcomingMirroredFlag ( );
	bool IsDoingMirrorTransition ( );
	bool PostureTransitionOutsideTimeSegment ( float StartOffset, float EndOffset );
	bool PostureTransitionIsInsideTimeSegment ( float StartOffset, float EndOffset );
	bool IsInPostureTransition ( unsigned char* rotatingBetweenPostures, unsigned char* postureTransitionAnimation, unsigned char* allowMovement );
	bool CustomPostureTransition ( unsigned char fromPosture, unsigned char toPosture );
	class UAnimNodeSequence* GetAnimNodeSequence ( struct FYS_AnimID animID );
	void GetAnimNodeSequences ( struct FYS_AnimID animID, TArray< class UAnimNodeSequence* >* animNodeSequences );
	bool ChangeBlendoutTime ( struct FYS_AnimID animID, float NewBlendOutTime );
	bool IsAnimationPlaying ( struct FYS_AnimID animID );
	void GetPlayingAnimations ( TArray< struct FYS_AnimID >* animIDs );
	bool ReplaceAnimation ( struct FYS_AnimID animID, struct FYS_AnimID withAnimID, struct FScriptDelegate animEndCallback );
	bool StopAnimation ( struct FYS_AnimID animID, unsigned long CallAnimEndCallbacks, unsigned long forceSynchGroupReset );
	bool PlayDynamicAnimation ( unsigned long looped, unsigned char mirrorMode, struct FScriptDelegate animEndCallback, float BlendTime, float BlendOutTime, float playRateFactor, unsigned long ignoreRootMotion, struct FYS_AnimID* animID, struct FYS_AnimInfo* AnimInfo );
	bool CanPlayWeaponSwitchAnimation ( unsigned long equip );
	bool PlayWeaponSwitchAnimation ( unsigned long equip, struct FScriptDelegate animEndCallback, unsigned long forceBlendInTime, struct FYS_AnimID* outAnimID );
	bool PlayAnimation ( struct FYS_AnimID animID, unsigned long looped, struct FScriptDelegate animEndCallback, float BlendTime, float BlendOutTime, float playRateFactor, unsigned long ignoreRootMotion );
	bool CanPlayDynamicAnimation ( struct FYS_AnimInfo* AnimInfo );
	bool CanPlayAnimation ( struct FYS_AnimID animID );
	unsigned char GetAnimPriorityFromChannel ( unsigned char channelID );
	void ClearAnimEndCallbacks ( );
	void OnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void ResetToRootBonePosition ( unsigned long ResetLocation, unsigned long ResetRotation, unsigned long updateMesh );
	bool RootOffsetBiggerThan ( float Offset );
	void SetZeroRootOffset ( unsigned long updateMesh );
	void TestZeroRootOffset ( );
	void GetRootOffset ( class UAnimSequence* Seq, float Time, struct FVector* LocationOffset, struct FRotator* RotationOffset );
	struct FRotator GetRootMotionRotation ( class UAnimSequence* Seq, float fromTime, float toTime );
	struct FVector GetRootMotionFromAnimID ( struct FYS_AnimID animID );
	struct FVector GetRootMotion ( class UAnimSequence* Seq, float fromTime, float toTime );
	float GetAnimPlaybackLength ( class UAnimSequence* Seq );
	class UAnimSequence* GetAnimSequenceFromID ( struct FYS_AnimID animID );
	int GetAnimSequencesFromID ( struct FYS_AnimID animID, TArray< class UAnimSequence* >* animSequences );
	class UAnimSequence* GetFirstAnimSequenceFromID ( struct FYS_AnimID animID );
	bool GetAnimPropertiesFromID ( struct FYS_AnimID animID, unsigned long ignoreMirrorMode, struct FYS_AnimProperties* animProperties );
	void GetAnimProperties ( class UAnimSequence* Seq, struct FYS_AnimProperties* animProperties );
	void OnTossWeapon ( );
	void GetWeaponHandVelocities ( struct FVector* LinVel, struct FVector* AngVel );
	void TestSmallHitReactions ( );
	void TestBigHitReactions ( );
	void HitReactionAnimFinished ( );
	void ResetHitReactionFirstHit ( );
	void RagRecoveryFailed ( );
	unsigned char CheckGetUp ( );
	void StartRagRecoveryToAnimDrivenDBNO ( );
	void StartRagRecoveryToNormalOrDBNOMainState ( );
	void CheckGetUpToAnimDrivenDBNO ( );
	void CheckGetUpToNormalOrDBNOMainState ( );
	void StartRagdollTimers ( unsigned long recoverToAnimDrivenDBNO );
	void ClearRagdollTimers ( );
	struct FVector GetImpactPhysicsTorque ( class UClass* DamageType, struct FVector HitLoc, struct FVector Momentum );
	struct FVector GetImpactPhysicsImpulse ( class UClass* DamageType, struct FVector HitLoc, struct FVector Momentum, unsigned long isExplosion, unsigned long bIsHitReaction, struct FTraceHitInfo* OutHitInfo );
	void YCheckHitInfo ( class UPrimitiveComponent* FallBackComponent, struct FVector Dir, struct FTraceHitInfo* HitInfo, struct FVector* out_HitLocation );
	void OnPhysicalImpactBlendingFinished ( );
	struct FName GetPhysicsImpactRemappedBone ( struct FName InBoneName );
	void StartKillHumanShieldPhysicsBlend ( float BlendTime );
	void DelayedStartKillHumanShieldPhysicsBlend ( );
	void StartExecutionPhysicsBlend ( float BlendTime );
	void RagdollDiedByFalling ( );
	void OnStumbled ( unsigned long recoverToAnimDrivenDBNO, unsigned long replicate );
	void PrepareForStumble ( );
	void TurnToRagdoll ( unsigned long matchAnimation );
	class UYAnimtreeManager* GetAnimTreeManager ( );
	void SetHighRagdollDamping ( );
	void DisableRagdollPhysicsComponents ( );
	void SetupPhysicsComponentsForRagdoll ( unsigned long immediately );
	void SetupFullDeathRagdoll ( unsigned long updateRBBodies );
	void SetupPhysicsForDeathAnimPlayback ( );
	void TimedFullDeathRagdoll ( );
	void OnBlendToDeathRagdoll ( class UYSeqAct_BlendToDeathRagdoll* act );
	void DisableJointDrives ( );
	void OnFinishedDeathAnim ( unsigned long doGC );
	void GetGrenadeMomentumAndBone ( struct FVector* Momentum, struct FTraceHitInfo* HitInfo );
	struct FVector GetRBMeshVelocity ( );
	void PlaySimpleRagdollDeath ( class UClass* DamageType, struct FVector HitLoc, struct FVector Momentum, unsigned long addForces );
	void SetBoneSpringStrengthScale ( float Scale );
	void SetJointMotorStrengthScale ( float Scale );
	void SetJointMotorState ( unsigned char NewState );
	void InitBoneStateFromLastBoneTransformsForSet ( float DeltaTime, TArray< struct FMatrix >* lastTransforms, TArray< struct FMatrix >* currentTransforms, struct FMatrix* lastLocalToWorld, struct FMatrix* currentLocalToWorld );
	void InitBoneStateFromLastBoneTransforms ( );
	void UpdateLastBoneTransformsForSet ( TArray< struct FMatrix >* transforms, float* worldTime, struct FMatrix* LocalToWorld );
	void UpdateLastBoneTransforms ( );
	void SetDeathDBNOPostRecoveryState ( );
	void SetNonRagdollState ( );
	void CreateBloodPool ( );
	void KillRagdolledPawn ( class UClass* DamageType, struct FVector HitLoc, struct FVector Momentum, unsigned long showReaction, unsigned long addJerk );
	void DisableRagdollGravity ( );
	void OnSpecialMoveDeathAnimFinished ( );
	bool CheckSpecialRagdollDeathAnim ( unsigned char specialMoveBeforeDeath );
	unsigned char GetDeathAnimHint ( );
	void PlayDeath ( class UClass* DamageType, struct FVector HitLoc, unsigned long isRetriggeringDueToDeathAnimTriggerFailed );
	bool IsPlayingBlockingCustomAnimation ( );
	bool ShouldGoDirectlyToRagdoll ( class UClass* dmgType );
	bool CanUseDeathAnimTrigger ( );
	bool CanPlayHitReactionAnim ( unsigned long checkPosture );
	bool CanPlayDeathAnim ( unsigned long checkPosture );
	void ServerTestMelee ( );
	void TestMelee ( );
	void TestMeleeDelayed ( float Delay );
	void TestRag ( );
	void StartMuscleStrengthFading ( float Target, float FadeTime );
	void StartMuscleFading ( );
	void SetMuscleFading ( float Target, float FadeTime, float StartTime, float StartValue );
	void SetJointLimitScaling ( float Target, float BlendTime, float StartValue );
	void BlendToFullPhysics ( float BlendTime );
	void StartPhysicsWeightBlend ( );
	void SetPhysicsWeightBlendTarget ( float Target, float BlendTime, float StartValue, float StartTime );
	bool IsAIUnconscious ( );
	bool IsRecovering ( );
	bool IsInRagdoll ( );
	void InitPhysicalObjects ( );
	void SetPushesRigidBodies ( unsigned long NewPush );
	void UpdateEffectTriggerLocations ( );
	void DestroyCollisionEffectTriggers ( );
	void EnableEffectTriggers ( unsigned long Enable );
	void CreateEffectTriggers ( );
	void UpdatePushdownForce ( );
	void OnOuterExplosion ( float Dist, struct FVector Loc, float explRadius, float explDamage, float sfxDuration );
	void OnInnerExplosion ( float Dist, struct FVector Loc, float explRadius, float explDamage, float sfxDuration );
	void UpdateDangerousFlyBys ( float dt );
	void UpdateFlyBySensor ( float dt );
	void OnExplosion ( struct FVector Loc, float Dist, float Damage, float Radius, float sfxDuration );
	void AddExplosionInfo ( struct FVector HitLoc, float Radius, float Strength, float sfxDuration );
	void SetRecoilInfoFromWeapon ( class AYWeapon* myWeapon );
	void PlayRecoil ( );
	void ToggleRaiseWeaponTesting ( );
	void StopRaiseWeaponAnimation ( unsigned char raiseWeaponAnimation );
	void PlayRaiseWeaponAnimation ( unsigned char raiseWeaponAnimation );
	bool IsWeaponRaised ( );
	void ServerRaiseWeapon ( unsigned char newRaiseState );
	void ClientRaiseWeapon ( unsigned char newRaiseState );
	void RaiseWeapon ( unsigned char newRaiseState );
	void UpdateRaiseWeapon ( );
	bool IsAttemptingToShootThroughWallAsync ( struct FVector muzzlePosition, struct FRotator muzzleRotation );
	bool IsAttemptingToShootThroughWallInstantly ( struct FVector muzzlePosition, struct FRotator muzzleRotation );
	void GetMuzzleLocation ( struct FVector* Loc, struct FRotator* rotat );
	struct FVector GetWeaponStartTraceLocation ( class AWeapon* CurrentWeapon );
	void UpdateWeaponStartTraceLocation ( );
	void ReequipCurrentWeapon ( );
	void HookUpCurrentWeapon ( );
	void tgt4 ( );
	void tgt3 ( );
	void ThrowGrenadeRegisterCallback ( struct FScriptDelegate deleg );
	void ThrowGrenadeForAI ( unsigned char throwMode, struct FScriptDelegate deleg );
	struct FVector GetGrenadeSpawnLocation ( unsigned char throwMode );
	void UpdateGrenadeAnim ( );
	void StopRunningGrenadeAnim ( );
	void CheckGrenadeHoldingAnimation ( unsigned long intoCrouch );
	void PlayGrenadeLongOutAnim ( );
	void PlayGrenadeLongThrowAnim ( );
	void PlayGrenadeLongIdleAnim ( );
	void OnThrowGrenade ( class AYProj_Physical* SpawnedProjectile );
	bool GetGrenadeLongThrowAnimID ( struct FYS_AnimID* throwAnimID, unsigned char* animStyle );
	bool GetGrenadeThrowIdleAnimID ( struct FYS_AnimID* idleAnimID, unsigned char* animStyle );
	bool PlayGrenadeThrowingAnimation ( unsigned char nextStage, unsigned long testOnly );
	bool GetGrenadeThrowAnimID ( struct FYS_AnimID* tossAnimId, struct FYS_AnimID* intoAnimID, unsigned char* animStyle );
	bool IsOnZipline ( );
	void GetIntoCoverStates ( unsigned char* mSt, unsigned char* sSt );
	bool GetCrouchedCoverGrenadeAnimID ( struct FYS_AnimID* tossAnimId, struct FYS_AnimID* intoAnimID );
	unsigned char GetGrenadeDirectionInCover ( );
	bool WantsToThrowGrenadeWhileAiming ( );
	bool IsThrowingGrenade ( );
	void ClientPlayGrenadeThrowAnimation ( );
	void OnEndReactionAnimation ( );
	void OnStartReactionAnimation ( );
	void OnEndCommandAnimation ( );
	void OnStartCommandAnimation ( );
	void OnEndDisarmExplosiveAnimation ( );
	void OnStartDisarmExplosiveAnimation ( );
	void OnEndPlaceExplosiveAnimation ( );
	void OnStartPlaceExplosiveAnimation ( );
	void OnEndHackComputerAnimation ( );
	void OnStartHackComputerAnimation ( );
	void OnEndRepairVitalPointAnimation ( );
	void OnStartRepairVitalPointAnimation ( );
	void OnEndCallChopperAttackAnimation ( );
	void OnStartCallChopperAttackAnimation ( );
	void OnEndMarkBaseAnimation ( );
	void OnStartMarkBaseAnimation ( );
	void OnEndDropGoldAnimation ( );
	void OnStartDropGoldAnimation ( );
	void OnEndThrowGrenade ( );
	void StopEquipScndModeAnimation ( );
	bool PlayEquipScndModeAnimation ( unsigned long testOnly, float* AnimLength );
	void OnEndEquipScndMode ( );
	void CheckForUnhandledNotifies ( unsigned char Reason );
	void OnReequipWeaponByAnimNotify ( unsigned char Reason );
	void OnAnimNotifyShowGrenade ( unsigned long shown );
	void OnFinishTacticalReload ( );
	void OnAnimNotifyHolsterWeapon ( unsigned long showGrenade );
	void OnEndRaiseGrenade ( );
	bool PlayFiringAnimation ( struct FYS_AnimID animID, unsigned char endCallback );
	float GetReloadAnimDuration ( unsigned long Looping, unsigned long endAnim );
	void ServerStopReloadAnimation ( );
	void ServerReloadWeapon ( );
	void CheckReenableAimOutAfterWeaponFunction ( );
	void CheckAimOutInterruptedByWeaponFunction ( );
	void OnEndReloadWeapon ( );
	void OnFinishReloadEndAnimation ( );
	void OnFinishReloadAnimation ( );
	void OnStartReloadWeapon ( );
	void StopSingleShellReload ( );
	bool ForceReloadWeapon ( );
	bool CanReload ( );
	bool CheckReloadWeapon ( );
	void StopReloadWeapon ( );
	bool ReloadWeapon ( );
	void OnEndRefireAnimation ( );
	void PlayRefireAnim ( );
	float GetReloadWeaponPlayRateFactor ( );
	void OnChangeWeapon ( );
	void ServerChangeWeaponByCategory ( unsigned char newCategory );
	void ServerCircleWeaponArsenal ( unsigned long upDown );
	bool CircleWeaponArsenal ( unsigned long upDown );
	void OnStopFire ( );
	void OnStartFire ( );
	bool IsFiringWeapon ( );
	void ServerSetFiring ( unsigned long newIsFiring );
	void SetWantsToFire ( unsigned long newWantsToFire );
	void ServerSetWantsToFire ( unsigned long newWantsToFire );
	void ClientSetWantsToFire ( unsigned long newWantsToFire );
	bool SpecialMovePreventsSecondaryWeaponFire ( );
	bool UpdateMayFireWeaponInternal ( unsigned char* canChangeToBlindfire, unsigned char* canChangeToAimOut, unsigned char* zoomWithoutFire );
	void UpdateMayFireWeapon ( );
	bool MayFireWeapon ( unsigned char* canChangeToBlindfire, unsigned char* canChangeToAimOut, unsigned char* zoomWithoutFire );
	void OnWeaponFired ( );
	void DoKismetAttachment ( class AActor* Attachment, class USeqAct_AttachToActor* Action );
	void OnDestroy ( class USeqAct_Destroy* Action );
	void DespawnPawn ( class UYSeqAct_DespawnPawn* seqAct );
	void Coop_ScriptedDeath ( );
	void ScriptedDeath ( );
	class AYDeathAnimTrigger* GetCurrentDeathAnimTrigger ( );
	void DestroyPawn ( );
	void DestroyPawnNow ( );
	void DestroyPawnAfterMaxMPLifeSpan ( );
	void PlayDying ( class UClass* DamageType, struct FVector HitLoc );
	bool Died ( class AController* Killer, class UClass* DamageType, struct FVector HitLocation );
	void KilledBy ( class APawn* EventInstigator );
	void UnPossessed ( );
	void DelayedCaptorReleaseKilledHumanShield ( );
	void DelayedCaptorReleaseHumanShield ( );
	void DestroyAllAttachments ( );
	bool YDied ( class AController* Killer, class UClass* DamageType, struct FVector HitLocation, unsigned char dbnoExitCondition, unsigned long killedByHeadshot, unsigned long makesHeadExplode, float lastTakenDamage, struct FVector Momentum );
	void OnSetForcedVaporizationType ( class UYSeqAct_SetForcedVaporizationType* Action );
	void DeathFadeTimer ( );
	void StartDeathFadeTimer ( );
	bool CheckForDeathDBNO ( );
	void OnMoveToPosFailed ( );
	void DoMoveToActorPosSpecialMove2 ( struct FVector* Loc, struct FRotator* Rot );
	void DoMoveToActorPosSpecialMove ( class AActor* TargetActor );
	void PlayerChangedTeam ( );
	void Destroyed ( );
	void ModifyHealth ( class UYSeqAct_GiveHealth* Action );
	void OnGiveHealth ( class UYSeqAct_GiveHealth* act );
	void IncreaseTemporaryMaxHealth ( float incValue );
	void inchealth ( float incValue );
	void UpdateHealthBar ( float DeltaTime );
	void ApplyToHealth ( float percentage );
	void InitHitSockets ( );
	void SetSoundCueOnAudioComponent ( class UYSoundCueFMOD* Cue, class UAudioComponent* AC );
	void UpdateEffortAudioComponentSound ( );
	void SetPendingEffortStatus ( unsigned long immediately );
	void ApplyMovementStateChangeToEffortStatus ( );
	void ChangeEffortStatus ( unsigned char NewStatus );
	void ForceIdleEffortStatus ( );
	void ForceSprintEffortStatus ( );
	void TimedUnblockEffortStatusBySpeakline ( );
	void UnblockEffortStatusBySpeakline ( );
	void BlockEffortStatusBySpeakline ( );
	void CreateEffortAudioComponent ( );
	void InitEffortStatusSystem ( );
	void InternalInitHealthSystem ( float healthPercentage );
	void InitializeHealthSystem ( float Pct );
	void InitHealthSystem ( );
	void PlayHit ( float Damage, class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, struct FVector Momentum, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void AddVelocity ( struct FVector NewVelocity, struct FVector HitLocation, class UClass* DamageType, struct FTraceHitInfo HitInfo );
	void ResetZoom ( );
	void IsStunnedInformServer ( unsigned long stunned );
	void ClientPlayStunnedEffect ( int Damage );
	void PlaySpecialActionOnNearbyPawn ( unsigned char SpecialAction, float rad, class AYGamePawn* Pawn, class AYGamePawn* excludedPawn, unsigned long teamOnly, struct FVector Loc, unsigned long findClosest, unsigned long enemyOnly, float Delay );
	void PlaySpecialActionOnNearbyPawnEvent ( unsigned char SpecialAction, float rad, class AYGamePawn* Pawn, class AYGamePawn* excludedPawn, unsigned long teamOnly, struct FVector Loc, unsigned long findClosest, unsigned long enemyOnly, float Delay );
	void GrenadeImpactImminent ( struct FVector Loc, float rad, unsigned char grenadeType );
	unsigned char GetGrenadeSpecialActionSetType ( unsigned char grenadeType );
	void DestroyDeadPawns ( );
	void ResetIdleTimers ( );
	void ClearSlomoTimers ( );
	void ResetSlomo ( );
	void StartSlomo ( );
	void EnableSlomo ( class AController* slomoInstigator, unsigned char EventType );
	void UpdateDeathStats ( class AController* Killer );
	void ClearHitFaceFXRegister ( );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	bool isHoldingGrenade ( );
	void TakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool IsIDAApplying ( class UClass* dtype );
	void OnSetInstantDeathAvoidance ( class UYSeqAct_SetInstantDeathAvoidance* Action );
	void DisableIDA ( );
	void ReenableIDA ( float percentage );
	void PlayHitByExplosionReaction ( class AActor* DamageCauser );
	void NotifyZiplineTraverseEnd ( );
	void OnAllyKilled ( );
	void StartDiedSpecialAction ( class AController* InstigatedBy );
	void PreparePawnKill ( class AController* InstigatedBy, class UClass* YDamageType, struct FVector Momentum );
	bool WasLastDamagedByDBNO ( );
	bool WasLastDamageWhileDBNO ( );
	bool IsLastDamageAHeadShot ( );
	void DecreaseStickyGrenadeCount ( );
	void SetLastDamageInfoForProjectile ( class AYProj_Physical* CausingProjectile );
	void SetLastDamageInfoForWeapon ( class AYGamePawn* InstigatorPawn, class AYWeapon* CausingWeapon );
	void SetLastDamageInfo ( class AYGamePawn* InstigatorPawn, class AActor* DamageCauser, class UClass* YDamageType, struct FTraceHitInfo HitInfo );
	bool CheckAndApplyMortarDamage ( class UClass* DamageType );
	bool IsIgnoringDamage ( );
	void IncrementDamageStats ( int Damage, class UClass* YDamageType, class AController* InstigatedBy, class AActor* DamageCauser, struct FName BoneName );
	bool IsVaultingOverCover ( );
	TArray< struct FName > GetAimOffsetProfileNames ( );
	void RemAdditionalAimingSetInternal ( class AActor* Requestor, struct FYS_AimingSet aimingSet );
	void RemAdditionalAimingSets ( class AActor* Requestor, TArray< struct FYS_AimingSet > aimingSets );
	void RemAdditionalAimingSet ( class AActor* Requestor, struct FYS_AimingSet aimingSet );
	void AddAdditionalAimingSetInternal ( class AActor* Requestor, struct FYS_AimingSet aimingSet );
	void AddAdditionalAimingSets ( class AActor* Requestor, TArray< struct FYS_AimingSet > aimingSets );
	void AddAdditionalAimingSet ( class AActor* Requestor, struct FYS_AimingSet aimingSet );
	void InitAimingSystem ( );
	TArray< struct FName > GetAnimSequenceNames ( );
	void RemAdditionalAnimSetInternal ( class UObject* Requestor, struct FYS_AnimSet remAnimSet );
	void RemAdditionalAnimSets ( class UObject* Requestor, TArray< struct FYS_AnimSet > remAnimSets );
	void RemAdditionalAnimSet ( class UObject* Requestor, struct FYS_AnimSet remAnimSet );
	void AddAdditionalPistolAnimSetInternal ( class UObject* Requestor, struct FYS_AnimSet newAnimSet, unsigned char Priority );
	void AddAdditionalAnimSetInternal ( class UObject* Requestor, struct FYS_AnimSet newAnimSet, unsigned char Priority );
	void AddAdditionalPistolAnimSets ( class UObject* Requestor, TArray< struct FYS_AnimSet > newAnimSets, unsigned char Priority );
	void AddAdditionalAnimSets ( class UObject* Requestor, TArray< struct FYS_AnimSet > newAnimSets, unsigned char Priority );
	void AddAdditionalAnimSet ( class UObject* Requestor, struct FYS_AnimSet newAnimSet, unsigned char Priority );
	void InitAnimSetSystem ( );
	void DirtyAnimationAndAnimSet ( );
	void TurnOff ( );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void SetCurrentGrenade ( class UClass* grenadeClass );
	void CheckWeaponAttachmentStatus ( );
	void SetCurrentWeapon ( class AYWeapon* wp );
	void SetMyController ( class AController* C, unsigned long checkForNone );
	void InitWeaponAttachments ( );
	void InitWeaponSystem ( );
	void InitFootPlacement ( );
	void DetermineMaterialsBelowFeet ( unsigned long needImmediateCheck );
	void SetMaxStepHeight ( float newMaxStepHeight );
	struct FVector CheckForLedges ( struct FVector accelDir, struct FVector Delta, struct FVector gravDir );
	struct FVector2D GetBanking ( );
	void UpdateBanking ( float DeltaTime );
	void UpdateSecondaryCylinder ( float DeltaTime );
	struct FVector GetPawnVelocity ( );
	float GetPawnSpeed2D ( );
	float GetPawnSpeed ( );
	float GetMaxSpeed ( unsigned char movementDirection, unsigned long inCover, unsigned long Crouched, unsigned long sprinting, unsigned long Walking, unsigned long combatSprinting, unsigned long aiming );
	float GetMaxSpeedModifier ( unsigned long inCover, unsigned long Crouched, unsigned long sprinting, unsigned long combatSprint, unsigned long Walking, unsigned long aiming, struct FVector* pawnVelocity, struct FVector* pawnAcceleration );
	void UpdateMovementSpeedRatios ( unsigned char movementSpeed, struct FName animNameFwd, struct FName animNameBwd, struct FName animNameLeft, struct FName animNameRight );
	void GetSpeedConstraints ( TArray< float >* Constraints );
	void UpdateSpeedConstraints ( );
	void InitFaceFXRegister ( );
	void InitAnimSystem ( );
	void UnTouch ( class AActor* Other );
	void Touch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void InitPawnPhysicsSystem ( );
	void ClientRestart ( );
	void SetSkeletalMesh ( class USkeletalMesh* NewMesh );
	void OnSetMesh ( class USeqAct_SetMesh* Action );
	void InitMeshPhysics ( );
	void InitSecondaryCylinder ( );
	void InitReflectionChannel ( );
	void ServerHidePDA ( );
	void ServerShowPDA ( );
	void ServerHideBlowtorch ( );
	void stopBlowtorchEffects ( );
	void playBlowtorchEffects ( );
	void ServerShowBlowtorch ( );
	void ServerAddDBNOWeapon ( class UClass* classToSpawn );
	void InitMaterialInstances ( );
	void InitAimingAndAnimSet ( );
	void ClientInitAimingAndAnimSet ( );
	void InitPawnPerk ( );
	bool SetupDynamicAnimationRestrictions ( class AController* C );
	bool ShouldInitAimingAndAnimSetsStatically ( );
	void PostSetSkeletalMesh ( class USkeletalMeshComponent* SkelComp );
	void ClearAIAnimationInfos ( );
	void PostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void DelayedInitPawn ( );
	void PostScriptDestroyed ( );
	void StartDelayedInitializationTimer ( );
	void InitSilhouetteMaterials ( );
	void YDropToGround ( );
	void PostBeginPlay ( );
	void OnSpawnedByFactory ( class UYSeqAct_AIFactory* Factory );
	void DisableViewAcceleration ( );
	void EnableViewAcceleration ( );
	void SpawnAndAttachAttractionActor ( );
	struct FYS_AnimInfo GetAnimInfo ( struct FYS_AnimID animID );
	void SingleDamageItem ( int Damage, class UClass* dmgTypeClass, struct FVector* Momentum, struct FVector* Position, struct FTraceHitInfo* HitInfo );
	bool FindNearestPositionInAiMesh ( struct FVector checkPos, float CheckRadius, struct FVector* posInMesh );
	void ReplicateShyfflrClass ( class UClass* classToReplicate );
	float GetBestMeleeAttackDistance ( class AYGamePawn* meleeTarget );
	float GetMaxRotationSpeed ( );
	void SetHoldingGrenade ( unsigned long isHoldingGrenade );
	void SpawnAttachment ( class UStaticMesh* attachmentMesh, struct FName BoneName, unsigned long mayBeShotOff );
	void GrenadeThrowEnded ( );
	void ExecCommandDelegate ( );
	void OnSpecialActionFinished ( class UYSpecialActionsDefinition* finishedSpecialAction, unsigned long hasBeenStopped );
	void OnSpeakLineFinished ( );
	void StopSpecialMoveCallback ( unsigned long Success );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYGamePawn::pClassPointer = NULL;

// Class SRGame.YGamePawn_Menu
// 0x0000 (0x21B4 - 0x21B4)
class AYGamePawn_Menu : public AYGamePawn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1637 ];

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	void PostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void PostBeginPlay ( );
};

UClass* AYGamePawn_Menu::pClassPointer = NULL;

// Class SRGame.YGamePawn_Player
// 0x04E0 (0x2694 - 0x21B4)
class AYGamePawn_Player : public AYGamePawn
{
public:
	struct FYS_DeathAnimationLists                     m_deathAnimations;                                		// 0x21B4 (0x01F8) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FYS_HitReactionAnimationLists               m_hitReactionAnimationsSmall;                     		// 0x23AC (0x0174) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FYS_HitReactionAnimationLists               m_hitReactionAnimationsBig;                       		// 0x2520 (0x0174) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1638 ];

		return pClassPointer;
	};

	void ShowDamageFeedback ( int DamageAmount, class AActor* DamageInstigator, class AActor* damageSource, class UClass* DamageType, struct FVector HitLoc, struct FVector Momentum );
	void PlayHit ( float Damage, class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, struct FVector Momentum, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
};

UClass* AYGamePawn_Player::pClassPointer = NULL;

// Class SRGame.YPawn_Infantry
// 0x0074 (0x2708 - 0x2694)
class AYPawn_Infantry : public AYGamePawn_Player
{
public:
	float                                              m_wtFirstDamageTime;                              		// 0x2694 (0x0004) [0x0000000000000000]              
	float                                              m_wtLastDamageTime;                               		// 0x2698 (0x0004) [0x0000000000000000]              
	int                                                m_wtLastDamage;                                   		// 0x269C (0x0004) [0x0000000000000000]              
	int                                                m_wtTotalDamage;                                  		// 0x26A0 (0x0004) [0x0000000000000000]              
	struct FYS_ShotsRecorder                           m_myShotsRecorder;                                		// 0x26A4 (0x0064) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1639 ];

		return pClassPointer;
	};

	void TakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void DebugPostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void NativePostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void PostBeginPlay ( );
	void RenderShotsSequenceInfos ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void ResetShotsSequence ( );
	void RecordShotFired ( unsigned long bIsHit, float fAtTime, float Duration );
};

UClass* AYPawn_Infantry::pClassPointer = NULL;

// Class SRGame.YPawn_Civilian
// 0x0004 (0x270C - 0x2708)
class AYPawn_Civilian : public AYPawn_Infantry
{
public:
	unsigned long                                      m_isAggressive : 1;                               		// 0x2708 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1640 ];

		return pClassPointer;
	};

	void TakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void InitAnimSystem ( );
	void InitReflectionChannel ( );
};

UClass* AYPawn_Civilian::pClassPointer = NULL;

// Class SRGame.YPawn_Enemy
// 0x0000 (0x2708 - 0x2708)
class AYPawn_Enemy : public AYPawn_Infantry
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1641 ];

		return pClassPointer;
	};

	void InitReflectionChannel ( );
};

UClass* AYPawn_Enemy::pClassPointer = NULL;

// Class SRGame.YPawn_EnemyElite
// 0x0008 (0x2710 - 0x2708)
class AYPawn_EnemyElite : public AYPawn_Enemy
{
public:
	float                                              m_lowHealthBarrier;                               		// 0x2708 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UPhysicsAsset*                               m_lowHealthPhysicsAsset;                          		// 0x270C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1642 ];

		return pClassPointer;
	};

	void TakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
};

UClass* AYPawn_EnemyElite::pClassPointer = NULL;

// Class SRGame.YPawn_Commando
// 0x0000 (0x2710 - 0x2710)
class AYPawn_Commando : public AYPawn_EnemyElite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1643 ];

		return pClassPointer;
	};

};

UClass* AYPawn_Commando::pClassPointer = NULL;

// Class SRGame.YPawn_HeavyTrooper
// 0x0018 (0x2728 - 0x2710)
class AYPawn_HeavyTrooper : public AYPawn_EnemyElite
{
public:
	TArray< class UClass* >                            m_reactionCauser;                                 		// 0x2710 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< class UClass* >                            m_armorDamagers;                                  		// 0x271C (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1644 ];

		return pClassPointer;
	};

	void VaporizeHead ( struct FVector Momentum, class UClass* dmgType );
	void Vaporize ( struct FVector Momentum, class UClass* dmgType );
	float GetBestMeleeAttackDistance ( class AYGamePawn* meleeTarget );
};

UClass* AYPawn_HeavyTrooper::pClassPointer = NULL;

// Class SRGame.YPawn_EnemySniper
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemySniper : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1645 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemySniper::pClassPointer = NULL;

// Class SRGame.YPawn_Multiplayer
// 0x019C (0x28A4 - 0x2708)
class AYPawn_Multiplayer : public AYPawn_Infantry
{
public:
	TArray< struct FYS_AttackerInfo >                  m_lastHits;                                       		// 0x2708 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_EnterCoverTime;                                 		// 0x2714 (0x0004) [0x0000000000000000]              
	int                                                m_TotalCoverTime;                                 		// 0x2718 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_showGoldIcon : 1;                               		// 0x271C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_showBombIcon : 1;                               		// 0x271C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bUnderAdrenalineEffects : 1;                    		// 0x271C (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_bAdrenalineExposedToEnemies : 1;                		// 0x271C (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      m_showScanSilhouette : 1;                         		// 0x271C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_decorateAsKillerForKillCam : 1;                 		// 0x271C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_decorateSelfForKillCam : 1;                     		// 0x271C (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      m_wantsToShowSilhouette : 1;                      		// 0x271C (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_silhouetteSameTeam : 1;                         		// 0x271C (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_isScanning : 1;                                 		// 0x271C (0x0004) [0x0000000000004020] [0x00000200] ( CPF_Net | CPF_Config )
	unsigned long                                      m_nearTacticalExpert : 1;                         		// 0x271C (0x0004) [0x0000000000000020] [0x00000400] ( CPF_Net )
	unsigned long                                      m_bShowTeammatePlayerNames : 1;                   		// 0x271C (0x0004) [0x0000000000004000] [0x00000800] ( CPF_Config )
	unsigned long                                      m_bShowEnemyPlayerNames : 1;                      		// 0x271C (0x0004) [0x0000000000004000] [0x00001000] ( CPF_Config )
	unsigned long                                      m_bOnlyShowAimedPlayerNames : 1;                  		// 0x271C (0x0004) [0x0000000000004000] [0x00002000] ( CPF_Config )
	unsigned long                                      m_bInvincible : 1;                                		// 0x271C (0x0004) [0x0000000000000020] [0x00004000] ( CPF_Net )
	unsigned long                                      m_hasBreacherBuff : 1;                            		// 0x271C (0x0004) [0x0000000000000020] [0x00008000] ( CPF_Net )
	unsigned long                                      m_hasGunnerBuff : 1;                              		// 0x271C (0x0004) [0x0000000000000020] [0x00010000] ( CPF_Net )
	unsigned long                                      m_hasMedicBuff : 1;                               		// 0x271C (0x0004) [0x0000000000000020] [0x00020000] ( CPF_Net )
	unsigned long                                      m_hasOfficerBuff : 1;                             		// 0x271C (0x0004) [0x0000000000000020] [0x00040000] ( CPF_Net )
	unsigned long                                      m_hasScavengerBuff : 1;                           		// 0x271C (0x0004) [0x0000000000000020] [0x00080000] ( CPF_Net )
	unsigned long                                      m_hasSniperBuff : 1;                              		// 0x271C (0x0004) [0x0000000000000020] [0x00100000] ( CPF_Net )
	unsigned long                                      m_hasBreacherPerk : 1;                            		// 0x271C (0x0004) [0x0000000000000020] [0x00200000] ( CPF_Net )
	unsigned long                                      m_hasGunnerPerk : 1;                              		// 0x271C (0x0004) [0x0000000000000020] [0x00400000] ( CPF_Net )
	unsigned long                                      m_hasMedicPerk : 1;                               		// 0x271C (0x0004) [0x0000000000000020] [0x00800000] ( CPF_Net )
	unsigned long                                      m_hasOfficerPerk : 1;                             		// 0x271C (0x0004) [0x0000000000000020] [0x01000000] ( CPF_Net )
	unsigned long                                      m_hasScavengerPerk : 1;                           		// 0x271C (0x0004) [0x0000000000000020] [0x02000000] ( CPF_Net )
	unsigned long                                      m_hasSniperPerk : 1;                              		// 0x271C (0x0004) [0x0000000000000020] [0x04000000] ( CPF_Net )
	unsigned long                                      m_showFootprints : 1;                             		// 0x271C (0x0004) [0x0000000000000020] [0x08000000] ( CPF_Net )
	unsigned long                                      m_desertWarriorSilhouettes : 1;                   		// 0x271C (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      m_seeBehindEnemies : 1;                           		// 0x271C (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      m_ShowFieldOpIcon : 1;                            		// 0x271C (0x0004) [0x0000000000000020] [0x40000000] ( CPF_Net )
	unsigned long                                      m_ShowCombatReadyIcon : 1;                        		// 0x271C (0x0004) [0x0000000000000020] [0x80000000] ( CPF_Net )
	unsigned long                                      m_bCallingForHelp : 1;                            		// 0x2720 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_alwaysShowInTacticalViewWhenFiring : 1;         		// 0x2720 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_disallowStumble : 1;                            		// 0x2720 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_bForceMeleeEnable : 1;                          		// 0x2720 (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	unsigned long                                      m_bMeshesSetUp : 1;                               		// 0x2720 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bStartSniperStealthEffect : 1;                  		// 0x2720 (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned long                                      m_isInvis : 1;                                    		// 0x2720 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bWasInvisible : 1;                              		// 0x2720 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bInvisStarted : 1;                              		// 0x2720 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bInvisCountdown : 1;                            		// 0x2720 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bForceLethalHeadShots : 1;                      		// 0x2720 (0x0004) [0x0000000000004000] [0x00000400] ( CPF_Config )
	float                                              m_teammateFireScanTimer;                          		// 0x2724 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_myDetectionFlags;                               		// 0x2728 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AController*                                 m_lastDamageController;                           		// 0x272C (0x0004) [0x0000000000000000]              
	float                                              m_armorMovePercent;                               		// 0x2730 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_armorReductionPercent;                          		// 0x2734 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UYSoundCueFMOD*                              m_scanDeviceOffSound;                             		// 0x2738 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_maxDistanceForName;                             		// 0x273C (0x0004) [0x0000000000004000]              ( CPF_Config )
	class AYEmitter*                                   m_invincibilityEmitter;                           		// 0x2740 (0x0004) [0x0000000000000000]              
	class UParticleSystem*                             m_invincibilitySystem;                            		// 0x2744 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_LastDamageType;                                 		// 0x2748 (0x0004) [0x0000000000000000]              
	struct FColor                                      m_lifeBarBackGroundColor;                         		// 0x274C (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FColor                                      m_lifeBarFrameColor;                              		// 0x2750 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FColor                                      m_lifeBarColor;                                   		// 0x2754 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maxDistanceForLifeBar;                          		// 0x2758 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_currentFootStepIndex;                           		// 0x275C (0x0004) [0x0000000000000000]              
	float                                              m_footPlacementInterval;                          		// 0x2760 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UYPerk_Major*                                m_MajorPerk;                                      		// 0x2764 (0x0004) [0x0000000000000000]              
	class UYPerk*                                      m_MinorPerk[ 0x3 ];                               		// 0x2768 (0x000C) [0x0000000000000000]              
	float                                              m_breacherExplosiveDamageMultiplier;              		// 0x2774 (0x0004) [0x0000000000000000]              
	float                                              m_gunnerDamageAddend;                             		// 0x2778 (0x0004) [0x0000000000000000]              
	float                                              m_medicRegenRateMultiplier;                       		// 0x277C (0x0004) [0x0000000000000000]              
	float                                              m_officerDamageReduction;                         		// 0x2780 (0x0004) [0x0000000000000000]              
	float                                              m_officerBuffEffectivnessMultiplier;              		// 0x2784 (0x0004) [0x0000000000000000]              
	float                                              m_scavengerExplosiveRadiusMultiplier;             		// 0x2788 (0x0004) [0x0000000000000000]              
	float                                              m_sniperAccuracyMultiplier;                       		// 0x278C (0x0004) [0x0000000000000000]              
	float                                              m_supplyRefillStandardAmmoCount;                  		// 0x2790 (0x0004) [0x0000000000000000]              
	float                                              m_supplyRefillExplosiveAmmoCount;                 		// 0x2794 (0x0004) [0x0000000000000000]              
	float                                              m_supplyRefillSAWAmmoCount;                       		// 0x2798 (0x0004) [0x0000000000000000]              
	struct FString                                     m_SpecOpsGunnerShyfflrClass;                      		// 0x279C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_SpecOpsMedicShyfflrClass;                       		// 0x27A8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_SpecOpsOfficerShyfflrClass;                     		// 0x27B4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_SpecOpsSniperShyfflrClass;                      		// 0x27C0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_SpecOpsBreacherShyfflrClass;                    		// 0x27CC (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_KonradGunnerShyfflrClass;                       		// 0x27D8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_KonradMedicShyfflrClass;                        		// 0x27E4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_KonradOfficerShyfflrClass;                      		// 0x27F0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_KonradSniperShyfflrClass;                       		// 0x27FC (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_KonradScavengerShyfflrClass;                    		// 0x2808 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FVector                                     m_shotDir;                                        		// 0x2814 (0x000C) [0x0000000000000020]              ( CPF_Net )
	float                                              m_defaultRunSpeedMultiplier;                      		// 0x2820 (0x0004) [0x0000000000000000]              
	float                                              m_defaultSprintSpeedMultiplier;                   		// 0x2824 (0x0004) [0x0000000000000000]              
	float                                              m_CallForHelpTimer;                               		// 0x2828 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_friendlyFireOverlapTimer;                       		// 0x282C (0x0004) [0x0000000000000000]              
	float                                              m_enemyOnTacticalVisionTimer;                     		// 0x2830 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_enemyTacticalViewDistance;                      		// 0x2834 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_enemyTacticalViewTimer;                         		// 0x2838 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_rappelSpeedMultiplier;                          		// 0x283C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_coverSpeedMultiplier;                           		// 0x2840 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_coverMovementSpeedMultiplier;                   		// 0x2844 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_reloadInCoverRateMultiplier;                    		// 0x2848 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sprintAnimSpeedMultiplier;                      		// 0x284C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_landingAnimSpeedMultiplier;                     		// 0x2850 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UMaterialInterface*                          m_scanSilhouetteMaterials_DM[ 0x5 ];              		// 0x2854 (0x0014) [0x0000000000000000]              
	float                                              m_lastChatTime;                                   		// 0x2868 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_showChatIconTime;                               		// 0x286C (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UMaterialInstance*                           m_speakingIcon;                                   		// 0x2870 (0x0004) [0x0000000000000000]              
	float                                              m_speakingIconSize;                               		// 0x2874 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_numOfSelfRevivesLeft;                           		// 0x2878 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class USkeletalMeshComponent*                      m_HeadSkelMeshCmp;                                		// 0x287C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class USkeletalMesh*                               m_HeadSkelMesh;                                   		// 0x2880 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_HeadMaterial;                                   		// 0x2884 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_TorsoMaterial;                                  		// 0x2888 (0x0004) [0x0000000000000000]              
	float                                              m_fParamValue;                                    		// 0x288C (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_sniperMatAsset;                                 		// 0x2890 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_sniperMaterial;                                 		// 0x2894 (0x0004) [0x0000000000000000]              
	float                                              m_minimumCoverRatProtection;                      		// 0x2898 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximimCoverRatProtection;                      		// 0x289C (0x0004) [0x0000000000004000]              ( CPF_Config )
	class AYPlayerController_MP*                       m_markedBy;                                       		// 0x28A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1646 ];

		return pClassPointer;
	};

	void OnExecutionMoveEnded ( );
	void ClientRaiseWeapon ( unsigned char newRaiseState );
	void DropToGround ( );
	void OnEndDisarmExplosiveAnimation ( );
	void OnStartDisarmExplosiveAnimation ( );
	void OnEndPlaceExplosiveAnimation ( );
	void OnStartPlaceExplosiveAnimation ( );
	void OnEndHackComputerAnimation ( );
	void OnStartHackComputerAnimation ( );
	void OnEndRepairVitalPointAnimation ( );
	void OnStartRepairVitalPointAnimation ( );
	void OnEndCallChopperAttackAnimation ( );
	void OnStartCallChopperAttackAnimation ( );
	void OnEndMarkBaseAnimation ( );
	void OnStartMarkBaseAnimation ( );
	void OnEndDropGoldAnimation ( );
	void OnStartDropGoldAnimation ( );
	void TakeDownWeapon ( unsigned long delayed );
	void TakeUpWeapon ( unsigned long forShooting );
	void OnC4Defused ( );
	bool PlayAdrenalineInjection ( );
	bool DoRevive ( class AYGamePawn* pawnToRevive, struct FScriptDelegate stopCallback );
	bool DoReviveFromDeath ( class AYGamePawn* pawnToRevive, struct FScriptDelegate stopCallback );
	void TakeFallingDamage ( );
	bool CheckReviveDeadPlayer ( class AYGamePawn** pawnToRevive );
	bool IsForcedVisibleToOtherTeamHUD ( );
	void SniperForceVisibleToOtherTeamHUD ( );
	void ForceVisibleToOtherTeamHUD ( unsigned long isforced );
	bool GetCrosshairColorType ( class AYGamePawn* shootingPawn, unsigned char* colorType );
	void ClientSetNumOfSelfRevivesLeft ( int Num );
	void EndCrouch ( float HeightAdjust );
	void StartCrouch ( float HeightAdjust );
	bool DoStopSprint ( unsigned char moveDir, struct FRotator TargetRotation, unsigned long Crouched, unsigned long doSlide, struct FScriptDelegate stopCallback );
	bool DoStartSprint ( unsigned char moveDir, struct FRotator TargetRotation, unsigned long Crouched, struct FScriptDelegate stopCallback );
	bool ProcessMainState ( unsigned char mainState, unsigned char substate, unsigned long forceMainState, unsigned long disablePostureTransition );
	void Destroyed ( );
	unsigned char GetStanding ( class AYGamePawn* pwn );
	bool CheckForStumble ( float checkDistMoveDir, float checkDistVoid, unsigned long checkVoid, unsigned long checkCustimDirection, struct FVector customDirection );
	void StopLandingAnim ( struct FYS_AnimID playingID );
	struct FYS_AnimID GetHardLandingAnim ( );
	struct FYS_AnimID GetSoftLandingAnim ( );
	float GetLandingAnimSpeedMultiplier ( );
	float GetCombatSprintMaxTime ( );
	float GetSprintAnimSpeedMultiplier ( );
	float GetCoverSpeedMultiplier ( );
	float GetRappelSpeedModifier ( );
	bool AlwaysUpdatePositionForTacView ( );
	void EnableSilhouette ( class UMaterialInterface* Material );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool IsEnabledForTacView ( );
	unsigned char DetermineDBNOSubState ( unsigned long bExcludeRagdollDBNO );
	bool HasHeavyWeaponAmmoLimitation ( );
	bool YDied ( class AController* Killer, class UClass* DamageType, struct FVector HitLocation, unsigned char dbnoExitCondition, unsigned long killedByHeadshot, unsigned long makesHeadExplode, float lastTakenDamage, struct FVector Momentum );
	void InitShyfflr ( );
	int GetMinorPerksSlot ( );
	bool SetMajorPerk ( class UYPerk_Major* newPerk );
	bool HasMajorPerk ( struct FName perkName );
	bool HasMinorPerk ( struct FName perkName );
	bool SetMinorPerk ( class UYPerk* newPerk, int perkSlot );
	bool CanTakePerk ( class UYPerk* perk );
	void ServerUpdateMinorPerkLevels ( int perk1, int perk2, int perk3 );
	void ClientUpdateMinorPerkLevels ( );
	void InitPerks ( );
	void CreatePerks ( );
	void AddPerks ( class UClass* perkClass );
	void ClearPerks ( );
	void ClientAddFakeHit ( float Damage );
	void AddFakeHit ( float Damage );
	void OnCallForHelpOver ( );
	void ServerCallForHelp ( unsigned char YSAST_Call );
	void UpdateAttackerInfo ( class AController* attacker, int Damage, class UClass* DamageType );
	void UpdateInvincibilityFx ( unsigned long isInvincible );
	void DrawSpeakingIcon ( class UCanvas* Canvas, struct FVector headLocation );
	void DrawHealthBar ( class UCanvas* Canvas, struct FVector headLocation );
	void DrawPlayerName ( class APlayerController* PC );
	struct FString GetNameAboveHead ( class AYGamePawn* localPawn );
	void RenderPawnNames ( class APlayerController* PC, class UCanvas* Canvas, struct FVector* CameraPosition, struct FVector* CameraDir );
	void PostRender ( class APlayerController* PC, class UCanvas* Canvas, struct FVector* CameraPosition, struct FVector* CameraDir );
	void DrawYouText ( class APlayerController* PC );
	void PostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void PlayPickupHeavyVoice ( );
	bool PlayReplicatedAnimation ( unsigned char replicatedAnimID, float playRateFactor );
	void UpdateHealthBasedFaceFX ( );
	void RefillAmmoFromSupplyDrop ( float DeltaTime );
	void SkipGamePawn_Multiplayer_Tick ( float DeltaTime );
	void Tick ( float DeltaTime );
	void TickMeshSetup ( class AYPlayerReplicationInfo_MP* pMP_PRI );
	bool HasStartedSniperStealthEffect ( );
	bool CanStartSniperStealthEffect ( );
	void ClientCancelInvisEffect ( );
	void ServerStopSniperStealthEffect ( );
	void FadeInFinished ( );
	void StopSniperStealthEffect ( );
	void FadeOutFinished ( );
	void SetMaterialScalarParameterValue ( struct FName ParmameterName, float fValue );
	void StartSniperStealthEffect ( );
	void SetInvis ( unsigned long bIsInvis );
	void ServerStartSniperStealthEffect ( );
	void OnStartInvisEffect ( );
	bool DontRenderSilhouette ( );
	void NotifyTeamChanged ( );
	void ChangeToMPBotsAnimationRestrictions ( );
	bool SetupDynamicAnimationRestrictions ( class AController* C );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void LoadShyfflr ( unsigned char perkEnum, int TeamNum );
	void InitializeVoiceShyfflr ( class AYGamePawn* P, struct FString shyfflrClass );
	void PostBeginPlay ( );
	void InitializeTacIcons ( );
	void InitSkelMeshComponents ( struct FYS_CharacterMeshAssetList* CMAL );
	void OnJustRespawned ( class AYPlayerController* PC );
	void ClientSetSeeEnemyOnTacticalVision ( unsigned long enemyVision );
	void EnemyVisionTimer ( );
	void UpdateScanStatus ( );
	bool SpecialMovePreventsSecondaryWeaponFire ( );
	bool ReloadWeapon ( );
	void OnEndRaiseGrenade ( );
	void OnWeaponFired ( );
	void UpdateSilhouetteRendering ( );
	bool IsSonarScanning ( );
	class UMaterialInterface* GetSilhouetteMaterial ( );
	bool IsTalking ( );
	void SetShowScanSilhouette ( unsigned long bIsTacticalExpert, unsigned long bUseInfiniteDistance );
	void OnScanEnded ( );
	void MarkAsScannedMP ( class AYPlayerController* PC, unsigned long bScan, unsigned long bForceScan );
	void SetIsNearATacticalExpert ( unsigned long NewState );
	bool IsNearATacticalExpert ( );
	bool IsScanning ( );
	void ClientStartScanning ( int scanTime );
	void SetWasScanned ( unsigned long scanned );
	void EnableTacVision ( class AYPlayerController* PC, unsigned long bEnable );
	bool IsSameTeam ( class APawn* Other );
	void PlayFootStepSound ( int FootDown );
	void LeaveMovementDecal ( struct FVector Loc, struct FRotator Dir, class AActor* HitActor, class UMaterialInstance* Mat );
	void UnPossessed ( );
	float GetRefireRateFactor ( );
	bool HasToHideCrossHair ( );
	float GetReviveAnimationSpeed ( );
	float GetWeaponRaiseAnimSpeed ( );
	float GetWeaponSwitchAnimSpeed ( );
	float GetRecoilModifier ( );
	float GetAccuracyModifier ( );
	void OnThrowGrenade ( class AYProj_Physical* SpawnedProjectile );
	void InternalInitHealthSystem ( float healthPercentage );
	float GetHealthMultiplier ( );
	float GetReloadWeaponPlayRateFactor ( );
	bool IsPawnReadyForWeaponInit ( );
	float GetAmmoMultiplier ( );
	int GetExtraMagazineCount ( );
	float GetGrenadeSpeedMultiplier ( );
	float GetDamageMultiplier ( class UClass* DamageType );
	void OnCauseDamage ( class USeqAct_ModifyHealth* Action );
	void AdjustDamage ( class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, struct FTraceHitInfo HitInfo, int* inDamage, struct FVector* Momentum );
	bool AdjustHeadShotDamage ( class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, struct FTraceHitInfo HitInfo, int* inDamage, struct FVector* Momentum );
	void RestoreRunSpeed ( );
	void MedicHealDamage ( int Amount );
	void OnNotifyAdrenalineInjection ( );
	void UpdateDeathStats ( class AController* Killer );
	void StartAdrenalineBuff ( );
	void AdrenalineBuffOver ( );
	void TakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void EndAdrenalineExposedToEnemies ( );
	void serverShowHitIndicatorForDamageInstigator ( class AYPawn_Multiplayer* InstigatorPawn );
	void clientShowHitIndicatorForDamageInstigator ( );
	bool HurtRadius ( float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, struct FVector HurtOrigin, class AActor* IgnoredActor, class AController* InstigatedByController, unsigned long bDoFullDamage );
	float GetExplosionRangeModifier ( );
	void IncrementDamageStats ( int Damage, class UClass* YDamageType, class AController* InstigatedBy, class AActor* DamageCauser, struct FName BoneName );
	void StartDiedSpecialAction ( class AController* InstigatedBy );
	void InitPawnPerk ( );
	void AddDefaultInventory ( );
	void InitFootPlacement ( );
	void SpawnAnnounce ( );
	void DelayedInitPawn ( );
	bool ShouldInitAimingAndAnimSetsStatically ( );
	void OnAddWeaponToArsenal ( class AYWeapon* NewWeapon );
	void OnRemoveWeaponFromArsenal ( class AYWeapon* NewWeapon );
	bool IsCurrentWeaponLimitedUse ( );
	void OnLeaveCover ( unsigned char lastSubstate );
	void OnEnterCover ( );
	void SetRootHidden ( unsigned long bHide );
	void SetMaterial ( class UMaterialInterface* Mat );
	void ConditionalIncreaseVaultKillProfileStats ( );
	bool DoSpecialMoveStumbleSandBomb ( struct FScriptDelegate stopCallback );
	void HandleMeleeAttack ( class AYGamePawn* attacker, struct FVector Momentum, int Damage, class UClass* DamageType, unsigned long doResetPawn, struct FVector ResetLocation );
	float GetMeleeRange ( );
	bool StopCombatReadyIcon ( );
	void SetShowCombatReadyIcon ( unsigned long show );
	void SetShowFieldOpIcon ( unsigned long show );
	float GetDamageReductionFactor ( );
	int GetStartGrenadeCount ( );
	int GetMaxGrenadeCount ( );
	class UMaterialInterface* CopyMaterial ( class UMaterialInterface* pSrcMaterial );
	float TakeUpWeaponMultiplayer ( float takeUpWeaponBlendTime );
	float GetMaxAmmoPickupMultiplier ( );
	float GetMaxAmmoMultiplier ( );
	void ChangeHealthRecoverySystem ( );
	void UpdateBuffs ( );
	void ServerSetShowFootPrints ( unsigned long bShowFootPrints );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYPawn_Multiplayer::pClassPointer = NULL;

// Class SRGame.YPawn_MPEnemy
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_MPEnemy : public AYPawn_Multiplayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1647 ];

		return pClassPointer;
	};

	void ChangeToMPBotsAnimationRestrictions ( );
};

UClass* AYPawn_MPEnemy::pClassPointer = NULL;

// Class SRGame.YPawn_MPHunter
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_MPHunter : public AYPawn_MPEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1648 ];

		return pClassPointer;
	};

	void SetShowScanSilhouette ( unsigned long B, unsigned long bUseInfiniteDistance );
	void Tick ( float DeltaTime );
	void DrawHUD ( class AHUD* H );
	void CheckPawnDistance ( );
	class UYPerk_Hunter* GetPerkHunter ( );
	void InitPerks ( );
};

UClass* AYPawn_MPHunter::pClassPointer = NULL;

// Class SRGame.YPawn_MPRage
// 0x0014 (0x28B8 - 0x28A4)
class AYPawn_MPRage : public AYPawn_MPEnemy
{
public:
	unsigned long                                      m_bIsRaging : 1;                                  		// 0x28A4 (0x0004) [0x0000000000002020] [0x00000001] ( CPF_Net | CPF_Transient )
	unsigned long                                      m_bBeingExecuted : 1;                             		// 0x28A4 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bDropGrenadeWhenDying : 1;                      		// 0x28A4 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	class UAudioComponent*                             m_rageAudioComponent;                             		// 0x28A8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UClass*                                      m_droppedExplosiveClass;                          		// 0x28AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYProj_Tracer*                               m_projectileTracerArchetype;                      		// 0x28B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYOPEmitter*                                 m_emitterTracerArchetype;                         		// 0x28B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1649 ];

		return pClassPointer;
	};

	bool YDied ( class AController* Killer, class UClass* DamageType, struct FVector HitLocation, unsigned char dbnoExitCondition, unsigned long killedByHeadshot, unsigned long makesHeadExplode, float lastTakenDamage, struct FVector Momentum );
	float GetAccuracyModifier ( );
	float GetDamageMultiplier ( class UClass* DamageType );
	void Tick ( float DeltaTime );
	void TakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void PlayRageEffects ( unsigned long bRage );
	void SetRaging ( unsigned long bNewValue );
	float GetHealthMultiplier ( );
	bool IsRaging ( );
	class UYPerk_Rage* GetPerkRage ( );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYPawn_MPRage::pClassPointer = NULL;

// Class SRGame.YPawn_MPStealthRanger
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_MPStealthRanger : public AYPawn_Multiplayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1650 ];

		return pClassPointer;
	};

	bool YDied ( class AController* Killer, class UClass* DamageType, struct FVector HitLocation, unsigned char dbnoExitCondition, unsigned long killedByHeadshot, unsigned long makesHeadExplode, float lastTakenDamage, struct FVector Momentum );
	void ChangeToMPBotsAnimationRestrictions ( );
};

UClass* AYPawn_MPStealthRanger::pClassPointer = NULL;

// Class SRGame.YPawn_StealthRanger
// 0x0008 (0x2710 - 0x2708)
class AYPawn_StealthRanger : public AYPawn_Infantry
{
public:
	unsigned long                                      m_deathDoesNotEndGame : 1;                        		// 0x2708 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_silhouetteFadeOutDelay;                         		// 0x270C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1651 ];

		return pClassPointer;
	};

	void OnScanEnded ( );
	bool IsSilhouetteLocked ( );
	void OnDelayStopSilhouette ( );
	void OnStopFeedbackSilhouette ( float Duration );
	void OnStartFeedbackSilhouette ( float Duration );
	void OnStartDownButNotOut ( );
	void InitReflectionChannel ( );
	void Tick ( float DeltaTime );
};

UClass* AYPawn_StealthRanger::pClassPointer = NULL;

// Class SRGame.YPawn_Walker
// 0x0000 (0x2710 - 0x2710)
class AYPawn_Walker : public AYPawn_StealthRanger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1652 ];

		return pClassPointer;
	};

	bool IsEnabledForTacView ( );
	void OnSetSquadEvolution ( class UYSeqAct_SetSquadEvolution* seqAct );
};

UClass* AYPawn_Walker::pClassPointer = NULL;

// Class SRGame.YMPMeshLookupTable
// 0x0060 (0x009C - 0x003C)
class UYMPMeshLookupTable : public UObject
{
public:
	int                                                m_numPackages;                                    		// 0x003C (0x0004) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x0040 (0x003C) UNKNOWN PROPERTY: MapProperty SRGame.YMPMeshLookupTable.IDAssetMap
	TArray< struct FYMP_HandleAssetPair >              MapSetupList;                                     		// 0x007C (0x000C) [0x0000000000406002]              ( CPF_Const | CPF_Transient | CPF_Config | CPF_NeedCtorLink )
	TArray< class UObjectReferencer* >                 m_LoadedPackageList;                              		// 0x0088 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	class UObject*                                     m_NotifyObject;                                   		// 0x0094 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	unsigned long                                      m_bActive : 1;                                    		// 0x0098 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1653 ];

		return pClassPointer;
	};

	bool HandleClassChange ( unsigned char in_MP_Team, unsigned char in_MP_Class, struct FYS_CharacterMeshList* in_MeshList, struct FYS_CharacterMeshList* out_MeshList );
	void GetFullAssetList ( struct FName in_Location, TArray< struct FYMP_HandleAssetPair >* out_AssetList );
	void GetAssetList ( unsigned char in_MP_Team, unsigned char in_MP_Class, struct FName in_Location, TArray< struct FYMP_HandleAssetPair >* out_AssetList );
	void ReleaseAssets ( );
	void LoadAssets ( class UObject* pNotifyObject, unsigned long bFlushAsyncLoads, unsigned long bAlwaysAddToRootSet, struct FYS_CharacterMeshList* in_MeshList );
	bool AreAssetsLoaded ( );
};

UClass* UYMPMeshLookupTable::pClassPointer = NULL;

// Class SRGame.YPawnEvolutionState
// 0x0044 (0x0080 - 0x003C)
class UYPawnEvolutionState : public UObject
{
public:
	class USkeletalMesh*                               m_characterMesh;                                  		// 0x003C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_shyfflrClass;                                   		// 0x0040 (0x0004) [0x0000000000000000]              
	struct FYS_AnimSet                                 m_executionPistolAnimSet;                         		// 0x0044 (0x0014) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_AnimSet                                 m_executionRifleAnimSet;                          		// 0x0058 (0x0014) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_AnimSet                                 m_executionAllAnimSet;                            		// 0x006C (0x0014) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1654 ];

		return pClassPointer;
	};

};

UClass* UYPawnEvolutionState::pClassPointer = NULL;

// Class SRGame.YPawnKinematicRBCollider
// 0x0010 (0x0210 - 0x0200)
class UYPawnKinematicRBCollider : public UPrimitiveComponent
{
public:
	struct FPointer                                    m_kinActorDataSW;                                 		// 0x0200 (0x0004) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	class AYGamePawn*                                  m_owningPawn;                                     		// 0x0204 (0x0004) [0x0000000000001000]              ( CPF_Native )
	unsigned long                                      m_activated : 1;                                  		// 0x0208 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FRBCollisionChannelContainer                m_originalRBCollideWithChannels;                  		// 0x020C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1655 ];

		return pClassPointer;
	};

	void SetActive ( unsigned long newActive );
	void UpdatePosition ( );
	void SetNxVis ( unsigned long Enable );
	void SetCollision ( unsigned long newCollision );
	void SetBodyInstanceCollision ( class URB_BodyInstance* Instance, unsigned long newCollision );
	void DisablePhysicsAssetCollision ( class UPhysicsAssetInstance* physAssetInst );
	void TermPhysics ( );
	void InitPhysics ( class AYGamePawn* GP );
};

UClass* UYPawnKinematicRBCollider::pClassPointer = NULL;

// Class SRGame.YPawnSpringyRBCollider
// 0x0040 (0x0240 - 0x0200)
class UYPawnSpringyRBCollider : public UPrimitiveComponent
{
public:
	struct FPointer                                    m_handleActorDataSW;                              		// 0x0200 (0x0004) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	struct FPointer                                    m_collActorDataSW;                                		// 0x0204 (0x0004) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	struct FPointer                                    m_jointDataSW;                                    		// 0x0208 (0x0004) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	class URB_BodyInstance*                            m_bodyInstance;                                   		// 0x020C (0x0004) [0x0000000000000000]              
	class AYGamePawn*                                  m_owningPawn;                                     		// 0x0210 (0x0004) [0x0000000000001000]              ( CPF_Native )
	unsigned long                                      m_activated : 1;                                  		// 0x0214 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      m_originalRBChannel;                              		// 0x0218 (0x0001) [0x0000000000000000]              
	struct FRBCollisionChannelContainer                m_originalRBCollideWithChannels;                  		// 0x021C (0x0004) [0x0000000000000000]              
	float                                              m_capsuleRadius;                                  		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_capsuleHeight;                                  		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_capsuleOffset;                                  		// 0x0228 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_capsuleMass;                                    		// 0x022C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_springForceXY;                                  		// 0x0230 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_dampingConstantXY;                              		// 0x0234 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_springForceZ;                                   		// 0x0238 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_dampingConstantZ;                               		// 0x023C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1656 ];

		return pClassPointer;
	};

	void SetActive ( unsigned long newActive );
	void SetCapsuleOffset ( float Offset );
	void SetCollisionSize ( float Radius, float Height );
	void GetColliderKineticData ( struct FVector* Velocity, struct FVector* Momentum );
	void GetColliderPos ( struct FVector* pos );
	void UpdatePosition ( );
	void SetColliderPosition ( struct FVector pos );
	void SetSpringParams ( float springXY, float dampingXY, float springZ, float dampingZ );
	void SetCapsuleMass ( float newMass );
	void SetNxVis ( unsigned long Enable );
	void SetCollision ( unsigned long newCollision );
	void DisablePhysicsAssetCollision ( class UPhysicsAssetInstance* physAssetInst );
	void TermPhysics ( );
	void InitPhysics ( class AYGamePawn* GP );
};

UClass* UYPawnSpringyRBCollider::pClassPointer = NULL;

// Class SRGame.YPawnState
// 0x0000 (0x003C - 0x003C)
class UYPawnState : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1657 ];

		return pClassPointer;
	};

};

UClass* UYPawnState::pClassPointer = NULL;

// Class SRGame.YPerk_DesertWarrior
// 0x0010 (0x0060 - 0x0050)
class UYPerk_DesertWarrior : public UYPerk
{
public:
	float                                              m_MinimapStaticValue;                             		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_extraMagazines;                                 		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bCanSeeInSandstorm : 1;                         		// 0x0058 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	float                                              m_explosiveStunTimeModifier;                      		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1658 ];

		return pClassPointer;
	};

	float GetStaticSliderValue ( );
};

UClass* UYPerk_DesertWarrior::pClassPointer = NULL;

// Class SRGame.YPerk_GunSlinger
// 0x0008 (0x0058 - 0x0050)
class UYPerk_GunSlinger : public UYPerk
{
public:
	float                                              m_raiseGunTimeModifier;                           		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_recoilMultiplier;                               		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1659 ];

		return pClassPointer;
	};

};

UClass* UYPerk_GunSlinger::pClassPointer = NULL;

// Class SRGame.YPerk_KonradPerks
// 0x0018 (0x0068 - 0x0050)
class UYPerk_KonradPerks : public UYPerk
{
public:
	float                                              m_sandstormBonusXP;                               		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_WeaponRangeBonus;                               		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fallDamageReduction;                            		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_baseMovementSpeedIncrease;                      		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_scopeZoomIncrease;                              		// 0x0060 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_ammoDropChance;                                 		// 0x0064 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1660 ];

		return pClassPointer;
	};

};

UClass* UYPerk_KonradPerks::pClassPointer = NULL;

// Class SRGame.YPerk_Major
// 0x0001 (0x0051 - 0x0050)
class UYPerk_Major : public UYPerk
{
public:
	unsigned char                                      m_charTypeLevel2;                                 		// 0x0050 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1661 ];

		return pClassPointer;
	};

	unsigned char StaticGetCharacterType ( class AYPlayerController_MPBase* PC );
	bool StaticLevel2UnlockedFromEnum ( class AYPlayerController_MPBase* PC, unsigned char perkEnum );
	bool StaticLevel2Unlocked ( class AYPlayerController_MPBase* PC );
	float GetBuffEffectiveDist ( );
	struct FName StaticGetProviderTag ( );
};

UClass* UYPerk_Major::pClassPointer = NULL;

// Class SRGame.YPerk_Class
// 0x0000 (0x0051 - 0x0051)
class UYPerk_Class : public UYPerk_Major
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1662 ];

		return pClassPointer;
	};

};

UClass* UYPerk_Class::pClassPointer = NULL;

// Class SRGame.YPerk_Breacher
// 0x0027 (0x0078 - 0x0051)
class UYPerk_Breacher : public UYPerk_Class
{
public:
	float                                              m_breacherExtraVitalPointDamage;                  		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_teamExplosiveDamageIncrease[ 0x2 ];             		// 0x0058 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_teamExplosiveDamageDistance[ 0x2 ];             		// 0x0060 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_breacherGrenadeCount[ 0x2 ];                    		// 0x0068 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_explosiveDisarmIncrease;                        		// 0x0070 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_explosiveArmIncrease;                           		// 0x0074 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1663 ];

		return pClassPointer;
	};

	int GetMaxGrenadeCount ( );
	float GetExtraVitalPointDamage ( );
	float GetExplosiveDamageIncrease ( );
	float GetBuffEffectiveDist ( );
};

UClass* UYPerk_Breacher::pClassPointer = NULL;

// Class SRGame.YPerk_Gunner
// 0x001B (0x006C - 0x0051)
class UYPerk_Gunner : public UYPerk_Class
{
public:
	float                                              m_teamDamageIncrease[ 0x2 ];                      		// 0x0054 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_teamDamageDistance[ 0x2 ];                      		// 0x005C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_gunnerDamageDecrease[ 0x2 ];                    		// 0x0064 (0x0008) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1664 ];

		return pClassPointer;
	};

	float GetDamageReduction ( );
	float GetGunnerBuffValue ( );
	float GetBuffEffectiveDist ( );
};

UClass* UYPerk_Gunner::pClassPointer = NULL;

// Class SRGame.YPerk_Medic
// 0x004B (0x009C - 0x0051)
class UYPerk_Medic : public UYPerk_Class
{
public:
	float                                              m_teamRegenRateIncrease[ 0x2 ];                   		// 0x0054 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_teamRegenRateDistance[ 0x2 ];                   		// 0x005C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_DBNOhealRateIncrease[ 0x2 ];                    		// 0x0064 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_DBNOhealInvincibleTime[ 0x2 ];                  		// 0x006C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_adrenalineBuffTime[ 0x2 ];                      		// 0x0074 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_adrenalineBuffCooldown[ 0x2 ];                  		// 0x007C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_adrenalineShotDistance[ 0x2 ];                  		// 0x0084 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_adrenalineShotAngle[ 0x2 ];                     		// 0x008C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_adrenalineHealthIncrease;                       		// 0x0094 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_adrenalineHealthBoostDecayRate;                 		// 0x0098 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1665 ];

		return pClassPointer;
	};

	float GetAdrenalineShotUseAngle ( );
	float GetAdrenalineShotUseDistance ( );
	float GetAdrenalineBuffCooldown ( );
	float GetAdrenalineBuffTime ( );
	float GetDBNOHealBuffTime ( );
	float GetDBNOHealRateBonus ( );
	float GetRegenRateIncrease ( );
	float GetBuffEffectiveDist ( );
};

UClass* UYPerk_Medic::pClassPointer = NULL;

// Class SRGame.YPerk_Officer
// 0x005F (0x00B0 - 0x0051)
class UYPerk_Officer : public UYPerk_Class
{
public:
	float                                              m_teamDamageReduction[ 0x2 ];                     		// 0x0054 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_teamDamageReductionDistance[ 0x2 ];             		// 0x005C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_teamEfficiencyIncrease[ 0x2 ];                  		// 0x0064 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_objectiveDamageIncrease[ 0x2 ];                 		// 0x006C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_objectiveDamageReduction[ 0x2 ];                		// 0x0074 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_objectiveDistance[ 0x2 ];                       		// 0x007C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_supplyCooldown[ 0x2 ];                          		// 0x0084 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_orderCooldown[ 0x2 ];                           		// 0x008C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_EnemyMinimapDistance[ 0x2 ];                    		// 0x0094 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_durationForStandardAmmoIncrease;                		// 0x009C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_durationForExplosiveAmmoIncrease;               		// 0x00A0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_durationForSAWAmmoIncrease;                     		// 0x00A4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UClass*                                      m_beaconClass;                                    		// 0x00A8 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_supplyClass;                                    		// 0x00AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1666 ];

		return pClassPointer;
	};

	float GetOrderCooldown ( );
	float GetSupplyDropCooldown ( );
	float GetTeamEfficiency ( );
	float GetBeaconDamageIncrease ( );
	float GetBeaconDamageReduction ( );
	float GetBeaconEffectiveDist ( );
	float GetDamageReductionBuff ( );
	float GetBuffEffectiveDist ( );
	float GetEnemyMinimapViewDist ( );
};

UClass* UYPerk_Officer::pClassPointer = NULL;

// Class SRGame.YPerk_Scavenger
// 0x003B (0x008C - 0x0051)
class UYPerk_Scavenger : public UYPerk_Class
{
public:
	float                                              m_teamExplosiveRadiusIncrease[ 0x2 ];             		// 0x0054 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_teamExplosiveRadiusDistance[ 0x2 ];             		// 0x005C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_explosiveDamageReduction[ 0x2 ];                		// 0x0064 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_barricadeRepairIncrease[ 0x2 ];                 		// 0x006C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_ammoDropIncreaseAmmo[ 0x2 ];                    		// 0x0074 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_ammoDropIncreaseGrenade[ 0x2 ];                 		// 0x007C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_ammoCarryCapacityMultiplier[ 0x2 ];             		// 0x0084 (0x0008) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1667 ];

		return pClassPointer;
	};

	float GetBaricadeRepairIncrease ( );
	float GetExplosiveDamageReduction ( );
	float GetBuffEffectiveDist ( );
	float GetAmmoCarryCapacityMultiplier ( );
	float GetAmmoDropIncreaseGrenade ( );
	float GetAmmoDropIncreaseAmmo ( );
	float GetTeamExplosiveRadius ( );
};

UClass* UYPerk_Scavenger::pClassPointer = NULL;

// Class SRGame.YPerk_Sniper
// 0x0053 (0x00A4 - 0x0051)
class UYPerk_Sniper : public UYPerk_Class
{
public:
	float                                              m_teamAccuracyIncrease[ 0x2 ];                    		// 0x0054 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_teamAccuracyDistance[ 0x2 ];                    		// 0x005C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_SniperForceHUDVisibility[ 0x2 ];                		// 0x0064 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_InvisEffectTime[ 0x2 ];                         		// 0x006C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_InvisLaunchTime[ 0x2 ];                         		// 0x0074 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_InvisFadeBackTime;                              		// 0x007C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_EspionageSpeedIncrease[ 0x2 ];                  		// 0x0080 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_MarkDuration;                                   		// 0x0088 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bSniperStealthCoundownBegun : 1;                		// 0x008C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bWasMoving : 1;                                 		// 0x008C (0x0004) [0x0000000000000000] [0x00000002] 
	class AYPawn_Multiplayer*                          m_pMarkedPawn;                                    		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              m_footstepRevealSeconds[ 0x2 ];                   		// 0x0094 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_terminalHackIncrease;                           		// 0x009C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_terminalRepairIncrease;                         		// 0x00A0 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1668 ];

		return pClassPointer;
	};

	void OnTakeDownWeapon ( class AYPawn_Multiplayer* P );
	void OnTakeUpWeapon ( class AYPawn_Multiplayer* P );
	void OnUnCrouch ( class AYPawn_Multiplayer* P );
	void OnCrouch ( class AYPawn_Multiplayer* P );
	void ReloadWeapon ( class AYPawn_Multiplayer* P );
	void OnEndRaiseGrenade ( class AYPawn_Multiplayer* P );
	void OnWeaponFired ( class AYPawn_Multiplayer* P );
	void TakeDamage ( class AYPawn_Multiplayer* P, int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void OnStartInvisCountdown ( class AYPawn_Multiplayer* P );
	void HandleCancelInvisEffect ( class AYPawn_Multiplayer* P );
	void CancelInvisEffect ( class AYPawn_Multiplayer* P );
	void SniperTick ( class AYPawn_Multiplayer* P );
	bool ShootingCancelsInvis ( );
	float GetTeamAccuracyModifier ( );
	float GetInvisLaunchTime ( );
	float GetSniperEspionageBuff ( );
	float GetInvisEffectTime ( );
	float GetBuffEffectiveDist ( );
};

UClass* UYPerk_Sniper::pClassPointer = NULL;

// Class SRGame.YPerk_Fremen
// 0x0013 (0x0064 - 0x0051)
class UYPerk_Fremen : public UYPerk_Major
{
public:
	unsigned long                                      m_bCanSeeInSandstorm : 1;                         		// 0x0054 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_bCanSeeInSandstormLevel2 : 1;                   		// 0x0054 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_bIgnoreSandstormMalus : 1;                      		// 0x0054 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_bIgnoreSandstormMalusLevel2 : 1;                		// 0x0054 (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	unsigned long                                      m_bScavenger : 1;                                 		// 0x0054 (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	unsigned long                                      m_bScavengerLevel2 : 1;                           		// 0x0054 (0x0004) [0x0000000000004000] [0x00000020] ( CPF_Config )
	int                                                m_maxGrenadeCount[ 0x2 ];                         		// 0x0058 (0x0008) [0x0000000000004000]              ( CPF_Config )
	int                                                m_pickupDropProbability;                          		// 0x0060 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1669 ];

		return pClassPointer;
	};

	float StaticGetPickupDropProbability ( );
	bool IgnoreSandstormMalus ( );
	bool Scavenger ( );
	bool CanSeeInSandstorm ( );
	int GetMaxGrenadeCount ( );
	void RemovePerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
};

UClass* UYPerk_Fremen::pClassPointer = NULL;

// Class SRGame.YPerk_Hunter
// 0x0023 (0x0074 - 0x0051)
class UYPerk_Hunter : public UYPerk_Major
{
public:
	class UYSoundCueFMOD*                              m_hunterSound;                                    		// 0x0054 (0x0004) [0x0000000000000000]              
	float                                              m_warningRange[ 0x2 ];                            		// 0x0058 (0x0008) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bTacticalExpertDontSee : 1;                     		// 0x0060 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_bTacticalExpertDontSeeLevel2 : 1;               		// 0x0060 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_bSeeOtherPlayersHealth : 1;                     		// 0x0060 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_bSeeOtherPlayersHealthLevel2 : 1;               		// 0x0060 (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	unsigned long                                      m_bSeeTeamMateHealth : 1;                         		// 0x0060 (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	unsigned long                                      m_bSeeTeamMateHealthLevel2 : 1;                   		// 0x0060 (0x0004) [0x0000000000004000] [0x00000020] ( CPF_Config )
	unsigned long                                      m_bSeeHealthOnlyForTargetedPawn : 1;              		// 0x0060 (0x0004) [0x0000000000004000] [0x00000040] ( CPF_Config )
	unsigned long                                      m_bSeeHealthOnlyForTargetedPawnLevel2 : 1;        		// 0x0060 (0x0004) [0x0000000000004000] [0x00000080] ( CPF_Config )
	unsigned long                                      m_bDisablePostProcess : 1;                        		// 0x0060 (0x0004) [0x0000000000004000] [0x00000100] ( CPF_Config )
	unsigned long                                      m_isSoundPlaying : 1;                             		// 0x0060 (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	float                                              m_effectFadeTime;                                 		// 0x0064 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_hunterMaterial;                                 		// 0x0068 (0x0004) [0x0000000000000000]              
	class UMaterialInstance*                           m_leftFootMaterial;                               		// 0x006C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstance*                           m_rightFootMaterial;                              		// 0x0070 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1670 ];

		return pClassPointer;
	};

	bool SeeTeamMateHealth ( );
	bool SeeHealthOnlyForTargetedPawn ( );
	bool SeeOtherPlayersHealth ( );
	bool IsPawnDetected ( class AYPawn_Multiplayer* hunter, class AYPawn_Multiplayer* Other, unsigned long bCheckHealth );
	class UYSoundCueFMOD* StaticGetHunterSound ( );
	float GetWarningRange ( );
	bool TacticalExpertDontSee ( );
	void Update ( float DeltaTime );
	void DrawHUD ( class AHUD* H );
	void CheckPawnDistanceFromHunter ( class AYGamePawn* hunter, class AWorldInfo* WI );
};

UClass* UYPerk_Hunter::pClassPointer = NULL;

// Class SRGame.YPerk_MetalDetector
// 0x0008 (0x0058 - 0x0050)
class UYPerk_MetalDetector : public UYPerk
{
public:
	float                                              m_pickupViewDistance;                             		// 0x0050 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_explodingMineDelay;                             		// 0x0054 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1671 ];

		return pClassPointer;
	};

};

UClass* UYPerk_MetalDetector::pClassPointer = NULL;

// Class SRGame.YPerk_NameTaker
// 0x0020 (0x0070 - 0x0050)
class UYPerk_NameTaker : public UYPerk
{
public:
	float                                              m_killStreakDamageIncrease;                       		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_KillStreakArmorIncrease;                        		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_MaxArmorIncrease;                               		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_killStreakTimer;                                		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_showOnHUDDistance[ 0x2 ];                       		// 0x0060 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_enemyScanTimer;                                 		// 0x0068 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_enemyScanDelay;                                 		// 0x006C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1672 ];

		return pClassPointer;
	};

	void NameTakerTick ( float DeltaTime, class AYPawn_Multiplayer* P );
};

UClass* UYPerk_NameTaker::pClassPointer = NULL;

// Class SRGame.YPerk_ShockTroop
// 0x0010 (0x0060 - 0x0050)
class UYPerk_ShockTroop : public UYPerk
{
public:
	float                                              m_meleeRange;                                     		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_meleeDamageMultiplier;                          		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_explosiveRadiusIncrease;                        		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_grenadeThrowSpeedModifier;                      		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1673 ];

		return pClassPointer;
	};

};

UClass* UYPerk_ShockTroop::pClassPointer = NULL;

// Class SRGame.YPerk_SupportOps
// 0x0004 (0x0054 - 0x0050)
class UYPerk_SupportOps : public UYPerk
{
public:
	float                                              m_DistToView;                                     		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1674 ];

		return pClassPointer;
	};

	void SupportOpsTick ( class AYPawn_Multiplayer* P );
};

UClass* UYPerk_SupportOps::pClassPointer = NULL;

// Class SRGame.YPlayerController_MPBase
// 0x00C0 (0x1118 - 0x1058)
class AYPlayerController_MPBase : public AYPlayerController
{
public:
	TArray< struct FXPEventBufferItems >               m_XPEventBuffer;                                  		// 0x1058 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bPendingUISceneOpen : 1;                        		// 0x1064 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      bReceivedUniqueId : 1;                            		// 0x1064 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_GetsTeamBonusXP : 1;                            		// 0x1064 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_StopRotatorIcon : 1;                            		// 0x1064 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	class UUIScene*                                    m_UISceneTemplate;                                		// 0x1068 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIScene*                                    m_CustomMatchScene;                               		// 0x106C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIScene*                                    m_CoopCustomMatchScene;                           		// 0x1070 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIScene*                                    m_LobbyScene;                                     		// 0x1074 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIScene*                                    m_OnlineMPScene;                                  		// 0x1078 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIScene*                                    m_UIScene;                                        		// 0x107C (0x0004) [0x0000000000000000]              
	TArray< int >                                      m_majorPerksAvailability;                         		// 0x1080 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_minorPerksAvailability;                         		// 0x108C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned char >                            m_minorPerkNameCache;                             		// 0x1098 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_primaryWeaponsAvailability;                     		// 0x10A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_secondaryWeaponsAvailability;                   		// 0x10B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_explosivesAvailability;                         		// 0x10BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_challengeSectionsAvailability;                  		// 0x10C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_lastChallengeCompleted;                         		// 0x10D4 (0x0004) [0x0000000000000000]              
	int                                                m_lastXPEventPriority;                            		// 0x10D8 (0x0004) [0x0000000000000000]              
	float                                              m_lastXPEventTime;                                		// 0x10DC (0x0004) [0x0000000000000000]              
	class UYUIScene_MatchEndXP*                        m_MatchEndXPTemplate;                             		// 0x10E0 (0x0004) [0x0000000000000000]              
	class UUIScene*                                    m_matchEndXPScene;                                		// 0x10E4 (0x0004) [0x0000000000000000]              
	class UUIScene*                                    m_ScoreboardScene;                                		// 0x10E8 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_LeaveReason;                                    		// 0x10EC (0x0001) [0x0000000000000000]              
	float                                              m_lastKickWarningTime;                            		// 0x10F0 (0x0004) [0x0000000000000000]              
	float                                              m_KeepAliveTimer;                                 		// 0x10F4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FString                                     m_switchTeamMessageTitle;                         		// 0x10F8 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_switchTeamMessageDescription;                   		// 0x1104 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	float                                              m_saveProfileDelay;                               		// 0x1110 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UYSoundCueFMOD*                              m_promotionSound;                                 		// 0x1114 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1675 ];

		return pClassPointer;
	};

	void UnMuteEveryone ( );
	void BeginSendingKeepAlives ( );
	void KeepAliveTimer ( );
	void ClientOpenPostMatchScene ( unsigned long bInGameLobby, unsigned long bXPSystemEnabled );
	void ClientOpenEndGameScoreboard ( );
	void ClientOpenMatchEndXPScene ( );
	bool IsChallengeSectionUnlocked ( unsigned char Section, unsigned char TeamID );
	int GetMajorPerkUnlockedLevel ( unsigned char perk );
	bool PlayerIsMajorPerkUnlocked ( unsigned char perk, int iLevel );
	bool PlayerIsPerkUnlocked ( unsigned char perk, int iLevel );
	void ClearUnlockedItem ( );
	void SendXPEventMessage ( int EventID, int earnedXP, int ChallengeID );
	void SwitchToNextPrestigeLevel ( int nextPrestigeLevel );
	bool IsNextPrestigeLevelAvailable ( int nextPrestigeLevel );
	void ClientSetProfilePrestigeLevel ( int Value );
	void ClientSetProfileXP ( int Value );
	void UpdateRank ( unsigned char TeamID );
	void UpdateExperienceData ( unsigned char TeamID, int collectedXP );
	void OnChallengeCompleted ( unsigned char ChallengeID, int earnedXP );
	void ServerOnChallengeCompleted ( unsigned char ChallengeID );
	void ClientIncrementCollectedXP ( int EventID, int earnedXP, unsigned char eventPriority, int ChallengeID );
	void ServerIncrementCollectedXP ( int EventID, int earnedXP, unsigned char eventPriority );
	void ClearExperienceData ( unsigned long bKeepPrestigeLevel );
	void WriteExperienceData ( );
	void ReadExperienceData ( );
	bool IsExperienceSystemInitialized ( );
	void UpdateServerAvailability ( );
	void InitExperienceSystem ( unsigned long bForceInit );
	void ForceSaveAndUpdateExperienceInProfile ( );
	void UpdateExperienceInProfile ( );
	void ClientUpdateExodusCoopProgressLevel ( int progressLevel );
	void PerformSaveProfile ( );
	void SaveProfile ( unsigned char Reason, struct FScriptDelegate OnSaveProfileSceneClosed );
	void WriteProfileStats ( );
	void EndQuitToMainMenu ( );
	void QuitToMainMenu ( unsigned long OnLoginChange );
	void SetMutedByRemote ( struct FUniqueNetId MutingPlayer, unsigned long muted );
	void RefreshLobby ( );
	void Destroyed ( );
	void ServerRemovePlayer ( );
	void RemoveRemotePlayer ( );
	bool IsUISceneOpened ( );
	void CloseUIScene ( );
	void OpenLoadedUIScene ( );
	void InitUIScene ( class UUIScene* UISceneTemplate );
	bool isCoopGame ( );
	void LoadLobbyUIScene ( );
	void LoadCoopLobbyScene ( );
	void LoadCoopSearchUIScene ( );
	void LoadSearchUIScene ( struct FString SearchSceneClass );
	void LoadCoopCustomMatchUIScene ( );
	void LoadCustomMatchUIScene ( );
	void LoadOnlineCoopUIScene ( );
	void LoadOnlineMPUIScene ( );
	void SetName ( struct FString S );
	void LoadSettingsFromProfile ( unsigned long bLoadCharacter );
	void PreClientTravel ( struct FString PendingURL, unsigned char TravelType, unsigned long bIsSeamlessTravel );
	void ClientUpdatePlayerTeam ( );
	void ServerSwitchTeam ( );
	void SwitchTeam ( );
	void ForceServerChangeTeam ( int TeamNum );
	void ForceSwitchTeam ( );
	void ForceServerStartLobbyCountDown ( );
	void KickWarning ( );
	void ForceStartLobbyCountDown ( );
	void ForceLaunchMatch ( );
	void ShowRotatorIcon ( );
	void DisplayReturningToMainMenuMessage ( );
	void DisplayWaitingForHostMessage ( );
	void HideRotatorIcon ( );
	void CloseWaitingForHostMessage ( );
	void SetWaitingForPlayer ( );
	void ConfirmPlayerReady ( );
	void ClientSetReady ( );
	void ClientSetUniquePlayerIdConfirmed ( );
	void ServerSetUniquePlayerId ( struct FUniqueNetId UniqueId, unsigned long bWasInvited );
	void ServerSetUniquePlayerIdEpicLegacy ( struct FUniqueNetId UniqueId, unsigned long bWasInvited );
	bool ServerInitUniquePlayerId ( unsigned long bWasInvited );
	void ClientInitUniquePlayerId ( );
	void InitUniquePlayerId ( );
	void InitUniquePlayerIdEpicLegacy ( );
	void HandlePostTravel ( );
	void ReceivedPlayer ( );
	void ClientAllowSwitchTeam ( );
	void ClientCloseSwitchTeamMessageBox ( );
	void ClientOpenSwitchTeamMessageBox ( );
	void SetGetsTeamBonusXP ( unsigned long bonusXP );
	void PlayerTick ( float DeltaTime );
	void UpdateHeadsets ( );
	void PostBeginPlay ( );
	class UUIScene* GetUIScene ( );
};

UClass* AYPlayerController_MPBase::pClassPointer = NULL;

// Class SRGame.YPlayerController_MP
// 0x0184 (0x129C - 0x1118)
class AYPlayerController_MP : public AYPlayerController_MPBase
{
public:
	TArray< struct FYKillData >                        m_KillsData;                                      		// 0x1118 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AYGamePawn* >                        m_HealedPawns;                                    		// 0x1124 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bAdrenalineShotOnCoolDown : 1;                  		// 0x1130 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bHasHealedAllTeammates : 1;                     		// 0x1130 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bMinimapFlashStarted : 1;                       		// 0x1130 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bNewRoundShowLoadoutSelection : 1;              		// 0x1130 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bAllowScndMode : 1;                             		// 0x1130 (0x0004) [0x0000000000004002] [0x00000010] ( CPF_Const | CPF_Config )
	unsigned long                                      m_bSuperBadChallenge : 1;                         		// 0x1130 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bPendingCharacterChange : 1;                    		// 0x1130 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bIsInSpawnSecurityTimer : 1;                    		// 0x1130 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      skipCam : 1;                                      		// 0x1130 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_ServerQoSIsRunning : 1;                         		// 0x1130 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_ServerQoSHasBeenChecked : 1;                    		// 0x1130 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_serverActionNeedsConnectionConfirmation : 1;    		// 0x1130 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_serverActionConnectionConfirmationFailed : 1;   		// 0x1130 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bNeedToChooseAnotherBoss : 1;                   		// 0x1130 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bHasFinishedWorldStreaming : 1;                 		// 0x1130 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bWaitingStateInitialized : 1;                   		// 0x1130 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bIsIdler : 1;                                   		// 0x1130 (0x0004) [0x0000000000000020] [0x00010000] ( CPF_Net )
	unsigned long                                      m_needFriendlyFireKick : 1;                       		// 0x1130 (0x0004) [0x0000000000000020] [0x00020000] ( CPF_Net )
	unsigned long                                      m_wantsToBeRevived : 1;                           		// 0x1130 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_RotateToFaceInteract : 1;                       		// 0x1130 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      m_bWaitForClientCharacterAssets : 1;              		// 0x1130 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_lastZoomMode : 1;                               		// 0x1130 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_bHasUpdatedPerkTimes : 1;                       		// 0x1130 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      m_bHasUpdatedRoundStats : 1;                      		// 0x1130 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_bWaitingForPlayerRestart : 1;                   		// 0x1130 (0x0004) [0x0000000000000000] [0x01000000] 
	class UYUIFrontEnd_CharacterRespawnSelection*      m_CharacterSelectionTemplate;                     		// 0x1134 (0x0004) [0x0000000000000000]              
	class UYUIFrontEnd_CharacterRespawnSelection*      m_CharacterSelection;                             		// 0x1138 (0x0004) [0x0000000000000000]              
	int                                                m_numSupplyDrops;                                 		// 0x113C (0x0004) [0x0000000000000000]              
	int                                                m_numberOfQoSQueryFailuresInGame;                 		// 0x1140 (0x0004) [0x0000000000000000]              
	float                                              m_serverActionConnectionConfirmationTimeOut;      		// 0x1144 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_serverActionConnectionConfirmationTimeOutHold;  		// 0x1148 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_MPSpecialHudMessage;                            		// 0x114C (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FYS_CharacterEquipmentList                  DefaultEquipmentClass;                            		// 0x1158 (0x0050) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_ControlRestrictions                     m_InteractionHoldCR;                              		// 0x11A8 (0x0004) [0x0000000000000000]              
	struct FYS_ControlRestrictions                     m_noSprint;                                       		// 0x11AC (0x0004) [0x0000000000000000]              
	int                                                m_currentSpectatingPointIndex;                    		// 0x11B0 (0x0004) [0x0000000000000000]              
	class AYProj_Physical*                             m_lastLaunchedProjectiles[ 0x3 ];                 		// 0x11B4 (0x000C) [0x0000000000000020]              ( CPF_Net )
	class AYProj_Physical*                             m_lastLaunchedCustomProjectiles[ 0x3 ];           		// 0x11C0 (0x000C) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_deathCamBlendFunc;                              		// 0x11CC (0x0001) [0x0000000000004000]              ( CPF_Config )
	float                                              m_deathCamBlendTime;                              		// 0x11D0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_deathCamBlendExp;                               		// 0x11D4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FVector                                     m_dbnoCameraOffset;                               		// 0x11D8 (0x000C) [0x0000000000004000]              ( CPF_Config )
	class UClass*                                      m_dbnoWeaponToSpawn;                              		// 0x11E4 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_noPerkSecondary;                                		// 0x11E8 (0x0004) [0x0000000000000000]              
	int                                                m_currentButtonLayout;                            		// 0x11EC (0x0004) [0x0000000000000000]              
	float                                              m_playerRespawnTimer;                             		// 0x11F0 (0x0004) [0x0000000000000000]              
	class UYPlayerCamMode*                             m_dbnoCamera;                                     		// 0x11F4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_LocationToFarMoveAfterSpawn;                    		// 0x11F8 (0x000C) [0x0000000000000000]              
	class AYGamePawn*                                  m_medicLastAndrenalineShotTeammate;               		// 0x1204 (0x0004) [0x0000000000000000]              
	float                                              IdleKickTime;                                     		// 0x1208 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UMaterialInstanceConstant*                   m_MatMinimapParent;                               		// 0x120C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatKillerMajorPerkParent;                       		// 0x1210 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatMinimapOverlayParent;                        		// 0x1214 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatMinimapConeParent;                           		// 0x1218 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatBlip;                                        		// 0x121C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatPing;                                        		// 0x1220 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTexture2D*                                  m_imgMap01;                                       		// 0x1224 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTexture2D*                                  m_imgMap02;                                       		// 0x1228 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTexture2D*                                  m_imgMap03;                                       		// 0x122C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTexture2D*                                  m_imgMap04;                                       		// 0x1230 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matMedicCooldownParent;                         		// 0x1234 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matOfficerOrdersCooldownParent;                 		// 0x1238 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matOfficerSupplyDropCooldownParent;             		// 0x123C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matBuffParent;                                  		// 0x1240 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matRockIconParent;                              		// 0x1244 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matOfficerOrderIconParent;                      		// 0x1248 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matOfficerSupplyDropIconParent;                 		// 0x124C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatBuriedScoreMarker;                           		// 0x1250 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatChopperAttackScoreMarker;                    		// 0x1254 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matChopperIcon;                                 		// 0x1258 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matDeliveryBombMarker;                          		// 0x125C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matDeliveryTeamBombMarker;                      		// 0x1260 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matDeliveryDroppedBombMarker;                   		// 0x1264 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matOfflineStationIcon;                          		// 0x1268 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_PerkMaterialParent;                             		// 0x126C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSoundCueFMOD*                              m_medicInjectSound;                               		// 0x1270 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_DesiredInteractionDirection;                    		// 0x1274 (0x000C) [0x0000000000000000]              
	float                                              m_InteractionRotationDuration;                    		// 0x1280 (0x0004) [0x0000000000000000]              
	float                                              m_InteractionRotationTimer;                       		// 0x1284 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeAfterSkipCam;                              		// 0x1288 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_lastPlaytimeUpdate;                             		// 0x128C (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __OnCharacterDelaySpawned__Delegate;              		// 0x1290 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1676 ];

		return pClassPointer;
	};

	void ServerForceVisibleToOtherTeamHUD ( class AYPawn_Multiplayer* TargetPawn, unsigned long bFlag );
	void ServerCancelMarkingForPawn ( class AYPawn_Multiplayer* TargetPawn );
	void ServerStartMarkingForPawn ( class AYPawn_Multiplayer* TargetPawn, float fDuration );
	void ServerUpdateLevelVisibility ( struct FName PackageName, unsigned long bIsVisible );
	void ShowHVTUnderAttackMessage ( );
	void ShowVitalPointUnderAttackMessage ( );
	void IngoreLocalControlInput ( );
	void ClientRestart ( class APawn* NewPawn );
	void AdviseReload ( );
	bool GamePad_Reload ( );
	void ClientSetAICombatPosSetEnabled ( struct FName coverNodeName, unsigned long bOff );
	bool DoCoverButtonAction ( unsigned long doMoveIntoCoverOnly );
	struct FString GetPartyGameTypeName ( );
	struct FString GetPartyMapNameFromIni ( );
	void ShowLeaveGameMessageBox ( struct FString Title, struct FString msg );
	void ClientReturnToParty ( struct FUniqueNetId RequestingPlayerId );
	void ServerDropOfficerSupply ( );
	bool GamePad_OfficerSupplyDrop ( );
	bool StopSecondaryWeaponFunction ( );
	bool GamePad_OfficerObjectiveRelease ( );
	bool GamePad_OfficerObjectivePress ( );
	void StartSecondaryWeaponFunction ( );
	bool GamePad_StopSecondaryWeaponFunction ( );
	bool GamePad_StartSecondaryWeaponFunction ( );
	bool IsThrowingGrenade ( );
	bool IsThrowingOfficerObjective ( );
	bool GamePad_InjectAdrenaline ( );
	void CheckForPreorder ( );
	bool IsWithinPreorderTimelimit ( );
	void ReceivedPlayer ( );
	bool HasKilledDev ( );
	void ServerSetButtonLayout ( int ButtonLayout );
	void ReceiveLocalizedMessage ( class UClass* Message, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	void NotifyHUDMatchStart ( );
	void HideKillerInfos ( );
	void ShowKillerInfos ( );
	void StoreKillerInfos ( class AYPlayerReplicationInfo* killerPRI );
	void PlayStartUpMessage ( unsigned char StartUpStage, class UClass* statupMsgClass );
	void NotifyLocalPlayerExperienceChange ( );
	void NotifyLocalPlayerTeamReceived ( );
	void SetCharacterName ( struct FString sCharacterName );
	void SetMinorPerk ( unsigned char ePerk1, unsigned char ePerk2, unsigned char ePerk3 );
	void SetMajorPerk ( unsigned char ePerk, int iLevel );
	void OnEquipmentChanged ( struct FYS_CharacterEquipmentList equipment );
	void ClientPlayTeamSpecificVoice ( int konradVoice, int specopsVoice, float Delay );
	bool HasFinishedWorldStreaming ( );
	void ServerNotifyPlayerHasFinishedWorldStreaming ( );
	void ClientSetOnlineStatus ( );
	void OnJoinTravelToSessionComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void ClientWriteLeaderboardStats ( class UClass* OnlineStatsWriteClass );
	void WriteAllStatsForPRI ( class AYPlayerReplicationInfo_MP* PRI );
	void WriteStats ( TArray< class UClass* > StatClasses, class AYPlayerReplicationInfo_MP* PRI );
	void ClientSetProfileStat ( int statistic, int Value );
	void ClientSetProfileXP ( int Value );
	struct FString GetSpecialHUDMessage ( struct FString msg );
	void ServerStopInteract ( );
	bool GamePad_StopContextSpecialMove ( );
	bool GamePad_EndAContextSensativeMove ( );
	void ClientSetPlayerWalking ( );
	void ServerSetPlayerWalking ( );
	void ClientSetPlayerInteracting ( );
	void ServerSetPlayerInteracting ( );
	void ServerInteract ( );
	class AYGamePawn* MedicGetNearestTeammate ( );
	void ClientUsedAdrenalineShot ( );
	bool MedicGiveAdrenalineShot ( );
	void AdrenalineCooldownOver ( );
	void UpdateSpecialMoveButtonAction ( unsigned char buttonType, unsigned long updateNow );
	bool GamePad_StartAContextSensativeMove ( );
	void GetSpecialMoveMessages ( );
	bool IsInteracting ( );
	void DisplayMustWaitForNextRound ( );
	void AsssetsLoadedCallback ( class AYPlayerController_MP* C );
	bool AreMeshesLoaded ( );
	bool AreCharacterAssetsLoading ( );
	void ServerWaitRespawn ( );
	void ClientShowScoreboard ( );
	void SpectateKiller ( );
	float determineCameraTransitionFactor ( unsigned long inZoomMode );
	void ServerRestartPlayer ( );
	void CheckServerPlayerConnectionAfterRelevantAction ( );
	void StartServerPlayerRelevantActionConfirmHold ( );
	void StartServerPlayerRelevantActionConfirm ( class AYPlayerController_MP* OtherPC );
	float GetTimeSinceLastNetworkReceive ( );
	void ScoreKillForAchievements ( class AController* Killed, class AYGamePawn* KilledPawn );
	bool IsNetworkReady ( );
	bool SuperBadEnd ( );
	void PlayStunnedEffect ( float Damage );
	void ServerSetSuperBad ( unsigned long Value );
	void SetSuperBad ( unsigned long Value );
	void ResetSpectatedCamState ( );
	class APlayerReplicationInfo* GetRealViewTarget ( );
	void UnreliableServerCycleSpectatingCamera ( unsigned long bPreviousCamera );
	void ServerCycleSpectatingCamera ( unsigned long bPreviousCamera );
	void ServerInitializeSpectating ( unsigned long bSpectatePlayer );
	bool SupportsAimSnapOn ( );
	void ClientInitializeRespawnSecurityTimer ( );
	void InitializeRespawnSecurityTimer ( );
	void IssuePointCommandReleased ( );
	void IssuePointCommand ( );
	void ClientSetMatchResult ( class AActor* Winner, float SpecopsScore, float KonradScore, unsigned long bMatchEnd );
	void ClientRoundEnded ( class AActor* EndRoundFocus );
	void RoundHasEnded ( class AActor* EndGameFocus );
	void ClientGameEnded ( class AActor* EndGameFocus, unsigned long bIsWinner );
	void GameHasEnded ( class AActor* EndGameFocus, unsigned long bIsWinner );
	bool DoFastRope ( unsigned char specialMove );
	bool DoZipline ( unsigned char specialMove );
	void IncrementRoundStats ( );
	void EndMinimapStaticFlashing ( );
	void StartMinimapStaticFlashing ( );
	void ClientIncrementKillStats ( class APlayerReplicationInfo* Killer, class APlayerReplicationInfo* Killed, class UClass* DamageType );
	void ClientIncrementDBNOStats ( class APlayerReplicationInfo* Killer, class APlayerReplicationInfo* Killed );
	void ClientIncrementProfileStat ( int StatId );
	void DestroyDBNOCamera ( );
	void CreateDBNOCamera ( class AActor* Killer );
	void ActivateDBNOInputScheme ( );
	void SpawnDefaultHUD ( );
	void EndInitialization ( );
	void ClientInitialize ( );
	bool IsShowingFullScreenUI ( );
	bool HideHudElementForMenu ( );
	void ServerChangeTeam ( int N );
	void PawnDied ( class APawn* inPawn );
	void CharacterRespawnMenuClosed ( );
	void RespawnTimeOver ( );
	bool GamePad_TogglePauseOrScoreboard ( );
	bool GamePad_ToggleScndWeaponMode ( );
	void OnPlayerTalkingStateChange ( struct FUniqueNetId PlayerID, unsigned long bIsTalking );
	void ClearOnlineDelegates ( );
	void AddOnlineDelegates ( unsigned long bRegisterVoice );
	void ServerUpdatePlayersMuteLists ( );
	void OnRegisterPlayerComplete ( struct FName SessionName, struct FUniqueNetId PlayerID, unsigned long bWasSuccessful );
	void StopTemporaryInvincibility ( );
	void SetTemporaryInvincibility ( float Duration );
	void Possess ( class APawn* inPawn, unsigned long bVehicleTransition );
	void ServerViewMyController ( struct FViewTargetTransitionParams TransitionParams );
	void EndQuitToMainMenu ( );
	void QuitToMainMenu ( unsigned long OnLoginChange );
	void OnPrematureQuit ( unsigned long bSaveProfileStats );
	void WritePerkUseTimes ( );
	void CheckOnlineServiceReachableInGame ( );
	void ContinueOnlineServiceReachableInGame ( );
	void OnOnlineServiceReachableCompleteInGame ( unsigned long bWasSuccessful, float timeLeftUntilNextQuery );
	void ServerStopQoSRequestInGame ( );
	void ServerStartQoSRequestInGame ( );
	void NotifyConnectionError ( struct FString Message, struct FString Title, unsigned long bAllowSecondAcceptInviteAttempt );
	void ServerQuit ( );
	void ClientArbitratedMatchEnded ( );
	void ClientCloseSpectateScene ( );
	void ServerStopSpectate ( );
	void StopSpectate ( );
	bool ShouldExitReturnToOnlineMenu ( );
	void MPCloseSpectateScene ( );
	void MPOpenSpectateScene ( unsigned long bShowCycleCamera, unsigned long bWaitingToRespawn );
	void OnJustDied ( class UClass* dmgType );
	void EnableDBNOSFX ( );
	void OnStartDownButNotOut ( );
	void EnableTargetingZoom ( float FOV, float Time );
	void SetCurrentWeapon ( class AYWeapon* Weapon );
	bool CanRestartPlayer ( );
	void ClientSetReady ( );
	void ClientMatchStart ( );
	float GetSprintMaxTime ( );
	float GetRespawnTimer ( );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void Destroyed ( );
	void ServerSetFriendKiller ( unsigned long bFriendKiller );
	void ServerSetIsIdler ( unsigned long bIsIdler );
	void ClearIdlerOnServer ( );
	void SetIdlerOnServer ( );
	void KickThisFriendKillerPlayer ( );
	void KickThisIdlePlayer ( );
	void DelayedFriendKillerKickForLeaderboards ( );
	void DelayedIdleKickForLeaderboards ( );
	void UpdateIdlerFlag ( );
	bool StopSecondaryByInterrupt ( unsigned long noRefire, unsigned long forceInterrupt );
	void PlayerTick ( float DeltaTime );
	void ServerPromotedXPEvent ( );
	void ServerScoreYachtFind ( );
	bool IsFriendKiller ( );
	bool IsIdler ( );
	void ChooseBossClass ( );
	void ValidateCurrentCharacter ( );
	struct FYS_CharacterEquipmentList GetEquipmentChoose ( );
	bool ExecuteButtonAction ( unsigned char buttonAction );
	void NotifyListCharacterChange ( );
	struct FYS_CharacterEquipmentList GetEquipmentClass ( );
	struct FYS_CharacterMeshList GetMeshList ( );
	void ServerSwitchTeamAndCharacter ( int iCharacterSelect );
	void AskToSwitchTeamAndCharacter ( );
	void AskToChangeCharacter ( unsigned char TeamID, int iCharacterSelect );
	bool IsClassAvailable ( int ClassIndex, unsigned long bCountMeIn );
	bool SelectFirstAvailablePlayerClass ( );
	void ReplicatedSetSelectedEquipment ( struct FYS_CharacterEquipmentList equipment );
	void SetSelectedEquipment ( struct FYS_CharacterEquipmentList equipment );
	void OpenCharacterSelectScene ( unsigned long bOpenedFromMidGameMenu );
	void ClientOpenCharacterSelectScene ( );
	void SetCharacterIndex ( int iCharacterSelect );
	void ClientSetCharacterIndex ( int iCharacterSelect );
	void ServerSetCharacterIndex ( int iCharacterSelect );
	void ClientOpenEquipmentMenu ( );
	void ServerSetFiring ( unsigned long newIsFiring );
	bool ShouldReturnToWalkingState ( );
	bool ConditionalEnterCover ( unsigned long byLocation, unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, unsigned long checkIfOccupied, unsigned long skipAIForOccupation );
	bool RequiresCharacterIndexReset ( );
	void ClientInitCharacterAndSpawn ( int Selection );
	void ClientForceCloseEquipmentMenu ( );
	void ClientValidateCharacterChange ( int characterSelected );
	void ServerChooseBossClassAndOpenMenu ( );
	void PostBeginPlay ( );
	void ServerAskToChangeCharacter ( unsigned char TeamID, int iCharacterSelect );
	void ClientSkipCharacterChange ( );
	void ServerSetSelectedEquipment ( struct FYS_CharacterEquipmentList equipment );
	struct FString GetSelectedCharacterName ( );
	bool IsChallengeDone ( unsigned char TeamID, int Character );
	void InitializeLocalCharacterSelectionManager ( unsigned long bForce );
	float GetScopingShakeModifier ( );
	void DestroyAllLaunchedProjectile ( );
	bool IsOwnerOfProjectile ( class AYProj_Physical* Projectile );
	void RemoveLaunchedProjectile ( class AYProj_Physical* Projectile );
	void AddNewLaunchedProjectile ( class AYProj_Physical* Projectile );
	bool GamePad_InteractFire ( );
	bool HasTrumpMoviePlayedAndFinished ( struct FName avalancheMovie );
	void PlayAvalancheMovie ( struct FName avalancheMovie );
	void Reset ( );
	void LoadAndSpawn ( struct FScriptDelegate in_delegate, unsigned long b_forceClientLoadSpawn );
	void ClientWasKickedForIdle ( unsigned long setFlag );
	void ResetGlobalClientWasKickedFlag ( );
	void SetGlobalClientWasKickedFlag ( );
	void ReplicatedEvent ( struct FName VarName );
	void ServerClientLoadCompleted ( );
	void CallOnCharacterDelaySpawned ( );
	void OnCharacterDelaySpawned ( class AYPlayerController_MP* C );
};

UClass* AYPlayerController_MP::pClassPointer = NULL;

// Class SRGame.YPlayerController_CP
// 0x0074 (0x1310 - 0x129C)
class AYPlayerController_CP : public AYPlayerController_MP
{
public:
	class UYSoundCueFMOD*                              m_objectiveSound;                                 		// 0x129C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSoundCueFMOD*                              m_eliteSound;                                     		// 0x12A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSoundCueFMOD*                              m_bossSound;                                      		// 0x12A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_eliteVoiceId;                                   		// 0x12A8 (0x0004) [0x0000000000000000]              
	int                                                m_konradBossVoiceId;                              		// 0x12AC (0x0004) [0x0000000000000000]              
	int                                                m_specopsBossVoiceId;                             		// 0x12B0 (0x0004) [0x0000000000000000]              
	int                                                m_eliteLevelUnlocked;                             		// 0x12B4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bBossUnlocked : 1;                              		// 0x12B8 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	struct FString                                     m_eliteChallengeUnlockMessages[ 0x5 ];            		// 0x12BC (0x003C) [0x000000000040A002]              ( CPF_Const | CPF_Transient | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_bossChallengeUnlockMessage;                     		// 0x12F8 (0x000C) [0x000000000040A002]              ( CPF_Const | CPF_Transient | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_bossIncomingMessage;                            		// 0x1304 (0x000C) [0x000000000040A002]              ( CPF_Const | CPF_Transient | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1677 ];

		return pClassPointer;
	};

	void ClientAddProfileStat ( int StatId, int Value );
	bool GamePad_IssuePointCommandReleased ( );
	bool GamePad_IssuePointCommand ( );
	void UpdateChoreoStatus ( unsigned long bIsChoreoPlaying, unsigned long bIsVersus );
	void ClientSetOnlineStatus ( );
	int GetMajorPerkUnlockedLevel ( unsigned char perk );
	unsigned char GetMajorPerkLevel ( );
	void ClientStopDeathPostProcess ( );
	void ClientStartDeathPostProcess ( );
	void IncrementRoundStats ( );
	void ClientIncrementKillStats ( class APlayerReplicationInfo* Killer, class APlayerReplicationInfo* Killed, class UClass* DamageType );
	void CharacterRespawnMenuClosed ( );
	void ServerSkipChoreo ( );
	bool GamePad_MPSkipChoreo ( );
	void CheckChallenges ( );
	void ClientDisplayChallengeUnlockMessage ( int iLevel );
	void ClientResetSelectedCharacter ( );
	bool RequiresCharacterIndexReset ( );
	void ClientDisplayBossIncomingMessage ( );
	void PlayBossUnlockedVoices ( );
	void ServerSetIsIdler ( unsigned long bIsIdler );
	void UpdateObjectiveMessage ( );
	void ClientSetCPEndMessage ( struct FString Message, float TimeToDisplay );
	void ClientUpdateObjectiveMessage ( );
	void OnStopDownButNotOut ( );
};

UClass* AYPlayerController_CP::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetSquadEvolution
// 0x0034 (0x0128 - 0x00F4)
class UYSeqAct_SetSquadEvolution : public USequenceAction
{
public:
	TArray< struct FYS_EvolutionSettings >             m_walkerSettings;                                 		// 0x00F4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	TArray< struct FYS_EvolutionSettings >             m_lugoSettings;                                   		// 0x0100 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	TArray< struct FYS_EvolutionSettings >             m_adamsSettings;                                  		// 0x010C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned char                                      m_evoState;                                       		// 0x0118 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_walkerEvolutionStateClass;                      		// 0x011C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_lugoEvolutionStateClass;                        		// 0x0120 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_adamsEvolutionStateClass;                       		// 0x0124 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1678 ];

		return pClassPointer;
	};

	void SetHardReferences ( );
	void VersionUpdated ( int OldVersion, int NewVersion );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SetSquadEvolution::pClassPointer = NULL;

// Class SRGame.YSpecialActionSuppressor
// 0x0008 (0x0044 - 0x003C)
class UYSpecialActionSuppressor : public UObject
{
public:
	class UYSpecialActionInstance*                     m_dominantSpecialAction;                          		// 0x003C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_isSpecialActionSuppressed : 1;                  		// 0x0040 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1679 ];

		return pClassPointer;
	};

	void StopSuppressSpecialActions ( class UYSpecialActionInstance* dominantSpecialAction );
	void SuppressAllSpecialActions ( class UYSpecialActionInstance* dominantSpecialAction );
};

UClass* UYSpecialActionSuppressor::pClassPointer = NULL;

// Class SRGame.YSpecialMove
// 0x007C (0x00B8 - 0x003C)
class UYSpecialMove : public UObject
{
public:
	unsigned char                                      m_specialMove;                                    		// 0x003C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_specialMoveState;                               		// 0x003D (0x0001) [0x0000000000000000]              
	class AYGamePawn*                                  m_pawn;                                           		// 0x0040 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_cachedCanDoSpecialMove : 1;                     		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_interruptible : 1;                              		// 0x0044 (0x0004) [0x0000000000000002] [0x00000002] ( CPF_Const )
	unsigned long                                      m_allowsMeleeAttack : 1;                          		// 0x0044 (0x0004) [0x0000000000000002] [0x00000004] ( CPF_Const )
	unsigned long                                      m_processPawnCollisionsForPhysNone : 1;           		// 0x0044 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bShouldBlockActorForTargetTest : 1;             		// 0x0044 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_blocksGrenadeThrows : 1;                        		// 0x0044 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_blocksReloading : 1;                            		// 0x0044 (0x0004) [0x0000000000000000] [0x00000040] 
	float                                              m_cachedCanDoSpecialMoveTimeStamp;                		// 0x0048 (0x0004) [0x0000000000000000]              
	struct FYS_SpecialMoveData                         m_cachedCanDoSpecialMoveData;                     		// 0x004C (0x0044) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             m_stopCallback;                                   		// 0x0090 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_id;                                             		// 0x009C (0x0004) [0x0000000000000000]              
	TArray< struct FYS_AnimSet >                       m_specialAnimSets;                                		// 0x00A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __StopSpecialMoveCallback__Delegate;              		// 0x00AC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1680 ];

		return pClassPointer;
	};

	void DumpGameData ( struct FYS_GameDumpNode* Node );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	bool CanPlaySpecialMoveDeathAnimation ( );
	void StopSprint ( );
	bool AllowsMeleeAttack ( unsigned char attackType );
	bool GetSpecialMoveTargetLocation ( struct FVector* Loc );
	void Hit ( struct FVector HitLocation, struct FVector HitNormal, class AActor* Other, class UPrimitiveComponent* OtherComp );
	void TickSpecialMove ( float DeltaTime );
	unsigned char GetSpecialMoveState ( );
	void GetSpecialAnimSets ( struct FYS_SpecialMoveData Data );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	bool HasFinished ( );
	void CancelSpecialMove ( );
	void OnCancelSpecialMove ( );
	void OnCancelSpecialMoveInternal ( );
	void OnStopSpecialMove ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMove ( struct FScriptDelegate stopCallback, unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMove ( struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	bool IsInterruptible ( );
	void Init ( unsigned char specialMove, class AYGamePawn* GamePawn );
	void StopSpecialMoveCallback ( unsigned long Success );
};

UClass* UYSpecialMove::pClassPointer = NULL;

// Class SRGame.YSpecialMove_Execute
// 0x0034 (0x00EC - 0x00B8)
class UYSpecialMove_Execute : public UYSpecialMove
{
public:
	TArray< unsigned char >                            m_animIDs;                                        		// 0x00B8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_variationIndex;                                 		// 0x00C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_executionWeaponType;                            		// 0x00C8 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_AnimSet                                 m_currentAnimSet;                                 		// 0x00CC (0x0014) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class AYGamePawn*                                  m_pawnToExecute;                                  		// 0x00E0 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_pawnWasExecuted : 1;                            		// 0x00E4 (0x0004) [0x0000000000000000] [0x00000001] 
	class UParticleSystem*                             m_bloodFx;                                        		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1681 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void PlayHitEffect ( );
	void KillVictim ( );
	void VaporizeHead ( );
	void StartVictimPhysicsBlend ( float BlendTime );
	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_Execute::pClassPointer = NULL;

// Class SRGame.YSpecialMove_IntoCover
// 0x0098 (0x0150 - 0x00B8)
class UYSpecialMove_IntoCover : public UYSpecialMove
{
public:
	TArray< struct FYS_EnterCoverTransition >          m_transitions;                                    		// 0x00B8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_AnimID                                  m_intoCoverAnimID;                                		// 0x00C4 (0x0004) [0x0000000000000000]              
	struct FYS_AnimID                                  m_intoCoverAnimIDEnd;                             		// 0x00C8 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_currentAnimSequence;                            		// 0x00CC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_startLocation;                                  		// 0x00D0 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_startRotation;                                  		// 0x00DC (0x000C) [0x0000000000000000]              
	struct FVector                                     m_targetLocation;                                 		// 0x00E8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_targetCoverNormal;                              		// 0x00F4 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_targetRotation;                                 		// 0x0100 (0x000C) [0x0000000000000000]              
	class UCameraAnim*                                 m_cameraAnim;                                     		// 0x010C (0x0004) [0x0000000000000000]              
	class UCameraAnimInst*                             m_cameraAnimPlaying;                              		// 0x0110 (0x0004) [0x0000000000000000]              
	class UCameraAnim*                                 m_impactCameraAnim;                               		// 0x0114 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_dashFXType;                                     		// 0x0118 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_coverEdgeType;                                  		// 0x0119 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_soundPlayed : 1;                                		// 0x011C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_slideSoundPlaying : 1;                          		// 0x011C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_crouchedAtEnd : 1;                              		// 0x011C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_moveInputIgnored : 1;                           		// 0x011C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_showDebugLines : 1;                             		// 0x011C (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_dustParticleFxPlayed : 1;                       		// 0x011C (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              m_rootMotionMultiplier;                           		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_onCoverReachedDistTolerance;                    		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_onCoverReachedDistToleranceParticleFx;          		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_moveInputEnableDelay;                           		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_animAlpha;                                      		// 0x0130 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_moveAlpha;                                      		// 0x0134 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYPlayerController*                          m_playerController;                               		// 0x0138 (0x0004) [0x0000000000000000]              
	class UParticleSystem*                             m_dustPuffTemplate;                               		// 0x013C (0x0004) [0x0000000000000000]              
	float                                              m_animTime;                                       		// 0x0140 (0x0004) [0x0000000000000000]              
	float                                              m_totalAnimLength;                                		// 0x0144 (0x0004) [0x0000000000000000]              
	float                                              m_distToCover;                                    		// 0x0148 (0x0004) [0x0000000000000000]              
	float                                              m_hitLevelMaxDist;                                		// 0x014C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1682 ];

		return pClassPointer;
	};

	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void DrawDebugLines ( );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	bool GetSpecialMoveTargetLocation ( struct FVector* Loc );
	int FindTransitionIdx ( float distToCover, struct FYS_SpecialMoveData* Data );
	void Hit ( struct FVector HitLocation, struct FVector HitNormal, class AActor* Other, class UPrimitiveComponent* OtherComp );
	void PlayDustPuffParticles ( );
	void OnCoverReached ( );
	void TickSpecialMove ( float DeltaTime );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	unsigned char DetermineCoverEdgeType ( struct FYS_CoverData coverData );
	void OnStartAnimPlayed ( );
	void GetAnimIDs ( int transitionIdx, unsigned char edgeType, struct FYS_AnimID* startAnimID, struct FYS_AnimID* endAnimID, float* totalPlayTime );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternalNative ( struct FYS_SpecialMoveData* Data );
	struct FYS_AnimProperties GetAnimProperties ( unsigned char movementAnimID );
	void Init ( unsigned char specialMove, class AYGamePawn* GamePawn );
};

UClass* UYSpecialMove_IntoCover::pClassPointer = NULL;

// Class SRGame.YSpecialMove_KnockOutPawn
// 0x001C (0x00D4 - 0x00B8)
class UYSpecialMove_KnockOutPawn : public UYSpecialMove
{
public:
	unsigned long                                      m_showHeadImpactFX : 1;                           		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_headBodyIndex;                                  		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              m_minHeadVelForBloodFX;                           		// 0x00C0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_headRadius;                                     		// 0x00C4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_traceLength;                                    		// 0x00C8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_decalSpawnMinTime;                              		// 0x00CC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_timeSinceLastDecalSpawn;                        		// 0x00D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1683 ];

		return pClassPointer;
	};

	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void TickSpecialMove ( float DeltaTime );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_KnockOutPawn::pClassPointer = NULL;

// Class SRGame.YSpecialMove_MeleeAttackBase
// 0x000C (0x00C4 - 0x00B8)
class UYSpecialMove_MeleeAttackBase : public UYSpecialMove
{
public:
	unsigned char                                      m_animIDs[ 0x2 ];                                 		// 0x00B8 (0x0002) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_specialMoveStance;                              		// 0x00BA (0x0001) [0x0000000000000000]              
	unsigned long                                      m_animationStarted : 1;                           		// 0x00BC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_interpolationRunning : 1;                       		// 0x00BC (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	float                                              m_interpolationTime;                              		// 0x00C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1684 ];

		return pClassPointer;
	};

	struct FYS_AnimID GetAnimID ( unsigned char specialMoveStance );
	void OnAnimationStarted ( );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	struct FVector GetBestAttackPos ( struct FVector dirToPawn, class AYGamePawn* meleeTarget );
	void TickSpecialMove ( float DeltaTime );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_MeleeAttackBase::pClassPointer = NULL;

// Class SRGame.YSpecialMove_PlayDeathAnim
// 0x0040 (0x00F8 - 0x00B8)
class UYSpecialMove_PlayDeathAnim : public UYSpecialMove
{
public:
	struct FYS_DeathAnimProperty                       m_deathAnimProp;                                  		// 0x00B8 (0x0038) [0x0000000000000000]              
	unsigned long                                      m_playing : 1;                                    		// 0x00F0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_flyingAnim : 1;                                 		// 0x00F0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	float                                              m_explosionAnimMinImpulse;                        		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1685 ];

		return pClassPointer;
	};

	bool IsStomachShot ( struct FName BoneName );
	bool IsNeckShot ( struct FName BoneName, struct FVector HitLocation );
	bool IsHeadShot ( struct FName BoneName );
	unsigned char PickDeathAnimationFromList ( TArray< unsigned char > animList, unsigned char* globalAnimIndex );
	void TickSpecialMove ( float DeltaTime );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_PlayDeathAnim::pClassPointer = NULL;

// Class SRGame.YSpecialMove_PlayHitReactionAnim
// 0x0008 (0x00C0 - 0x00B8)
class UYSpecialMove_PlayHitReactionAnim : public UYSpecialMove
{
public:
	unsigned char                                      m_animID;                                         		// 0x00B8 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_stopMovement : 1;                               		// 0x00BC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1686 ];

		return pClassPointer;
	};

	bool IsChestShot ( struct FName BoneName );
	bool IsRightArmShot ( struct FName BoneName );
	bool IsLeftArmShot ( struct FName BoneName );
	bool IsRightLegShot ( struct FName BoneName );
	bool IsLeftLegShot ( struct FName BoneName );
	bool SelectHitReactionAnimation ( struct FVector HitLocation, struct FVector Momentum, int Damage, class UClass* DamageType, struct FTraceHitInfo HitInfo );
	unsigned char PickHitReactionAnimationFromList ( unsigned long doCheckHitReactionLength, unsigned long forceBigReaction, TArray< unsigned char >* animListSmall, unsigned char* globalAnimIndexSmall, TArray< unsigned char >* animListBig, unsigned char* globalAnimIndexBig );
	bool PlayHitReactionAnimation ( int Damage, class UClass* DamageType, struct FVector* HitLocation, struct FVector* Momentum, struct FTraceHitInfo* HitInfo );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	bool CheckHitReactionLength ( struct FYS_AnimProperties hitReactionProperties );
};

UClass* UYSpecialMove_PlayHitReactionAnim::pClassPointer = NULL;

// Class SRGame.YSpecialMove_Revive
// 0x0030 (0x00E8 - 0x00B8)
class UYSpecialMove_Revive : public UYSpecialMove
{
public:
	struct FYS_ReviveAnimIDs                           m_animIDs[ 0x2 ];                                 		// 0x00B8 (0x0008) [0x0000000000000000]              
	unsigned char                                      m_reactionAnimID;                                 		// 0x00C0 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_specialMoveStance;                              		// 0x00C1 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_reviveState;                                    		// 0x00C2 (0x0001) [0x0000000000000000]              
	float                                              m_rotationBlendTime;                              		// 0x00C4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_locationBlendTime;                              		// 0x00C8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class AYGamePawn*                                  m_pawnToRevive;                                   		// 0x00CC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_pawnWasRevived : 1;                             		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_useCustomCamMode : 1;                           		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_reviveDistance;                                 		// 0x00D4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_maxReviveAnimDistance;                          		// 0x00D8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_maxReviveWaitTime;                              		// 0x00DC (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_specialMoveStartTime;                           		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              m_minCamModeDistance;                             		// 0x00E4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1687 ];

		return pClassPointer;
	};

	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void Revive ( );
	void PlayEndAnimation ( );
	void PlayMidAnimation ( );
	bool PlayBeginAnimation ( );
	struct FVector GetBestRevivePos ( struct FVector dirToPawn );
	struct FYS_AnimID GetAnimID ( unsigned char specialMoveStance, unsigned char reviveState );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_Revive::pClassPointer = NULL;

// Class SRGame.YSpecialMove_Revive_MP
// 0x0030 (0x00E8 - 0x00B8)
class UYSpecialMove_Revive_MP : public UYSpecialMove
{
public:
	struct FYS_ReviveMPAnimIDs                         m_animIDs[ 0x2 ];                                 		// 0x00B8 (0x0008) [0x0000000000000000]              
	unsigned char                                      m_reactionAnimID;                                 		// 0x00C0 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_specialMoveStance;                              		// 0x00C1 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_reviveState;                                    		// 0x00C2 (0x0001) [0x0000000000000000]              
	float                                              m_rotationBlendTime;                              		// 0x00C4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_locationBlendTime;                              		// 0x00C8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class AYGamePawn*                                  m_pawnToRevive;                                   		// 0x00CC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_pawnWasRevived : 1;                             		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_useCustomCamMode : 1;                           		// 0x00D0 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_reviveDistance;                                 		// 0x00D4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_maxReviveAnimDistance;                          		// 0x00D8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_maxReviveWaitTime;                              		// 0x00DC (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_specialMoveStartTime;                           		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              m_minCamModeDistance;                             		// 0x00E4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1688 ];

		return pClassPointer;
	};

	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void Revive ( );
	void PlayEndAnimation ( );
	void PlayMidAnimation ( );
	bool PlayBeginAnimation ( );
	struct FVector GetBestRevivePos ( struct FVector dirToPawn );
	struct FYS_AnimID GetAnimID ( unsigned char specialMoveStance, unsigned char reviveState );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_Revive_MP::pClassPointer = NULL;

// Class SRGame.YSpecialMove_ReviveSelf
// 0x0008 (0x00C0 - 0x00B8)
class UYSpecialMove_ReviveSelf : public UYSpecialMove
{
public:
	unsigned char                                      m_animIDs[ 0x2 ];                                 		// 0x00B8 (0x0002) [0x0000000000000000]              
	unsigned char                                      m_specialMoveStance;                              		// 0x00BA (0x0001) [0x0000000000000000]              
	unsigned long                                      m_useCustomCamMode : 1;                           		// 0x00BC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_pawnWasRevived : 1;                             		// 0x00BC (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1689 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void Revive ( );
	void PlayBeginAnimation ( );
	struct FYS_AnimID GetAnimID ( unsigned char specialMoveStance );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_ReviveSelf::pClassPointer = NULL;

// Class SRGame.YSpecialMove_SprintSlide
// 0x0048 (0x0100 - 0x00B8)
class UYSpecialMove_SprintSlide : public UYSpecialMove
{
public:
	float                                              m_rampDownForce;                                  		// 0x00B8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_rampDownDelay;                                  		// 0x00BC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minVelocityThreshold;                           		// 0x00C0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minVelocityInputThreshold;                      		// 0x00C4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minVelocityPostureThreshold;                    		// 0x00C8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_cancelTimeStrafe;                               		// 0x00CC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_cancelTimeForward;                              		// 0x00D0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_cancelTimeBackward;                             		// 0x00D4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned long                                      m_useLocationInterpolation : 1;                   		// 0x00D8 (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_soundPlayed : 1;                                		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_allowMovement : 1;                              		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_isAiming : 1;                                   		// 0x00D8 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_crouched : 1;                                   		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000010] 
	class UYSoundCueFMOD*                              m_sprintSlideSound;                               		// 0x00DC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_currentVelocity;                                		// 0x00E0 (0x000C) [0x0000000000000000]              
	float                                              m_slideTime;                                      		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              m_minSlideTime;                                   		// 0x00F0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_currentCancelTimeStrafe;                        		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_currentCancelTimeForward;                       		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_currentCancelTimeBackward;                      		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1690 ];

		return pClassPointer;
	};

	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	void Hit ( struct FVector HitLocation, struct FVector HitNormal, class AActor* Other, class UPrimitiveComponent* OtherComp );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	struct FYS_AnimID GetAnim ( unsigned long aiming, unsigned long Crouched );
	void TickSpecialMove ( float DeltaTime );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_SprintSlide::pClassPointer = NULL;

// Class SRGame.YSpecialMove_SwatTurn
// 0x0114 (0x01CC - 0x00B8)
class UYSpecialMove_SwatTurn : public UYSpecialMove
{
public:
	struct FYS_SwatTurnFixedAnimProperties             m_animProperties[ 0x3 ];                          		// 0x00B8 (0x0048) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_AnimID                                  m_animID;                                         		// 0x0100 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_swatDirection;                                  		// 0x0104 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_crouchedAtEnd : 1;                              		// 0x0108 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_drawDebugLines : 1;                             		// 0x0108 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	struct FYS_CoverData                               m_swatTargetCoverData;                            		// 0x010C (0x0084) [0x0000000000000000]              
	float                                              m_maxSwatDistance;                                		// 0x0190 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FVector2D                                   m_relativeCollisionCylinderSize;                  		// 0x0194 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_animTime;                                       		// 0x019C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_animAlpha;                                      		// 0x01A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_totalAnimLength;                                		// 0x01A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_startLocation;                                  		// 0x01A8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_targetLocation;                                 		// 0x01B4 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_targetRotation;                                 		// 0x01C0 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1691 ];

		return pClassPointer;
	};

	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	bool GetSpecialMoveTargetLocation ( struct FVector* Loc );
	bool GetAnimationsFromSpecialMoveData ( unsigned long crouchedAtEnd, struct FVector swatTargetLocation, struct FYS_SpecialMoveData* Data, struct FYS_CoverData* coverData, struct FYS_AnimID* animID, struct FYS_AnimProperties* animProperties );
	bool GetSwatTargetPosition ( struct FYS_SpecialMoveData* Data, struct FYS_CoverData* swatTarget, struct FYS_CoverData* coverData );
	void LeaveCover ( );
	void Hit ( struct FVector HitLocation, struct FVector HitNormal, class AActor* Other, class UPrimitiveComponent* OtherComp );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void DelayedLeaveCover ( );
	void TickSpecialMove ( float DeltaTime );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	void Init ( unsigned char specialMove, class AYGamePawn* GamePawn );
};

UClass* UYSpecialMove_SwatTurn::pClassPointer = NULL;

// Class SRGame.YSpecialMove_TurretLeave
// 0x0008 (0x00C0 - 0x00B8)
class UYSpecialMove_TurretLeave : public UYSpecialMove
{
public:
	class AYTrigger_TurretInteraction*                 m_turretInteraction;                              		// 0x00B8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_wasCrouchedAtStart : 1;                         		// 0x00BC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1692 ];

		return pClassPointer;
	};

	void AnimationWeaponSwitchEnded ( );
	void AnimationLeaveEnded ( );
	bool PlayAnimationLeave ( );
	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_TurretLeave::pClassPointer = NULL;

// Class SRGame.YSpecialMoveDestination
// 0x002C (0x00E4 - 0x00B8)
class UYSpecialMoveDestination : public UYSpecialMove
{
public:
	unsigned long                                      m_splineInterpolation : 1;                        		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_fastInterpolation : 1;                          		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_reachTargetLocation : 1;                        		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_targetLocationReached : 1;                      		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_faceTargetRotation : 1;                         		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_keepUpdatingRotation : 1;                       		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_targetRotationFaced : 1;                        		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_moveInputIgnored : 1;                           		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_targetPositionJustSet : 1;                      		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_forceTargetRotationWhenTargetLocationReached : 1;		// 0x00B8 (0x0004) [0x0000000000000002] [0x00000200] ( CPF_Const )
	unsigned long                                      m_failIfDestinationCannotBeReached : 1;           		// 0x00B8 (0x0004) [0x0000000000000000] [0x00000400] 
	struct FVector                                     m_targetLocation;                                 		// 0x00BC (0x000C) [0x0000000000000000]              
	float                                              m_targetLocationTimeoutDuration;                  		// 0x00C8 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_targetRotation;                                 		// 0x00CC (0x000C) [0x0000000000000000]              
	float                                              m_reachLocationThreshold;                         		// 0x00D8 (0x0004) [0x0000000000000000]              
	int                                                m_reachRotationThreshold;                         		// 0x00DC (0x0004) [0x0000000000000000]              
	float                                              m_rotationSpeed;                                  		// 0x00E0 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1693 ];

		return pClassPointer;
	};

	bool OnStopSpecialMoveInternal ( );
	void SetTargetRotation ( struct FRotator TargetRotation );
	void SetTargetLocation ( struct FVector TargetLocation );
	void IgnoreMoveInput ( unsigned long bIgnore );
	void OnReachedDestinationTimeout ( );
	void OnReachedDestinationTimeoutInternal ( );
	void OnReachedDestination ( );
	void OnReachedDestinationInternal ( );
};

UClass* UYSpecialMoveDestination::pClassPointer = NULL;

// Class SRGame.YSpecialMove_BeingExecuted
// 0x002C (0x0110 - 0x00E4)
class UYSpecialMove_BeingExecuted : public UYSpecialMoveDestination
{
public:
	TArray< struct FYS_ExecutionReactionAnimSet >      m_reactionAnimSets;                               		// 0x00E4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_cameFromRagdoll : 1;                            		// 0x00F0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	int                                                m_variationIndex;                                 		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYGamePawn*                                  m_attacker;                                       		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_AnimSet                                 m_currentAnimSet;                                 		// 0x00FC (0x0014) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1694 ];

		return pClassPointer;
	};

	void PlayAnimation ( );
	struct FYS_AnimID GetAnimID ( );
	void OnCancelSpecialMoveInternal ( );
	void TickSpecialMove ( float DeltaTime );
	bool OnStopSpecialMoveInternal ( );
	void OnReachedDestinationInternal ( );
	void HandleRagdollState ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	void StartBeingExecuted ( );
};

UClass* UYSpecialMove_BeingExecuted::pClassPointer = NULL;

// Class SRGame.YSpecialMove_CustomAnimation
// 0x0024 (0x0108 - 0x00E4)
class UYSpecialMove_CustomAnimation : public UYSpecialMoveDestination
{
public:
	struct FYS_AnimID                                  m_animID;                                         		// 0x00E4 (0x0004) [0x0000000000000000]              
	class UObject*                                     m_callbackObject;                                 		// 0x00E8 (0x0004) [0x0000000000000000]              
	class UYCustomAnimation*                           m_customAnimation;                                		// 0x00EC (0x0004) [0x0000000000000000]              
	struct FName                                       m_customAnimationName;                            		// 0x00F0 (0x0008) [0x0000000000000000]              
	int                                                m_playCount;                                      		// 0x00F8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_crouchCylinderLocked : 1;                       		// 0x00FC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_forceLeaveCover : 1;                            		// 0x00FC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_synchronizeControllerRotation : 1;              		// 0x00FC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_disabledBlocking : 1;                           		// 0x00FC (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned char                                      m_coverLeaveTime;                                 		// 0x0100 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_minForceLeaveCoverPriority;                     		// 0x0101 (0x0001) [0x0000000000000002]              ( CPF_Const )
	class UAnimNodeSequence*                           m_currentAnimSequence;                            		// 0x0104 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1695 ];

		return pClassPointer;
	};

	void DumpGameData ( struct FYS_GameDumpNode* Node );
	bool BlocksDeathAnim ( );
	class UAnimNodeSequence* GetCurrentAnimSequence ( );
	class UYSeqAct_CustomAnimation* GetTriggeringSequenceAction ( );
	void TickSpecialMove ( float DeltaTime );
	void OnCancelSpecialMoveInternal ( );
	void ClearCurrentAnimSequence ( );
	bool OnStopSpecialMoveInternal ( );
	void ResetCollision ( );
	void OnAnimationPlayed ( );
	bool PlayAnimation ( unsigned char* outAnimID, unsigned char* ignoreMovement );
	void OnReachedDestinationInternal ( );
	void OnReachedDestinationTimeoutInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_CustomAnimation::pClassPointer = NULL;

// Class SRGame.YSpecialMove_FastRope
// 0x0038 (0x011C - 0x00E4)
class UYSpecialMove_FastRope : public UYSpecialMoveDestination
{
public:
	float                                              m_maxDistanceSq;                                  		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_maxAngle;                                       		// 0x00E8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FVector                                     m_locOffset;                                      		// 0x00EC (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_useOffsetStartLocation : 1;                     		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_collisionDisabled : 1;                          		// 0x00F8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_meleeAttackEnabled : 1;                         		// 0x00F8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	float                                              m_minTeleportDist;                                		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_startLocation;                                  		// 0x0100 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_startRotation;                                  		// 0x010C (0x000C) [0x0000000000000000]              
	class AYRopeActor*                                 m_ropeActor;                                      		// 0x0118 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1696 ];

		return pClassPointer;
	};

	bool GetExitPoint ( class AYRopeActor* ropeActor, struct FVector* outLoc, struct FRotator* outRot );
	bool GetEntryPoint ( class AYRopeActor* ropeActor, struct FVector Offset, struct FVector* outLoc, struct FRotator* outRot );
	bool AllowsMeleeAttack ( unsigned char attackType );
	void Hit ( struct FVector HitLocation, struct FVector HitNormal, class AActor* Other, class UPrimitiveComponent* OtherComp );
	void GetSpecialAnimSets ( struct FYS_SpecialMoveData Data );
	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void EnableControls ( unsigned long Enable );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_FastRope::pClassPointer = NULL;

// Class SRGame.YSpecialMove_IntelOp
// 0x0010 (0x00F4 - 0x00E4)
class UYSpecialMove_IntelOp : public UYSpecialMoveDestination
{
public:
	struct FYS_IntelOpAnimIDs                          m_animIDs[ 0x2 ];                                 		// 0x00E4 (0x0008) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_specialMoveStance;                              		// 0x00EC (0x0001) [0x0000000000000000]              
	unsigned char                                      m_intelOpState;                                   		// 0x00ED (0x0001) [0x0000000000000000]              
	unsigned char                                      m_intelOpSuccessful;                              		// 0x00EE (0x0001) [0x0000000000000000]              
	class UYSeqAct_IntelOp*                            m_intelOpSeqAct;                                  		// 0x00F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1697 ];

		return pClassPointer;
	};

	void PlayEndAnimation ( );
	void PlayLoopAnimation ( );
	void PlayBeginAnimation ( );
	struct FYS_AnimID GetAnimID ( unsigned char specialMoveStance, unsigned char intelOpState );
	bool StopIntelOp ( unsigned long succeeded );
	bool CanStopIntelOp ( );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void OnReachedDestinationInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
};

UClass* UYSpecialMove_IntelOp::pClassPointer = NULL;

// Class SRGame.YSpecialMove_OverCover
// 0x00B0 (0x0194 - 0x00E4)
class UYSpecialMove_OverCover : public UYSpecialMoveDestination
{
public:
	TArray< struct FYS_SpecialMoveAnimProperties >     m_animProperties;                                 		// 0x00E4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_animIndex;                                      		// 0x00F0 (0x0004) [0x0000000000000000]              
	float                                              m_minCoverDistance;                               		// 0x00F4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxCoverDistance;                               		// 0x00F8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxZDistance;                                   		// 0x00FC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAngleDegrees;                                		// 0x0100 (0x0004) [0x0000000000024003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_EditConst )
	float                                              m_maxAngleDegreesEdge;                            		// 0x0104 (0x0004) [0x0000000000024003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_EditConst )
	float                                              m_animCoverHeight;                                		// 0x0108 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_rightEdgeCorrection;                            		// 0x010C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxOrientation;                                 		// 0x0110 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_maxOrientationEdge;                             		// 0x0114 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_coverHeightRange;                               		// 0x0118 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FRotator                                    m_alignRotationToCoverOffset;                     		// 0x0120 (0x000C) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned long                                      m_uncrouchBeforeMove : 1;                         		// 0x012C (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_animationStarted : 1;                           		// 0x012C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_networkPositionCorrectionPrevented : 1;         		// 0x012C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_alignDuringMove : 1;                            		// 0x012C (0x0004) [0x0000000000000002] [0x00000008] ( CPF_Const )
	unsigned long                                      m_alignDuringThisMove : 1;                        		// 0x012C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_applyEdgeOffset : 1;                            		// 0x012C (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              m_heightOffset;                                   		// 0x0130 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_upMovementTargetLocation;                       		// 0x0134 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_upMovementTargetRotation;                       		// 0x0140 (0x000C) [0x0000000000000000]              
	float                                              m_maxInterpolationDistance;                       		// 0x014C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_maxDistanceForInstantMove;                      		// 0x0150 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_maxRotationDifferenceForInstantMove;            		// 0x0154 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_animPct;                                        		// 0x0158 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_alignDuringMoveSequenceNode;                    		// 0x015C (0x0004) [0x0000000000000000]              
	float                                              m_animCorrectionLengthOffset;                     		// 0x0160 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FVector                                     m_animStartLocation;                              		// 0x0164 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_animStartRotation;                              		// 0x0170 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_coverRotation;                                  		// 0x017C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_currentPawnVelocity;                            		// 0x0188 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1698 ];

		return pClassPointer;
	};

	void MoveToCurrentAnimPosition ( );
	void DrawDebugLines ( );
	bool CanMoveOverCover ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data, struct FYS_CoverData* coverData, float* HeightOffset, struct FVector* upMovementTargetLocation, struct FRotator* upMovementTargetRotation, struct FVector* animStartLocation, struct FRotator* animStartRotation, struct FVector* TargetLocation, struct FRotator* coverRotation, unsigned char* alignDuringThisMove );
	void UpdateAnimationIndex ( struct FYS_SpecialMoveData* Data, struct FYS_CoverData* coverData );
	struct FYS_AnimID GetAnimID ( );
	void InitAnimProperties ( struct FYS_SpecialMoveAnimProperties* animProperties );
	void TickSpecialMove ( float DeltaTime );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void OnReachedDestinationInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	void Init ( unsigned char specialMove, class AYGamePawn* GamePawn );
};

UClass* UYSpecialMove_OverCover::pClassPointer = NULL;

// Class SRGame.YSpecialMove_CoverVault
// 0x0080 (0x0214 - 0x0194)
class UYSpecialMove_CoverVault : public UYSpecialMove_OverCover
{
public:
	float                                              m_vaultStartPawnHeight;                           		// 0x0194 (0x0004) [0x0000000000000000]              
	class AYPlayerController*                          m_playerController;                               		// 0x0198 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_maxStandCoverDistance;                          		// 0x019C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_thinCoverTheshold;                              		// 0x01A0 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UCameraAnim*                                 m_vaultKickCamShake;                              		// 0x01A4 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_vaultKickSoundCue;                              		// 0x01A8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_doDropDown : 1;                                 		// 0x01AC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_playVaultKickAnim : 1;                          		// 0x01AC (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_usedExtendedRange : 1;                          		// 0x01AC (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_showDebugLines : 1;                             		// 0x01AC (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	struct FVector                                     m_startLocation;                                  		// 0x01B0 (0x000C) [0x0000000000000000]              
	float                                              m_vaultKickStartPct;                              		// 0x01BC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_vaultKickEndPct;                                		// 0x01C0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_SpecialMoveDetectionParams              m_vaultKickDetectionParamsNormal;                 		// 0x01C4 (0x0018) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_SpecialMoveDetectionParams              m_vaultKickDetectionParamsExtended;               		// 0x01DC (0x0018) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_vaultKickRotationMaxAdjustLeft;                 		// 0x01F4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_vaultKickRotationMaxAdjustRight;                		// 0x01F8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_vaultKickRotationAdjustRatio;                   		// 0x01FC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_vaultKickRotationAdjustStartPct;                		// 0x0200 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class USkelControlSingleBone*                      m_rotationControl;                                		// 0x0204 (0x0004) [0x0000000000000000]              
	int                                                m_vaultCamMode_Start;                             		// 0x0208 (0x0004) [0x0000000000000000]              
	int                                                m_vaultCamMode_Vault;                             		// 0x020C (0x0004) [0x0000000000000000]              
	int                                                m_vaultCamMode_Finish;                            		// 0x0210 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1699 ];

		return pClassPointer;
	};

	bool AllowsMeleeAttack ( unsigned char attackType );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	bool IsCloseToStandCover ( struct FVector specialMoveStartLocation, struct FYS_CoverData* coverData, unsigned char* Direction );
	void UpdateAnimationIndex ( struct FYS_SpecialMoveData* Data, struct FYS_CoverData* coverData );
	struct FVector HandleBeingMeleeAttacked ( );
	void DrawDebugLines ( );
	void TickSpecialMove ( float DeltaTime );
	void Hit ( struct FVector HitLocation, struct FVector HitNormal, class AActor* Other, class UPrimitiveComponent* OtherComp );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void MoveToCurrentAnimPosition ( );
	bool OnStopSpecialMoveInternal ( );
	void OnReachedDestinationInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_CoverVault::pClassPointer = NULL;

// Class SRGame.YSpecialMove_ReviveFromDeath
// 0x0050 (0x0134 - 0x00E4)
class UYSpecialMove_ReviveFromDeath : public UYSpecialMoveDestination
{
public:
	struct FYS_ReviveDeathAnimIDs                      m_animIDs[ 0x2 ];                                 		// 0x00E4 (0x0008) [0x0000000000000000]              
	unsigned char                                      m_reactionAnimID;                                 		// 0x00EC (0x0001) [0x0000000000000000]              
	unsigned char                                      m_specialMoveStance;                              		// 0x00ED (0x0001) [0x0000000000000000]              
	unsigned char                                      m_reviveState;                                    		// 0x00EE (0x0001) [0x0000000000000000]              
	float                                              m_rotationBlendTime;                              		// 0x00F0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_locationBlendTime;                              		// 0x00F4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class AYGamePawn*                                  m_pawnToRevive;                                   		// 0x00F8 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_pawnToReviveLocation;                           		// 0x00FC (0x000C) [0x0000000000000000]              
	unsigned long                                      m_pawnWasRevived : 1;                             		// 0x0108 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_useCustomCamMode : 1;                           		// 0x0108 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_reviveDistance;                                 		// 0x010C (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_maxReviveAnimDistance;                          		// 0x0110 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_minCamModeDistance;                             		// 0x0114 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FRotator                                    m_pawnToReviveTargetRot;                          		// 0x0118 (0x000C) [0x0000000000000000]              
	float                                              m_pawnToReviveRotationDuration;                   		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              m_pawnToReviveRotationTimer;                      		// 0x0128 (0x0004) [0x0000000000000000]              
	float                                              m_CountDownToReviveTimer;                         		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              m_CountDownToReviveTime;                          		// 0x0130 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1700 ];

		return pClassPointer;
	};

	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void Revive ( );
	void PlayEndAnimation ( );
	void PlayMidAnimation ( );
	void PlayBeginAnimation ( );
	struct FVector GetBestRevivePos ( struct FVector dirToPawn );
	struct FYS_AnimID GetAnimID ( unsigned char specialMoveStance, unsigned char reviveState );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void OnReachedDestinationInternal ( );
	void TickSpecialMove ( float DeltaTime );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_ReviveFromDeath::pClassPointer = NULL;

// Class SRGame.YSpecialMove_TurretEnter
// 0x00AC (0x0190 - 0x00E4)
class UYSpecialMove_TurretEnter : public UYSpecialMoveDestination
{
public:
	struct FYS_MiscAnimProperties                      m_animPropertiesStand[ 0x3 ];                     		// 0x00E4 (0x003C) [0x0000000000000000]              
	struct FYS_MiscAnimProperties                      m_animPropertiesCrouch[ 0x3 ];                    		// 0x0120 (0x003C) [0x0000000000000000]              
	unsigned char                                      m_currentState;                                   		// 0x015C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_originalWeaponEnum;                             		// 0x015D (0x0001) [0x0000000000000000]              
	float                                              m_maxDistanceSq;                                  		// 0x0160 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_maxAngle;                                       		// 0x0164 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FVector                                     m_locOffset;                                      		// 0x0168 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	class AYTrigger_TurretInteraction*                 m_turretInteraction;                              		// 0x0174 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_startLocation;                                  		// 0x0178 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_startRotation;                                  		// 0x0184 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1701 ];

		return pClassPointer;
	};

	void EquipTurretWeapon ( );
	void AnimationIntoEnded ( );
	void PlayAnimationInto ( );
	void CheckTurretWeaponEquipped ( );
	void PlayAnimationHolster ( );
	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void OnReachedDestinationInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_TurretEnter::pClassPointer = NULL;

// Class SRGame.YSpecialMove_ZiplineTraverse
// 0x00D4 (0x01B8 - 0x00E4)
class UYSpecialMove_ZiplineTraverse : public UYSpecialMoveDestination
{
public:
	struct FYS_MiscAnimProperties                      m_animProperties[ 0x4 ];                          		// 0x00E4 (0x0050) [0x0000000000000000]              
	unsigned char                                      m_currentAnimState;                               		// 0x0134 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_resetPhysicsMode : 1;                           		// 0x0138 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_useOffsetStartLocation : 1;                     		// 0x0138 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_weaponIsHolstered : 1;                          		// 0x0138 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_loopSoundPlaying : 1;                           		// 0x0138 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_collisionDisabled : 1;                          		// 0x0138 (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              m_maxDistanceSq;                                  		// 0x013C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_maxAngle;                                       		// 0x0140 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_MP_maxAngle;                                    		// 0x0144 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector                                     m_locOffset;                                      		// 0x0148 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minUseLockTime;                                 		// 0x0154 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minTeleportDist;                                		// 0x0158 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_startLocation;                                  		// 0x015C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_endLocation;                                    		// 0x0168 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_targetRot;                                      		// 0x0174 (0x000C) [0x0000000000000000]              
	class AYTrigger_ZiplineInteraction*                m_ziplineTrigger;                                 		// 0x0180 (0x0004) [0x0000000000000000]              
	float                                              m_traversalTime;                                  		// 0x0184 (0x0004) [0x0000000000000000]              
	float                                              m_accelerationTime;                               		// 0x0188 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_moveDir;                                        		// 0x018C (0x000C) [0x0000000000000000]              
	float                                              m_maxSpeed;                                       		// 0x0198 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_SpecialMoveDetectionParams              m_zipKickDetectionParams;                         		// 0x019C (0x0018) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_performZipKicksIn;                              		// 0x01B4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1702 ];

		return pClassPointer;
	};

	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	bool GetNextMoveVector ( float vel, float dt, struct FVector* moveVec );
	bool OnStopSpecialMoveInternal ( );
	void OnCancelSpecialMoveInternal ( );
	void DisableZipKicks ( );
	void DelayZipKicks ( );
	void EnableZipKicks ( );
	void OnEndAnimationEnded ( );
	void PlayEndAnimation ( );
	void TickSpecialMove ( float DeltaTime );
	bool CanPlaySpecialMoveDeathAnimation ( );
	void StartZiplineTraversalAnimation ( );
	void OnStartMovement ( );
	void OnEquipWeapon ( );
	void OnHolsterWeapon ( );
	void OnBeginAnimationEnded ( );
	void PlayBeginAnimation ( );
	void OnReachedDestinationInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_ZiplineTraverse::pClassPointer = NULL;

// Class SRGame.YSpecialMoveDirectional
// 0x0014 (0x00CC - 0x00B8)
class UYSpecialMoveDirectional : public UYSpecialMove
{
public:
	float                                              m_rotationBlendTime;                              		// 0x00B8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_lockCrouchCylinder : 1;                         		// 0x00BC (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	struct FYS_AnimID                                  m_currentAnimID;                                  		// 0x00C0 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_currentDirection;                               		// 0x00C4 (0x0001) [0x0000000000000000]              
	float                                              m_locationBlendTime;                              		// 0x00C8 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1703 ];

		return pClassPointer;
	};

	float GetAnimPlayRate ( );
	struct FYS_AnimID GetAnimID ( struct FYS_SpecialMoveData* Data );
	struct FYS_AnimID GetCurrentAnimID ( );
	unsigned char GetCurrentDirection ( );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void OnAnimStarted ( struct FYS_SpecialMoveData* Data );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMoveDirectional::pClassPointer = NULL;

// Class SRGame.YSpecialMove_StartSprint
// 0x0028 (0x00F4 - 0x00CC)
class UYSpecialMove_StartSprint : public UYSpecialMoveDirectional
{
public:
	struct FYS_StartSprintAnimations                   m_animations[ 0x2 ];                              		// 0x00CC (0x0020) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_enableRotation : 1;                             		// 0x00EC (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_camMode;                                        		// 0x00F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1704 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	float GetAnimPlayRate ( );
	struct FYS_AnimID GetAnimID ( struct FYS_SpecialMoveData* Data );
	void StartSprint ( );
	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_StartSprint::pClassPointer = NULL;

// Class SRGame.YSpecialMove_StopSprint
// 0x0008 (0x00D4 - 0x00CC)
class UYSpecialMove_StopSprint : public UYSpecialMoveDirectional
{
public:
	unsigned char                                      m_stopToIdleAnimations[ 0x2 ];                    		// 0x00CC (0x0002) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_stopToRunAnimation;                             		// 0x00CE (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class AYPlayerController*                          m_myPC;                                           		// 0x00D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1705 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	struct FYS_AnimID GetAnimID ( struct FYS_SpecialMoveData* Data );
	void Hit ( struct FVector HitLocation, struct FVector HitNormal, class AActor* Other, class UPrimitiveComponent* OtherComp );
	void TickSpecialMove ( float DeltaTime );
	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_StopSprint::pClassPointer = NULL;

// Class SRGame.YSpecialMove_Stumble
// 0x0004 (0x00D0 - 0x00CC)
class UYSpecialMove_Stumble : public UYSpecialMoveDirectional
{
public:
	class AYPlayerController*                          m_cachedPlayerController;                         		// 0x00CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1706 ];

		return pClassPointer;
	};

	void EnableControls ( unsigned long Enable );
	void LeaveTurret ( );
	void LeaveCover ( );
	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_Stumble::pClassPointer = NULL;

// Class SRGame.YSpecialMove_StumbleSandBomb
// 0x0000 (0x00D0 - 0x00D0)
class UYSpecialMove_StumbleSandBomb : public UYSpecialMove_Stumble
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1707 ];

		return pClassPointer;
	};

	float GetAnimPlayRate ( );
	struct FYS_AnimID GetAnimID ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_StumbleSandBomb::pClassPointer = NULL;

// Class SRGame.YSpecialMove_StumbleSandPool
// 0x0050 (0x0120 - 0x00D0)
class UYSpecialMove_StumbleSandPool : public UYSpecialMove_Stumble
{
public:
	struct FYS_FeedbackAnimProperties                  m_stumbleVariations[ 0x4 ];                       		// 0x00D0 (0x0050) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1708 ];

		return pClassPointer;
	};

	struct FYS_AnimID GetAnimID ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_StumbleSandPool::pClassPointer = NULL;

// Class SRGame.YSpecialMove_TakeHit
// 0x0080 (0x014C - 0x00CC)
class UYSpecialMove_TakeHit : public UYSpecialMoveDirectional
{
public:
	struct FYS_TakeHitAnimations                       m_animations[ 0x2 ];                              		// 0x00CC (0x0020) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_TakeHitAnimSetsForMoveDirs              m_separatedAnimations[ 0x2 ];                     		// 0x00EC (0x0020) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_animPhase;                                      		// 0x010C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_isStumbled : 1;                                 		// 0x0110 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_wantsStumbleCheck : 1;                          		// 0x0110 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_crouched : 1;                                   		// 0x0110 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	float                                              m_stumbleCheckTime;                               		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_timeSinceStart;                                 		// 0x0118 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_initialHitMomentum;                             		// 0x011C (0x000C) [0x0000000000000000]              
	class AYGamePawn*                                  m_attacker;                                       		// 0x0128 (0x0004) [0x0000000000000000]              
	class UCameraAnim*                                 m_cameraAnim;                                     		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              m_camShakeStrength;                               		// 0x0130 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_camShakeZValue;                                 		// 0x0134 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_idleTimeStamp;                                  		// 0x0138 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_executionDelayForward;                          		// 0x013C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_executionDelayBackward;                         		// 0x0140 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_executionDelayLeft;                             		// 0x0144 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_executionDelayRight;                            		// 0x0148 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1709 ];

		return pClassPointer;
	};

	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	bool IsExecutable ( );
	bool WillBeCancelledBy ( unsigned char otherSpecialMove );
	bool CanPlaySpecialMoveDeathAnimation ( );
	void OnCancelSpecialMoveInternal ( );
	void TickSpecialMove ( float DeltaTime );
	struct FYS_AnimID GetAnimID ( struct FYS_SpecialMoveData* Data );
	void IntoPhaseFinished ( );
	bool StartNewAnimPhase ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_TakeHit::pClassPointer = NULL;

// Class SRGame.YAimingSet
// 0x000C (0x0048 - 0x003C)
class UYAimingSet : public UObject
{
public:
	TArray< struct FYS_AimOffsetProfile >              m_aimOffsetProfiles;                              		// 0x003C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1710 ];

		return pClassPointer;
	};

};

UClass* UYAimingSet::pClassPointer = NULL;

// Class SRGame.YAnimNodeAdditiveBlending
// 0x0004 (0x010C - 0x0108)
class UYAnimNodeAdditiveBlending : public UAnimNodeAdditiveBlending
{
public:
	class UAnimNodeSequence*                           m_animNodeSequence;                               		// 0x0108 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1711 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeAdditiveBlending::pClassPointer = NULL;

// Class SRGame.YAnimNodeAimOffset
// 0x0038 (0x0174 - 0x013C)
class UYAnimNodeAimOffset : public UAnimNodeAimOffset
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                     		// 0x013C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class AYGamePawn*                                  m_pawn;                                           		// 0x0140 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class UYAimingSet*                                 m_aimingSet;                                      		// 0x0144 (0x0004) [0x0000000000020003]              ( CPF_Edit | CPF_Const | CPF_EditConst )
	struct FName                                       m_animNameCustomRef;                              		// 0x0148 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	struct FPointer                                    m_currentAimOffsetProfile;                        		// 0x0150 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FName                                       m_currentAimOffsetProfileName;                    		// 0x0154 (0x0008) [0x0000000000000000]              
	unsigned long                                      m_showSlider : 1;                                 		// 0x015C (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_interpolating : 1;                              		// 0x015C (0x0004) [0x0000000000002002] [0x00000002] ( CPF_Const | CPF_Transient )
	float                                              m_lastAimX;                                       		// 0x0160 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              m_interpSpeed;                                    		// 0x0164 (0x0004) [0x0000000000000000]              
	float                                              m_interpSpeedAI;                                  		// 0x0168 (0x0004) [0x0000000000000000]              
	float                                              m_interpThreshold;                                		// 0x016C (0x0004) [0x0000000000000000]              
	float                                              m_interpThresholdAI;                              		// 0x0170 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1712 ];

		return pClassPointer;
	};

	void OnAimingSetsChanged ( );
	bool IsProfilePresent ( struct FName ProfileName );
	struct FName GetCurrentProfileName ( );
	void SetActiveProfileByIndex ( int ProfileIndex );
	void SetActiveProfileByName ( struct FName ProfileName );
};

UClass* UYAnimNodeAimOffset::pClassPointer = NULL;

// Class SRGame.YAnimNodeBank
// 0x0010 (0x0184 - 0x0174)
class UYAnimNodeBank : public UYAnimNodeAimOffset
{
public:
	struct FVector2D                                   m_currentBanking;                                 		// 0x0174 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_currentBankingVelocity;                         		// 0x017C (0x0008) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1713 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeBank::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlend
// 0x0008 (0x010C - 0x0104)
class UYAnimNodeBlend : public UAnimNodeBlend
{
public:
	unsigned long                                      m_playBlend : 1;                                  		// 0x0104 (0x0004) [0x0000000000002001] [0x00000001] ( CPF_Edit | CPF_Transient )
	float                                              m_blendTime;                                      		// 0x0108 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1714 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeBlend::pClassPointer = NULL;

// Class SRGame.YAnimation
// 0x0018 (0x0054 - 0x003C)
class UYAnimation : public UObject
{
public:
	struct FScriptDelegate                             __OnAnimEndCallback__Delegate;                    		// 0x003C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnAnimStartCallback__Delegate;                  		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1715 ];

		return pClassPointer;
	};

	void SetZeroRootRotation ( class UAnimNodeSequence* AnimNodeSequence, unsigned long Enable );
	void SetZeroRootTranslation ( class UAnimNodeSequence* AnimNodeSequence, unsigned long Enable );
	void MirrorAnimNode ( class UAnimNode* AnimNode, unsigned long mirror );
	bool IsAimingProfilePlaying ( class UYAnimNodeChannel* animNodeChannel, class UYAnimNodeAimOffset* AnimNodeAimOffset, struct FName aimingProfileName );
	void StopAimingProfile ( class UYAnimNodeChannel* animNodeChannel, class UYAnimNodeAimOffset* AnimNodeAimOffset );
	void PlayAimingProfile ( class UYAnimNodeChannel* animNodeChannel, class UYAnimNodeAimOffset* AnimNodeAimOffset, struct FName aimingProfileName, unsigned long ForceUpdate );
	bool CanPlayAnimation ( unsigned char art, unsigned long playEnemyAnimation, unsigned long playSquadAnimation );
	void OnAnimStartCallback ( );
	void OnAnimEndCallback ( );
};

UClass* UYAnimation::pClassPointer = NULL;

// Class SRGame.YAnimInfo
// 0x299C (0x29D8 - 0x003C)
class UYAnimInfo : public UObject
{
public:
	struct FYS_AnimID                                  m_animID_None;                                    		// 0x003C (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FYS_AnimGroup                               m_animGroups[ 0xA ];                              		// 0x0040 (0x0078) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	struct FYS_PostureInfo                             m_postureInfos[ 0x36 ];                           		// 0x00B8 (0x05E8) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FYS_AnimSetIdle                             m_idleAnimSets[ 0x33 ];                           		// 0x06A0 (0x1584) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	struct FYS_AnimSetMovement                         m_movementAnimSets[ 0x1C ];                       		// 0x1C24 (0x05B0) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	struct FYS_AnimSetSprint                           m_sprintAnimSets[ 0x4 ];                          		// 0x21D4 (0x0070) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FYS_ChannelInfo                             m_aimingChannelInfo;                              		// 0x2244 (0x0050) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	struct FYS_AimingPoseInfo                          m_aimingPoseInfos[ 0x41 ];                        		// 0x2294 (0x071C) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	TArray< struct FYS_PostureTransition >             m_postureTransitions;                             		// 0x29B0 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	struct FYS_FaceFXAnim                              m_defaultFaceFXAnim;                              		// 0x29BC (0x001C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1716 ];

		return pClassPointer;
	};

	int GetAnimInfoCount ( unsigned char animGroupID );
	TArray< unsigned char > GetPosturesForGroup ( unsigned char GroupID );
	int FindPostureTransition ( unsigned char fromPosture, unsigned char toPosture, unsigned long aiming, unsigned long shooting, unsigned long wantsToShoot, unsigned long canAimOut, unsigned long wantsAimOut, unsigned long IsIdle, unsigned long isAI, unsigned char* outIsReversed, struct FYS_PostureTransition* outPostureTransition );
	void SetPostureTransition ( int postureIdx, struct FYS_PostureTransition postureTransition );
	struct FYS_PostureTransition GetPostureTransition ( int postureIdx );
	struct FYS_ChannelInfo GetAimingChannelInfo ( );
	struct FYS_AimingPoseInfo GetAimingPoseInfo ( unsigned char aimingPoseID );
	struct FYS_AnimSetSprint GetSprintAnimSet ( unsigned char sprintAnimSetID );
	struct FYS_AnimSetMovement GetMovementAnimSet ( unsigned char movementAnimSetID );
	void SetIdleAnimSet ( unsigned char idleAnimSetID, struct FYS_AnimSetIdle animSetIdle );
	struct FYS_AnimSetIdle GetIdleAnimSet ( unsigned char idleAnimSetID );
	struct FYS_PostureInfo GetPostureInfo ( unsigned char postureID );
	void SetAnimInfo ( struct FYS_AnimID animID, struct FYS_AnimInfo AnimInfo );
	struct FYS_AnimInfo GetAnimInfoCopy ( struct FYS_AnimID animID );
	struct FYS_AnimID AnimID_DeathAnim ( unsigned char animID );
	struct FYS_AnimID AnimID_Additive ( unsigned char animID );
	struct FYS_AnimID AnimID_Camera ( unsigned char animID );
	struct FYS_AnimID AnimID_Feedback ( unsigned char animID );
	struct FYS_AnimID AnimID_Misc ( unsigned char animID );
	struct FYS_AnimID AnimID_Combat ( unsigned char animID );
	struct FYS_AnimID AnimID_Transition ( unsigned char animID );
	struct FYS_AnimID AnimID_Movement ( unsigned char animID );
	struct FYS_AnimID AnimID_Dynamic ( unsigned char animID );
};

UClass* UYAnimInfo::pClassPointer = NULL;

// Class SRGame.YDeathAnimInfo
// 0x1AE0 (0x44B8 - 0x29D8)
class UYDeathAnimInfo : public UYAnimInfo
{
public:
	struct FYS_DeathAnimProperty                       m_deathAnimProperties[ 0x79 ];                    		// 0x29D8 (0x1A78) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FName >                             m_torsoBoneList;                                  		// 0x4450 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             m_leftLegBoneList;                                		// 0x445C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             m_rightLegBoneList;                               		// 0x4468 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             m_leftArmBoneList;                                		// 0x4474 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             m_rightArmBoneList;                               		// 0x4480 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FName                                       m_headBoneName;                                   		// 0x448C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_leftHandBoneName;                               		// 0x4494 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_rightHandBoneName;                              		// 0x449C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_hipBoneName;                                    		// 0x44A4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FName >                             m_velDriveJointNames;                             		// 0x44AC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1717 ];

		return pClassPointer;
	};

	struct FYS_DeathAnimProperty GetDeathAnimProperties ( unsigned char animID );
};

UClass* UYDeathAnimInfo::pClassPointer = NULL;

// Class SRGame.YAnimInfoSpecialIdle
// 0x000C (0x44C4 - 0x44B8)
class UYAnimInfoSpecialIdle : public UYDeathAnimInfo
{
public:
	TArray< struct FYS_SpecialIdleAnimProperty >       m_specialIdleAnimProperties;                      		// 0x44B8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1718 ];

		return pClassPointer;
	};

};

UClass* UYAnimInfoSpecialIdle::pClassPointer = NULL;

// Class SRGame.YAnimInfoDebug
// 0x0000 (0x003C - 0x003C)
class UYAnimInfoDebug : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1719 ];

		return pClassPointer;
	};

	void DumpHandPoses ( class UYAnimInfo* AnimInfo );
	bool CheckAimingStateFallbacks ( class UYAnimInfo* pawnAnimInfo );
	int CheckAnimInfoForErrors ( class UYAnimInfo* pawnAnimInfo, struct FYS_AnimID animInfoID, class AYGamePawn* Pawn, TArray< struct FName >* usedAnimNames, TArray< struct FName >* usedAimProfileNames, TArray< struct FName >* missingAnimNames );
	int CheckSprintAnimSetForErrors ( class UYAnimInfo* pawnAnimInfo, unsigned char sprintAnimSetID, unsigned char postureID, class AYGamePawn* Pawn, TArray< struct FName >* usedAnimNames, TArray< struct FName >* missingAnimNames );
	int CheckMovementAnimSetForErrors ( class UYAnimInfo* pawnAnimInfo, unsigned char movementAnimSetID, unsigned char postureID, class AYGamePawn* Pawn, TArray< struct FName >* usedAnimNames, TArray< struct FName >* usedAimProfileNames, TArray< struct FName >* missingAnimNames );
	int CheckAimingPoseForErrors ( class UYAnimInfo* pawnAnimInfo, unsigned char aimingPose, unsigned char postureID, class AYGamePawn* Pawn, TArray< struct FName >* usedAimProfileNames );
	void CheckAnim ( class AYGamePawn* Pawn, struct FName AnimName, TArray< struct FName >* usedAnimNames, TArray< struct FName >* missingAnimNames );
	int CheckIdleAnimSetForErrors ( class UYAnimInfo* pawnAnimInfo, unsigned char idleAnimSet, unsigned char postureID, class AYGamePawn* Pawn, TArray< struct FName >* usedAnimNames, TArray< struct FName >* missingAnimNames );
	void CheckForErrors ( class UYAnimInfo* pawnAnimInfo, class AYGamePawn* Pawn );
	struct FString PostureIDToString ( int postureID );
	void DumpAnimInfo ( struct FYS_AnimInfo* AnimInfo );
	void GetAnimNamesInTree ( class UAnimTree* AnimTree, TArray< struct FName >* usedAnimNames );
	struct FString AnimIDToString ( struct FYS_AnimID animID );
};

UClass* UYAnimInfoDebug::pClassPointer = NULL;

// Class SRGame.YAnimInfoSnippet
// 0x00C4 (0x0100 - 0x003C)
class UYAnimInfoSnippet : public UObject
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x003C (0x0004) [0x0000000000000000]              
	TArray< struct FYS_AnimID >                        m_animIDs;                                        		// 0x0040 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_AnimInfo >                      LastAnims;                                        		// 0x004C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_transitionIdx;                                  		// 0x0058 (0x0004) [0x0000000000000000]              
	struct FYS_PostureTransition                       CurrentTransition;                                		// 0x005C (0x0030) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_currentPostureID;                               		// 0x008C (0x0001) [0x0000000000000000]              
	struct FYS_AnimSetIdle                             Idle;                                             		// 0x0090 (0x006C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_idleAimed : 1;                                  		// 0x00FC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1720 ];

		return pClassPointer;
	};

	void WriteBack ( );
};

UClass* UYAnimInfoSnippet::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendByEffortStatus
// 0x0008 (0x011C - 0x0114)
class UYAnimNodeBlendByEffortStatus : public UAnimNodeBlendList
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x0114 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              m_blendTime;                                      		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1721 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeBlendByEffortStatus::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendByLOD
// 0x000C (0x0120 - 0x0114)
class UYAnimNodeBlendByLOD : public UAnimNodeBlendList
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x0114 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              m_blendTime;                                      		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDistanceFactor;                              		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1722 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeBlendByLOD::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendByPlaying
// 0x0024 (0x0138 - 0x0114)
class UYAnimNodeBlendByPlaying : public UAnimNodeBlendList
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x0114 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              m_blendTime;                                      		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FName >                             m_nodeNames;                                      		// 0x011C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_checkBlending : 1;                              		// 0x0128 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	TArray< class UAnimNodeSequence* >                 m_animSequenceNodes;                              		// 0x012C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1723 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeBlendByPlaying::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendByPosture
// 0x0008 (0x011C - 0x0114)
class UYAnimNodeBlendByPosture : public UAnimNodeBlendList
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x0114 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              m_blendTime;                                      		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1724 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeBlendByPosture::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendBySandStorm
// 0x0008 (0x011C - 0x0114)
class UYAnimNodeBlendBySandStorm : public UAnimNodeBlendList
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x0114 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              m_blendTime;                                      		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1725 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeBlendBySandStorm::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendBySpeed
// 0x0038 (0x017C - 0x0144)
class UYAnimNodeBlendBySpeed : public UAnimNodeBlendBySpeed
{
public:
	TArray< struct FYS_ChannelSequenceNodes >          m_channelSequences;                               		// 0x0144 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UAnimNodeSequence* >                 m_breathingSequenceNodes;                         		// 0x0150 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class AYGamePawn*                                  m_pawn;                                           		// 0x015C (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	struct FName                                       m_movementAnimGroupName;                          		// 0x0160 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FName                                       m_sprintAnimGroupName;                            		// 0x0168 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FScriptDelegate                             __OnBlendBranchChanged__Delegate;                 		// 0x0170 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1726 ];

		return pClassPointer;
	};

	void OnAnimSetsChanged ( );
	void Reset ( );
	void OnBlendBranchChanged ( int newBranch, float BlendInTime );
};

UClass* UYAnimNodeBlendBySpeed::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendBySprintType
// 0x0008 (0x011C - 0x0114)
class UYAnimNodeBlendBySprintType : public UAnimNodeBlendList
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x0114 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              m_blendTime;                                      		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1727 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeBlendBySprintType::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendDirectional
// 0x0050 (0x0198 - 0x0148)
class UYAnimNodeBlendDirectional : public UAnimNodeSequenceBlendBase
{
public:
	struct FYS_MovementAnims                           m_currentAnims;                                   		// 0x0148 (0x0030) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_blendSpeed;                                     		// 0x0178 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_forwardBackwardStrafeTolerance;                 		// 0x017C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_singleAnimAtOrAboveLOD;                         		// 0x0180 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_currentAngle;                                   		// 0x0184 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_isInitialized : 1;                              		// 0x0188 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_forceAnimUpdate : 1;                            		// 0x0188 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_isForwardStrafing : 1;                          		// 0x0188 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_disabledHandIK : 1;                             		// 0x0188 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	class AYGamePawn*                                  m_pawn;                                           		// 0x018C (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	struct FName                                       m_masterSequenceName;                             		// 0x0190 (0x0008) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1728 ];

		return pClassPointer;
	};

	void ReplaceAnims ( struct FYS_MovementAnims* newAnims );
	bool CheckAnims ( struct FYS_MovementAnims* newAnims );
};

UClass* UYAnimNodeBlendDirectional::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendList
// 0x0018 (0x012C - 0x0114)
class UYAnimNodeBlendList : public UAnimNodeBlendList
{
public:
	TArray< float >                                    m_childBlendInTime;                               		// 0x0114 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned long >                            m_blockSetActiveChildWhenRelevant;                		// 0x0120 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1729 ];

		return pClassPointer;
	};

	void SetActiveChild ( int ChildIndex, float BlendTime );
};

UClass* UYAnimNodeBlendList::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendPerBone
// 0x000C (0x0138 - 0x012C)
class UYAnimNodeBlendPerBone : public UAnimNodeBlendPerBone
{
public:
	TArray< struct FName >                             m_branchStopBoneName;                             		// 0x012C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1730 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeBlendPerBone::pClassPointer = NULL;

// Class SRGame.YAnimNodeChannel
// 0x0048 (0x015C - 0x0114)
class UYAnimNodeChannel : public UAnimNodeBlendList
{
public:
	struct FPointer                                    VfTable_IYIAnimNodeChannel;                       		// 0x0114 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class AYGamePawn*                                  m_pawn;                                           		// 0x0118 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	unsigned long                                      m_notifyParent : 1;                               		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_parentNotified : 1;                             		// 0x011C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_keepAliveWhenFinished : 1;                      		// 0x011C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_resetParentBlendPending : 1;                    		// 0x011C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_earlyAnimEndNotify : 1;                         		// 0x011C (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	int                                                m_resetBranch;                                    		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeBlendPerBone*                       m_parentBlend;                                    		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              m_blendOffTime;                                   		// 0x0128 (0x0004) [0x0000000000000000]              
	struct FAimingNodeData                             m_aimingData;                                     		// 0x012C (0x0010) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_forceAnimUpdateFlags;                           		// 0x013C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_pendingAimTimer;                                		// 0x0140 (0x0004) [0x0000000000000000]              
	int                                                m_pendingAimChannel;                              		// 0x0144 (0x0004) [0x0000000000000000]              
	struct FName                                       m_pendingAimProfileName;                          		// 0x0148 (0x0008) [0x0000000000000000]              
	struct FName                                       m_pendingSecondAimProfileName;                    		// 0x0150 (0x0008) [0x0000000000000000]              
	float                                              m_pendingAimBlendTime;                            		// 0x0158 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1731 ];

		return pClassPointer;
	};

	void SetBlendoutTime ( float NewBlendOutTime );
	void MirrorAnimNodeSequence ( class UAnimNodeSequence* AnimNodeSequence, unsigned long mirror );
	void OnAimingSetsChanged ( );
	void OnAnimSetsChanged ( );
	int GetResetBranch ( );
	void SetActiveChild ( int ChildIndex, float BlendTime );
	class UYAnimNodeAimOffset* PlayAimingProfile ( struct FName aimProfileName, unsigned long mirrored, float BlendInTime, float BlendOutTime );
	class UAnimNodeSequence* PlayAnimation ( struct FName Animation, struct FName additiveAnimation, struct FName aimProfileName, struct FName secondAimProfileName, float aimDelayPct, unsigned long Looping, unsigned long mirrored, float Rate, unsigned long keepAlive, unsigned long earlyNotify, float BlendInTime, float BlendOutTime, unsigned long limitBlendInTime );
	void SetZeroRootRotation ( unsigned long Enable );
	void SetZeroRootTranslation ( unsigned long Enable );
	void Deactivate ( float blendOffTime );
	class UAnimNodeBlendPerBone* GetParentBlend ( );
};

UClass* UYAnimNodeChannel::pClassPointer = NULL;

// Class SRGame.YAnimNodeBlendByIdle
// 0x00C8 (0x0224 - 0x015C)
class UYAnimNodeBlendByIdle : public UYAnimNodeChannel
{
public:
	float                                              m_blendTime;                                      		// 0x015C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_idleAnimSetID;                                  		// 0x0160 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_lastIdleAnimSetID;                              		// 0x0161 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_lastIsUsingGrenade : 1;                         		// 0x0164 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_customIdleAnimation : 1;                        		// 0x0164 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_customIdleHasBeenStarted : 1;                   		// 0x0164 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_lastIsIdle : 1;                                 		// 0x0164 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_mirrored : 1;                                   		// 0x0164 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_forceUpdate : 1;                                		// 0x0164 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_hasFullWeight : 1;                              		// 0x0164 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_useHorizontalAimForAnimPos : 1;                 		// 0x0164 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_useVerticalAimForAnimPos : 1;                   		// 0x0164 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_nextUseHorizontalAimForAnimPos : 1;             		// 0x0164 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_nextUseVerticalAimForAnimPos : 1;               		// 0x0164 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_enabledRootMotionTranslation : 1;               		// 0x0164 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_enabledRootMotionRotation : 1;                  		// 0x0164 (0x0004) [0x0000000000000000] [0x00001000] 
	TArray< struct FYS_IdleAnim >                      m_idleAnimations;                                 		// 0x0168 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_RotationAnim >                  m_turnAnimations;                                 		// 0x0174 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_FaceFXAnim                              m_faceFXAnim;                                     		// 0x0180 (0x001C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_FaceFXAnim                              m_combatFaceFXAnim;                               		// 0x019C (0x001C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_FaceFXAnim                              m_prevFxAnim;                                     		// 0x01B8 (0x001C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_nextBlendTime;                                  		// 0x01D4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_lastAnimationName;                              		// 0x01D8 (0x0008) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_currentRotationAnimNodeSequence;                		// 0x01E0 (0x0004) [0x0000000000000000]              
	struct FName                                       m_playingRotationName;                            		// 0x01E4 (0x0008) [0x0000000000000000]              
	int                                                m_playingRotationDelta;                           		// 0x01EC (0x0004) [0x0000000000000000]              
	float                                              m_playingRotationDeltaRate;                       		// 0x01F0 (0x0004) [0x0000000000000000]              
	struct FName                                       m_aimOffsetProfileName;                           		// 0x01F4 (0x0008) [0x0000000000000000]              
	struct FName                                       m_secondAimOffsetProfileName;                     		// 0x01FC (0x0008) [0x0000000000000000]              
	float                                              m_secondAimProfileBlendEnd;                       		// 0x0204 (0x0004) [0x0000000000000000]              
	struct FName                                       m_additiveAnim;                                   		// 0x0208 (0x0008) [0x0000000000000000]              
	struct FName                                       m_additiveAnimRotation;                           		// 0x0210 (0x0008) [0x0000000000000000]              
	int                                                m_minTurnAngle;                                   		// 0x0218 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_minTurnAngleAI;                                 		// 0x021C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_postureAimingRange;                             		// 0x0220 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1732 ];

		return pClassPointer;
	};

	void OnAimingSetsChanged ( );
	void OnAnimSetsChanged ( );
	void SetIdleAnimations ( unsigned char animSetID, struct FYS_FaceFXAnim faceFXAnim, struct FYS_FaceFXAnim combatFaceFxAnim, struct FName additiveAnim, struct FName additiveAnimRotation, struct FName aimingProfile, struct FName secondAimingProfile, float secondAimProfileBlendEnd, unsigned long useHorizontalAimForAnimPos, unsigned long useVerticalAimForAnimPos, float postureAimingRange, float BlendTime, unsigned long mirrored, TArray< struct FYS_IdleAnim >* idleAnimations, TArray< struct FYS_RotationAnim >* turnAnimations );
	void PlayReplicatedAnimation ( struct FName Animation, unsigned long looped, float Rate, int initialRotationYaw, int targetAngle );
	class UAnimNodeSequence* PlayAnimation ( struct FName Animation, struct FName additiveAnimation, struct FName aimProfileName, struct FName secondAimProfileName, float aimDelayPct, unsigned long looped, unsigned long mirrored, float Rate, unsigned long keepAlive, unsigned long earlyNotify, float BlendInTime, float BlendOutTime, unsigned long limitBlendInTime );
	void Deactivate ( float blendOffTime );
};

UClass* UYAnimNodeBlendByIdle::pClassPointer = NULL;

// Class SRGame.YAnimNodeChn_FB
// 0x0050 (0x01AC - 0x015C)
class UYAnimNodeChn_FB : public UYAnimNodeChannel
{
public:
	TArray< struct FYS_BlendListNode >                 m_blendListNodes;                                 		// 0x015C (0x000C) [0x0000000000502002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FYS_FaceFXAnim >                    m_faceFXAnims;                                    		// 0x0168 (0x000C) [0x0000000020400002]              ( CPF_Const | CPF_NeedCtorLink | CPF_Deprecated )
	struct FYS_FaceFXAnim                              m_faceFXAnimations[ 0x2 ];                        		// 0x0174 (0x0038) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1733 ];

		return pClassPointer;
	};

	void OnAimingSetsChanged ( );
	void OnAnimSetsChanged ( );
	void PlayMovementSet ( class UYAnimInfo* AnimInfo, int where, unsigned long aiming, float BlendInTime, unsigned long mirrored, struct FYS_AnimSetMovement* movementSet );
};

UClass* UYAnimNodeChn_FB::pClassPointer = NULL;

// Class SRGame.YAnimNodeChannelAdditive
// 0x0024 (0x0138 - 0x0114)
class UYAnimNodeChannelAdditive : public UAnimNodeBlendList
{
public:
	struct FPointer                                    VfTable_IYIAnimNodeChannel;                       		// 0x0114 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class AYGamePawn*                                  m_pawn;                                           		// 0x0118 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	TArray< class UYAnimNodeAdditiveBlending* >        m_children;                                       		// 0x011C (0x000C) [0x0000000000502002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	int                                                m_forceAnimUpdateFlags;                           		// 0x0128 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_earlyAnimEndNotify : 1;                         		// 0x012C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_keepAliveWhenFinished : 1;                      		// 0x012C (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_blendOffTime;                                   		// 0x0130 (0x0004) [0x0000000000000000]              
	int                                                m_activeChildIndex;                               		// 0x0134 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1734 ];

		return pClassPointer;
	};

	void SetBlendoutTime ( float NewBlendOutTime );
	void MirrorAnimNodeSequence ( class UAnimNodeSequence* AnimNodeSequence, unsigned long mirror );
	void OnAimingSetsChanged ( );
	void OnAnimSetsChanged ( );
	int GetResetBranch ( );
	void SetActiveChild ( int ChildIndex, float BlendTime );
	class UYAnimNodeAimOffset* PlayAimingProfile ( struct FName aimProfileName, unsigned long mirrored, float BlendInTime, float BlendOutTime );
	class UAnimNodeSequence* PlayAnimation ( struct FName Animation, struct FName additiveAnimation, struct FName aimProfileName, struct FName secondAimProfileName, float aimDelayPct, unsigned long Looping, unsigned long mirrored, float Rate, unsigned long keepAlive, unsigned long earlyNotify, float BlendInTime, float BlendOutTime, unsigned long limitBlendInTime );
	void Deactivate ( float blendOffTime );
	class UAnimNodeBlendPerBone* GetParentBlend ( );
};

UClass* UYAnimNodeChannelAdditive::pClassPointer = NULL;

// Class SRGame.YAnimNodeRotationPreview
// 0x001F (0x0110 - 0x00F1)
class UYAnimNodeRotationPreview : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[ 0xF ];                             		// 0x00F1 (0x000F) MISSED OFFSET
	struct FQuat                                       m_rotationDelta;                                  		// 0x0100 (0x0010) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1735 ];

		return pClassPointer;
	};

};

UClass* UYAnimNodeRotationPreview::pClassPointer = NULL;

// Class SRGame.YAnimNotify_DeathDBNOSound
// 0x0000 (0x005C - 0x005C)
class UYAnimNotify_DeathDBNOSound : public UAnimNotify_Sound
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1736 ];

		return pClassPointer;
	};

};

UClass* UYAnimNotify_DeathDBNOSound::pClassPointer = NULL;

// Class SRGame.YAnimNotify_DetachWeaponBase
// 0x0001 (0x0041 - 0x0040)
class UYAnimNotify_DetachWeaponBase : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_detachReason;                                   		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1737 ];

		return pClassPointer;
	};

	unsigned char GetDetachReason ( class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_DetachWeaponBase::pClassPointer = NULL;

// Class SRGame.YAnimNotify_DetachWeapon
// 0x0017 (0x0058 - 0x0041)
class UYAnimNotify_DetachWeapon : public UYAnimNotify_DetachWeaponBase
{
public:
	struct FName                                       m_socketNameToAttachTo;                           		// 0x0044 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_socketNameIfMirrored;                           		// 0x004C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_ignoreMissingReequip : 1;                       		// 0x0054 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1738 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
	bool UpdateChosenSocketName ( );
};

UClass* UYAnimNotify_DetachWeapon::pClassPointer = NULL;

// Class SRGame.YAnimNotify_Kismet
// 0x0008 (0x0048 - 0x0040)
class UYAnimNotify_Kismet : public UAnimNotify_Scripted
{
public:
	struct FName                                       m_notifyName;                                     		// 0x0040 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1739 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_Kismet::pClassPointer = NULL;

// Class SRGame.YAnimNotify_Sound
// 0x0001 (0x005D - 0x005C)
class UYAnimNotify_Sound : public UAnimNotify_Sound
{
public:
	unsigned char                                      SoundType;                                        		// 0x005C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1740 ];

		return pClassPointer;
	};

};

UClass* UYAnimNotify_Sound::pClassPointer = NULL;

// Class SRGame.YAnimNotify_SpecialAction
// 0x0002 (0x0042 - 0x0040)
class UYAnimNotify_SpecialAction : public UAnimNotify
{
public:
	unsigned char                                      m_type;                                           		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_priority;                                       		// 0x0041 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1741 ];

		return pClassPointer;
	};

};

UClass* UYAnimNotify_SpecialAction::pClassPointer = NULL;

// Class SRGame.YAnimNotify_Tag
// 0x0008 (0x0048 - 0x0040)
class UYAnimNotify_Tag : public UAnimNotify
{
public:
	struct FName                                       m_tagName;                                        		// 0x0040 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1742 ];

		return pClassPointer;
	};

};

UClass* UYAnimNotify_Tag::pClassPointer = NULL;

// Class SRGame.YAnimtreeManager
// 0x0290 (0x02CC - 0x003C)
class UYAnimtreeManager : public UObject
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x003C (0x0004) [0x0000000000000000]              
	class UAnimTree*                                   m_animtree;                                       		// 0x0040 (0x0004) [0x0000000000000000]              
	TArray< struct FYS_AnimChannel >                   m_animChannels;                                   		// 0x0044 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UYIAnimNodeChannel* >                m_animNodeChannels;                               		// 0x0050 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UYAnimNodeChn_FB*                            m_animNodeChannelFullBody;                        		// 0x005C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAnimNodeBlendByIdle*                       m_animNodeChannelIdle;                            		// 0x0060 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAnimNodeBlendBySpeed*                      m_movementAnimNode;                               		// 0x0064 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAnimNodeBlendBySpeed*                      m_additiveBySpeedAnimNode;                        		// 0x0068 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UAnimNodeSequence*                           m_sprintAnimNode;                                 		// 0x006C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UAnimNodeSequence*                           m_combatSprintAnimNode;                           		// 0x0070 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAnimNodeAdditiveBlending*                  m_aimedSprintAnimNode;                            		// 0x0074 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAnimNodeBank*                              m_bankingAnimNode;                                		// 0x0078 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_movementAnimGroupName;                          		// 0x007C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_sprintAnimGroupName;                            		// 0x0084 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_defaultSynchGroupName;                          		// 0x008C (0x0008) [0x0000000000000002]              ( CPF_Const )
	class UYAnimInfo*                                  m_animInfo;                                       		// 0x0094 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_currentPosture;                                 		// 0x0098 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_previousPosture;                                		// 0x0099 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentAimingPose;                              		// 0x009A (0x0001) [0x0000000000000000]              
	unsigned char                                      m_moveTransitionAnimID;                           		// 0x009B (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentMovementSpeed;                           		// 0x009C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentAimingPoseState;                         		// 0x009D (0x0001) [0x0000000000000000]              
	unsigned char                                      m_handToWorldPositionControlsEnabled;             		// 0x009E (0x0001) [0x0000000000000000]              
	unsigned char                                      m_rootMotionMode;                                 		// 0x009F (0x0001) [0x0000000000000000]              
	TArray< class UAnimNodeSequence* >                 m_pendingMirrorAnimations;                        		// 0x00A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_aimingPosePlaying : 1;                          		// 0x00AC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_zoomPosturesEnabled : 1;                        		// 0x00AC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_forceKeepMoveAnim : 1;                          		// 0x00AC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_moveTransitionReversed : 1;                     		// 0x00AC (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_isRunning : 1;                                  		// 0x00AC (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_currentPostureMirrored : 1;                     		// 0x00AC (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_nextPostureMirrored : 1;                        		// 0x00AC (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_previousPostureMirrored : 1;                    		// 0x00AC (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_isPlayingPostureAnimation : 1;                  		// 0x00AC (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_aimingEnabled : 1;                              		// 0x00AC (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_aimingPossible : 1;                             		// 0x00AC (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      m_zoomingEnabled : 1;                             		// 0x00AC (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_handToWeaponControlsEnabled : 1;                		// 0x00AC (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_handIKControlsEnabled : 1;                      		// 0x00AC (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      m_recoilEnabled : 1;                              		// 0x00AC (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	TArray< unsigned char >                            m_aimingStateFallbacks;                           		// 0x00B0 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	float                                              m_defaultTransitionBlendTime;                     		// 0x00BC (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_defaultAimingBlendTime;                         		// 0x00C0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_defaultPostureBlendTime;                        		// 0x00C4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FYS_AnimID                                  m_transitionAnimID;                               		// 0x00C8 (0x0004) [0x0000000000000000]              
	int                                                m_transitionIdx;                                  		// 0x00CC (0x0004) [0x0000000000000000]              
	struct FYS_AnimID                                  m_previousTransitionAnimID;                       		// 0x00D0 (0x0004) [0x0000000000000000]              
	float                                              m_idleTransitionTimeLimit;                        		// 0x00D4 (0x0004) [0x0000000000000000]              
	struct FYS_AnimID                                  m_lastAnimIDs[ 0x5 ];                             		// 0x00D8 (0x0014) [0x0000000000000000]              
	int                                                m_lastAnimEntry;                                  		// 0x00EC (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_transitionAnimNodeSequence;                     		// 0x00F0 (0x0004) [0x0000000000000000]              
	struct FYS_PostureTransitionInfo                   m_postureTransitionInfo;                          		// 0x00F4 (0x0024) [0x0000000000000000]              
	float                                              m_nextPostureBlendTime;                           		// 0x0118 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_coverRotation;                                  		// 0x011C (0x000C) [0x0000000000000000]              
	int                                                m_aimingBlockedCount;                             		// 0x0128 (0x0004) [0x0000000000000000]              
	int                                                m_shootingBlockedCount;                           		// 0x012C (0x0004) [0x0000000000000000]              
	class USkelControlLimb*                            m_leftHandToWeaponLocationControl;                		// 0x0130 (0x0004) [0x0000000000000000]              
	struct FName                                       m_leftHandToWeaponLocationControlName;            		// 0x0134 (0x0008) [0x0000000000000000]              
	class USkelControlLimb*                            m_rightHandToWeaponLocationControl;               		// 0x013C (0x0004) [0x0000000000000000]              
	struct FName                                       m_rightHandToWeaponLocationControlName;           		// 0x0140 (0x0008) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_leftHandToWeaponRotationControl;                		// 0x0148 (0x0004) [0x0000000000000000]              
	struct FName                                       m_leftHandToWeaponRotationControlName;            		// 0x014C (0x0008) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_rightHandToWeaponRotationControl;               		// 0x0154 (0x0004) [0x0000000000000000]              
	struct FName                                       m_rightHandToWeaponRotationControlName;           		// 0x0158 (0x0008) [0x0000000000000000]              
	int                                                m_leftHandToWeaponControlsDisableCount;           		// 0x0160 (0x0004) [0x0000000000000000]              
	int                                                m_rightHandToWeaponControlsDisableCount;          		// 0x0164 (0x0004) [0x0000000000000000]              
	class USkelControlLimb*                            m_leftHandToWorldLocationControl;                 		// 0x0168 (0x0004) [0x0000000000000000]              
	struct FName                                       m_leftHandToWorldLocationControlName;             		// 0x016C (0x0008) [0x0000000000000000]              
	class USkelControlLimb*                            m_rightHandToWorldLocationControl;                		// 0x0174 (0x0004) [0x0000000000000000]              
	struct FName                                       m_rightHandToWorldLocationControlName;            		// 0x0178 (0x0008) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_leftHandToWorldRotationControl;                 		// 0x0180 (0x0004) [0x0000000000000000]              
	struct FName                                       m_leftHandToWorldRotationControlName;             		// 0x0184 (0x0008) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_rightHandToWorldRotationControl;                		// 0x018C (0x0004) [0x0000000000000000]              
	struct FName                                       m_rightHandToWorldRotationControlName;            		// 0x0190 (0x0008) [0x0000000000000000]              
	struct FVector                                     m_leftHandToWeaponControlLocationOffset;          		// 0x0198 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_leftHandToWeaponControlRotationOffset;          		// 0x01A4 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_rightHandToWeaponControlLocationOffset;         		// 0x01B0 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rightHandToWeaponControlRotationOffset;         		// 0x01BC (0x000C) [0x0000000000000000]              
	int                                                m_handIKDisableCount;                             		// 0x01C8 (0x0004) [0x0000000000000000]              
	class UYSkelControlRecoil*                         m_weaponRecoilControl;                            		// 0x01CC (0x0004) [0x0000000000000000]              
	struct FName                                       m_weaponRecoilControlName;                        		// 0x01D0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	class UYSkelControlRecoil*                         m_spineRecoilControl;                             		// 0x01D8 (0x0004) [0x0000000000000000]              
	struct FName                                       m_spineRecoilControlName;                         		// 0x01DC (0x0008) [0x0000000000000002]              ( CPF_Const )
	class UYSkelControlRecoil*                         m_leftShoulderRecoilControl;                      		// 0x01E4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_leftShoulderRecoilControlName;                  		// 0x01E8 (0x0008) [0x0000000000000002]              ( CPF_Const )
	class UYSkelControlRecoil*                         m_rightShoulderRecoilControl;                     		// 0x01F0 (0x0004) [0x0000000000000000]              
	struct FName                                       m_rightShoulderRecoilControlName;                 		// 0x01F4 (0x0008) [0x0000000000000002]              ( CPF_Const )
	float                                              m_ragrecoverBlendTime;                            		// 0x01FC (0x0004) [0x0000000000000000]              
	TArray< struct FYS_DynamicAnimInfo >               m_dynamicAnimInfos;                               		// 0x0200 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_rootMotionEnableCount;                          		// 0x020C (0x0004) [0x0000000000000000]              
	int                                                m_rootMotionRotationEnableCount;                  		// 0x0210 (0x0004) [0x0000000000000000]              
	struct FName                                       m_rotationAdjustControlName;                      		// 0x0214 (0x0008) [0x0000000000000002]              ( CPF_Const )
	class USkelControlSingleBone*                      m_rotationAdjustControl;                          		// 0x021C (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_animNodeNames;                                  		// 0x0220 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	struct FName                                       m_animNodeNameFullBody;                           		// 0x022C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameUpperBody;                          		// 0x0234 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameHead;                               		// 0x023C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameLowerBody;                          		// 0x0244 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameIdle;                               		// 0x024C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameFullBodyOverlay;                    		// 0x0254 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameUpperBodyOverlay;                   		// 0x025C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameCamera;                             		// 0x0264 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameFullBodyAdditive;                   		// 0x026C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameMoveFullBodyAdditive;               		// 0x0274 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameWeakFullBodyAdditive;               		// 0x027C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameIdleFullBodyAdditive;               		// 0x0284 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameMovement;                           		// 0x028C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameAdditiveBySpeed;                    		// 0x0294 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameSprint;                             		// 0x029C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameAimedSprint;                        		// 0x02A4 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameCombatSprint;                       		// 0x02AC (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_animNodeNameBanking;                            		// 0x02B4 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_finishedTakingUpWeaponCallbackName;             		// 0x02BC (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_finishedTakingDownWeaponCallbackName;           		// 0x02C4 (0x0008) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1743 ];

		return pClassPointer;
	};

	bool FindLastNotifyFootstep ( class UAnimSequence* Sequence, float endTimeOffset, struct FAnimNotifyEvent* Left, struct FAnimNotifyEvent* Right );
	bool FindFirstNotifyFootstep ( class UAnimSequence* Sequence, float startTimeOffset, struct FAnimNotifyEvent* Left, struct FAnimNotifyEvent* Right );
	struct FAnimNotifyEvent FindLastNotify ( class UAnimSequence* Sequence, class UClass* clss, float endTimeOffset );
	struct FAnimNotifyEvent FindFirstNotify ( class UAnimSequence* Sequence, class UClass* clss, float startTimeOffset );
	void DisplayDebug ( class AHUD* H, float* out_YL, float* out_YPos );
	void DisplayPlayingAnimNames ( class AHUD* H, unsigned long detailed, float* out_YL, float* out_YPos );
	TArray< class UYAnimNodeAimOffset* > GetPlayingAimOffsets ( );
	TArray< class UAnimNodeSequence* > GetPlayingAnimSequences ( );
	void DumpPlayingAnimations ( );
	void DumpAnimChannels ( );
	void DumpPostureTransitionInfo ( );
	void SetZeroRootOffset ( unsigned char zeroRootTranslation, unsigned char zeroRootRotation );
	void EnableRootMotionRotation ( unsigned long Enable );
	unsigned char GetRootMotionMode ( );
	void EnableRootMotion ( unsigned long Enable, unsigned char RootMotionMode );
	void EnableZoomPostures ( unsigned long Enabled );
	void EnableZooming ( unsigned long zooming );
	void GetMovementTransitionDoneCallback ( struct FScriptDelegate* movementTransitionDone );
	void UpdateMovementTransition ( unsigned char newCoverMoveDir );
	void UpdateAimingSet ( float BlendTime );
	bool EnableAiming ( unsigned long aiming, float BlendTime );
	bool DebugAreHandIKControlsEnabled ( );
	void DebugEnableHandIKControls ( unsigned long Enable );
	bool DebugIsRecoilEnabled ( );
	void DebugEnableRecoil ( unsigned long Enable );
	void DisableHandIKControls ( unsigned long Disable );
	void GetHandToWorldPosition ( struct FVector* leftHandLocation, struct FVector* rightHandLocation, struct FRotator* leftHandRotation, struct FRotator* rightHandRotation );
	void SetHandToWorldPosition ( struct FVector leftHandLocation, struct FVector rightHandLocation, struct FRotator leftHandRotation, struct FRotator rightHandRotation );
	void EnableHandToWorldPositionControls ( unsigned char NewMode );
	void SetRightHandToWeaponControlOffset ( struct FVector LocationOffset, struct FRotator RotationOffset );
	void SetLeftHandToWeaponControlOffset ( struct FVector LocationOffset, struct FRotator RotationOffset );
	void DisableRightHandToWeaponControls ( unsigned long Disable );
	void DisableLeftHandToWeaponControls ( unsigned long Disable );
	void EnableHandToWeaponControls ( unsigned long Enable );
	bool IsControlledByRootMotionOrRootMotionRotation ( );
	bool IsControlledByRootMotionRotation ( );
	bool IsControlledByRootMotion ( );
	bool IsZoomingEnabled ( );
	bool IsAimingPossible ( );
	bool IsAimingEnabled ( );
	bool IsIdleBranchRotating ( );
	bool IsIdleBranchRelevant ( );
	unsigned char GetCurrentMovementSpeed ( );
	void UpdateSpeedConstraints ( );
	struct FRotator CalcFaceRotation ( struct FRotator CurrentRotation );
	void SetCoverRotation ( struct FRotator coverRotation );
	void SetRecoilInfoFromWeapon ( class AYWeapon* Weapon );
	void PlayRecoil ( );
	void PlayReplicatedIdleAnimation ( struct FName Animation, unsigned long Looping, float Rate, int startRotationYaw, int targetAngle );
	void SetBankingProfile ( struct FName bankingProfileName );
	bool PostureTransitionOutsideTimeSegment ( float StartOffset, float EndOffset );
	bool PostureTransitionIsInsideTimeSegment ( float StartOffset, float EndOffset );
	void OnAimingSetsChanged ( );
	void OnAnimSetsChanged ( );
	void OnFinishPostureAnimation ( );
	void GetFinishPostureAnimationCallback ( struct FScriptDelegate* finishPostureAnimationCallback );
	void GrenadePostureDone ( );
	int FindPostureTransition ( unsigned char fromPosture, unsigned char toPosture, unsigned char* outIsReversed, struct FYS_PostureTransition* outPostureTransition );
	bool PlayPosture ( unsigned char postureID, float BlendInTime, unsigned long forcePosture, unsigned long disablePostureTransition );
	unsigned char GetLastPosture ( );
	unsigned char GetCurrentPosture ( );
	float GetPostureTransitionLength ( );
	void ForceMirrored ( unsigned long mirrored );
	bool GetUpcomingMirroredFlag ( );
	bool IsDoingMirrorTransition ( );
	bool IsInPostureTransition ( unsigned char* rotatingBetweenPostures, unsigned char* postureTransitionAnimation, unsigned char* allowMovement );
	bool IsShootingBlocked ( );
	bool IsAimingBlocked ( );
	struct FYS_AnimID GetLastAnimation ( int Idx );
	int GetCurrentTransition ( struct FYS_PostureTransition* transition );
	bool FinishPostureTransition ( );
	void GetAnimNodeSequences ( struct FYS_AnimID animID, TArray< class UAnimNodeSequence* >* animNodeSequences );
	void GetPlayingAnimations ( TArray< struct FYS_AnimID >* animIDs );
	bool ChangeBlendoutTime ( struct FYS_AnimID animID, float NewBlendOutTime );
	bool IsAnimationPlaying ( struct FYS_AnimID animID );
	bool IsAnAnimationPlaying ( );
	bool StopAnimationsByPriority ( unsigned char Priority );
	bool StopAllAnimations ( );
	bool StopAnimation ( struct FYS_AnimID animID, unsigned long CallAnimEndCallbacks, unsigned long forceSynchGroupReset );
	bool PlayDynamicAnimation ( unsigned long looped, unsigned char mirrorMode, struct FScriptDelegate animEndCallback, float BlendInTime, float BlendOutTime, float playRateFactor, unsigned long ignoreRootMotion, struct FYS_AnimID* animID, struct FYS_AnimInfo* AnimInfo );
	bool PlayAnimation ( struct FYS_AnimID animID, unsigned long looped, struct FScriptDelegate animEndCallback, float BlendInTime, float BlendOutTime, float playRateFactor, unsigned long ignoreRootMotion );
	bool CanPlayDynamicAnimation ( struct FYS_AnimInfo* AnimInfo );
	bool CanPlayAnimation ( struct FYS_AnimID animID );
	unsigned char GetAnimPriorityFromChannel ( unsigned char channelID );
	void OnCamBoneModifierDisabled ( );
	void GetCamBoneModifierDisabledCallback ( struct FScriptDelegate* camBoneModifierDisabledCallback );
	void OnMovementTransitionDone ( );
	unsigned char GetMovementSpeed ( );
	void OnMovementBlendBranchChanged ( int newBranch, float BlendInTime );
	void ClearAnimEndCallbacks ( );
	void CallAnimEndCallbacks ( TArray< struct FScriptDelegate >* animEndCallbacks );
	void OnAnimEndEx ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime, TArray< struct FScriptDelegate >* animEndCallbacks );
	void Tick ( float DeltaTime );
	bool FreeDynamicAnimInfo ( struct FYS_AnimID animID );
	bool StoreDynamicAnimInfo ( struct FYS_AnimInfo* AnimInfo, struct FYS_AnimID* animID );
	struct FYS_AnimInfo GetAnimInfo ( struct FYS_AnimID animID );
	void ConnectOnBlendBranchChanged ( class UYAnimNodeBlendBySpeed* movementAnimNode );
	void Init ( class AYGamePawn* Pawn, class UYAnimInfo* AnimInfo );
};

UClass* UYAnimtreeManager::pClassPointer = NULL;

// Class SRGame.YAnimTreeOverlay
// 0x001C (0x0058 - 0x003C)
class UYAnimTreeOverlay : public UObject
{
public:
	class UTexture2D*                                  m_animNodeIcon;                                   		// 0x003C (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  m_animNodeBlendListIcon;                          		// 0x0040 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  m_animNodeBlendDirectionalIcon;                   		// 0x0044 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  m_animNodeAimOffsetIcon;                          		// 0x0048 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  m_sequenceTrack;                                  		// 0x004C (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  m_sequenceCaret;                                  		// 0x0050 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  m_mirrorIcon;                                     		// 0x0054 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1744 ];

		return pClassPointer;
	};

	void Draw ( class UCanvas* Canvas, class APawn* Pawn, struct FName startNodeName, struct FVector2D Offset );
};

UClass* UYAnimTreeOverlay::pClassPointer = NULL;

// Class SRGame.YCheapShooter
// 0x0210 (0x0450 - 0x0240)
class AYCheapShooter : public ASkeletalMeshActorMAT
{
public:
	struct FPointer                                    VfTable_IYShootable;                              		// 0x0240 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_IYIScanable;                              		// 0x0244 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x0248 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	TArray< struct FYS_CheapShooter_CoverTypeData >    m_coverTypeData;                                  		// 0x024C (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< struct FYS_CheapShooter_MoveTypeData >     m_moveTypeData;                                   		// 0x0258 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	float                                              m_health;                                         		// 0x0264 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_enemyType;                                      		// 0x0268 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentCoverType;                               		// 0x0269 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_currentKismetAction;                            		// 0x026A (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_currentMovingState;                             		// 0x026B (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentShootingState;                           		// 0x026C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_replicatedPreviousKismetAction;                 		// 0x026D (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_replicatedAnimationStateEnum;                   		// 0x026E (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_currentMoveType;                                		// 0x026F (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_standing;                                       		// 0x0270 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_commandType;                                    		// 0x0271 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_attackCommandGiveEvent;                         		// 0x0272 (0x0001) [0x0000000000000000]              
	struct FYS_CheapShooterShooting                    m_shootingSettings;                               		// 0x0274 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FYS_CheapShooterPerformance                 m_performanceSettings;                            		// 0x0280 (0x0004) [0x0000000000000000]              
	class UDynamicLightEnvironmentComponent*           m_lightEnvironment;                               		// 0x0284 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< struct FYS_CheapShooterAccuracy >          m_accuracyList;                                   		// 0x0288 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_accuracyListIndex;                              		// 0x0294 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nextAccuracyListIndex;                          		// 0x0298 (0x0004) [0x0000000000000000]              
	int                                                m_stdRollOffset;                                  		// 0x029C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_stdPitchOffset;                                 		// 0x02A0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_crcRollOffset;                                  		// 0x02A4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_crcPitchOffset;                                 		// 0x02A8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       m_current_shootingDeathAnimName;                  		// 0x02AC (0x0008) [0x0000000000000020]              ( CPF_Net )
	float                                              m_current_shootingDeathRagdollBlendTime;          		// 0x02B4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       m_current_coveringDeathAnimName;                  		// 0x02B8 (0x0008) [0x0000000000000020]              ( CPF_Net )
	float                                              m_current_coveringDeathRagdollBlendTime;          		// 0x02C0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_current_cleanAfterDeathAnimIsFinished : 1;      		// 0x02C4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_replicatedStartDummyFire : 1;                   		// 0x02C4 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_replicatedDisableLookat : 1;                    		// 0x02C4 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_onlyAim : 1;                                    		// 0x02C4 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      m_laserSight : 1;                                 		// 0x02C4 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      m_ragdollPhysicsDisabled : 1;                     		// 0x02C4 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_silhouetteShowing : 1;                          		// 0x02C4 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_tacticalViewEnabled : 1;                        		// 0x02C4 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_markedAsAttackTarget : 1;                       		// 0x02C4 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_showSelectionSilhouette : 1;                    		// 0x02C4 (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	unsigned long                                      m_isScanned : 1;                                  		// 0x02C4 (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      m_NeverCleanUpWhenDead : 1;                       		// 0x02C4 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_miss : 1;                                       		// 0x02C4 (0x0004) [0x0000000000002020] [0x00001000] ( CPF_Net | CPF_Transient )
	unsigned long                                      m_killWithCustomAnimFinished : 1;                 		// 0x02C4 (0x0004) [0x0000000000000000] [0x00002000] 
	class AYCheapShooterSplineActor*                   m_currentSplineActor;                             		// 0x02C8 (0x0004) [0x0000000000000000]              
	class UYSeqAct_CheapShooter_Spawn*                 m_kisAct_Spawned;                                 		// 0x02CC (0x0004) [0x0000000000000000]              
	class UYSeqAct_CheapShooter_TakeCover*             m_kisAct_TakeCover;                               		// 0x02D0 (0x0004) [0x0000000000000000]              
	class UYSeqAct_CheapShooter_MoveToSplineNode*      m_kisAct_MoveTo;                                  		// 0x02D4 (0x0004) [0x0000000000000000]              
	class UYSeqAct_CheapShooter_CustomAnim*            m_kisAct_CustomAnim;                              		// 0x02D8 (0x0004) [0x0000000000000000]              
	class UYSeqAct_CheapShooter_ShootAt*               m_kisAct_ShootAt;                                 		// 0x02DC (0x0004) [0x0000000000000000]              
	class UAnimSet*                                    m_replicatedAnimsets[ 0x5 ];                      		// 0x02E0 (0x0014) [0x0000000000000020]              ( CPF_Net )
	class UAnimTree*                                   m_replicatedAnimTree;                             		// 0x02F4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UPhysicsAsset*                               m_replicatedPhysicsAsset;                         		// 0x02F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      m_replicatedLookAtActor;                          		// 0x02FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      m_replicatedLookAtActorRootOnly;                  		// 0x0300 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_replicatedWeaponKismetTargetLoc;                		// 0x0304 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_replicatedMoveLocation;                         		// 0x0310 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FRotator                                    m_replicatedMoveRotation;                         		// 0x031C (0x000C) [0x0000000000000020]              ( CPF_Net )
	class UAnimNodeBlend*                              m_BlendNode_Death;                                		// 0x0328 (0x0004) [0x0000000000000000]              
	class UAnimNodeBlend*                              m_BlendNode_Cover;                                		// 0x032C (0x0004) [0x0000000000000000]              
	class UAnimNodeBlend*                              m_BlendNode_Move;                                 		// 0x0330 (0x0004) [0x0000000000000000]              
	class UAnimNodeBlend*                              m_BlendNode_Custom;                               		// 0x0334 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_AnimSeq_CoveringAnim;                           		// 0x0338 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_AnimSeq_AimOutOfCover;                          		// 0x033C (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_AnimSeq_DeathAnim;                              		// 0x0340 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_AnimSeq_MoveAnim;                               		// 0x0344 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_AnimSeq_CustomAnim;                             		// 0x0348 (0x0004) [0x0000000000000000]              
	class UYSkelControlLookAt*                         m_skelControlLookAtSpine;                         		// 0x034C (0x0004) [0x0000000000000000]              
	class UYSkelControlLookAt*                         m_skelControlLookAtRoot;                          		// 0x0350 (0x0004) [0x0000000000000000]              
	float                                              m_blendOutTimeCustomAnim;                         		// 0x0354 (0x0004) [0x0000000000000000]              
	int                                                m_currentShootPattern;                            		// 0x0358 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       m_socketWeaponAttachTo;                           		// 0x035C (0x0008) [0x0000000000000000]              
	class AYWeapon*                                    m_spawnedWeapon;                                  		// 0x0364 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYBT_ShootSet*                               m_shootSet;                                       		// 0x0368 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_weaponClass;                                    		// 0x036C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      m_shootAtActor;                                   		// 0x0370 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_laserTarget;                                    		// 0x0374 (0x000C) [0x0000000000000000]              
	class AActor*                                      m_lookAtActor;                                    		// 0x0380 (0x0004) [0x0000000000000000]              
	float                                              m_currentMovingSpeed;                             		// 0x0384 (0x0004) [0x0000000000000000]              
	float                                              m_movingSpeedInWorldUnits;                        		// 0x0388 (0x0004) [0x0000000000000000]              
	float                                              m_currentSplineComponentLength;                   		// 0x038C (0x0004) [0x0000000000000000]              
	class USplineComponent*                            m_currentSplineComponentGoal;                     		// 0x0390 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_currentDistanceAlongSplineComponent;            		// 0x0394 (0x0004) [0x0000000000000000]              
	TArray< class ASplineActor* >                      m_wayToMoveContainingSplineActors;                		// 0x0398 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_currentPositionInWaySplineActors;               		// 0x03A4 (0x0004) [0x0000000000000000]              
	float                                              m_rollYawSpeed;                                   		// 0x03A8 (0x0004) [0x0000000000000000]              
	float                                              m_BlendTimePrepareToMove_Left;                    		// 0x03AC (0x0004) [0x0000000000000000]              
	float                                              m_BlendTimePrepareToMove;                         		// 0x03B0 (0x0004) [0x0000000000000000]              
	struct FName                                       m_Death_TryToDestroyCheapShooterCallbackName;     		// 0x03B4 (0x0008) [0x0000000000000000]              
	struct FName                                       m_Death_TryDisablePhysicsOnRagdollCallbackName;   		// 0x03BC (0x0008) [0x0000000000000000]              
	struct FName                                       m_DeathDisableMeshUpdatesCallbackName;            		// 0x03C4 (0x0008) [0x0000000000000000]              
	class UYMarkerBase*                                m_tacIconAttack;                                  		// 0x03CC (0x0004) [0x0000000000000000]              
	class UClass*                                      m_tacIconAttackClass;                             		// 0x03D0 (0x0004) [0x0000000000000000]              
	class UYMarkerBase*                                m_tacIconArrow;                                   		// 0x03D4 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_tacIconArrowClass;                              		// 0x03D8 (0x0004) [0x0000000000000000]              
	struct FName                                       m_tacIconBoneName;                                		// 0x03DC (0x0008) [0x0000000000000000]              
	struct FName                                       m_tacIconBoneNameCrouchPopUp;                     		// 0x03E4 (0x0008) [0x0000000000000000]              
	struct FName                                       m_headBoneName;                                   		// 0x03EC (0x0008) [0x0000000000000000]              
	struct FName                                       m_neckBoneName;                                   		// 0x03F4 (0x0008) [0x0000000000000000]              
	struct FName                                       m_breastBoneName;                                 		// 0x03FC (0x0008) [0x0000000000000000]              
	class UMaterialInterface*                          m_silhouetteMaterial;                             		// 0x0404 (0x0004) [0x0000000000000000]              
	float                                              m_attackCommandSilhouetteFadeTime;                		// 0x0408 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UCylinderComponent*                          CylinderComponent;                                		// 0x040C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FCylinder                                   m_frictionCylinderFactor;                         		// 0x0410 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class AYAIFakeTarget*                              m_fakeTarget;                                     		// 0x0418 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UObject* >                           m_fightAreas;                                     		// 0x041C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FYS_HitTargetSocketInfo >           m_hitTargetSockets;                               		// 0x0428 (0x000C) [0x0000000000404003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_NeedCtorLink )
	TArray< struct FYS_MaterialDamageInfo >            m_materialDmgInfo;                                		// 0x0434 (0x000C) [0x0000000000404003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_NeedCtorLink )
	float                                              m_TimeOfDeath;                                    		// 0x0440 (0x0004) [0x0000000000000000]              
	class UYBoneData*                                  m_boneData;                                       		// 0x0444 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_headExplodeModifier;                            		// 0x0448 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_stunGrenadeDeathRadius;                         		// 0x044C (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1745 ];

		return pClassPointer;
	};

	void ReplicatedEvent ( struct FName VarName );
	void GetAllCheapShooters ( TArray< class AYCheapShooter* >* cheapShooters );
	void DumpGameData ( struct FYS_GameDumpNode* Node );
	void OnChangeSpeed ( class UYSeqAct_CheapShooter_ChangeSpeed* Action );
	void PlaySpecialActionOnNearbyPawn ( unsigned char SpecialAction, float rad, class AYGamePawn* Pawn, class AYGamePawn* excludedPawn, unsigned long teamOnly, struct FVector Loc, unsigned long findClosest, unsigned long enemyOnly, float Delay );
	void PlaySpecialActionOnNearbyPawnEvent ( unsigned char SpecialAction, float rad, class AYGamePawn* Pawn, class AYGamePawn* excludedPawn, unsigned long teamOnly, struct FVector Loc, unsigned long findClosest, unsigned long enemyOnly, float Delay );
	void DestroyFakeTarget ( );
	void SpawnFakeTarget ( );
	void NativePostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void RegisterToPostRender ( );
	void PostBeginPlay ( );
	void OnDetected ( unsigned long detected );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	struct FBoxSphereBounds GetBounds ( );
	void GetAdhesionLoc ( struct FVector* headLoc, struct FVector* breastLoc );
	void GetFrictionCylinder ( float* CylRad, float* cylHeight, struct FVector* CylLoc );
	void GetCollisionCylinderSize ( float* outHeight, float* outRadius );
	bool IsEnabledForTacView ( );
	void SetSilhouetteFading ( unsigned long Start );
	void SetSilhouetteMaterial ( class UMaterialInterface* Mat );
	void EnableSilhouette ( unsigned long Enable );
	void UpdateSilhouetteRendering ( unsigned long Force );
	unsigned char GetScanableType ( int m_scanningTeamIdx );
	void OnScanEnded ( );
	void DoScanEffects ( );
	void OnScanned ( class AYPlayerController* PC, unsigned char Appearance, float Delay, unsigned long PlaySound );
	void LinkFightAreas ( );
	void OnLinkAttackCommandArea ( class UYSeqAct_LinkAttackCommandArea* Action );
	void OnChangeStanding ( class UYSeqAct_CheapShooter_ChangeStanding* Action );
	void Tick ( float DeltaTime );
	void KisAct_ToKismet_MoveTo ( );
	void KisAct_MoveTo_Finishing ( );
	void KisAct_MoveTo_PrepareIsOver ( );
	bool KisAct_MoveTo_Start ( class AYCheapShooterSplineActor* csDestinationSplineActor );
	bool KisAct_MoveTo_Abort ( );
	bool KisAct_FromKismet_MoveTo ( class AYCheapShooterSplineActor* csDestinationSplineActor, class UYSeqAct_CheapShooter_MoveToSplineNode* seqMoveTo );
	void KisAct_ToKismet_CustomAnim ( );
	bool KisAct_CustomAnim_Start ( struct FName _custonAnimSequence, float _blendInTime, float _blendOutTime, unsigned long _looping );
	bool KisAct_FromKismet_CustomAnim ( class UYSeqAct_CheapShooter_CustomAnim* seqCustomAnim, struct FName customAnimSequence, float _blendInTime, float _blendOutTime, unsigned long _looping );
	void KisAct_ToKismet_TakeCover ( );
	void KisAct_TakeCover_Start ( unsigned long isShootingAt );
	bool KisAct_FromKismet_TakeCover ( class UYSeqAct_CheapShooter_TakeCover* seqTakeCover );
	void KisAct_LookAt_Start ( unsigned long enableLookAt, class AActor* lookAtActor );
	void KisAct_FromKismet_LookAt ( unsigned long enableLookAt, class AActor* lookAtActor );
	void KisAct_ShootAt_UpdateAfterShootingBurst ( );
	void KisAct_ShootAt_FiringStop ( );
	void KisAct_ShootAt_FiringStart ( );
	void KisAct_ShootAt_AimToFiring ( );
	void KisAct_ShootAt_Start ( );
	bool KisAct_FromKismet_ShootAt ( class AActor* _shootAtActor, class UYSeqAct_CheapShooter_ShootAt* _seqShootAt, float _kismetInacc, float _aimingTime, unsigned long _onlyaim );
	float StateRequest_ToCustomAnim ( struct FName _customAnimSequence, float _blendInTime, float _blendOutTime, unsigned long _looping );
	float StateRequest_ToAiming ( );
	float StateRequest_ToCoveringFromAiming ( );
	float StateRequest_ToCoveringFromCustomAnim ( );
	float StateRequest_ToCoveringFromMoving ( );
	float StateRequest_ToMoving ( );
	bool IsDead ( );
	void UpdateMissileLockingStatus ( );
	void ServerSetMissileLock ( unsigned long newLockingStatus );
	void SetMissileLocked ( unsigned long newLockingStatus );
	bool IsMissileLocked ( );
	bool IsMissileLockable ( );
	bool IsExecutable ( class AYGamePawn* executor );
	bool IsRevivable ( class AYGamePawn* Reviver );
	bool SupportsAutoAiming ( class AYGamePawn* shootingPawn );
	void PostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void Death_FinishedDeahtAnim ( );
	bool Death_UseDeathAnim ( struct FName _deathAnimName, float _deathRagDollBlend );
	void VaporizeHead ( struct FVector Momentum, class UClass* dmgType );
	void Death_NowDying ( struct FName forcedDeathAnimSequence );
	bool makesHeadExplode ( class AYWeapon* Weapon, class UClass* DamageType, struct FTraceHitInfo HitInfo, float Damage );
	void TakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void DropWeapon ( );
	void CurrentSplineActorUpdated ( );
	void SetupWeapon ( );
	class UYBoneData* GetBoneData ( );
	void Death_SetRagCollisionChannels ( );
	void Death_DisableMeshUpdates ( );
	void Death_TryDisablePhysicsOnRagdoll ( );
	void Death_TurnToRagdoll ( unsigned long comingFromDeathAnimation );
	void Death_TryToDestroyCheapShooter ( );
	void SetLastTimePlayerKilledACheapShooter ( class AYGamePawn* GamePawn );
	bool ShouldICauseDamage ( class AActor* damageActor );
	void LookAtDisable ( );
	void LookAtRootOnly ( class AActor* lookAtObject );
	void LookAt ( class AActor* lookAtObject );
	bool GetCrosshairColorType ( class AYGamePawn* shootingPawn, unsigned char* colorType );
	bool IsAlive ( );
	void DestroyCheapShooter ( unsigned long _removeFromList, unsigned long _triggerOutputEvent );
	bool IsMeleeAttackable ( class AYGamePawn* attacker, unsigned long checkStanding, unsigned char specificAttackType );
	void InitHitSockets ( );
};

UClass* AYCheapShooter::pClassPointer = NULL;

// Class SRGame.YCustomAnimation
// 0x038B (0x03F8 - 0x006D)
class UYCustomAnimation : public UYCustomAnimationBase
{
public:
	struct FYS_CustomAnimationTemplate                 m_animInfoTemplates[ 0x6 ];                       		// 0x0070 (0x02E8) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	struct FYS_ChannelInfoData                         m_cameraChannelInfoData;                          		// 0x0358 (0x001C) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_animType;                                       		// 0x0374 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_priority;                                       		// 0x0375 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_coverLeaveTime;                                 		// 0x0376 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_mirrorMode;                                     		// 0x0377 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_FaceFXAnim                              m_faceFXAnim;                                     		// 0x0378 (0x001C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_looped : 1;                                     		// 0x0394 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_endsInFalling : 1;                              		// 0x0394 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_failIfDBNO : 1;                                 		// 0x0394 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_failIfDead : 1;                                 		// 0x0394 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_alignToTargetLocation : 1;                      		// 0x0394 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_alignToTargetRotation : 1;                      		// 0x0394 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_synchronizeControllerRotation : 1;              		// 0x0394 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_supressDeathAnimPlayback : 1;                   		// 0x0394 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	struct FVector2D                                   m_relativeCollisionCylinderSize;                  		// 0x0398 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_cameraAnimName;                                 		// 0x03A0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UAnimSet*                                    m_cameraAnimSet;                                  		// 0x03A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_CameraAnimInfo                          m_cameraAnimInfo;                                 		// 0x03AC (0x0024) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_locationOffset;                                 		// 0x03D0 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_rotationOffset;                                 		// 0x03DC (0x000C) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_playCount;                                      		// 0x03E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_blendInTime;                                    		// 0x03EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_blendOutTime;                                   		// 0x03F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_playRate;                                       		// 0x03F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1746 ];

		return pClassPointer;
	};

	struct FYS_CustomAnimationParameters StaticGetAnimParameters ( unsigned char customAnimType );
	void StaticCustomizeAnimInfo ( struct FName AnimName, struct FName additiveAnimName, unsigned char aimingPose, unsigned char Priority, float BlendInTime, float BlendOutTime, float PlayRate, unsigned long lookAtDisabled, struct FName cameraAnimName, struct FYS_AnimInfo* AnimInfo, struct FYS_FaceFXAnim* faceFXAnim, struct FYS_CameraAnimInfo* cameraAnimInfo );
	struct FYS_AnimInfo StaticGetCustomizedAnimInfo ( unsigned char customAnimType, struct FName AnimName, struct FName additiveAnimName, unsigned char aimingPose, unsigned char Priority, float BlendInTime, float BlendOutTime, float PlayRate, unsigned long lookAtDisabled, struct FName cameraAnimName, struct FYS_FaceFXAnim* faceFXAnim, struct FYS_CameraAnimInfo* cameraAnimInfo );
	struct FYS_CustomAnimationParameters GetAnimParameters ( );
	void GetAnimInfo ( struct FYS_AnimInfo* AnimInfo, class UAnimSet** AnimSet, unsigned char* looped, unsigned char* mirrorMode, class UAnimSet** cameraAnimSet );
};

UClass* UYCustomAnimation::pClassPointer = NULL;

// Class SRGame.YAI_SimpleCustomAnimation
// 0x0000 (0x03F8 - 0x03F8)
class UYAI_SimpleCustomAnimation : public UYCustomAnimation
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1747 ];

		return pClassPointer;
	};

};

UClass* UYAI_SimpleCustomAnimation::pClassPointer = NULL;

// Class SRGame.YIAnimNodeChannel
// 0x0000 (0x003C - 0x003C)
class UYIAnimNodeChannel : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1748 ];

		return pClassPointer;
	};

	void SetBlendoutTime ( float NewBlendOutTime );
	void MirrorAnimNodeSequence ( class UAnimNodeSequence* AnimNodeSequence, unsigned long mirror );
	void OnAimingSetsChanged ( );
	void OnAnimSetsChanged ( );
	int GetResetBranch ( );
	void SetActiveChild ( int ChildIndex, float BlendTime );
	class UYAnimNodeAimOffset* PlayAimingProfile ( struct FName aimProfileName, unsigned long mirrored, float BlendInTime, float BlendOutTime );
	class UAnimNodeSequence* PlayAnimation ( struct FName Animation, struct FName additiveAnimation, struct FName aimProfileName, struct FName secondAimProfileName, float aimDelayPct, unsigned long Looping, unsigned long mirrored, float Rate, unsigned long keepAlive, unsigned long earlyNotify, float BlendInTime, float BlendOutTime, unsigned long limitBlendInTime );
	void Deactivate ( float blendOffTime );
	class UAnimNodeBlendPerBone* GetParentBlend ( );
};

UClass* UYIAnimNodeChannel::pClassPointer = NULL;

// Class SRGame.YRecoilMasterNode
// 0x003B (0x012C - 0x00F1)
class UYRecoilMasterNode : public UAnimNodeBlendBase
{
public:
	class UYSkelControlRecoil*                         m_weaponRecoilControl;                            		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSkelControlRecoil*                         m_spineRecoilControl;                             		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSkelControlRecoil*                         m_leftShoulderRecoilControl;                      		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSkelControlRecoil*                         m_rightShoulderRecoilControl;                     		// 0x0100 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_weaponControlName;                              		// 0x0104 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FName                                       m_spineControlName;                               		// 0x010C (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FName                                       m_leftShoulderControlName;                        		// 0x0114 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FName                                       m_rightShoulderControlName;                       		// 0x011C (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned long                                      m_playRecoil : 1;                                 		// 0x0124 (0x0004) [0x0000000000002001] [0x00000001] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_playBurst : 1;                                  		// 0x0124 (0x0004) [0x0000000000002001] [0x00000002] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_copyParamsToClipboard : 1;                      		// 0x0124 (0x0004) [0x0000000000002001] [0x00000004] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_copyValueFromWeapon : 1;                        		// 0x0124 (0x0004) [0x0000000000002001] [0x00000008] ( CPF_Edit | CPF_Transient )
	class UClass*                                      m_weaponToCopyValuesFrom;                         		// 0x0128 (0x0004) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1749 ];

		return pClassPointer;
	};

	void CopyWeaponValuesToControl ( class UClass* WeaponClass, class UYSkelControlRecoil* Control );
	void CopyWeaponValuesToControls ( class UClass* WeaponClass );
};

UClass* UYRecoilMasterNode::pClassPointer = NULL;

// Class SRGame.YRopeActor
// 0x00A0 (0x02D4 - 0x0234)
class AYRopeActor : public ASkeletalMeshActor
{
public:
	unsigned char                                      m_currentUsersCount;                              		// 0x0234 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_fastRopeType;                                   		// 0x0235 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_speedModifier;                                  		// 0x0238 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_numElements;                                    		// 0x023C (0x0004) [0x0000000000000002]              ( CPF_Const )
	unsigned long                                      m_numElementsNeedsUpdate : 1;                     		// 0x0240 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_drawDebugLines : 1;                             		// 0x0240 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_overrideRopeLength : 1;                         		// 0x0240 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	float                                              m_ropeLength;                                     		// 0x0244 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_ropeEndAboveGround;                             		// 0x0248 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_numIterations;                                  		// 0x024C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_damping;                                        		// 0x0250 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_additionalForce;                                		// 0x0254 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_gravityScaling;                                 		// 0x0260 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_forceRandomizationFactor;                       		// 0x0264 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_forceRandomizationUpdateTime;                   		// 0x0268 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_forceScale;                                     		// 0x0270 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_checkOffsetNear;                                		// 0x0274 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_checkOffsetFar;                                 		// 0x0278 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_checkDistance;                                  		// 0x027C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_fixedParticle;                                  		// 0x0280 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_currentRandomForceFactor;                       		// 0x0284 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_nextForceGenerationTime;                        		// 0x0288 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastForceGenerationTimeStamp;                   		// 0x028C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSkelControlRope*                           m_skelControlRope;                                		// 0x0290 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_upperHandLocation;                              		// 0x0294 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_lowerHandLocation;                              		// 0x02A0 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_specialMoveAnimSetName;                         		// 0x02AC (0x0008) [0x0000000000000000]              
	class UAnimSet*                                    m_specialMoveAnimSet;                             		// 0x02B4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_specialMoveAnimSetNameEnemy;                    		// 0x02B8 (0x0008) [0x0000000000000000]              
	class UAnimSet*                                    m_specialMoveAnimSetEnemy;                        		// 0x02C0 (0x0004) [0x0000000000000000]              
	float                                              m_integrationTimeStep;                            		// 0x02C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxIterations;                                  		// 0x02C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_pawnCollisionTestRadius;                        		// 0x02CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_version;                                        		// 0x02D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1750 ];

		return pClassPointer;
	};

	void AttachHardReferences ( );
	void UnclaspRope ( );
	void GrabRope ( struct FVector Loc );
	void UnfixParticlesFromIndex ( int Index );
	void FixParticlesToIndexAlongLine ( int fromIndex, int toIndex, struct FVector Dir, struct FVector topPos );
	void FixParticlesToFirstIndexAlongLine ( int fromIndex, struct FVector Dir, struct FVector topPos );
	void SetHandLocations ( struct FVector upperHandLoc, struct FVector lowerHandLoc );
	void UpdateRope ( float dt );
	void PostBeginPlay ( );
};

UClass* AYRopeActor::pClassPointer = NULL;

// Class SRGame.YUpperBodyIKHack
// 0x0037 (0x0128 - 0x00F1)
class UYUpperBodyIKHack : public UAnimNodeBlendBase
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x00F4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< struct FYS_BoneCopyInfo >                  m_boneCopyArray;                                  		// 0x00F8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FYS_BoneCopyInfo >                  m_boneCopyArrayMirrored;                          		// 0x0104 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_requiredBones;                                  		// 0x0110 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned char >                            m_requiredBonesMirrored;                          		// 0x011C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1751 ];

		return pClassPointer;
	};

};

UClass* UYUpperBodyIKHack::pClassPointer = NULL;

// Class SRGame.YAIAnimationDefinition
// 0x000C (0x0048 - 0x003C)
class UYAIAnimationDefinition : public UObject
{
public:
	TArray< struct FYS_AIMovement >                    m_movements;                                      		// 0x003C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1752 ];

		return pClassPointer;
	};

};

UClass* UYAIAnimationDefinition::pClassPointer = NULL;

// Class SRGame.YAIDefinition
// 0x00C0 (0x00FC - 0x003C)
class UYAIDefinition : public UObject
{
public:
	int                                                m_instanceVersion;                                		// 0x003C (0x0004) [0x0000000000000000]              
	float                                              m_maxAimTime;                                     		// 0x0040 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_aimDistShort;                                   		// 0x0044 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< class UYBT_ShootSet* >                     m_shootSetsCloseDistance;                         		// 0x0048 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_aimDistMid;                                     		// 0x0054 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< class UYBT_ShootSet* >                     m_shootSetsMediumDistance;                        		// 0x0058 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UYBT_ShootSet* >                     m_shootSetsFarDistance;                           		// 0x0064 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_shootTargetSmoothingFactor;                     		// 0x0070 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_shootTargetSmoothingDistance;                   		// 0x0074 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_movementReachRadius;                            		// 0x0078 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverReachRadius;                               		// 0x007C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< struct FYS_SensorProperties >              m_sensorPropertyPresets;                          		// 0x0080 (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )
	class UYBT_BehaviorTreeAsset*                      m_behaviorTree;                                   		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_coverNeedThreshold;                             		// 0x0090 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverNeedAboveThresholdTime;                    		// 0x0094 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverNeedReductionPerSecond;                    		// 0x0098 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverNeedAddition_DirectHit;                    		// 0x009C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UKynapseEntityDefinitionActive*              m_entityDefinition;                               		// 0x00A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_coverNeedAddition_ImpactNearby;                 		// 0x00A4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverNeedImpactDistance;                        		// 0x00A8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_enemyCloseDistance;                             		// 0x00AC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_specialEnemyCloseDistance;                      		// 0x00B0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_enemyCloseDistance_Height;                      		// 0x00B4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	TArray< unsigned char >                            m_behaviorFilters;                                		// 0x00B8 (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )
	float                                              m_timeBadCoverIsMarkedAsBad;                      		// 0x00C4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned long                                      m_canVault : 1;                                   		// 0x00C8 (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_canStack : 1;                                   		// 0x00C8 (0x0004) [0x0000000000004001] [0x00000002] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_reactToLineOfFire : 1;                          		// 0x00C8 (0x0004) [0x0000000000004001] [0x00000004] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_maySwatTurn : 1;                                		// 0x00C8 (0x0004) [0x0000000000004001] [0x00000008] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_reloadSingleBullets : 1;                        		// 0x00C8 (0x0004) [0x0000000000004001] [0x00000010] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_mayStrafe : 1;                                  		// 0x00C8 (0x0004) [0x0000000000004001] [0x00000020] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_findPathAroundGrenades : 1;                     		// 0x00C8 (0x0004) [0x0000000000004001] [0x00000040] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_findPathAroundDangerZones : 1;                  		// 0x00C8 (0x0004) [0x0000000000004001] [0x00000080] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_findPathAroundEnemies : 1;                      		// 0x00C8 (0x0004) [0x0000000000004001] [0x00000100] ( CPF_Edit | CPF_Config )
	float                                              m_coverNeedLowHealthBarrier;                      		// 0x00CC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverNeedLowHealthReductionPerSecond;           		// 0x00D0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coverNeedLowHealthAddition_ImpactNearby;        		// 0x00D4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_slowDownThreshold;                              		// 0x00D8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_crouchRunSlowDownThreshold;                     		// 0x00DC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UYAIAnimationDefinition*                     m_animationDefinition;                            		// 0x00E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYAIDefinition*                              m_referenceDefinition;                            		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_movementStyle;                                  		// 0x00E8 (0x0001) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned char                                      m_enemyContactEvent;                              		// 0x00E9 (0x0001) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned char                                      m_attackCommandGiveEvent;                         		// 0x00EA (0x0001) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_increaseCoverNeedToTargetAiIsAimingAtPerSecond; 		// 0x00EC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_multipierToAccuracyOfAIwhichIsAimingAtMe;       		// 0x00F0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_reloadThreshold;                                		// 0x00F4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_avoidanceDistance;                              		// 0x00F8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1753 ];

		return pClassPointer;
	};

};

UClass* UYAIDefinition::pClassPointer = NULL;

// Class SRGame.YAITurretDefinition
// 0x0064 (0x00A0 - 0x003C)
class UYAITurretDefinition : public UObject
{
public:
	struct FYS_SensorProperties                        m_turretSensors;                                  		// 0x003C (0x0024) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_useTurretSensors : 1;                           		// 0x0060 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_seeFromTurret : 1;                              		// 0x0060 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_aimInFrontWhenNotShooting : 1;                  		// 0x0060 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_useRemotely : 1;                                		// 0x0060 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	struct FVector                                     m_seeFromTurretOffset;                            		// 0x0064 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxHorizontalAngle;                             		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxUpAngle;                                     		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDownAngle;                                   		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UYBT_ShootSet* >                     m_overrideShootSetsShortDist;                     		// 0x007C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UYBT_ShootSet* >                     m_overrideShootSetsMidDist;                       		// 0x0088 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UYBT_ShootSet* >                     m_overrideShootSetsLongDist;                      		// 0x0094 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1754 ];

		return pClassPointer;
	};

};

UClass* UYAITurretDefinition::pClassPointer = NULL;

// Class SRGame.YBT_PositionSelectionModifierPreset
// 0x000C (0x0048 - 0x003C)
class UYBT_PositionSelectionModifierPreset : public UObject
{
public:
	TArray< class UYSC_SelectionModifierBase* >        m_positionModifiers;                              		// 0x003C (0x000C) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1755 ];

		return pClassPointer;
	};

};

UClass* UYBT_PositionSelectionModifierPreset::pClassPointer = NULL;

// Class SRGame.YBT_TargetModifierPreset
// 0x000C (0x0048 - 0x003C)
class UYBT_TargetModifierPreset : public UObject
{
public:
	TArray< class UYSC_TargetModifierBase* >           m_targetModifiers;                                		// 0x003C (0x000C) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1756 ];

		return pClassPointer;
	};

};

UClass* UYBT_TargetModifierPreset::pClassPointer = NULL;

// Class SRGame.YAIAbstractBehaviorManager
// 0x001C (0x0058 - 0x003C)
class UYAIAbstractBehaviorManager : public UObject
{
public:
	unsigned long                                      m_wasStarted : 1;                                 		// 0x003C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_isAttachedToTrigger : 1;                        		// 0x003C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	struct FYAIAbstractBehaviorManager_BehaviorInfo    m_entityInfos[ 0x2 ];                             		// 0x0040 (0x0010) [0x0000000000100000]              
	class AYAIPlayerSquad*                             m_playerSquad;                                    		// 0x0050 (0x0004) [0x0000000000000000]              
	class AYAIAbstractPlayerSquadTrigger*              m_parentTrigger;                                  		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1757 ];

		return pClassPointer;
	};

	bool IsActiveBTManager ( );
	bool IsAttachedToTrigger ( );
	void WasAborted ( );
	bool IsBehaviorTreeSucceded ( int Index );
	bool IsBehaviorTreeFinished ( int Index );
	bool AreAllBehaviorTreesFinished ( );
	bool AreAllBehaviorTreesSucceeded ( );
	bool AreAllBehaviorTreesStarted ( );
	void OnBehaviorTreeFinished ( struct AYAIPlayerSquad_FYAIHandle entity, unsigned long Success );
	void AddSquad ( class AYAIPlayerSquad* PlayerSquad );
	void AddPawn ( class AYGamePawn* Pawn );
	void EndBehavior ( );
	void Clear ( );
};

UClass* UYAIAbstractBehaviorManager::pClassPointer = NULL;

// Class SRGame.YAI_ABM_Attack
// 0x0000 (0x0058 - 0x0058)
class UYAI_ABM_Attack : public UYAIAbstractBehaviorManager
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1758 ];

		return pClassPointer;
	};

};

UClass* UYAI_ABM_Attack::pClassPointer = NULL;

// Class SRGame.YAI_ABM_Heal
// 0x0004 (0x005C - 0x0058)
class UYAI_ABM_Heal : public UYAIAbstractBehaviorManager
{
public:
	struct UYAI_ABM_Heal_FYAIHandle                    m_healedSquadMate;                                		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1759 ];

		return pClassPointer;
	};

};

UClass* UYAI_ABM_Heal::pClassPointer = NULL;

// Class SRGame.YAI_ABM_PairGoto
// 0x0004 (0x005C - 0x0058)
class UYAI_ABM_PairGoto : public UYAIAbstractBehaviorManager
{
public:
	unsigned long                                      m_eventStartTriggerd : 1;                         		// 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_eventStartFailedTriggerd : 1;                   		// 0x0058 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_eventAbortedTriggerd : 1;                       		// 0x0058 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_eventBothFinishedTriggerd : 1;                  		// 0x0058 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_eventAdamsFinishedTriggerd : 1;                 		// 0x0058 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_eventLugoFinishedTriggerd : 1;                  		// 0x0058 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_eventAdamsAbortedTriggerd : 1;                  		// 0x0058 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_eventLugoAbortedTriggerd : 1;                   		// 0x0058 (0x0004) [0x0000000000000000] [0x00000080] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1760 ];

		return pClassPointer;
	};

	void TriggerEventClass ( int ActivateIndex );
	void CheckTriggerEvents ( );
	void ResetTriggerEvents ( );
};

UClass* UYAI_ABM_PairGoto::pClassPointer = NULL;

// Class SRGame.YAI_ABM_SniperAttack
// 0x0000 (0x0058 - 0x0058)
class UYAI_ABM_SniperAttack : public UYAIAbstractBehaviorManager
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1761 ];

		return pClassPointer;
	};

};

UClass* UYAI_ABM_SniperAttack::pClassPointer = NULL;

// Class SRGame.YAIAbstractPlayerSquadTrigger
// 0x0024 (0x021C - 0x01F8)
class AYAIAbstractPlayerSquadTrigger : public AActor
{
public:
	unsigned long                                      bEnabled : 1;                                     		// 0x01F8 (0x0004) [0x0000000000000021] [0x00000001] ( CPF_Edit | CPF_Net )
	unsigned long                                      m_reactToPlayer : 1;                              		// 0x01F8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_reactToAdams : 1;                               		// 0x01F8 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_reactToLugo : 1;                                		// 0x01F8 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_reactToRiggs : 1;                               		// 0x01F8 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_touched : 1;                                    		// 0x01F8 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_combatStarted : 1;                              		// 0x01F8 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_reacted : 1;                                    		// 0x01F8 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	class AYLocatorFightArea*                          m_adams;                                          		// 0x01FC (0x0004) [0x0000000000000002]              ( CPF_Const )
	class AYLocatorFightArea*                          m_lugo;                                           		// 0x0200 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_triggerCount;                                   		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_triggerCountValue;                              		// 0x0208 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAssetReference*                            m_mesh;                                           		// 0x020C (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class UStaticMeshComponent*                        m_meshComponent;                                  		// 0x0210 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UYAssetReference*                            m_highlightMesh;                                  		// 0x0214 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class UStaticMeshComponent*                        m_highlightMeshComponent;                         		// 0x0218 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1762 ];

		return pClassPointer;
	};

	void OnTriggerPlayerSquadTrigger ( class UYSeqAct_TriggerPlayerSquadTrigger* Action );
	void OnToggle ( class USeqAct_Toggle* Action );
	void CombatStarted ( class AYGamePawn* institgtr );
	void ActorLeavingVolume ( class AActor* Other );
	void ActorEnteredVolume ( class AActor* Other );
	void ForceUpdateComponents ( unsigned long bCollisionUpdate, unsigned long bTransformOnly );
	void SpawnMesh ( );
	class AYAIAbstractPlayerSquadTrigger* GetActiveTrigger ( );
	void UnTouch ( class AActor* Other );
	void OnUnTouch ( class AActor* Other );
	void Touch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void OnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	bool ReactTo ( class AActor* Actor );
	void SetActiveTrigger ( class AYAIAbstractPlayerSquadTrigger* Trigger );
	bool TriggerEventClassNative ( class UClass* InEventClass, class AActor* InInstigator, int ActivateIndex, unsigned long bTest, TArray< class USequenceEvent* >* ActivatedEvents );
};

UClass* AYAIAbstractPlayerSquadTrigger::pClassPointer = NULL;

// Class SRGame.YAIGenericPlayerSquadTrigger
// 0x0040 (0x025C - 0x021C)
class AYAIGenericPlayerSquadTrigger : public AYAIAbstractPlayerSquadTrigger
{
public:
	class AYFightArea*                                 m_customFightArea;                                		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AYFightArea*                                 m_secondaryCustomFightArea;                       		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYAI_ABM_PairGoto*                           m_behaviorManager;                                		// 0x0224 (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	struct FYS_SquadMovementSettings                   m_settingsAdams;                                  		// 0x0228 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_SquadMovementSettings                   m_settingsLugo;                                   		// 0x0238 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	class AActor*                                      m_fightAreaForRiggs;                              		// 0x0248 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_feedbackMinDifferenceForOneDelayed;             		// 0x024C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_feedbackTimeAdvantage;                          		// 0x0250 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_feedbackBothDelayedGoTime;                      		// 0x0254 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximalDistanceToForUseMovementOverwrite;       		// 0x0258 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1763 ];

		return pClassPointer;
	};

	void SetRiggsFightArea ( );
	void UpdateEnabledFlag ( );
	void StartManager ( unsigned long resetEvents, unsigned long ignoreDelayAndVoiceSettings );
	void ForceUpdateComponents ( unsigned long bCollisionUpdate, unsigned long bTransformOnly );
	void OnUnTouch ( class AActor* Other );
	void OnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* AYAIGenericPlayerSquadTrigger::pClassPointer = NULL;

// Class SRGame.YAIScriptedPlayerSquadTrigger
// 0x0000 (0x021C - 0x021C)
class AYAIScriptedPlayerSquadTrigger : public AYAIAbstractPlayerSquadTrigger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1764 ];

		return pClassPointer;
	};

	void OnUnTouch ( class AActor* Other );
	void OnTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* AYAIScriptedPlayerSquadTrigger::pClassPointer = NULL;

// Class SRGame.YAIBaseController
// 0x0024 (0x03C4 - 0x03A0)
class AYAIBaseController : public AAIController
{
public:
	struct FPointer                                    VfTable_IYIController;                            		// 0x03A0 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_YIAIConnectable;                          		// 0x03A4 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    m_kynapseConnector;                               		// 0x03A8 (0x0004) [0x0000000000001000]              ( CPF_Native )
	class AYAISquad*                                   m_squad;                                          		// 0x03AC (0x0004) [0x0000000000000000]              
	class UYAIDefinition*                              m_aiDefinition;                                   		// 0x03B0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYBT_BehaviorTreeAsset*                      m_standardBehaviorTree;                           		// 0x03B4 (0x0004) [0x0000000000000000]              
	TArray< struct FYBT_GateInfo >                     m_gateInfo;                                       		// 0x03B8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1765 ];

		return pClassPointer;
	};

	void OnCombatSituationChanged ( unsigned long IsInCombat );
	void OnStopExecution ( );
	void OnStartExecution ( );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void OnChangeAIController ( class UYSeqAct_ChangeAIType* act );
	void StopCamShake ( class UCameraAnimInst* cameraAnimInstance, unsigned long immediately );
	class UCameraAnimInst* PlayCamShake ( class UCameraAnim* Anim, float Rate, float Scale, float FadeInTime, float FadeOutTime, unsigned long looped, unsigned long randomStartTime );
	void HandleTeleport ( class USeqAct_Teleport* Sequence, struct FVector inLoc, struct FRotator inRot, unsigned long abortBehavior );
	unsigned char GetMovementDirection ( );
	bool DoDropDown ( );
	bool AllowMoveOverLedge ( );
	void ClearControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	void SetControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	bool SprintCoverDashEnabled ( );
	bool AimOutByStickInput ( );
	bool AutoLookAtEnabled ( );
	bool AimDownLockEnabled ( );
	bool BlindfireRestricted ( );
	bool PeekingRestricted ( );
	bool AutoRaiseWeapon ( );
	bool AutoTakeDownWeapon ( );
	void OnStateChangeFinished ( unsigned char lastMainState, unsigned char lastSubstate, unsigned char newMainState, unsigned char newSubstate );
	class AYAISquad* SetSquadName ( struct FName NewSquadName, unsigned long bLeader );
	class AYAISquad* GetSquad ( );
	struct FName GetSquadName ( );
	bool IsLookInputIgnored ( );
	void IgnoreLookInput ( unsigned long bNewLookInput );
	bool IsMoveInputIgnored ( );
	void IgnoreMoveInput ( unsigned long bNewMoveInput );
	void DisableDBNOSFX ( unsigned long hardDisable );
	void EnableDBNOSFX ( );
	void DisableLowHealthSFX ( unsigned long hardDisable );
	void EnableLowHealthSFX ( );
	void OnEndReloadWeapon ( );
	void OnStartReloadWeapon ( );
	bool DoesOnlyDryBlindFire ( );
	void AdviseReload ( );
	void DisableZoomMode ( );
	void OnDisableZoom ( );
	void OnEnableZoom ( );
	void OnWeaponFired ( );
	class AYWeapon* GetCurrentWeapon ( );
	void SetCurrentGrenade ( unsigned char gt );
	void SetCurrentWeapon ( class AYWeapon* wp );
	bool IsDeadOrDown ( );
	void OnStopDownButNotOut ( );
	void OnStartDownButNotOut ( );
	void OnStopLeanOverCover ( );
	void OnStartLeanOverCover ( );
	void OnMoveIntoCoverFailed ( );
	void DisableCover ( );
	void DisableCrouch ( );
	bool CheckConditionalEnterCover ( unsigned long byLocation, unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, struct FYS_CoverData* coverData );
	bool ConditionalEnterCover ( unsigned long byLocation, unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, unsigned long checkIfOccupied, unsigned long skipAIForOccupation );
	void OnLeaveCover ( );
	void OnEnterCover ( );
	void OnCoverLost ( unsigned char Reason );
	void SetKiller ( class AActor* Killer );
	void OnExplosion ( struct FVector Loc, float Dist, float Damage, float Radius, float sfxDuration );
	void GetAimAdjustmentFor ( class AYWeapon* W, struct FVector* StartFireLoc, struct FVector* aimAtLoc );
	void InitDamageFeedbackCallbacks ( class AYGamePawn* pwn );
	void StartCriticalDamageFeedback ( int DamageAmount );
	void OnJustDied ( class UClass* dmgType );
	struct FRotator GetRotation ( );
	class AYGamePawn* GetGamePawn ( );
	class AController* GetController ( );
	class AYHUD* GetHUD ( );
	class AYPlayerReplicationInfo* GetPRI ( );
	class AYCamera* GetPlayerCam ( );
	class AActor* GetFocusedActor ( );
	TArray< class UYIHitFeedback* > GetHitDirectionIndicator ( );
};

UClass* AYAIBaseController::pClassPointer = NULL;

// Class SRGame.YAIController
// 0x0100 (0x04C4 - 0x03C4)
class AYAIController : public AYAIBaseController
{
public:
	class AYWeapon*                                    m_currentWeapon;                                  		// 0x03C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAIDefinition*                              m_defaultAIDefinition;                            		// 0x03C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_ignoreMoveInput;                                		// 0x03CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_ignoreLookInput;                                		// 0x03D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_HitInfo                                 m_lastHit;                                        		// 0x03D4 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_shotsFired;                                     		// 0x03E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_kismetShotsFiredCount;                          		// 0x03E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_hasWeaponFiredEventAttached : 1;                		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_useExactRotation : 1;                           		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_shouldShoot : 1;                                		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_shouldLookAtLocation : 1;                       		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_isLookingAtLocation : 1;                        		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_shouldAim : 1;                                  		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_shouldAimForShooting : 1;                       		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_isAiming : 1;                                   		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_wantedCoverSlotNoTransition : 1;                		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_shouldCrouch : 1;                               		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	unsigned long                                      m_isCrouching : 1;                                		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      m_interpolateToLoc : 1;                           		// 0x03E8 (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      m_isInterpolatingToLoc : 1;                       		// 0x03E8 (0x0004) [0x0000000000002000] [0x00001000] ( CPF_Transient )
	unsigned long                                      m_interpolateToRot : 1;                           		// 0x03E8 (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      m_isInterpolatingToRot : 1;                       		// 0x03E8 (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      m_mayWalk : 1;                                    		// 0x03E8 (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	unsigned long                                      m_maySprint : 1;                                  		// 0x03E8 (0x0004) [0x0000000000002000] [0x00010000] ( CPF_Transient )
	unsigned long                                      m_mayCombatSprint : 1;                            		// 0x03E8 (0x0004) [0x0000000000002000] [0x00020000] ( CPF_Transient )
	unsigned long                                      m_isWalkEnabled : 1;                              		// 0x03E8 (0x0004) [0x0000000000002000] [0x00040000] ( CPF_Transient )
	unsigned long                                      m_isSprintEnabled : 1;                            		// 0x03E8 (0x0004) [0x0000000000002000] [0x00080000] ( CPF_Transient )
	unsigned long                                      m_isCombatSprintEnabled : 1;                      		// 0x03E8 (0x0004) [0x0000000000002000] [0x00100000] ( CPF_Transient )
	unsigned long                                      m_sprintToFullStop : 1;                           		// 0x03E8 (0x0004) [0x0000000000002000] [0x00200000] ( CPF_Transient )
	unsigned long                                      m_isInInfiltrateMode : 1;                         		// 0x03E8 (0x0004) [0x0000000000002000] [0x00400000] ( CPF_Transient )
	unsigned long                                      m_isSpawning : 1;                                 		// 0x03E8 (0x0004) [0x0000000000002000] [0x00800000] ( CPF_Transient )
	unsigned long                                      m_sniperTarget : 1;                               		// 0x03E8 (0x0004) [0x0000000000002000] [0x01000000] ( CPF_Transient )
	unsigned long                                      m_preventAimingAndShooting : 1;                   		// 0x03E8 (0x0004) [0x0000000000002000] [0x02000000] ( CPF_Transient )
	unsigned long                                      m_blockHitReactions : 1;                          		// 0x03E8 (0x0004) [0x0000000000002000] [0x04000000] ( CPF_Transient )
	unsigned long                                      m_mayReactToStun : 1;                             		// 0x03E8 (0x0004) [0x0000000000002000] [0x08000000] ( CPF_Transient )
	struct FVector                                     m_acceleration;                                   		// 0x03EC (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_desiredRotation;                                		// 0x03F8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_AllowedActionChanges                    m_allowedActionChanges;                           		// 0x0404 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_AllowedParallelActions                  m_allowedParallelActions;                         		// 0x0408 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FPointer                                    m_controllerState;                                		// 0x040C (0x0004) [0x0000000000001000]              ( CPF_Native )
	unsigned char                                      m_wantedPeekMode;                                 		// 0x0410 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_currentPeekMode;                                		// 0x0411 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_reloadState;                                    		// 0x0412 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_weaponToRestore;                                		// 0x0413 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_CurrentInteractionStatus;                       		// 0x0414 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_lookAtLocation;                                 		// 0x0418 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_aimTarget;                                      		// 0x0424 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_keepWeaponUpUntil;                              		// 0x0430 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_keepWeaponDirectionUpUntil;                     		// 0x0434 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYOctreeDataHndl                            m_wantedCoverSlot;                                		// 0x0438 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYOctreeDataHndl                            m_animNotifyAIEnterCoverHandle;                   		// 0x043C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYOctreeDataHndl                            m_currentCoverSlot;                               		// 0x0440 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_interpolateToLocTime;                           		// 0x0444 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_interpolateToRotTime;                           		// 0x0448 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_interpolationLoc;                               		// 0x044C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_interpolationRot;                               		// 0x0458 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_WallHitInfo                             m_wallHit;                                        		// 0x0464 (0x0020) [0x0000000000002000]              ( CPF_Transient )
	struct FGuid                                       MyGuid;                                           		// 0x0484 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	TArray< unsigned char >                            m_deniedSpecialMoves;                             		// 0x0494 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FYS_ControlRestrictions                     m_noControlCR;                                    		// 0x04A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_armorModifier;                                  		// 0x04A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_delayedPawnDiedCallbackName;                    		// 0x04A8 (0x0008) [0x0000000000000000]              
	float                                              m_highAccelerationUntilTime;                      		// 0x04B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< unsigned char >                            m_kismetBehaviorFilters;                          		// 0x04B4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UYBT_BehaviorTreeAsset*                      m_behaviorTree;                                   		// 0x04C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1766 ];

		return pClassPointer;
	};

	void ReceivedNewEvent ( class USequenceEvent* Evt );
	void UpdateSpecialAction ( float DeltaTime );
	void OnSetSquadEvolution ( class UYSeqAct_SetSquadEvolution* seqAct );
	void OnSetSpecialActionSetList ( class UYSeqAct_SetSpecialActionSetList* Action );
	unsigned char GetMovementDirection ( );
	bool MayStopPeekingUsingSpecialHitReactionAnim ( );
	void UpdateCoverInfosFromPawn ( class AYGamePawn* myPawn );
	bool UpdateSwitchWeapons ( float DeltaTime );
	bool UpdateReloading ( float DeltaTime );
	void UpdateStandardMovement ( float DeltaTime );
	void UpdateShooting ( float DeltaTime );
	void UpdateLookAt ( float DeltaTime );
	void UpdateAiming ( float DeltaTime );
	void ApplyActionsNative ( float DeltaTime );
	bool NotifyHitWall ( struct FVector HitNormal, class AActor* Wall );
	void OnRotInterpolationFinished ( unsigned long finished );
	void OnLocInterpolationFinished ( unsigned long finished );
	void InterpolateToTargetRotation ( );
	void InterpolateToTargetLocation ( );
	void StopFire ( );
	void StartFire ( );
	void OnClearOverwrittenShootSet ( class UYSeqAct_ClearOverwrittenShootSet* act );
	void OnOverwriteShootSet ( class UYSeqAct_OverwriteShootSet* act );
	void OnStartFlanking ( class UYSeqAct_StartFlanking* act );
	void OnSendBehaviorTreeEvent ( class UYSeqAct_SendBehaviorTreeEvent* act );
	void SetCombatFallbackDirectionsFromTrigger ( class AYAIFallbackDirectionTrigger* Trigger );
	void OnSetCombatFallbackDirections ( class UYSeqAct_SetCombatFallbackDirections* act );
	void OnSetUserData ( class UYSeqAct_SetUserData* act );
	void OnLinkAttackCommandArea ( class UYSeqAct_LinkAttackCommandArea* act );
	void OnClearFightAreas ( class UYSeqAct_ClearFightAreas* act );
	void OnRemoveFightArea ( class UYSeqAct_RemoveFightArea* act );
	void OnAddFightArea ( class UYSeqAct_AddFightArea* act );
	void OnSetFightArea ( class UYSeqAct_SetFightArea* act );
	void OnSetFightAreas ( TArray< class UObject* > m_fightAreas );
	void AddEntityTarget ( class UObject* Object, unsigned char targetType, unsigned char alwaysVisible );
	void OnClearTargets ( class UYSeqAct_ClearTargets* entityTarget );
	void OnAddEntityTarget ( class UYSeqAct_AddEntityTarget* entityTarget );
	void OnSetFakeTarget ( class UYSeqAct_SetFakeTarget* fakeTarget );
	void OnGenericKismetBehavior ( class USequenceAction* genericKismetBehavior, unsigned long orientLikePosition, unsigned long aimToFront, unsigned long mayTurnBodyForLookAimAt, unsigned long onlyLookAtTarget, unsigned long abortOnEnemySeenOrHeard, unsigned long abortOnReactionToGrenadeOrStun, unsigned char kisemtOverrideMovement, unsigned char kismetBehaviorState, unsigned long enableCrouching, unsigned long EnterCover, unsigned long runDefaultBehaviorWhenFinished );
	void OnForcedGotoPos ( class UYSeqAct_GoToPosForced* forcedGoToPos );
	void OnStandLookAimAt_NonLatent ( class UYSeqAct_StandLookAimAt_NonLatent* standLookAimAt_NonLatent );
	void OnGotoPos ( class UYSeqAct_GotoPosAbstractBase* gotoPos );
	void SetDecisionMaker ( unsigned char decisionMakerType );
	void ClearInteractionStatus ( );
	void OnCompleteInteraction ( );
	void OnStopInteract ( );
	void OnStartInteract ( );
	void StopInteract ( );
	void StartInteract ( );
	void OnAIChangeState ( class UYAnimNotify_AIChangeState* Notify, class UAnimNodeSequence* Sequence );
	void ChangeState ( unsigned char State );
	void OnAIEnterCover ( class UYAnimNotify_AIEnterCover* Notify, class UAnimNodeSequence* Sequence );
	void OnSetArmorMultiplier ( class UYSeqAct_SetArmorMultiplier* act );
	void OnRunDefaultBehavior ( class UYSeqAct_RunDefaultBehavior* act );
	void OnAbortBehaviorTree ( class UYSeqAct_AbortBehaviorTree* act );
	void OnClearAndRunBehaviorTree_NonLatent ( class UYSeqAct_RunBehaviorTree_NonLatent* act );
	void OnClearAndRunBehaviorTree ( class UYSeqAct_RunBehaviorTree* act );
	void OnClearAndRunBehaviorTreeScripted ( class UYSeqAct_RunBehaviorTreeScripted* act );
	void HandleLatentActionFinished ( class UObject* Sender, struct FString Reason, class UClass* actionClass, unsigned long Success, class USeqAct_Latent* newAction );
	void OnBehaviorTreeFinished ( class UObject* Sender, struct FString Reason, unsigned long Success, class USequenceAction* newAction );
	void OnEnterTurret ( class UYSeqAct_EnterTurret* act );
	void InformBrainOnSpeaklineFinished ( );
	void InformBrainOnDead ( class AController* Killer );
	void InformBrainOnWeaponjamming ( class UYSeqAct_ToggleAI_WeaponJamming* act );
	void AbortBehaviorTree ( class UObject* Sender, struct FString Reason, unsigned long runDefaultBehavior, unsigned long wasSucesfull, unsigned long cleanUpLatentActions );
	void OnRunBehaviorTree_NonLatent ( class UYSeqAct_RunBehaviorTree_NonLatent* act );
	void OnRunBehaviorTree ( class UYSeqAct_RunBehaviorTree* act );
	bool ShouldSaveForCheckpoint ( );
	void ApplyCheckpointRecord ( struct AYAIController_FCheckpointRecord* Record );
	void CreateCheckpointRecord ( struct AYAIController_FCheckpointRecord* Record );
	void OnHandleTeleport ( class USeqAct_Teleport* Sequence, struct FVector inLoc, struct FRotator inRot, unsigned long abortBehavior );
	void HandleTeleport ( class USeqAct_Teleport* Sequence, struct FVector inLoc, struct FRotator inRot, unsigned long abortBehavior );
	void OnHitTaken ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void SetUseExactRotation ( unsigned long useExactRotation );
	struct FRotator GetRotation ( );
	bool TeleportToLocation ( struct FVector NewLoc, struct FRotator NewRot );
	void OnEndReloadWeapon ( );
	void OnStartReloadWeapon ( );
	void ReportWeaponAmmoState ( class AYWeapon* Weapon, int Ammo, int ammoMax );
	void GetWeaponsStatus ( );
	void RemoveWeapon ( class AYWeapon* Weapon );
	void AddWeapon ( class AYWeapon* Weapon );
	void Destroyed ( );
	void UnPossess ( );
	void Possess ( class APawn* inPawn, unsigned long bVehicleTransition );
	void DelayedPawnDied ( );
	void PawnDied ( class APawn* inPawn );
	void DestroyKynapseEntity ( );
	void CreateKynapseEntity ( );
	bool DoDropDown ( );
	bool AllowMoveOverLedge ( );
	void ClearControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	void SetControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	bool AimOutByStickInput ( );
	bool AutoLookAtEnabled ( );
	bool AimDownLockEnabled ( );
	bool BlindfireRestricted ( );
	bool PeekingRestricted ( );
	bool AutoRaiseWeapon ( );
	bool AutoTakeDownWeapon ( );
	class AYGamePawn* GetSquadLeader ( );
	bool IsLookInputIgnored ( );
	bool IsMoveInputIgnored ( );
	void IgnoreLookInput ( unsigned long bNewLookInput );
	void IgnoreMoveInput ( unsigned long bNewMoveInput );
	void DisableDBNOAudioFilter ( );
	void EnableDBNOAudioFilter ( );
	void DisableLowHealthAudioFilter ( );
	void EnableLowHealthAudioFilter ( );
	void OnWeaponFired ( );
	bool DoesOnlyDryBlindFire ( );
	void AdviseReload ( );
	void DisableZoomMode ( );
	void OnDisableZoom ( );
	void OnEnableZoom ( );
	class AYWeapon* GetCurrentWeapon ( );
	void SetCurrentWeapon ( class AYWeapon* wp );
	bool IsDeadOrDown ( );
	void OnStopLeanOverCover ( );
	void OnStartLeanOverCover ( );
	bool CheckConditionalEnterCover ( unsigned long byLocation, unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, struct FYS_CoverData* coverData );
	bool ConditionalEnterCover ( unsigned long byLocation, unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, unsigned long checkIfOccupied, unsigned long skipAIForOccupation );
	void OnLeaveCover ( );
	void OnEnterCover ( );
	void OnCoverLost ( unsigned char Reason );
	void OnExplosion ( struct FVector Loc, float Dist, float Damage, float Radius, float sfxDuration );
	void GetAimAdjustmentFor ( class AYWeapon* W, struct FVector* StartFireLoc, struct FVector* aimAtLoc );
	void InitDamageFeedbackCallbacks ( class AYGamePawn* pwn );
	void StartCriticalDamageFeedback ( int DamageAmount );
	void OnJustDied ( class UClass* dmgType );
	class AYGamePawn* GetGamePawn ( );
	class AController* GetController ( );
	class AYHUD* GetHUD ( );
	class AYCamera* GetPlayerCam ( );
	class AYPlayerReplicationInfo* GetPRI ( );
	class AActor* GetFocusedActor ( );
	TArray< class UYIHitFeedback* > GetHitDirectionIndicator ( );
	void SetStayInCoverFlag ( unsigned long stayInCover );
	void ClearAnimNotifyAIEnterCoverHandle ( );
	void ClearWantedCoverSlot ( );
	void ClearCurrentCoverSlot ( );
	bool WantedCoverSlotIsValid ( );
	bool CurrentCoverSlotIsValid ( );
};

UClass* AYAIController::pClassPointer = NULL;

// Class SRGame.YAICtrl_Humanoid
// 0x004C (0x0510 - 0x04C4)
class AYAICtrl_Humanoid : public AYAIController
{
public:
	struct FPointer                                    VfTable_IYICustomAnimationCallbackHandler;        		// 0x04C4 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned char                                      m_specialActionByType;                            		// 0x04C8 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_specialActionByTypePriority;                    		// 0x04C9 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_specialActionState;                             		// 0x04CA (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_customAnimationState;                           		// 0x04CB (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_throwGrenadeType;                               		// 0x04CC (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_throwGrenadeThrowMode;                          		// 0x04CD (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_throwGrenadeState;                              		// 0x04CE (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class UYSpecialActionsDefinition*                  m_specialActionByAsset;                           		// 0x04D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSpecialActionSet*                          m_specialActionBySet;                             		// 0x04D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_SpecialActionData                       m_specialActionData;                              		// 0x04D8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_customAnimationIdentifier;                      		// 0x04E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_AnimID                                  m_runningGenericAnimation;                        		// 0x04E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_throwGrenadeAimZ;                               		// 0x04EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_throwGrenadeShowDebugTrail : 1;                 		// 0x04F0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_throwGrenadeCallbackReceived : 1;               		// 0x04F0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_throwGrenadeIgnoreCollision : 1;                		// 0x04F0 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_throwGrenadeNotifyAi : 1;                       		// 0x04F0 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_throwGrenadeUseBlindFire : 1;                   		// 0x04F0 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_doInCoverMove : 1;                              		// 0x04F0 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_gotStunned : 1;                                 		// 0x04F0 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_allowReactionToLineOfFire : 1;                  		// 0x04F0 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_hasAttackTargetPosition : 1;                    		// 0x04F0 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	struct FVector                                     m_throwGrenadeTargetPosition;                     		// 0x04F4 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_throwGrenadeDelay;                              		// 0x0500 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_attackTargetPosition;                           		// 0x0504 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1767 ];

		return pClassPointer;
	};

	void OnAllowReactionToLineOfFire ( class UYSeqAct_AllowReactionToLineOfFire* act );
	void DumpGameData ( struct FYS_GameDumpNode* Node );
	void OnAdjustPathFinding ( class UYSeqAct_AdjustPathFinding* act );
	void OnStunAI ( class UYSeqAct_StunAI* act );
	void OnToggleAIMayReactToStun ( class UYSeqAct_ToggleAIMayReactToStun* act );
	void OnBecomeVaultKickTarget ( class AYGamePawn* instigtr );
	void OnEndReactionAnimation ( );
	void OnStartReactionAnimation ( );
	void OnSetPawnSpeeds ( class UYSeqAct_SetPawnSpeeds* seqAct );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void ThrowGrenadeCallbackReceived ( );
	void ThrowGrenadeRegisterCallback ( );
	void ThrowGrenade ( unsigned char grenadeType, unsigned char grenadeThrowMode, float aimZ, struct FVector targetPosition, unsigned long ignoreCollision, float Delay, unsigned long showDebugTrail, unsigned long notifyAI, unsigned long useBlindFire );
	void GetGenericAnimationEndedCallback ( struct FScriptDelegate* callback );
	void UpdateReplicatedAnimations ( float DeltaTime );
	void UpdateGenericAnimations ( float DeltaTime );
	void GenericAnimationFinished ( );
	void OnStartFailedCustomAnimation ( );
	void OnInitializeCustomAnimation ( );
	void OnFailedCustomAnimation ( );
	void OnSucceededCustomAnimation ( );
	void OnStartedCustomAnimation ( );
	void ApplyActionsNative ( float DeltaTime );
	void HandleTeleport ( class USeqAct_Teleport* Sequence, struct FVector inLoc, struct FRotator inRot, unsigned long abortBehavior );
	void Possess ( class APawn* inPawn, unsigned long bVehicleTransition );
	void OnJustDied ( class UClass* dmgType );
	void OnHitTaken ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void UpdateSpecialAction ( float DeltaTime );
	void OnSpecialActionFinished ( class UYSpecialActionsDefinition* finishedSpecialAction, unsigned long hasBeenStopped );
	void HandleLostCover ( );
	void HandleLeavingCover ( );
	void OnLeaveCover ( );
	void OnCoverLost ( unsigned char Reason );
	bool ConditionalEnterCover ( unsigned long byLocation, unsigned char coverStance, unsigned char coverDirection, unsigned long disablePostureTransition, unsigned long checkIfOccupied, unsigned long skipAIForOccupation );
	void GetPlayerViewPoint ( struct FVector* out_Location, struct FRotator* out_Rotation );
	void ClearAllowedActionChanges ( unsigned long flag );
	void ClearAllowedParallelActions ( unsigned long flag );
	void stunned ( unsigned char stunState );
	void Blinded ( );
	void Burn ( );
};

UClass* AYAICtrl_Humanoid::pClassPointer = NULL;

// Class SRGame.YAIMPBot
// 0x0008 (0x0518 - 0x0510)
class AYAIMPBot : public AYAICtrl_Humanoid
{
public:
	class AYFightArea*                                 m_defaultFightArea;                               		// 0x0510 (0x0004) [0x0000000000000000]              
	class UYBT_BehaviorTreeAsset*                      m_idleBehavior;                                   		// 0x0514 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1768 ];

		return pClassPointer;
	};

	void ClearControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	void SetControlRestrictions ( struct FYS_ControlRestrictions controlRestrictions, unsigned long codeRestrictions );
	void StopTemporaryInvincibility ( );
	void SetTemporaryInvincibility ( float Duration );
	void UnPossess ( );
	void PawnDied ( class APawn* inPawn );
	void Possess ( class APawn* inPawn, unsigned long bVehicleTransition );
	class USkeletalMesh* GetOverridePawnMesh ( class AYGameInfo_MP* GameInfo );
	unsigned char GetTeamNum ( );
	float GetRankDamageModifier ( );
	float GetRankAccuracyModifier ( );
	void SwitchToIdleBehavior ( unsigned long bIdle );
	void ComputeStartingEquipment ( );
	void StrategyManagerOnUnPossess ( );
	bool SetFightArea ( class AYFightArea* area );
	void ClearDefaultFightArea ( );
	void SetDefaultFightArea ( class AYFightArea* area );
	void OnSetFightArea ( class UYSeqAct_SetFightArea* act );
	void OnSetDefaultFightArea ( class UYSeqAct_SetDefaultFightArea* act );
	void OnBehaviorTreeFinished ( class UObject* Sender, struct FString Reason, unsigned long Success, class USequenceAction* newAction );
};

UClass* AYAIMPBot::pClassPointer = NULL;

// Class SRGame.YAIDebugManagerComponent
// 0x0010 (0x0210 - 0x0200)
class UYAIDebugManagerComponent : public UPrimitiveComponent
{
public:
	struct FPointer                                    m_debugLines;                                     		// 0x0200 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_debugPoints;                                    		// 0x0204 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_debugBrushs;                                    		// 0x0208 (0x0004) [0x0000000000001000]              ( CPF_Native )
	unsigned long                                      m_wasDrawing : 1;                                 		// 0x020C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1769 ];

		return pClassPointer;
	};

};

UClass* UYAIDebugManagerComponent::pClassPointer = NULL;

// Class SRGame.YAIEventPropagator
// 0x0024 (0x0060 - 0x003C)
class UYAIEventPropagator : public UObject
{
public:
	float                                              m_aiBulletFlyByRadius;                            		// 0x003C (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	float                                              m_hearEventShotRange;                             		// 0x0040 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	float                                              m_hearEventSilencedShotRange;                     		// 0x0044 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	float                                              m_hearEventShotImpactRange;                       		// 0x0048 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	float                                              m_hearEventSilencedShotImpactRange;               		// 0x004C (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	float                                              m_hearEventExplosionRange;                        		// 0x0050 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	float                                              m_hearEventDeath;                                 		// 0x0054 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	float                                              m_hearEventMeleeAttack;                           		// 0x0058 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      m_silencedWeaponCausesFlyBy : 1;                  		// 0x005C (0x0004) [0x0000000000044000] [0x00000001] ( CPF_Config | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1770 ];

		return pClassPointer;
	};

	void SendEvent_CloseDeath ( class AController* Instigator, struct FVector pos );
	void SendEvent_GrenadeImpact ( class AController* Instigator, struct FVector pos, float estimatedTimeToImpact, unsigned char grenadeType, float MaxRange, unsigned long explosion );
	void SendEvent_FlyBy ( class AController* Instigator, struct FVector pos, class AController* almostTarget );
	void SendEvent_Impact ( class AController* Instigator, struct FVector pos );
	void SendEvent_Shot ( class UObject* Instigator, struct FVector pos );
	void SendHearEvent_Melee ( class AController* ctrl, struct FVector pos, float Volume );
	void SendHearEvent_Death ( class AController* ctrl, struct FVector pos, float Volume );
	void SendHearEvent_Explosion ( class AController* ctrl, struct FVector pos, float Volume );
	class UYAIEventPropagator* Get ( );
};

UClass* UYAIEventPropagator::pClassPointer = NULL;

// Class SRGame.YAIFallbackDirectionTrigger
// 0x0039 (0x023D - 0x0204)
class AYAIFallbackDirectionTrigger : public ATrigger
{
public:
	struct FYS_AffectedFactionsSettings                m_affectingSettings[ 0x7 ];                       		// 0x0204 (0x0038) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_presetSelector;                                 		// 0x023C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1771 ];

		return pClassPointer;
	};

	bool ShouldSaveForCheckpoint ( );
	bool StopsProjectile ( class AProjectile* P );
	void HandleTouch ( class AActor* touchingActor );
	void Touch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* AYAIFallbackDirectionTrigger::pClassPointer = NULL;

// Class SRGame.YAISquad
// 0x0028 (0x0220 - 0x01F8)
class AYAISquad : public AReplicationInfo
{
public:
	struct FPointer                                    m_kynapseConnector;                               		// 0x01F8 (0x0004) [0x0000000000001000]              ( CPF_Native )
	class AController*                                 Leader;                                           		// 0x01FC (0x0004) [0x0000000000020021]              ( CPF_Edit | CPF_Net | CPF_EditConst )
	struct FName                                       SquadName;                                        		// 0x0200 (0x0008) [0x0000000000020021]              ( CPF_Edit | CPF_Net | CPF_EditConst )
	int                                                m_teamIndex;                                      		// 0x0208 (0x0004) [0x0000000000000000]              
	TArray< class AController* >                       m_squadMembers;                                   		// 0x020C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_numSquadMembers;                                		// 0x0218 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_usedByAIFactory : 1;                            		// 0x021C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1772 ];

		return pClassPointer;
	};

	bool IsSpawning ( );
	void OnRunDefaultBehavior ( class UYSeqAct_RunDefaultBehavior* act );
	void OnAbortBehaviorTree ( class UYSeqAct_AbortBehaviorTree* act );
	void OnStandLookAimAt_NonLatent ( class UYSeqAct_StandLookAimAt_NonLatent* act );
	void OnClearAndRunBehaviorTree_NonLatent ( class UYSeqAct_RunBehaviorTree_NonLatent* act );
	void OnToggleWeaponJamming ( class UYSeqAct_ToggleAI_WeaponJamming* Action );
	void OnToggleAIGrenadeReaction ( class UYSeqAct_ToggleAIGrenadeReaction* Action );
	void OnToggleGenericGrenadeUsage ( class UYSeqAct_ToggleGenericGrenadeUsage* Action );
	void OnAddEntityTarget ( class UYSeqAct_AddEntityTarget* entityTarget );
	void AddEntityTargetSquad ( class AYAISquad* targetSquad );
	void OnStartFlanking ( class UYSeqAct_StartFlanking* Action );
	void OnClearTargets ( class UYSeqAct_ClearTargets* act );
	void OnSetFakeTarget ( class UYSeqAct_SetFakeTarget* fakeTarget );
	void OnSetSquadCombatState ( class UYSeqAct_SetSquadCombatState* Action );
	void OnLinkAttackCommandArea ( class UYSeqAct_LinkAttackCommandArea* Action );
	void OnClearFightAreas ( class UYSeqAct_ClearFightAreas* act );
	void OnRemoveFightArea ( class UYSeqAct_RemoveFightArea* act );
	void OnAddFightArea ( class UYSeqAct_AddFightArea* act );
	void OnSetFightArea ( class UYSeqAct_SetFightArea* Action );
	void OnAddToCommunicationPool ( class UYSeqAct_AddToCommunicationPool* Action );
	class AYAISquad* SpawnNewSquad ( class UClass* SpawnClass, class AActor* SpawnOwner, struct FName spawnName );
	struct FName GetUniqueSquadName ( struct FName baseName );
	void SetDefensiveBehaviour ( );
	void SetOffensiveBehaviour ( );
	void Destroyed ( );
	int GetMemberCount ( );
	void GetMembers ( TArray< class AController* >* out_Members );
	void OnSetCombatFallbackDirections ( class UYSeqAct_SetCombatFallbackDirections* act );
	void FindNewLeader ( class AController* OldLeader );
	bool AllowLeaderChange ( class AController* NewMember );
	void UnregisterSquadMember ( class AController* OldMember );
	void CommentOnDeadSquadMember ( class APawn* diedPawn );
	void OnSquadMemberDied ( class APawn* diedPawn );
	void RegisterSquadMember ( class AController* NewMember, unsigned long bLeader );
	bool HasSquadMemberPawn ( class AYGamePawn* P );
	void RemoveSquadMemberPawn ( class AYGamePawn* P );
	void AddSquadMemberPawn ( class AYGamePawn* P );
	bool RemoveFromSquad ( class AController* member );
	bool AddToSquad ( class AController* member );
	void DestroyKynapseSquad ( );
	void CreateKynapseSquad ( );
};

UClass* AYAISquad::pClassPointer = NULL;

// Class SRGame.YAIPlayerSquad
// 0x0338 (0x0558 - 0x0220)
class AYAIPlayerSquad : public AYAISquad
{
public:
	float                                              m_commandTimeStamp;                               		// 0x0220 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_shouldScan : 1;                                 		// 0x0224 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_squadCanOpenFire : 1;                           		// 0x0224 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_squadCanStunEnemies : 1;                        		// 0x0224 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_isScannerCharged : 1;                           		// 0x0224 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_useSituationReports : 1;                        		// 0x0224 (0x0004) [0x0000000000004002] [0x00000010] ( CPF_Const | CPF_Config )
	unsigned long                                      m_blockDynamicRegroupFightArea : 1;               		// 0x0224 (0x0004) [0x0000000000000000] [0x00000020] 
	class AYGamePawn*                                  m_squadMemberPawns[ 0x3 ];                        		// 0x0228 (0x000C) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	struct FYS_ContextCommandInfo                      m_currentCommandInfo;                             		// 0x0234 (0x00D8) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_squadStateDescription[ 0x10 ];                  		// 0x030C (0x00C0) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	float                                              m_lastEnemyContact;                               		// 0x03CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastFocusUpdateTime;                            		// 0x03D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_focusUpdateInterval;                            		// 0x03D4 (0x0004) [0x0000000000000000]              
	float                                              m_lastOuterUpdateTime;                            		// 0x03D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_outerUpdateInterval;                            		// 0x03DC (0x0004) [0x0000000000000000]              
	unsigned char                                      m_currentSquadState;                              		// 0x03E0 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_squadMemberForScanning;                         		// 0x03E1 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_squadMemberForMortar;                           		// 0x03E2 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_squadMemberForAssistingMortar;                  		// 0x03E3 (0x0001) [0x0000000000000000]              
	struct FPointer                                    m_squadCommand;                                   		// 0x03E4 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_secondarySquadCommand;                          		// 0x03E8 (0x0004) [0x0000000000001000]              ( CPF_Native )
	float                                              m_gotoFightAreaRadius;                            		// 0x03EC (0x0004) [0x0000000000000000]              
	float                                              m_gotoFightAreaHeight;                            		// 0x03F0 (0x0004) [0x0000000000000000]              
	float                                              m_regroupFightAreaRadius;                         		// 0x03F4 (0x0004) [0x0000000000000000]              
	float                                              m_regroupFightAreaHeight;                         		// 0x03F8 (0x0004) [0x0000000000000000]              
	float                                              m_attackingTimeout;                               		// 0x03FC (0x0004) [0x0000000000000000]              
	float                                              m_scanningRadius;                                 		// 0x0400 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_scanInfoLifetime;                               		// 0x0404 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_scanRechargeTime;                               		// 0x0408 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_scanItemDelay;                                  		// 0x040C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_defaultScanningRadius;                          		// 0x0410 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_defaultScanInfoLifetime;                        		// 0x0414 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_defaultScanRechargeTime;                        		// 0x0418 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastScanTime;                                   		// 0x041C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_SitRepOverrideData                      m_sitRepOverrideData;                             		// 0x0420 (0x0014) [0x0000000000000000]              
	TArray< struct FYS_ScanReportPriority >            m_scanReportPriorities;                           		// 0x0434 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	class AYGamePawn*                                  m_scanningMate;                                   		// 0x0440 (0x0004) [0x0000000000002020]              ( CPF_Net | CPF_Transient )
	TArray< struct AYAIPlayerSquad_FYAIHandle >        m_scannedPawns;                                   		// 0x0444 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class AActor* >                            m_scannedActors;                                  		// 0x0450 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FName                                       m_scanReportTypeNames[ 0xB ];                     		// 0x045C (0x0058) [0x0000000000000000]              
	class UYScanReportSASType*                         m_scanReportSASTypes[ 0xB ];                      		// 0x04B4 (0x002C) [0x0000000000000000]              
	struct FVector                                     m_squadCommandPosition;                           		// 0x04E0 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_specificCoverGotoTimeout;                       		// 0x04EC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_lastTimeSpecificCoverGoto;                      		// 0x04F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             m_specialActionFinishedCallback;                  		// 0x04F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_suppressiveFireCooldown;                        		// 0x0500 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_lastSupressiveFireTime;                         		// 0x0504 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_suppressiveFireLifetime;                        		// 0x0508 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_suppressiveFireBlinkStart;                      		// 0x050C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_suppressiveFireBpsStart;                        		// 0x0510 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_suppressiveFireBpsEnd;                          		// 0x0514 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FUObjectHandle                              m_activePlayerSquadTrigger;                       		// 0x0518 (0x0004) [0x0000000000000000]              
	struct FUObjectHandle                              m_currentBehaviorManager;                         		// 0x051C (0x0004) [0x0000000000000000]              
	struct FUObjectHandle                              m_delayedBehaviorManager;                         		// 0x0520 (0x0004) [0x0000000000000000]              
	class UYAI_ABM_PairGoto*                           m_gotoCommandBehaviorManager;                     		// 0x0524 (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	class UYAI_ABM_Heal*                               m_healCommandBehaviorManager;                     		// 0x0528 (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	class UYAI_ABM_Attack*                             m_attackCommandBehaviorManager;                   		// 0x052C (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	class UYAI_ABM_SniperAttack*                       m_sniperAttackCommandBehaviorManager;             		// 0x0530 (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	float                                              m_timePlayerHasToIdleUntilPlayerIdleVoiceOver;    		// 0x0534 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sandStunCooldown;                               		// 0x0538 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_lastSandStunTime;                               		// 0x053C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             __OnSpecialActionFinishedDelegate__Delegate;      		// 0x0540 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __TriggerSpecialActionDelegate__Delegate;         		// 0x054C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1773 ];

		return pClassPointer;
	};

	void OnCancelSquadCommand ( class UYSeqAct_CancelSquadCommand* act );
	bool CheckSuppressiveFireCommandDisabled ( );
	bool CheckSuppressiveFireReady ( );
	void SetDBNO ( unsigned long isDBNO, class AYGamePawn* Pawn );
	void ScannerIsCharged ( );
	void OnScanCompleted ( );
	void DoRevive ( class AYGamePawn* healerPawn, class AYGamePawn* injuredPawn );
	void OnReviveFinished ( unsigned long Success );
	void StopCurrentSquadCommand ( unsigned long removeMarkers );
	void SetSquadState ( unsigned char squadState );
	void TriggerRandomSpecialActionOnWholeSquad ( unsigned char specialActionSetType, float Delay );
	void TriggerSpecialActionOnRandomSquadmate ( unsigned char specialActionSetType, float Delay );
	void TriggerSpecialActionDelegate ( );
	void TriggerSpecialActionCallbackSimulated ( class UYSpecialActionsDefinition* finishedSpecialAction, unsigned long hasBeenStopped );
	void TriggerSpecialActionCallback ( );
	void TriggerSpecialAction ( class AYGamePawn* runningPawn, unsigned char specialActionType, float Delay );
	void ReceiveCommand ( class AYPlayerController* ctrl, struct FYS_ContextCommandInfo* Command );
	void TriggerContextCommandEvent ( class AActor* Inst, int Idx, struct FYS_ContextCommandInfo* Command );
	void UnregisterSquadMember ( class AController* OldMember );
	void RegisterSquadMember ( class AController* NewMember, unsigned long bLeader );
	bool HasSquadMemberPawn ( class AYGamePawn* P );
	void OnAssignEquipment ( class UYSeqAct_AssignEquipment* act );
	void InitSquadRole ( class AYGamePawn* P, unsigned long Clear );
	unsigned char GetSquadmemberType ( class AYGamePawn* P );
	void RemoveSquadMemberPawn ( class AYGamePawn* P );
	void AddSquadMemberPawn ( class AYGamePawn* P );
	void ConditionalCreateScanReportObjects ( );
	void PreBeginPlay ( );
	void BlockDynamicRegroupFightArea ( unsigned long bLock );
	void OnSetBlockDynamicRegroupFightArea ( class UYSeqAct_BlockDynamicRegroupFightArea* Action );
	void SetSquadToInfiltrateMode ( unsigned long enableInfiltrate, unsigned long forceInfiltrate );
	void OnSetSquadToInfiltrateMode ( class UYSeqAct_SetSquadToInfiltrateMode* Action );
	void ClearLatentActionNative ( class UClass* actionClass, unsigned long failed, class USeqAct_Latent* newAction );
	unsigned char GetCurrentSquadCommand ( );
	void SetSquadMemberPawn ( class AYGamePawn* PawnToSet, unsigned char eMemberType );
	class AYGamePawn* GetSquadMemberPawn ( unsigned char eMember );
	bool HasNonPlayerMembers ( );
	class AYPlayerController* GetLocalPlayerController ( );
	class UYAI_ABM_PairGoto* GetDelayedBehaviorManager ( );
	class UYAIAbstractBehaviorManager* GetCurrentBehaviorManager ( );
	void ClearBehaviorManagers ( );
	void ClearActiveSquadTrigger ( );
	void SetActiveSquadTrigger ( class AYAIAbstractPlayerSquadTrigger* Trigger );
	class AYAIAbstractPlayerSquadTrigger* GetActiveSquadTrigger ( );
	class AYAIPlayerSquad* GetInstance ( );
	void ReplicatedEvent ( struct FName VarName );
	void OnSpecialActionFinishedDelegate ( class UYSpecialActionsDefinition* finishedSpecialAction, unsigned long hasBeenStopped );
};

UClass* AYAIPlayerSquad::pClassPointer = NULL;

// Class SRGame.YAITuning_Base
// 0x01C4 (0x0200 - 0x003C)
class UYAITuning_Base : public UObject
{
public:
	struct FYS_AiTuning_AccuracyMultiplier             m_accuracyMultiplier_EnemyMarauder;               		// 0x003C (0x000C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_AiTuning_AccuracyMultiplier             m_accuracyMultiplier_EnemyKonrad;                 		// 0x0048 (0x000C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_AiTuning_AccuracyMultiplier             m_accuracyMultiplier_EnemyElite;                  		// 0x0054 (0x000C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_AiTuning_AccuracyMultiplier             m_accuracyMultiplier_EnemyHeavy;                  		// 0x0060 (0x000C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_AiTuning_AccuracyMultiplier             m_accuracyMultiplier_EnemyCommando;               		// 0x006C (0x000C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_AiTuning_AccuracyMultiplier             m_accuracyMultiplier_EnemyAdams;                  		// 0x0078 (0x000C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_AiTuning_AccuracyMultiplier             m_accuracyMultiplier_EnemyLugo;                   		// 0x0084 (0x000C) [0x0000000000004000]              ( CPF_Config )
	float                                              m_rubberBandSnapSpeedMultiplier_EnemyMarauder;    		// 0x0090 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_rubberBandSnapSpeedMultiplier_EnemyKonrad;      		// 0x0094 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_rubberBandSnapSpeedMultiplier_EnemyElite;       		// 0x0098 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_rubberBandSnapSpeedMultiplier_EnemyHeavy;       		// 0x009C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_rubberBandSnapSpeedMultiplier_EnemyCommando;    		// 0x00A0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_rubberBandSnapSpeedMultiplier_EnemyAdams;       		// 0x00A4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_rubberBandSnapSpeedMultiplier_EnemyLugo;        		// 0x00A8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayForAquiringNewTarget_EnemyMarauder;		// 0x00AC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayForAquiringNewTarget_EnemyKonrad;  		// 0x00B0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayForAquiringNewTarget_EnemyElite;   		// 0x00B4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayForAquiringNewTarget_EnemyMarauder;		// 0x00B8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayForAquiringNewTarget_EnemyKonrad;  		// 0x00BC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayForAquiringNewTarget_EnemyElite;   		// 0x00C0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayForEscapeFromGrenade_EnemyMarauder;		// 0x00C4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayForEscapeFromGrenade_EnemyKonrad;  		// 0x00C8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayForEscapeFromGrenade_EnemyElite;   		// 0x00CC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayForEscapeFromGrenade_EnemyMarauder;		// 0x00D0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayForEscapeFromGrenade_EnemyKonrad;  		// 0x00D4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayForEscapeFromGrenade_EnemyElite;   		// 0x00D8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayForEscapeFromGrenadeInSandStorm_EnemyMarauder;		// 0x00DC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayForEscapeFromGrenadeInSandStorm_EnemyKonrad;		// 0x00E0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayForEscapeFromGrenadeInSandStorm_EnemyElite;		// 0x00E4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayForEscapeFromGrenadeInSandStorm_EnemyMarauder;		// 0x00E8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayForEscapeFromGrenadeInSandStorm_EnemyKonrad;		// 0x00EC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayForEscapeFromGrenadeInSandStorm_EnemyElite;		// 0x00F0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_timePassedUntilFlankingBehaviorStarts_EnemyMarauder;		// 0x00F4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_timePassedUntilFlankingBehaviorStarts_EnemyKonrad;		// 0x00F8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_timePassedUntilFlankingBehaviorStarts_EnemyElite;		// 0x00FC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBeforeReactingToCoverNeed_EnemyMarauder;		// 0x0100 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBeforeReactingToCoverNeed_EnemyKonrad;		// 0x0104 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBeforeReactingToCoverNeed_EnemyElite;		// 0x0108 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBeforeReactingToCoverNeed_EnemyMarauder;		// 0x010C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBeforeReactingToCoverNeed_EnemyKonrad;		// 0x0110 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBeforeReactingToCoverNeed_EnemyElite;		// 0x0114 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBetweenSidestepDodgeMoves_EnemyMarauder;		// 0x0118 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBetweenSidestepDodgeMoves_EnemyKonrad;		// 0x011C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBetweenSidestepDodgeMoves_EnemyElite;		// 0x0120 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBetweenSidestepDodgeMoves_EnemyMarauder;		// 0x0124 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBetweenSidestepDodgeMoves_EnemyKonrad;		// 0x0128 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBetweenSidestepDodgeMoves_EnemyElite;		// 0x012C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBeforeMeleeAttack_EnemyMarauder;   		// 0x0130 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBeforeMeleeAttack_EnemyKonrad;     		// 0x0134 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBeforeMeleeAttack_EnemyElite;      		// 0x0138 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBeforeMeleeAttack_EnemyHeavy;      		// 0x013C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBeforeMeleeAttack_EnemyCommando;   		// 0x0140 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBeforeMeleeAttack_EnemyMarauder;   		// 0x0144 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBeforeMeleeAttack_EnemyKonrad;     		// 0x0148 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBeforeMeleeAttack_EnemyElite;      		// 0x014C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBeforeMeleeAttack_EnemyHeavy;      		// 0x0150 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBeforeMeleeAttack_EnemyCommando;   		// 0x0154 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_probabilityForWeapomJam_EnemyMarauder;          		// 0x0158 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimal_delayBetweenMeleeAttacks_Commando;      		// 0x015C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maximal_delayBetweenMeleeAttacks_Commando;      		// 0x0160 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_mulitplierOnDelayUntilGrenadeIsThrownOnPlayer_Global;		// 0x0164 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_mulitplierOnAmountOfMovementPlayerCanMoveBeforeGrenade_Global;		// 0x0168 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_AfterFlanking_min;        		// 0x016C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_AfterFlanking_max;        		// 0x0170 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_EnemyClose_min;           		// 0x0174 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_EnemyClose_max;           		// 0x0178 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_AfterIsShotAt_min;        		// 0x017C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_AfterIsShotAt_max;        		// 0x0180 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_TargetIsDead_min;         		// 0x0184 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_TargetIsDead_max;         		// 0x0188 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_TargetIsGuess_min;        		// 0x018C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_TargetIsGuess_max;        		// 0x0190 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_LostAndNewEnemy_min;      		// 0x0194 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_LostAndNewEnemy_max;      		// 0x0198 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Target_LostToGuess;                       		// 0x019C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Target_GuessToSure;                       		// 0x01A0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Target_SureToGuess;                       		// 0x01A4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Target_GuessToLost;                       		// 0x01A8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Reaction_EnemySeen;                       		// 0x01AC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Reaction_EnemySeenByFriend;               		// 0x01B0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Reaction_Footsteps;                       		// 0x01B4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Reaction_Explosion;                       		// 0x01B8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Reaction_Death;                           		// 0x01BC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Reaction_Melee;                           		// 0x01C0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Reaction_Shot;                            		// 0x01C4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_Reaction_SilencedShot;                    		// 0x01C8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delayBeforeMovingAfterSquadCommand_Adams;       		// 0x01CC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delayBeforeMovingAfterSquadCommand_Lugo;        		// 0x01D0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_time_attackCommandIdleVoiceOver_min;            		// 0x01D4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_time_attackCommandIdleVoiceOver_max;            		// 0x01D8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_time_playerIsStarringVoiceOver_min;             		// 0x01DC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_time_playerIsStarringVoiceOver_max;             		// 0x01E0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_distance_maximal_range_of_enemy_for_panicked_reload;		// 0x01E4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_distance_maximal_range_of_enemy_for_enemyCloseToPlayer;		// 0x01E8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< float >                                    m_aiTuningVariable_BT_list;                       		// 0x01EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_delay_TargetSelection_EnemyIsStunned_min;       		// 0x01F8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delay_TargetSelection_EnemyIsStunned_max;       		// 0x01FC (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1774 ];

		return pClassPointer;
	};

	float GetMaximalRangeofEnemyForEnemyCloseToPlayerVoiceOver ( );
	float GetMaximalRangeofEnemyForPanickedReload ( );
	float GetMulitplierOnAmountOfMovementPlayerCanMoveBeforeGrenade ( );
	float GetMulitplierOnDelayUntilGrenadeIsThrownOnPlayer ( );
	float GetAccuracyMultiplier_Internal ( unsigned char Range, struct FYS_AiTuning_AccuracyMultiplier multiplier );
	float GetAccuracyMultiplier ( unsigned char Range, unsigned char kismetFilter );
	float GetRubberbandMultiplier ( unsigned char kismetFilter );
	float GetBehaviorTreeVariableValue ( unsigned char Variable );
	void InitVariableList ( );
};

UClass* UYAITuning_Base::pClassPointer = NULL;

// Class SRGame.YAITuning_Easy
// 0x0000 (0x0200 - 0x0200)
class UYAITuning_Easy : public UYAITuning_Base
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1775 ];

		return pClassPointer;
	};

};

UClass* UYAITuning_Easy::pClassPointer = NULL;

// Class SRGame.YAITuning_Hard
// 0x0000 (0x0200 - 0x0200)
class UYAITuning_Hard : public UYAITuning_Base
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1776 ];

		return pClassPointer;
	};

};

UClass* UYAITuning_Hard::pClassPointer = NULL;

// Class SRGame.YAITuning_Insane
// 0x0000 (0x0200 - 0x0200)
class UYAITuning_Insane : public UYAITuning_Base
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1777 ];

		return pClassPointer;
	};

};

UClass* UYAITuning_Insane::pClassPointer = NULL;

// Class SRGame.YAITuning_Normal
// 0x0000 (0x0200 - 0x0200)
class UYAITuning_Normal : public UYAITuning_Base
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1778 ];

		return pClassPointer;
	};

};

UClass* UYAITuning_Normal::pClassPointer = NULL;

// Class SRGame.YCheapShooterSplineActor
// 0x004C (0x0294 - 0x0248)
class AYCheapShooterSplineActor : public ASplineActor
{
public:
	unsigned char                                      m_coverType;                                      		// 0x0248 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_coverRotation;                                  		// 0x024C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_CheapShooterDeathAnimSettings           m_deathAnimSettings;                              		// 0x0258 (0x001C) [0x0000000000000001]              ( CPF_Edit )
	class UStaticMeshComponent*                        m_coverMesh_StandNormal;                          		// 0x0274 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UStaticMeshComponent*                        m_coverMesh_CrouchNoCover;                        		// 0x0278 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UStaticMeshComponent*                        m_coverMesh_CrouchPopUp;                          		// 0x027C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UStaticMeshComponent*                        m_coverMesh_Civ_StandNormal;                      		// 0x0280 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UYAssetReference*                            m_ref_StandNormal;                                		// 0x0284 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAssetReference*                            m_ref_CrouchNoCover;                              		// 0x0288 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAssetReference*                            m_ref_CrouchPopUp;                                		// 0x028C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAssetReference*                            m_ref_Civ_StandNormal;                            		// 0x0290 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1779 ];

		return pClassPointer;
	};

};

UClass* AYCheapShooterSplineActor::pClassPointer = NULL;

// Class SRGame.YGrenadeDirectorSettings
// 0x003C (0x0078 - 0x003C)
class UYGrenadeDirectorSettings : public UObject
{
public:
	struct FString                                     m_settings_name;                                  		// 0x003C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned long                                      m_decision_checkForDBNO : 1;                      		// 0x0048 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_selection_throwerHasValidFireLinkToTheTarget : 1;		// 0x0048 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	float                                              m_decision_distanceTargetHasToMove;               		// 0x004C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_decision_initialTimerSinceLastMove;             		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_decision_coolDownTime;                          		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_decision_waitingTimmerInbetweenWaves;           		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_decision_numberOfGrenadesPerWaves;              		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_misc_waitingTimeBetweenAudioFeedbackAndThrow;   		// 0x0060 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_minimalDistanceToTheTarget;           		// 0x0064 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_maximalDistanceToTheTarget;           		// 0x0068 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_targetCanSeeTheThrower;               		// 0x006C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_throwerIsAttackedByTarget;            		// 0x0070 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_distanceScoreMultiplier;              		// 0x0074 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1780 ];

		return pClassPointer;
	};

};

UClass* UYGrenadeDirectorSettings::pClassPointer = NULL;

// Class SRGame.YGrenadeDirectorSettings_Infrequent
// 0x0000 (0x0078 - 0x0078)
class UYGrenadeDirectorSettings_Infrequent : public UYGrenadeDirectorSettings
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1781 ];

		return pClassPointer;
	};

};

UClass* UYGrenadeDirectorSettings_Infrequent::pClassPointer = NULL;

// Class SRGame.YGrenadeDirectorSettings_Normal
// 0x0000 (0x0078 - 0x0078)
class UYGrenadeDirectorSettings_Normal : public UYGrenadeDirectorSettings
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1782 ];

		return pClassPointer;
	};

};

UClass* UYGrenadeDirectorSettings_Normal::pClassPointer = NULL;

// Class SRGame.YGrenadeDirectorSettings_Often
// 0x0000 (0x0078 - 0x0078)
class UYGrenadeDirectorSettings_Often : public UYGrenadeDirectorSettings
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1783 ];

		return pClassPointer;
	};

};

UClass* UYGrenadeDirectorSettings_Often::pClassPointer = NULL;

// Class SRGame.YGrenadeDirectorSettings_Test_ClusterFuck
// 0x0000 (0x0078 - 0x0078)
class UYGrenadeDirectorSettings_Test_ClusterFuck : public UYGrenadeDirectorSettings
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1784 ];

		return pClassPointer;
	};

};

UClass* UYGrenadeDirectorSettings_Test_ClusterFuck::pClassPointer = NULL;

// Class SRGame.YPlayerSquad_GrenadeDirectorSettings
// 0x0048 (0x0084 - 0x003C)
class UYPlayerSquad_GrenadeDirectorSettings : public UObject
{
public:
	float                                              m_decision_distancePlayerHasToMove;               		// 0x003C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_decision_initialTimerSinceLastMove;             		// 0x0040 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_decision_coolDownTime;                          		// 0x0044 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minimalTimeSincePlayerKilledAPawn;              		// 0x0048 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_misc_waitingTimeBetweenAudioFeedbackAndThrow;   		// 0x004C (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_selection_minimalAmountOfClusteredEnemies;      		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_radius_of_the_cluster;                		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_minimalDistanceToTheTarget;           		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_maximalDistanceToTheTarget;           		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_PlayerCanSeeTheTarget;                		// 0x0060 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_selection_throwerHasValidFireLinkToTheTarget : 1;		// 0x0064 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	float                                              m_selection_scoreIfThrowerIsInFrontOfThePlayer;   		// 0x0068 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_scoreIfThrowerIsInCover;              		// 0x006C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_scoreIfCloserToTheEnemy;              		// 0x0070 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_scoreIfCloserToThePlayer;             		// 0x0074 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_distanceScoreMultiplier;              		// 0x0078 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_eliteEnemyMultiplier;                 		// 0x007C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_selection_normalEnemyMultiplier;                		// 0x0080 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1785 ];

		return pClassPointer;
	};

};

UClass* UYPlayerSquad_GrenadeDirectorSettings::pClassPointer = NULL;

// Class SRGame.YScanReportSASType
// 0x0012 (0x004E - 0x003C)
class UYScanReportSASType : public UObject
{
public:
	TArray< unsigned char >                            m_SASTypeForThisManyFindings;                     		// 0x003C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                m_priority;                                       		// 0x0048 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_forcedPosition;                                 		// 0x004C (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_preferedPosition;                               		// 0x004D (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1786 ];

		return pClassPointer;
	};

};

UClass* UYScanReportSASType::pClassPointer = NULL;

// Class SRGame.YSeqAct_AddToCommunicationPool
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_AddToCommunicationPool : public USequenceAction
{
public:
	struct FString                                     m_poolName;                                       		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1787 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_AddToCommunicationPool::pClassPointer = NULL;

// Class SRGame.YSeqAct_IssueScanCommand
// 0x001C (0x0120 - 0x0104)
class UYSeqAct_IssueScanCommand : public USeqAct_Latent
{
public:
	float                                              m_scanningRadius;                                 		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_scanInfoLifetime;                               		// 0x0108 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_scanRechargeTime;                               		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_actionFinished : 1;                             		// 0x0110 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_succeedOnAbort : 1;                             		// 0x0110 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FPointer                                    m_squadCommand;                                   		// 0x0114 (0x0004) [0x0000000000001000]              ( CPF_Native )
	class AYAIPlayerSquad*                             m_squad;                                          		// 0x0118 (0x0004) [0x0000000000000000]              
	class AYPlayerController*                          m_player;                                         		// 0x011C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1788 ];

		return pClassPointer;
	};

	void HandleCommandFinished ( unsigned long Success );
	bool Update ( float DeltaTime );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_IssueScanCommand::pClassPointer = NULL;

// Class SRGame.YSeqAct_IssueSquadCommand
// 0x0024 (0x0128 - 0x0104)
class UYSeqAct_IssueSquadCommand : public USeqAct_Latent
{
public:
	unsigned char                                      m_command;                                        		// 0x0104 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UObject* >                           m_relatedActors;                                  		// 0x0108 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AActor*                                      m_relatedLocationActor;                           		// 0x0114 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_actionFinished : 1;                             		// 0x0118 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_succeedOnAbort : 1;                             		// 0x0118 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_silent : 1;                                     		// 0x0118 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_executeCommand : 1;                             		// 0x0118 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	struct FPointer                                    m_squadCommand;                                   		// 0x011C (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	class AYAIPlayerSquad*                             m_squad;                                          		// 0x0120 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYPlayerController*                          m_player;                                         		// 0x0124 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1789 ];

		return pClassPointer;
	};

	void HandleCommandFinished ( unsigned long Success );
	bool Update ( float DeltaTime );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_IssueSquadCommand::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleAI_WeaponJamming
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleAI_WeaponJamming : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1790 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ToggleAI_WeaponJamming::pClassPointer = NULL;

// Class SRGame.YAnimNotify_BehaviorTreeEvent
// 0x0002 (0x0042 - 0x0040)
class UYAnimNotify_BehaviorTreeEvent : public UAnimNotify
{
public:
	unsigned char                                      m_eventToTrigger;                                 		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_recvievingEntity;                               		// 0x0041 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1791 ];

		return pClassPointer;
	};

};

UClass* UYAnimNotify_BehaviorTreeEvent::pClassPointer = NULL;

// Class SRGame.YBT_BehaviorTreeAsset
// 0x000C (0x0048 - 0x003C)
class UYBT_BehaviorTreeAsset : public UObject
{
public:
	class UYBT_StaticNode*                             m_rootNode;                                       		// 0x003C (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	int                                                m_nodeCount;                                      		// 0x0040 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nodeMemorySize;                                 		// 0x0044 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1792 ];

		return pClassPointer;
	};

};

UClass* UYBT_BehaviorTreeAsset::pClassPointer = NULL;

// Class SRGame.YBT_NodeComment
// 0x0044 (0x0080 - 0x003C)
class UYBT_NodeComment : public UObject
{
public:
	class UYBT_StaticNode*                             m_commentedNode;                                  		// 0x003C (0x0004) [0x0000000000000000]              
	struct FString                                     ObjComment;                                       		// 0x0040 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_selected : 1;                                   		// 0x004C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_boxStyle : 1;                                   		// 0x004C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	class UMaterialInstanceConstant*                   m_materialTemplate;                               		// 0x0050 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_boxMaterialTemplate;                            		// 0x0054 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_material;                                       		// 0x0058 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_boxMaterial;                                    		// 0x005C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FLinearColor                                m_fillcolor;                                      		// 0x0060 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	int                                                PosX;                                             		// 0x0070 (0x0004) [0x0000000000000000]              
	int                                                PosY;                                             		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                SizeX;                                            		// 0x0078 (0x0004) [0x0000000000000000]              
	int                                                SizeY;                                            		// 0x007C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1793 ];

		return pClassPointer;
	};

};

UClass* UYBT_NodeComment::pClassPointer = NULL;

// Class SRGame.YBT_Register
// 0x0000 (0x003C - 0x003C)
class UYBT_Register : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1794 ];

		return pClassPointer;
	};

};

UClass* UYBT_Register::pClassPointer = NULL;

// Class SRGame.YBT_ShootSet
// 0x0034 (0x0070 - 0x003C)
class UYBT_ShootSet : public UObject
{
public:
	float                                              m_aimTime;                                        		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_accuracy;                                       		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_duration;                                       		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ShootingAngle                           m_shootingAngles;                                 		// 0x0048 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_directionMode;                                  		// 0x0050 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_startDistance;                                  		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_positionInLineWhenHitting;                      		// 0x0058 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FYS_ShootPattern >                  m_shootPatterns;                                  		// 0x005C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_shootTargetSmoothingFactorOverwrite;            		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_shootTargetSmoothingDistanceOverwrite;          		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1795 ];

		return pClassPointer;
	};

};

UClass* UYBT_ShootSet::pClassPointer = NULL;

// Class SRGame.YBT_StaticNode
// 0x0034 (0x0070 - 0x003C)
class UYBT_StaticNode : public UObject
{
public:
	class UYBT_StaticNode*                             m_parent;                                         		// 0x003C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYBT_StaticNodeEditorData*                   m_editorData;                                     		// 0x0040 (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	int                                                m_UID;                                            		// 0x0044 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_doNotDebug : 1;                                 		// 0x0048 (0x0004) [0x0000000020000001] [0x00000001] ( CPF_Edit | CPF_Deprecated )
	unsigned long                                      m_enabled : 1;                                    		// 0x0048 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	TArray< unsigned char >                            m_eventsHandled;                                  		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned char >                            m_eventsDropped;                                  		// 0x0058 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UYBT_NodeComment*                            m_nodeCommentObjLong;                             		// 0x0064 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	class UYBT_NodeComment*                            m_nodeCommentObjShort;                            		// 0x0068 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	int                                                m_instanceVersion;                                		// 0x006C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1796 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticLeafNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticLeafNode : public UYBT_StaticNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1797 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticLeafNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticActionNode : public UYBT_StaticLeafNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1798 ];

		return pClassPointer;
	};

};

UClass* UYBT_StaticActionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionAbstractShootNode
// 0x0024 (0x0094 - 0x0070)
class UYBT_StaticActionAbstractShootNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_target;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_numBursts;                                      		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_useBlindfire : 1;                               		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_turnBody : 1;                                   		// 0x0078 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_continueActionWhenDone : 1;                     		// 0x0078 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_failIfWeaponEmpty : 1;                          		// 0x0078 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_onlyAimWhenCanAimAhead : 1;                     		// 0x0078 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_ignoreAccuracyModifier : 1;                     		// 0x0078 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_preferHeadshots : 1;                            		// 0x0078 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	float                                              m_maxTimeWithoutShotFired;                        		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_AllowedPeekModes                       m_peeking;                                        		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_overrideAccuracy;                               		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UYBT_ShootSet* >                     m_overrideShotSet;                                		// 0x0088 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1799 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionAbstractShootNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionShootAtNode
// 0x0004 (0x0098 - 0x0094)
class UYBT_StaticActionShootAtNode : public UYBT_StaticActionAbstractShootNode
{
public:
	unsigned long                                      m_ignoreVisibility : 1;                           		// 0x0094 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1800 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionShootAtNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionSuppressFireNode
// 0x0000 (0x0094 - 0x0094)
class UYBT_StaticActionSuppressFireNode : public UYBT_StaticActionAbstractShootNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1801 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionSuppressFireNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionAimAtNode
// 0x0018 (0x0088 - 0x0070)
class UYBT_StaticActionAimAtNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_time_min_waitTimeOverwriteVariable;             		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_time_max_waitTimeOverwriteVariable;             		// 0x0073 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_useKismetTimerInstead;                          		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_turnBody : 1;                                   		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_turnBodyExact : 1;                              		// 0x0078 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_useBlindfire : 1;                               		// 0x0078 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_continueActionWhenDone : 1;                     		// 0x0078 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_onlyAimWhenCanAimAhead : 1;                     		// 0x0078 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_shootWhileAiming : 1;                           		// 0x0078 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_useKismetCountForShooting : 1;                  		// 0x0078 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_aimAtHead : 1;                                  		// 0x0078 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	struct FYBT_Timer                                  m_time;                                           		// 0x007C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_AllowedPeekModes                       m_peeking;                                        		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1802 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionAimAtNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionCancelCustomAnimationNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticActionCancelCustomAnimationNode : public UYBT_StaticActionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1803 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionCancelCustomAnimationNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionChangeBotDefinitionNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticActionChangeBotDefinitionNode : public UYBT_StaticActionNode
{
public:
	unsigned long                                      m_bSwitchToDefault : 1;                           		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class UYAIDefinition*                              m_newBotDefinition;                               		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1804 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionChangeBotDefinitionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionCheckAttackPosNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticActionCheckAttackPosNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_checkCanAttackWhichAttackTarget;                		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_checkIsCoveredAgainst : 1;                      		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1805 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionCheckAttackPosNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionCheckCoverPosNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticActionCheckCoverPosNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_checkCoverTarget : 1;                           		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1806 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionCheckCoverPosNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionClearAttackTarget
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticActionClearAttackTarget : public UYBT_StaticActionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1807 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionClearAttackTarget::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionClearObserveTargetNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticActionClearObserveTargetNode : public UYBT_StaticActionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1808 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionClearObserveTargetNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionClearPositionNode
// 0x0002 (0x0072 - 0x0070)
class UYBT_StaticActionClearPositionNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_positionToClear;                                		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_selectionEntity;                                		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1809 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionClearPositionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionClearUserDataNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticActionClearUserDataNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_userDataListType;                               		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1810 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionClearUserDataNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionCopyUserDataToRegisterNode
// 0x0003 (0x0073 - 0x0070)
class UYBT_StaticActionCopyUserDataToRegisterNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_userDataListType;                               		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_registerToChange;                               		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_userDataPos;                                    		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1811 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionCopyUserDataToRegisterNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionCrouchNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticActionCrouchNode : public UYBT_StaticActionNode
{
public:
	unsigned long                                      m_crouch : 1;                                     		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_forced : 1;                                     		// 0x0070 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_playAnimation : 1;                              		// 0x0070 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1812 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionCrouchNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionDieNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticActionDieNode : public UYBT_StaticActionNode
{
public:
	class UClass*                                      m_damageType;                                     		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_entityToKill;                                   		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_momentum;                                       		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1813 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionDieNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionDoDBNONode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticActionDoDBNONode : public UYBT_StaticActionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1814 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionDoDBNONode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionDoSidestepNode
// 0x0018 (0x0088 - 0x0070)
class UYBT_StaticActionDoSidestepNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_sideStepMoveMode;                               		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_frontDistanceForwardDefault;                    		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_frontDistanceForwardEvade;                      		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_frontDistanceForwardDive;                       		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_sideDistanceDefault;                            		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_sideDistanceDodgeRoll;                          		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1815 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionDoSidestepNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionDoSpecialMoveNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticActionDoSpecialMoveNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_specialMove;                                    		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_target;                                         		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_targetPosition;                                 		// 0x0073 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1816 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionDoSpecialMoveNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionEndBehaviorTreeNode
// 0x0010 (0x0080 - 0x0070)
class UYBT_StaticActionEndBehaviorTreeNode : public UYBT_StaticActionNode
{
public:
	unsigned long                                      m_finishSucessfull : 1;                           		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FString                                     m_reason;                                         		// 0x0074 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1817 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionEndBehaviorTreeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionExecuteAttackTargetSelectionNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticActionExecuteAttackTargetSelectionNode : public UYBT_StaticActionNode
{
public:
	class UYBT_TargetModifierPreset*                   m_targetModifiers;                                		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bSetSquadAttackCommandTargetAlso : 1;           		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1818 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionExecuteAttackTargetSelectionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionExecuteCoverTargetSelectionNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticActionExecuteCoverTargetSelectionNode : public UYBT_StaticActionNode
{
public:
	class UYBT_TargetModifierPreset*                   m_targetModifiers;                                		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1819 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionExecuteCoverTargetSelectionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionGetClosestEntityNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticActionGetClosestEntityNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_fromEntity;                                     		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_setAs;                                          		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_standing;                                       		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_setCurrentEntityAsObserveTargetForClosest : 1;  		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1820 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionGetClosestEntityNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionGoIntoRandomDirectionNode
// 0x001C (0x008C - 0x0070)
class UYBT_StaticActionGoIntoRandomDirectionNode : public UYBT_StaticActionNode
{
public:
	float                                              m_minAngle;                                       		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxAngle;                                       		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_entity;                                         		// 0x0078 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0079 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_movementMode;                                   		// 0x007A (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_invertDirection : 1;                            		// 0x007C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FYBT_Timer                                  m_duration;                                       		// 0x0080 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_distanceToTestAhead;                            		// 0x0088 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1821 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionGoIntoRandomDirectionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionGotoPos
// 0x0014 (0x0084 - 0x0070)
class UYBT_StaticActionGotoPos : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_gotoEntity;                                     		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_gotoPos;                                        		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_movementMode;                                   		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_enterCover;                                     		// 0x0073 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_reachMode;                                      		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_reachRadius;                                    		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_moveOn : 1;                                     		// 0x007C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_skipStopAnimation : 1;                          		// 0x007C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_ignoreSlowDown : 1;                             		// 0x007C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_ignoreSlowDownToCrouch : 1;                     		// 0x007C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	struct FYBT_EdgeCosts                              m_costs;                                          		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1822 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
	int GetClassVersion ( );
};

UClass* UYBT_StaticActionGotoPos::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionIdleLookAtEntityNode
// 0x0034 (0x00A4 - 0x0070)
class UYBT_StaticActionIdleLookAtEntityNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_forcedEntity;                                   		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_radiusMin;                                      		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_radiusMax;                                      		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_height;                                         		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_angleStanding;                                  		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_angleWalking;                                   		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_angleRunning;                                   		// 0x0088 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_angleSprinting;                                 		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_angleCoverTowards;                              		// 0x0090 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_angleCoverAway;                                 		// 0x0094 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_Timer                                  m_time;                                           		// 0x0098 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_onlyIfNotAiming : 1;                            		// 0x00A0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_onlyIfNotReloading : 1;                         		// 0x00A0 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_mayTurnBody : 1;                                		// 0x00A0 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_failWhenInEdgePose : 1;                         		// 0x00A0 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_failWhenInStackingPose : 1;                     		// 0x00A0 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1823 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionIdleLookAtEntityNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionJumpToBehaviorTreeNode
// 0x0014 (0x0084 - 0x0070)
class UYBT_StaticActionJumpToBehaviorTreeNode : public UYBT_StaticActionNode
{
public:
	class UYBT_BehaviorTreeAsset*                      m_behaviorTree;                                   		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_runCurrentTreeWhenDone : 1;                     		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_wasCurrentBT_Succesfull : 1;                    		// 0x0074 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_useBehaviorJumpForAllTargets : 1;               		// 0x0074 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	struct FString                                     m_reason;                                         		// 0x0078 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1824 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionJumpToBehaviorTreeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionJumpToDefaultBehaviorTreeNode
// 0x0010 (0x0080 - 0x0070)
class UYBT_StaticActionJumpToDefaultBehaviorTreeNode : public UYBT_StaticActionNode
{
public:
	unsigned long                                      m_wasCurrentBT_Succesfull : 1;                    		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FString                                     m_reason;                                         		// 0x0074 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1825 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionJumpToDefaultBehaviorTreeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionLookAtNode
// 0x0014 (0x0084 - 0x0070)
class UYBT_StaticActionLookAtNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_useKismetTimerInstead;                          		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_turnBody : 1;                                   		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_continueActionWhenDone : 1;                     		// 0x0074 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	struct FYBT_Timer                                  m_time;                                           		// 0x0078 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_AllowedPeekModes                       m_peeking;                                        		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1826 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionLookAtNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionModifyArsenalNode
// 0x0024 (0x0094 - 0x0070)
class UYBT_StaticActionModifyArsenalNode : public UYBT_StaticActionNode
{
public:
	TArray< struct FYBT_ModifyArsenal >                m_arsenal;                                        		// 0x0070 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_weaponEnums;                                    		// 0x007C (0x000C) [0x0000000020400000]              ( CPF_NeedCtorLink | CPF_Deprecated )
	TArray< unsigned char >                            m_secondaryModes2Activate;                        		// 0x0088 (0x000C) [0x0000000020400000]              ( CPF_NeedCtorLink | CPF_Deprecated )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1827 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionModifyArsenalNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionNextUserDataNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticActionNextUserDataNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_userDataListType;                               		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_wrap : 1;                                       		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1828 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionNextUserDataNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionNoAimLookAtShootAtObserveNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticActionNoAimLookAtShootAtObserveNode : public UYBT_StaticActionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1829 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionNoAimLookAtShootAtObserveNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionObserveAreaNode
// 0x0048 (0x00B8 - 0x0070)
class UYBT_StaticActionObserveAreaNode : public UYBT_StaticActionNode
{
public:
	float                                              m_area;                                           		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_Timer                                  m_duration;                                       		// 0x0074 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_ObserveSettings                        m_primary;                                        		// 0x007C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_ObserveSettings                        m_secondary;                                      		// 0x0088 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_continueActionWhenDone : 1;                     		// 0x0094 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_ignoreInfiltrateModeRestrictions : 1;           		// 0x0094 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_usePeakMode : 1;                                		// 0x0094 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	TArray< struct FYS_ObserveAreaAnimation >          m_animations;                                     		// 0x0098 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_animChance;                                     		// 0x00A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_Timer                                  m_genericObserveTime;                             		// 0x00A8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_observedEntity;                                 		// 0x00B0 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_observedPosition;                               		// 0x00B1 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_checkDistance;                                  		// 0x00B4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1830 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionObserveAreaNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionPeekNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticActionPeekNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_peekMode;                                       		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_Timer                                  m_time;                                           		// 0x0074 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1831 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionPeekNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionPlayBlindFireAnimationNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticActionPlayBlindFireAnimationNode : public UYBT_StaticActionNode
{
public:
	unsigned long                                      m_playOutAnimation : 1;                           		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FName                                       m_outAnimationName;                               		// 0x0074 (0x0008) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1832 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionPlayBlindFireAnimationNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionPlayCustomAnimationNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticActionPlayCustomAnimationNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_orientToEntity;                                 		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_orientToPosition;                               		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UYCustomAnimationBase*                       m_customAnimation;                                		// 0x0074 (0x0004) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	unsigned long                                      m_useKismetOverwrite : 1;                         		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1833 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionPlayCustomAnimationNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionPlayGenericAnimationNode
// 0x003C (0x00AC - 0x0070)
class UYBT_StaticActionPlayGenericAnimationNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_group;                                          		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_id;                                             		// 0x0074 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_collisionHeight;                                		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_collisionRadius;                                		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_loop : 1;                                       		// 0x0084 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_allowsMovement : 1;                             		// 0x0084 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_weaponJaming : 1;                               		// 0x0084 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_movingSideStep : 1;                             		// 0x0084 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_preventAimingAndShooting : 1;                   		// 0x0084 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_onlyWhenMovingInStraightLine : 1;               		// 0x0084 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_interpolateToStage : 1;                         		// 0x0084 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	float                                              m_blendTimeIn;                                    		// 0x0088 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_blendTimeOut;                                   		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_playRate;                                       		// 0x0090 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_interpolateToStageOffset;                       		// 0x0094 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FName >                             m_groupNames;                                     		// 0x00A0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1834 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionPlayGenericAnimationNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionPlayIdleAnimationNode
// 0x0018 (0x0088 - 0x0070)
class UYBT_StaticActionPlayIdleAnimationNode : public UYBT_StaticActionNode
{
public:
	unsigned long                                      m_failWhenNoAnimationAvailable : 1;               		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	TArray< struct FYS_PlayIdleAnimation >             m_animations;                                     		// 0x0074 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_sameAnimationBlockingTimer;                     		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_anyIdleAnimationBlockingTimer;                  		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1835 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionPlayIdleAnimationNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionPlayReplicatedAnimationNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticActionPlayReplicatedAnimationNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_animation;                                      		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_playRate;                                       		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_returnImmediately : 1;                          		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1836 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionPlayReplicatedAnimationNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionPreviousUserDataNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticActionPreviousUserDataNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_userDataListType;                               		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_wrap : 1;                                       		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1837 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionPreviousUserDataNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionRaiseAlarmNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticActionRaiseAlarmNode : public UYBT_StaticActionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1838 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionRaiseAlarmNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionReloadWeaponNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticActionReloadWeaponNode : public UYBT_StaticActionNode
{
public:
	int                                                m_minAmmoPercentage;                              		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1839 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionReloadWeaponNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionRemoveBehaviorFilterNode
// 0x0010 (0x0080 - 0x0070)
class UYBT_StaticActionRemoveBehaviorFilterNode : public UYBT_StaticActionNode
{
public:
	unsigned long                                      m_bClearAllFilters : 1;                           		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	TArray< unsigned char >                            m_filtersToRemove;                                		// 0x0074 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1840 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionRemoveBehaviorFilterNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionResetUserDataPositionNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticActionResetUserDataPositionNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_userDataListType;                               		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1841 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionResetUserDataPositionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionReviveEntityNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticActionReviveEntityNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1842 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionReviveEntityNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionRunSpecialActionNode
// 0x0007 (0x0077 - 0x0070)
class UYBT_StaticActionRunSpecialActionNode : public UYBT_StaticActionNode
{
public:
	class UYSpecialActionsDefinition*                  m_specialAction;                                  		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_priority;                                       		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_dataPositionEntity;                             		// 0x0075 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_dataPositionPosition;                           		// 0x0076 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1843 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionRunSpecialActionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionRunSpecialActionSetNode
// 0x0007 (0x0077 - 0x0070)
class UYBT_StaticActionRunSpecialActionSetNode : public UYBT_StaticActionNode
{
public:
	class UYSpecialActionSet*                          m_specialActionSet;                               		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_priority;                                       		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_dataPositionEntity;                             		// 0x0075 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_dataPositionPosition;                           		// 0x0076 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1844 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionRunSpecialActionSetNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionRunSpecialActionTypeNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticActionRunSpecialActionTypeNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_type;                                           		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_priority;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_dataPositionEntity;                             		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_dataPositionPosition;                           		// 0x0073 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_returnInstant : 1;                              		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_getGrenadeTypeFromBrain : 1;                    		// 0x0074 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1845 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionRunSpecialActionTypeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionSelectAttackPosNode
// 0x0020 (0x0090 - 0x0070)
class UYBT_StaticActionSelectAttackPosNode : public UYBT_StaticActionNode
{
public:
	unsigned long                                      m_immediate : 1;                                  		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_useSpecifiedSelectionCenter : 1;                		// 0x0070 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_onlySetValidAttackPos : 1;                      		// 0x0070 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_checkAgainstRealPos : 1;                        		// 0x0070 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	float                                              m_selectionRadius;                                		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_selectionHeight;                                		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_selectionCenterEntity;                          		// 0x007C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_selectionCenterPos;                             		// 0x007D (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UYSC_SelectionModifierBase* >        m_selectionModifiers;                             		// 0x0080 (0x000C) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	class UYBT_PositionSelectionModifierPreset*        m_selectionModifierPreset;                        		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1846 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionSelectAttackPosNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionSelectCoverPosNode
// 0x0020 (0x0090 - 0x0070)
class UYBT_StaticActionSelectCoverPosNode : public UYBT_StaticActionNode
{
public:
	unsigned long                                      m_immediate : 1;                                  		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_useSpecifiedSelectionCenter : 1;                		// 0x0070 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_onlySetValidCoverPos : 1;                       		// 0x0070 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_checkAgainstRealPos : 1;                        		// 0x0070 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	float                                              m_selectionRadius;                                		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_selectionHeight;                                		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_selectionCenterEntity;                          		// 0x007C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_selectionCenterPos;                             		// 0x007D (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UYSC_SelectionModifierBase* >        m_selectionModifiers;                             		// 0x0080 (0x000C) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	class UYBT_PositionSelectionModifierPreset*        m_selectionModifierPreset;                        		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1847 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionSelectCoverPosNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionSendBehaviorEventNode
// 0x0002 (0x0072 - 0x0070)
class UYBT_StaticActionSendBehaviorEventNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_eventToSend;                                    		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_recvievingEntity;                               		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1848 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionSendBehaviorEventNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionSetBehaviorFilterNode
// 0x0006 (0x0076 - 0x0070)
class UYBT_StaticActionSetBehaviorFilterNode : public UYBT_StaticActionNode
{
public:
	unsigned long                                      m_bClearOldFilters : 1;                           		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      m_filter;                                         		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_entity;                                         		// 0x0075 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1849 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionSetBehaviorFilterNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionSetBehaviorGateNode
// 0x0010 (0x0080 - 0x0070)
class UYBT_StaticActionSetBehaviorGateNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_gateScope;                                      		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_modifier;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_gateName;                                       		// 0x0074 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_increment;                                      		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1850 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionSetBehaviorGateNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionSpeakByUIDNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticActionSpeakByUIDNode : public UYBT_StaticActionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1851 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionSpeakByUIDNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionSuppressEnemiesNode
// 0x0020 (0x0090 - 0x0070)
class UYBT_StaticActionSuppressEnemiesNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_doNotSuppressGivenEntity : 1;                   		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_suppressRadius;                                 		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_suppressHeight;                                 		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_Timer                                  m_suppressDelay;                                  		// 0x0080 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_Timer                                  m_suppressTime;                                   		// 0x0088 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1852 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionSuppressEnemiesNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionTeleportEntityNode
// 0x0002 (0x0072 - 0x0070)
class UYBT_StaticActionTeleportEntityNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1853 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionTeleportEntityNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionThrowGrenadeNode
// 0x0014 (0x0084 - 0x0070)
class UYBT_StaticActionThrowGrenadeNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_grenadeType;                                    		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_grenadeThrowMode;                               		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_targetEntity;                                   		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_targetPosition;                                 		// 0x0073 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_useKismetTimerInstead;                          		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_showDebugTrail : 1;                             		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_ignoreCollision : 1;                            		// 0x0078 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_notifyAI : 1;                                   		// 0x0078 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_aimAtHead : 1;                                  		// 0x0078 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_useBlindfire : 1;                               		// 0x0078 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	float                                              m_aimAngle;                                       		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_aimTime;                                        		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1854 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionThrowGrenadeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionToogleWeaponNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticActionToogleWeaponNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_eToggleAction;                                  		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1855 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionToogleWeaponNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionTossWeaponNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticActionTossWeaponNode : public UYBT_StaticActionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1856 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionTossWeaponNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionTriggerGrenadeEventNode
// 0x0003 (0x0073 - 0x0070)
class UYBT_StaticActionTriggerGrenadeEventNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_grenadeType;                                    		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1857 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionTriggerGrenadeEventNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionTurnBodyNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticActionTurnBodyNode : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_facingAngle;                                    		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_orientLikePosition : 1;                         		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_orientLikeEntity : 1;                           		// 0x0078 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_invertDirection : 1;                            		// 0x0078 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_turnBody : 1;                                   		// 0x0078 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_turnTorso : 1;                                  		// 0x0078 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_moveBackward : 1;                               		// 0x0078 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1858 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionTurnBodyNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionWaitForeverNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticActionWaitForeverNode : public UYBT_StaticActionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1859 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionWaitForeverNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticActionWaitNode
// 0x0014 (0x0084 - 0x0070)
class UYBT_StaticActionWaitNode : public UYBT_StaticActionNode
{
public:
	struct FYBT_Timer                                  m_timeToWait;                                     		// 0x0070 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_min_waitTimeOverwriteVariable;                  		// 0x0078 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_max_waitTimeOverwriteVariable;                  		// 0x0079 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_useKismetTimerInstead;                          		// 0x007A (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minTimeChange;                                  		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lastRandom;                                     		// 0x0080 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1860 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticActionWaitNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticCover
// 0x0002 (0x0072 - 0x0070)
class UYBT_StaticCover : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_coverStance;                                    		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_coverPosition;                                  		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1861 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticCover::pClassPointer = NULL;

// Class SRGame.YBT_StaticObserveDirection
// 0x0031 (0x00A1 - 0x0070)
class UYBT_StaticObserveDirection : public UYBT_StaticActionNode
{
public:
	float                                              m_direction;                                      		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_area;                                           		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_doAim : 1;                                      		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_continueActionWhenDone : 1;                     		// 0x0078 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_mayPeekOver : 1;                                		// 0x0078 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_turnBody : 1;                                   		// 0x0078 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_updateDirection : 1;                            		// 0x0078 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	struct FYBT_Timer                                  m_duration;                                       		// 0x007C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_ObserveSettings                        m_primary;                                        		// 0x0084 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_ObserveSettings                        m_secondary;                                      		// 0x0090 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_start;                                          		// 0x009C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_observedCoverSide;                              		// 0x009D (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_entity;                                         		// 0x009E (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x009F (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_useKismetTimerInstead;                          		// 0x00A0 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1862 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticObserveDirection::pClassPointer = NULL;

// Class SRGame.YBT_StaticObservePosition
// 0x0038 (0x00A8 - 0x0070)
class UYBT_StaticObservePosition : public UYBT_StaticActionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_start;                                          		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_action;                                         		// 0x0073 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_observeSubPosition;                             		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_area;                                           		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_updateDirectionWhenMoving : 1;                  		// 0x007C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_continueActionWhenDone : 1;                     		// 0x007C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	struct FYBT_Timer                                  m_duration;                                       		// 0x0080 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_ObserveSettings                        m_primary;                                        		// 0x0088 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FYBT_ObserveSettings                        m_secondary;                                      		// 0x0094 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FYSOP_AllowedPeekModes                      m_allowedPeekModes;                               		// 0x00A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_observeHeightOffset;                            		// 0x00A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1863 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticObservePosition::pClassPointer = NULL;

// Class SRGame.YBT_StaticBehaviorNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticBehaviorNode : public UYBT_StaticLeafNode
{
public:
	class UYBT_BehaviorTreeAsset*                      m_behaviorTreeAsset;                              		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1864 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticBehaviorNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticConditionNode : public UYBT_StaticLeafNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1865 ];

		return pClassPointer;
	};

};

UClass* UYBT_StaticConditionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionCanAttackFromPositionNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionCanAttackFromPositionNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_AttackingEntity;                                		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_entity;                                         		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maximalDistance;                                		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1866 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionCanAttackFromPositionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionCanBeMeleedNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionCanBeMeleedNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_ignoreDownOnTheGround : 1;                      		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1867 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionCanBeMeleedNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionCanGoNode
// 0x0018 (0x0088 - 0x0070)
class UYBT_StaticConditionCanGoNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_endEntity;                                      		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_endPosition;                                    		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_startEntity;                                    		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_startPosition;                                  		// 0x0073 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_checkOnlyAiMesh : 1;                            		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_startDistance;                                  		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_endDistance;                                    		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_distanceToCollisionPoint;                       		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_entityWidth;                                    		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1868 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionCanGoNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionCertaintyIsAtLeastNode
// 0x0002 (0x0072 - 0x0070)
class UYBT_StaticConditionCertaintyIsAtLeastNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_minCertainty;                                   		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1869 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionCertaintyIsAtLeastNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionCheckAnglesNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticConditionCheckAnglesNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_targetEntity;                                   		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxAngleToAimUp;                                		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxAngleToAimSide;                              		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1870 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionCheckAnglesNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionCompareEntitiesNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticConditionCompareEntitiesNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_firstEntity;                                    		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_firstEntityRegister;                            		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_secondEntity;                                   		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_secondEntityRegister;                           		// 0x0073 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1871 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionCompareEntitiesNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionCoverNeedAtLeastNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticConditionCoverNeedAtLeastNode : public UYBT_StaticConditionNode
{
public:
	float                                              m_coverNeed;                                      		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1872 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionCoverNeedAtLeastNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionEntityIsValidNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionEntityIsValidNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_eCheckEntityType;                               		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_checkDownButNotOut : 1;                         		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1873 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
	int GetClassVersion ( );
};

UClass* UYBT_StaticConditionEntityIsValidNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionEntitySpeedIsNode
// 0x0002 (0x0072 - 0x0070)
class UYBT_StaticConditionEntitySpeedIsNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_requiredSpeed;                                  		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1874 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionEntitySpeedIsNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionGameModeIsNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticConditionGameModeIsNode : public UYBT_StaticConditionNode
{
public:
	class UClass*                                      m_IntendedGameMode;                               		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1875 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionGameModeIsNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionGrenadeExplodedNearbyNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticConditionGrenadeExplodedNearbyNode : public UYBT_StaticConditionNode
{
public:
	float                                              m_timeSinceExplosion;                             		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_distanceToExplosion;                            		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_checkExplosionsOnly : 1;                        		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1876 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionGrenadeExplodedNearbyNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionHasAttackCommandAreaNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionHasAttackCommandAreaNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1877 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionHasAttackCommandAreaNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionHasEnemyNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticConditionHasEnemyNode : public UYBT_StaticConditionNode
{
public:
	unsigned long                                      m_ignoreLostTargets : 1;                          		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_ignoreFakeTargets : 1;                          		// 0x0070 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1878 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionHasEnemyNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionHasPositionInPlayerSquadPathNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionHasPositionInPlayerSquadPathNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_pathOrderToCheckFor;                            		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1879 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionHasPositionInPlayerSquadPathNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionHasUserDataNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticConditionHasUserDataNode : public UYBT_StaticConditionNode
{
public:
	unsigned long                                      m_checkForEntity : 1;                             		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_checkForPosition : 1;                           		// 0x0070 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1880 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionHasUserDataNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionHealthIsNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticConditionHealthIsNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_min;                                            		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_max;                                            		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1881 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionHealthIsNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionImpactIsOfTypeNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticConditionImpactIsOfTypeNode : public UYBT_StaticConditionNode
{
public:
	TArray< unsigned char >                            m_types;                                          		// 0x0070 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1882 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionImpactIsOfTypeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsAimingNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsAimingNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1883 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsAimingNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsAtPositionNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionIsAtPositionNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDistance;                                    		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1884 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsAtPositionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsBadCoverNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsBadCoverNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_position;                                       		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1885 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsBadCoverNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsBehaviorStateNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsBehaviorStateNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_behaviorStateToCheck;                           		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1886 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsBehaviorStateNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsBehindEntityNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsBehindEntityNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1887 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsBehindEntityNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsCoveredAgainstNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsCoveredAgainstNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1888 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsCoveredAgainstNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsCrouchingNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsCrouchingNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1889 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsCrouchingNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsDangerousEnemyNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsDangerousEnemyNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1890 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsDangerousEnemyNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsDBNONode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsDBNONode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1891 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsDBNONode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsDownedNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsDownedNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1892 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsDownedNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsEntityInSandstormNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionIsEntityInSandstormNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_minimumSandstormLevel;                          		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1893 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsEntityInSandstormNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsEntityMovingNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticConditionIsEntityMovingNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_standingDelay;                                  		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_checkMoveTarget : 1;                            		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1894 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsEntityMovingNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsFallingNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsFallingNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1895 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsFallingNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsFlankedByNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsFlankedByNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1896 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsFlankedByNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsFlankingPositionNode
// 0x0002 (0x0072 - 0x0070)
class UYBT_StaticConditionIsFlankingPositionNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1897 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsFlankingPositionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsInCoverNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionIsInCoverNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_acceptStandCover : 1;                           		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_acceptCrouchCover : 1;                          		// 0x0074 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_acceptStack : 1;                                		// 0x0074 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_checkForDirection : 1;                          		// 0x0074 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_checkIfInTheEdgePose : 1;                       		// 0x0074 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_checkCurrentPositionIfNotInCover : 1;           		// 0x0074 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1898 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsInCoverNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsInLineOfFireNode
// 0x0005 (0x0075 - 0x0070)
class UYBT_StaticConditionIsInLineOfFireNode : public UYBT_StaticConditionNode
{
public:
	unsigned long                                      m_checkPlayer : 1;                                		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_checkSquadMates : 1;                            		// 0x0070 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_ownSquad : 1;                                   		// 0x0070 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_fireTargetAllowed : 1;                          		// 0x0070 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_failIfinCover : 1;                              		// 0x0070 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_ignoreAiming : 1;                               		// 0x0070 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_checkTestPosition : 1;                          		// 0x0070 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1899 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsInLineOfFireNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsInMaxVisionRangeNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionIsInMaxVisionRangeNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxPercentageOfVisionRange;                     		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1900 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsInMaxVisionRangeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsInMoveDirectionNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionIsInMoveDirectionNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entityOrigin;                                   		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_entity;                                         		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_dotProduct;                                     		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1901 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsInMoveDirectionNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsInRangeNode
// 0x0014 (0x0084 - 0x0070)
class UYBT_StaticConditionIsInRangeNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_entityOrigin;                                   		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_checkMode;                                      		// 0x0073 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_useKismetTimerInstead;                          		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxHeightDifference;                            		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minDistance;                                    		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDistance;                                    		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1902 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsInRangeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsMovingNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionIsMovingNode : public UYBT_StaticConditionNode
{
public:
	float                                              m_time;                                           		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_checkMoveTarget : 1;                            		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1903 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsMovingNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsPeekModeNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticConditionIsPeekModeNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_IsPeekModeMode                          m_mode;                                           		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_IsPeekModeDirection                     m_direction;                                      		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1904 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsPeekModeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsPositionBehindMeNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionIsPositionBehindMeNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_entityOrigin;                                   		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_dotProductAngle;                                		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1905 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsPositionBehindMeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsRunningSpeakToLineNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticConditionIsRunningSpeakToLineNode : public UYBT_StaticConditionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1906 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsRunningSpeakToLineNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsSquadInCombatModeNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsSquadInCombatModeNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1907 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsSquadInCombatModeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsSquadInInfiltrateModeNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticConditionIsSquadInInfiltrateModeNode : public UYBT_StaticConditionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1908 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsSquadInInfiltrateModeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionIsUsingTurretNode
// 0x0001 (0x0071 - 0x0070)
class UYBT_StaticConditionIsUsingTurretNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1909 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionIsUsingTurretNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionMaximalEntitiesShootingAtNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionMaximalEntitiesShootingAtNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_maximalEnemies;                                 		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1910 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionMaximalEntitiesShootingAtNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionPositionIsLockedNode
// 0x0002 (0x0072 - 0x0070)
class UYBT_StaticConditionPositionIsLockedNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1911 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionPositionIsLockedNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionPositionIsValidNode
// 0x0002 (0x0072 - 0x0070)
class UYBT_StaticConditionPositionIsValidNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1912 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionPositionIsValidNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionShouldEnterCoverNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionShouldEnterCoverNode : public UYBT_StaticConditionNode
{
public:
	unsigned char                                      m_entity;                                         		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x0071 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_mode;                                           		// 0x0072 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_ignoreAiming : 1;                               		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1913 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionShouldEnterCoverNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionSpeakLineShouldLookAtNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticConditionSpeakLineShouldLookAtNode : public UYBT_StaticConditionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1914 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionSpeakLineShouldLookAtNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionSpeakLineShouldTurnToNode
// 0x0000 (0x0070 - 0x0070)
class UYBT_StaticConditionSpeakLineShouldTurnToNode : public UYBT_StaticConditionNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1915 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionSpeakLineShouldTurnToNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionTimeSinceAttackCommandNodeNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticConditionTimeSinceAttackCommandNodeNode : public UYBT_StaticConditionNode
{
public:
	float                                              m_maxTime;                                        		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1916 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionTimeSinceAttackCommandNodeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionTimeSinceLastSeenNode
// 0x0006 (0x0076 - 0x0070)
class UYBT_StaticConditionTimeSinceLastSeenNode : public UYBT_StaticConditionNode
{
public:
	float                                              m_maxTimeSinceSeen;                               		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_entity;                                         		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_maxTimeSinceSeen_OverwriteVariable;             		// 0x0075 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1917 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionTimeSinceLastSeenNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionTimeSinceLastSidestepNode
// 0x000E (0x007E - 0x0070)
class UYBT_StaticConditionTimeSinceLastSidestepNode : public UYBT_StaticConditionNode
{
public:
	float                                              m_minTime;                                        		// 0x0070 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	float                                              m_maxTime;                                        		// 0x0074 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	float                                              m_time;                                           		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_minTime_waitTimeOverwriteVariable;              		// 0x007C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_maxTime_waitTimeOverwriteVariable;              		// 0x007D (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1918 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionTimeSinceLastSidestepNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticConditionTimeSinceLastWeaponJamingNode
// 0x0008 (0x0078 - 0x0070)
class UYBT_StaticConditionTimeSinceLastWeaponJamingNode : public UYBT_StaticConditionNode
{
public:
	float                                              m_minTime;                                        		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxTime;                                        		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1919 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticConditionTimeSinceLastWeaponJamingNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorAmmoIsAtLeastNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticDecoratorAmmoIsAtLeastNode : public UYBT_StaticConditionNode
{
public:
	float                                              m_ammoIsAtLeast;                                  		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1920 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorAmmoIsAtLeastNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticManyChildNode
// 0x000C (0x007C - 0x0070)
class UYBT_StaticManyChildNode : public UYBT_StaticNode
{
public:
	TArray< class UYBT_StaticNode* >                   m_children;                                       		// 0x0070 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1921 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticManyChildNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticCompositeNode
// 0x0000 (0x007C - 0x007C)
class UYBT_StaticCompositeNode : public UYBT_StaticManyChildNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1922 ];

		return pClassPointer;
	};

};

UClass* UYBT_StaticCompositeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticCompositeBehaviorFilterNode
// 0x000C (0x0088 - 0x007C)
class UYBT_StaticCompositeBehaviorFilterNode : public UYBT_StaticCompositeNode
{
public:
	TArray< struct FYBT_OutputNode >                   m_outputNodes;                                    		// 0x007C (0x000C) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1923 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticCompositeBehaviorFilterNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticCompositeSelectorSingleNode
// 0x0000 (0x007C - 0x007C)
class UYBT_StaticCompositeSelectorSingleNode : public UYBT_StaticCompositeNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1924 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticCompositeSelectorSingleNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticParallelNode
// 0x0004 (0x0080 - 0x007C)
class UYBT_StaticParallelNode : public UYBT_StaticCompositeNode
{
public:
	unsigned long                                      m_returnOnFirstFail : 1;                          		// 0x007C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_returnOnFirstSuccess : 1;                       		// 0x007C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1925 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticParallelNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticSelectorLinearNode
// 0x0000 (0x007C - 0x007C)
class UYBT_StaticSelectorLinearNode : public UYBT_StaticCompositeNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1926 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
	int GetClassVersion ( );
};

UClass* UYBT_StaticSelectorLinearNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticSelectorRandomNode
// 0x0000 (0x007C - 0x007C)
class UYBT_StaticSelectorRandomNode : public UYBT_StaticCompositeNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1927 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticSelectorRandomNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticSequenceLinearNode
// 0x0000 (0x007C - 0x007C)
class UYBT_StaticSequenceLinearNode : public UYBT_StaticCompositeNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1928 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticSequenceLinearNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticSingleChildNode
// 0x0004 (0x0074 - 0x0070)
class UYBT_StaticSingleChildNode : public UYBT_StaticNode
{
public:
	class UYBT_StaticNode*                             m_child;                                          		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1929 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticSingleChildNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorNode
// 0x0000 (0x0074 - 0x0074)
class UYBT_StaticDecoratorNode : public UYBT_StaticSingleChildNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1930 ];

		return pClassPointer;
	};

};

UClass* UYBT_StaticDecoratorNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticBlockEventsNode
// 0x0000 (0x0074 - 0x0074)
class UYBT_StaticBlockEventsNode : public UYBT_StaticDecoratorNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1931 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticBlockEventsNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorAbstractGateTriggerNode
// 0x0010 (0x0084 - 0x0074)
class UYBT_StaticDecoratorAbstractGateTriggerNode : public UYBT_StaticDecoratorNode
{
public:
	unsigned char                                      m_gateScope;                                      		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_gateName;                                       		// 0x0078 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_increment;                                      		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1932 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorAbstractGateTriggerNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorDistanceGateTriggerNode
// 0x0000 (0x0084 - 0x0084)
class UYBT_StaticDecoratorDistanceGateTriggerNode : public UYBT_StaticDecoratorAbstractGateTriggerNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1933 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorDistanceGateTriggerNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorGateTriggerNode
// 0x0000 (0x0084 - 0x0084)
class UYBT_StaticDecoratorGateTriggerNode : public UYBT_StaticDecoratorAbstractGateTriggerNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1934 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorGateTriggerNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorAdditionalAnimSetsNode
// 0x000C (0x0080 - 0x0074)
class UYBT_StaticDecoratorAdditionalAnimSetsNode : public UYBT_StaticDecoratorNode
{
public:
	TArray< struct FYS_AnimSet >                       m_animSets;                                       		// 0x0074 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1935 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorAdditionalAnimSetsNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorApplyAccuracyMultiplierNode
// 0x0004 (0x0078 - 0x0074)
class UYBT_StaticDecoratorApplyAccuracyMultiplierNode : public UYBT_StaticDecoratorNode
{
public:
	float                                              m_accuracyMultiplier;                             		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1936 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorApplyAccuracyMultiplierNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorApplyArmorMultiplierNode
// 0x0004 (0x0078 - 0x0074)
class UYBT_StaticDecoratorApplyArmorMultiplierNode : public UYBT_StaticDecoratorNode
{
public:
	float                                              m_armorMultiplier;                                		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1937 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorApplyArmorMultiplierNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorBehaviorDistanceGateNode
// 0x001C (0x0090 - 0x0074)
class UYBT_StaticDecoratorBehaviorDistanceGateNode : public UYBT_StaticDecoratorNode
{
public:
	unsigned char                                      m_gateScope;                                      		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_centerOfInterestEntity;                         		// 0x0075 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_centerOfInterestPosition;                       		// 0x0076 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_gateName;                                       		// 0x0078 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_minValue;                                       		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_maxValue;                                       		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_closedWhenInsideMinMax : 1;                     		// 0x0088 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_checkFriendlies : 1;                            		// 0x0088 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_checkHostiles : 1;                              		// 0x0088 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_checkNeutrals : 1;                              		// 0x0088 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	float                                              m_influenceRadius;                                		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1938 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorBehaviorDistanceGateNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorBehaviorGateNode
// 0x0018 (0x008C - 0x0074)
class UYBT_StaticDecoratorBehaviorGateNode : public UYBT_StaticDecoratorNode
{
public:
	unsigned char                                      m_gateScope;                                      		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_gateName;                                       		// 0x0078 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_minValue;                                       		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_maxValue;                                       		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_closedWhenInsideMinMax : 1;                     		// 0x0088 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1939 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorBehaviorGateNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorChanceNode
// 0x0005 (0x0079 - 0x0074)
class UYBT_StaticDecoratorChanceNode : public UYBT_StaticDecoratorNode
{
public:
	float                                              m_chance;                                         		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_chance_OverwriteVariable;                       		// 0x0078 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1940 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorChanceNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorDisableSensoryNode
// 0x0000 (0x0074 - 0x0074)
class UYBT_StaticDecoratorDisableSensoryNode : public UYBT_StaticDecoratorNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1941 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorDisableSensoryNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorDrawDebugTextNode
// 0x003E (0x00B2 - 0x0074)
class UYBT_StaticDecoratorDrawDebugTextNode : public UYBT_StaticDecoratorNode
{
public:
	struct FYS_DebugTextTimed                          m_enter;                                          		// 0x0074 (0x0014) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FYS_DebugText                               m_active;                                         		// 0x0088 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FYS_DebugTextTimed                          m_leave;                                          		// 0x0098 (0x0014) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_heightOffset;                                   		// 0x00AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_entity;                                         		// 0x00B0 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x00B1 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1942 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorDrawDebugTextNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorFailedNode
// 0x0000 (0x0074 - 0x0074)
class UYBT_StaticDecoratorFailedNode : public UYBT_StaticDecoratorNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1943 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorFailedNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorIgnoreFightAreasNode
// 0x0000 (0x0074 - 0x0074)
class UYBT_StaticDecoratorIgnoreFightAreasNode : public UYBT_StaticDecoratorNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1944 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorIgnoreFightAreasNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorLevelDesignerGateNode
// 0x000C (0x0080 - 0x0074)
class UYBT_StaticDecoratorLevelDesignerGateNode : public UYBT_StaticDecoratorNode
{
public:
	unsigned char                                      m_gateScope;                                      		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_gateName;                                       		// 0x0078 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1945 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorLevelDesignerGateNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorLogNode
// 0x0030 (0x00A4 - 0x0074)
class UYBT_StaticDecoratorLogNode : public UYBT_StaticDecoratorNode
{
public:
	struct FStaticDecoratorLogNodeMessage              m_enter;                                          		// 0x0074 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FStaticDecoratorLogNodeMessage              m_active;                                         		// 0x0084 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FStaticDecoratorLogNodeMessage              m_leave;                                          		// 0x0094 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1946 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorLogNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorLoopNode
// 0x0008 (0x007C - 0x0074)
class UYBT_StaticDecoratorLoopNode : public UYBT_StaticDecoratorNode
{
public:
	unsigned char                                      m_loopMode;                                       		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_anyChildHandlesAnEvent : 1;                     		// 0x0078 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1947 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorLoopNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorModifyAimTimeNode
// 0x0008 (0x007C - 0x0074)
class UYBT_StaticDecoratorModifyAimTimeNode : public UYBT_StaticDecoratorNode
{
public:
	float                                              m_aimTimeEnter;                                   		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_aimTimeLeave;                                   		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1948 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorModifyAimTimeNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorModifyArsenalNode
// 0x001C (0x0090 - 0x0074)
class UYBT_StaticDecoratorModifyArsenalNode : public UYBT_StaticDecoratorNode
{
public:
	unsigned long                                      m_modifyOnEnter : 1;                              		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_modifyOnExit : 1;                               		// 0x0074 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	TArray< struct FYBT_ModifyArsenal >                m_modifyOnEnterArsenal;                           		// 0x0078 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FYBT_ModifyArsenal >                m_modifyOnExitArsenal;                            		// 0x0084 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1949 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorModifyArsenalNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorModifyPawnFlagNode
// 0x0008 (0x007C - 0x0074)
class UYBT_StaticDecoratorModifyPawnFlagNode : public UYBT_StaticDecoratorNode
{
public:
	unsigned char                                      m_playHitReactions;                               		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_canBeMeleedByAI;                                		// 0x0075 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_allowRagdollWhenMeleed;                         		// 0x0076 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_stumbleWhenHitByGrenade;                        		// 0x0077 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_showMeleeBloodEffect;                           		// 0x0078 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_canBeStunnedBySand;                             		// 0x0079 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_isStunned;                                      		// 0x007A (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_forcedStayInCover;                              		// 0x007B (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1950 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorModifyPawnFlagNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorNotNode
// 0x0000 (0x0074 - 0x0074)
class UYBT_StaticDecoratorNotNode : public UYBT_StaticDecoratorNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1951 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorNotNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorOverrideMovement
// 0x0008 (0x007C - 0x0074)
class UYBT_StaticDecoratorOverrideMovement : public UYBT_StaticDecoratorNode
{
public:
	unsigned char                                      m_movementOverride;                               		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_limit : 1;                                      		// 0x0078 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1952 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorOverrideMovement::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorOverrideSensorProperties
// 0x0001 (0x0075 - 0x0074)
class UYBT_StaticDecoratorOverrideSensorProperties : public UYBT_StaticDecoratorNode
{
public:
	unsigned char                                      m_sensorOverride;                                 		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1953 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorOverrideSensorProperties::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorRestrictControlsNode
// 0x0004 (0x0078 - 0x0074)
class UYBT_StaticDecoratorRestrictControlsNode : public UYBT_StaticDecoratorNode
{
public:
	struct FYS_ControlRestrictions                     m_controlRestrictions;                            		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1954 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorRestrictControlsNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorSetBehaviorStateNode
// 0x0001 (0x0075 - 0x0074)
class UYBT_StaticDecoratorSetBehaviorStateNode : public UYBT_StaticDecoratorNode
{
public:
	unsigned char                                      m_BehaviorState;                                  		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1955 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorSetBehaviorStateNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorSetDemiGodNode
// 0x0000 (0x0074 - 0x0074)
class UYBT_StaticDecoratorSetDemiGodNode : public UYBT_StaticDecoratorNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1956 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorSetDemiGodNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorSpeedModifierNode
// 0x0004 (0x0078 - 0x0074)
class UYBT_StaticDecoratorSpeedModifierNode : public UYBT_StaticDecoratorNode
{
public:
	float                                              m_speedMultiplier;                                		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1957 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorSpeedModifierNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorSuccessNode
// 0x0000 (0x0074 - 0x0074)
class UYBT_StaticDecoratorSuccessNode : public UYBT_StaticDecoratorNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1958 ];

		return pClassPointer;
	};

	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorSuccessNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorSwitchToSecondaryWeaponNode
// 0x0004 (0x0078 - 0x0074)
class UYBT_StaticDecoratorSwitchToSecondaryWeaponNode : public UYBT_StaticDecoratorNode
{
public:
	unsigned long                                      m_quickDraw : 1;                                  		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_onlySwitchBack : 1;                             		// 0x0074 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1959 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorSwitchToSecondaryWeaponNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticDecoratorUseAttackCommandAreaNode
// 0x0000 (0x0074 - 0x0074)
class UYBT_StaticDecoratorUseAttackCommandAreaNode : public UYBT_StaticDecoratorNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1960 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticDecoratorUseAttackCommandAreaNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticImpulseNode
// 0x0004 (0x0078 - 0x0074)
class UYBT_StaticImpulseNode : public UYBT_StaticSingleChildNode
{
public:
	float                                              m_delay;                                          		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1961 ];

		return pClassPointer;
	};

};

UClass* UYBT_StaticImpulseNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticImpulseEventNode
// 0x0014 (0x008C - 0x0078)
class UYBT_StaticImpulseEventNode : public UYBT_StaticImpulseNode
{
public:
	TArray< unsigned char >                            m_eventsUsed;                                     		// 0x0078 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_timeValid;                                      		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_clearEventIfValid : 1;                          		// 0x0088 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_includeEvenIfCleared : 1;                       		// 0x0088 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1962 ];

		return pClassPointer;
	};

	int GetClassVersion ( );
	struct FString GetToolTip ( );
};

UClass* UYBT_StaticImpulseEventNode::pClassPointer = NULL;

// Class SRGame.YBT_StaticNodeEditorData
// 0x00C8 (0x0104 - 0x003C)
class UYBT_StaticNodeEditorData : public UObject
{
public:
	class UYBT_BehaviorTreeAsset*                      m_containingAsset;                                		// 0x003C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bCollapse : 1;                                  		// 0x0040 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_isBreakpoint : 1;                               		// 0x0040 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_doNotDebug : 1;                                 		// 0x0040 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	struct FString                                     m_editorMenuCategory;                             		// 0x0044 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_nodeDisplayName;                                		// 0x0050 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYPropertyHelpersPath >             m_showPropertiesInNodeDisplay;                    		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_shownPropertiesValues;                          		// 0x0068 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UYBT_NodeComment*                            m_nodeCommentObjLong;                             		// 0x0074 (0x0004) [0x0000000000000000]              
	class UYBT_NodeComment*                            m_nodeCommentObjShort;                            		// 0x0078 (0x0004) [0x0000000000000000]              
	int                                                m_treeImageIndex;                                 		// 0x007C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_frameMaterialTemplate;                          		// 0x0080 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_frameMaterial;                                  		// 0x0084 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FTextureCoordinates                         m_textureCoodinates;                              		// 0x0088 (0x0010) [0x0000000000000000]              
	struct FVector2D                                   m_textureSize;                                    		// 0x0098 (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_connectorMaterialTemplate;                      		// 0x00A0 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_leftConnectorMaterial;                          		// 0x00A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UMaterialInstanceConstant* >         m_connectorMaterials;                             		// 0x00A8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FTextureCoordinates                         m_connectorCoodinates;                            		// 0x00B4 (0x0010) [0x0000000000000000]              
	struct FLinearColor                                m_nodeColor;                                      		// 0x00C4 (0x0010) [0x0000000000000002]              ( CPF_Const )
	struct FLinearColor                                m_nodeOutlineColor;                               		// 0x00D4 (0x0010) [0x0000000000000002]              ( CPF_Const )
	struct FLinearColor                                m_hatchColor;                                     		// 0x00E4 (0x0010) [0x0000000000000002]              ( CPF_Const )
	struct FLinearColor                                m_overlayColor;                                   		// 0x00F4 (0x0010) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1963 ];

		return pClassPointer;
	};

};

UClass* UYBT_StaticNodeEditorData::pClassPointer = NULL;

// Class SRGame.YSC_SelectionModifierBase
// 0x0010 (0x004C - 0x003C)
class UYSC_SelectionModifierBase : public UObject
{
public:
	unsigned char                                      m_priority;                                       		// 0x003C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_modifierComplexity;                             		// 0x003D (0x0001) [0x0000000000000000]              
	int                                                m_shouldHaveScore;                                		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_checkRealPos : 1;                               		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_spawnSubTasksMinPosCount;                       		// 0x0048 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1964 ];

		return pClassPointer;
	};

};

UClass* UYSC_SelectionModifierBase::pClassPointer = NULL;

// Class SRGame.YSCSM_CanAttack
// 0x0001 (0x004D - 0x004C)
class UYSCSM_CanAttack : public UYSC_SelectionModifierBase
{
public:
	unsigned char                                      m_entity;                                         		// 0x004C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1965 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_CanAttack::pClassPointer = NULL;

// Class SRGame.YSCSM_CanShortcutToGotoMarker
// 0x0004 (0x0050 - 0x004C)
class UYSCSM_CanShortcutToGotoMarker : public UYSC_SelectionModifierBase
{
public:
	unsigned long                                      m_invertResult : 1;                               		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1966 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_CanShortcutToGotoMarker::pClassPointer = NULL;

// Class SRGame.YSCSM_InRange
// 0x000C (0x0058 - 0x004C)
class UYSCSM_InRange : public UYSC_SelectionModifierBase
{
public:
	unsigned char                                      m_entity;                                         		// 0x004C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x004D (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minDist;                                        		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDist;                                        		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1967 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_InRange::pClassPointer = NULL;

// Class SRGame.YSCSM_InRange_WeightedValues
// 0x0014 (0x0060 - 0x004C)
class UYSCSM_InRange_WeightedValues : public UYSC_SelectionModifierBase
{
public:
	unsigned char                                      m_entity;                                         		// 0x004C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_position;                                       		// 0x004D (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minDist;                                        		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDist;                                        		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minShouldHaveScore;                             		// 0x0058 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxShouldHaveScore;                             		// 0x005C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1968 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_InRange_WeightedValues::pClassPointer = NULL;

// Class SRGame.YSCSM_InRangeToDangerousEnemies
// 0x0008 (0x0054 - 0x004C)
class UYSCSM_InRangeToDangerousEnemies : public UYSC_SelectionModifierBase
{
public:
	float                                              m_minDist;                                        		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDist;                                        		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1969 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_InRangeToDangerousEnemies::pClassPointer = NULL;

// Class SRGame.YSCSM_InRangeToEnemies
// 0x0008 (0x0054 - 0x004C)
class UYSCSM_InRangeToEnemies : public UYSC_SelectionModifierBase
{
public:
	float                                              m_minDist;                                        		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDist;                                        		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1970 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_InRangeToEnemies::pClassPointer = NULL;

// Class SRGame.YSCSM_InRangeToFriends
// 0x0008 (0x0054 - 0x004C)
class UYSCSM_InRangeToFriends : public UYSC_SelectionModifierBase
{
public:
	float                                              m_minDist;                                        		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDist;                                        		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1971 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_InRangeToFriends::pClassPointer = NULL;

// Class SRGame.YSCSM_InRangeToPlayer
// 0x0008 (0x0054 - 0x004C)
class UYSCSM_InRangeToPlayer : public UYSC_SelectionModifierBase
{
public:
	float                                              m_minDist;                                        		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDist;                                        		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1972 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_InRangeToPlayer::pClassPointer = NULL;

// Class SRGame.YSCSM_IsBadCover
// 0x0004 (0x0050 - 0x004C)
class UYSCSM_IsBadCover : public UYSC_SelectionModifierBase
{
public:
	unsigned long                                      m_invertResult : 1;                               		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1973 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsBadCover::pClassPointer = NULL;

// Class SRGame.YSCSM_IsCoveredAgainst
// 0x0001 (0x004D - 0x004C)
class UYSCSM_IsCoveredAgainst : public UYSC_SelectionModifierBase
{
public:
	unsigned char                                      m_entity;                                         		// 0x004C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1974 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsCoveredAgainst::pClassPointer = NULL;

// Class SRGame.YSCSM_IsCoveredAgainstDangerAreas
// 0x000C (0x0058 - 0x004C)
class UYSCSM_IsCoveredAgainstDangerAreas : public UYSC_SelectionModifierBase
{
public:
	int                                                m_numDangerAreasCoveredAgainst;                   		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDistanceFromCoverTargetToDanagerArea;        		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minDistanceToDangerArea;                        		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1975 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsCoveredAgainstDangerAreas::pClassPointer = NULL;

// Class SRGame.YSCSM_IsCoverType
// 0x0004 (0x0050 - 0x004C)
class UYSCSM_IsCoverType : public UYSC_SelectionModifierBase
{
public:
	unsigned long                                      m_crouchCover : 1;                                		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_standCover : 1;                                 		// 0x004C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_noCover : 1;                                    		// 0x004C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_peekOver : 1;                                   		// 0x004C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_peekLeft : 1;                                   		// 0x004C (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_peekRight : 1;                                  		// 0x004C (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_peekLeanOver : 1;                               		// 0x004C (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_noPeek : 1;                                     		// 0x004C (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1976 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsCoverType::pClassPointer = NULL;

// Class SRGame.YSCSM_IsCurrentPos
// 0x0000 (0x004C - 0x004C)
class UYSCSM_IsCurrentPos : public UYSC_SelectionModifierBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1977 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsCurrentPos::pClassPointer = NULL;

// Class SRGame.YSCSM_IsFlanking
// 0x0001 (0x004D - 0x004C)
class UYSCSM_IsFlanking : public UYSC_SelectionModifierBase
{
public:
	unsigned char                                      m_entity;                                         		// 0x004C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1978 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsFlanking::pClassPointer = NULL;

// Class SRGame.YSCSM_IsGrenadeBetween
// 0x0005 (0x0051 - 0x004C)
class UYSCSM_IsGrenadeBetween : public UYSC_SelectionModifierBase
{
public:
	unsigned long                                      m_invertResult : 1;                               		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      m_entity;                                         		// 0x0050 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1979 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsGrenadeBetween::pClassPointer = NULL;

// Class SRGame.YSCSM_IsInFront
// 0x0005 (0x0051 - 0x004C)
class UYSCSM_IsInFront : public UYSC_SelectionModifierBase
{
public:
	unsigned long                                      m_invertResult : 1;                               		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      m_entity;                                         		// 0x0050 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1980 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsInFront::pClassPointer = NULL;

// Class SRGame.YSCSM_IsNotInLineOfFire
// 0x0004 (0x0050 - 0x004C)
class UYSCSM_IsNotInLineOfFire : public UYSC_SelectionModifierBase
{
public:
	unsigned long                                      m_checkPlayer : 1;                                		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_checkSquadMates : 1;                            		// 0x004C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1981 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsNotInLineOfFire::pClassPointer = NULL;

// Class SRGame.YSCSM_IsSameCover
// 0x0001 (0x004D - 0x004C)
class UYSCSM_IsSameCover : public UYSC_SelectionModifierBase
{
public:
	unsigned char                                      m_entity;                                         		// 0x004C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1982 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsSameCover::pClassPointer = NULL;

// Class SRGame.YSCSM_IsSameHeight
// 0x000C (0x0058 - 0x004C)
class UYSCSM_IsSameHeight : public UYSC_SelectionModifierBase
{
public:
	unsigned char                                      m_entity;                                         		// 0x004C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxHeightDifference;                            		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_invert : 1;                                     		// 0x0054 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1983 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsSameHeight::pClassPointer = NULL;

// Class SRGame.YSCSM_IsStackingPosition
// 0x0004 (0x0050 - 0x004C)
class UYSCSM_IsStackingPosition : public UYSC_SelectionModifierBase
{
public:
	unsigned long                                      m_invertResult : 1;                               		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1984 ];

		return pClassPointer;
	};

};

UClass* UYSCSM_IsStackingPosition::pClassPointer = NULL;

// Class SRGame.YSC_TargetModifierBase
// 0x000C (0x0048 - 0x003C)
class UYSC_TargetModifierBase : public UObject
{
public:
	unsigned char                                      m_priority;                                       		// 0x003C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_shouldHaveScore;                                		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_checkRealPos : 1;                               		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1985 ];

		return pClassPointer;
	};

};

UClass* UYSC_TargetModifierBase::pClassPointer = NULL;

// Class SRGame.YSCTM_IsAttackableFromCurrentPosition
// 0x0000 (0x0048 - 0x0048)
class UYSCTM_IsAttackableFromCurrentPosition : public UYSC_TargetModifierBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1986 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsAttackableFromCurrentPosition::pClassPointer = NULL;

// Class SRGame.YSCTM_IsCoveredAgainst
// 0x0004 (0x004C - 0x0048)
class UYSCTM_IsCoveredAgainst : public UYSC_TargetModifierBase
{
public:
	unsigned long                                      m_invertResult : 1;                               		// 0x0048 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1987 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsCoveredAgainst::pClassPointer = NULL;

// Class SRGame.YSCTM_IsCurrentTarget
// 0x0004 (0x004C - 0x0048)
class UYSCTM_IsCurrentTarget : public UYSC_TargetModifierBase
{
public:
	unsigned long                                      m_useAttackTargets : 1;                           		// 0x0048 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1988 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsCurrentTarget::pClassPointer = NULL;

// Class SRGame.YSCTM_IsDistanceToEnemyCloserThan
// 0x0004 (0x004C - 0x0048)
class UYSCTM_IsDistanceToEnemyCloserThan : public UYSC_TargetModifierBase
{
public:
	float                                              m_distance;                                       		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1989 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsDistanceToEnemyCloserThan::pClassPointer = NULL;

// Class SRGame.YSCTM_IsEnemyStunned
// 0x0000 (0x0048 - 0x0048)
class UYSCTM_IsEnemyStunned : public UYSC_TargetModifierBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1990 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsEnemyStunned::pClassPointer = NULL;

// Class SRGame.YSCTM_IsEnemyType_Commando
// 0x0004 (0x004C - 0x0048)
class UYSCTM_IsEnemyType_Commando : public UYSC_TargetModifierBase
{
public:
	unsigned long                                      m_invertResult : 1;                               		// 0x0048 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1991 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsEnemyType_Commando::pClassPointer = NULL;

// Class SRGame.YSCTM_IsInRange
// 0x0014 (0x005C - 0x0048)
class UYSCTM_IsInRange : public UYSC_TargetModifierBase
{
public:
	unsigned char                                      m_ToEntity;                                       		// 0x0048 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_ToEntityPosition;                               		// 0x0049 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_checkMode;                                      		// 0x004A (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxHeightDifference;                            		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minDistance;                                    		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDistance;                                    		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bUseLinearScoreInterpolation : 1;               		// 0x0058 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bPreferNearestTarget : 1;                       		// 0x0058 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1992 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsInRange::pClassPointer = NULL;

// Class SRGame.YSCTM_IsPlayerTarget
// 0x0004 (0x004C - 0x0048)
class UYSCTM_IsPlayerTarget : public UYSC_TargetModifierBase
{
public:
	unsigned long                                      m_invertResult : 1;                               		// 0x0048 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1993 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsPlayerTarget::pClassPointer = NULL;

// Class SRGame.YSCTM_IsSameHeight
// 0x0008 (0x0050 - 0x0048)
class UYSCTM_IsSameHeight : public UYSC_TargetModifierBase
{
public:
	unsigned long                                      m_invertResult : 1;                               		// 0x0048 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_maxHeightDifference;                            		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1994 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsSameHeight::pClassPointer = NULL;

// Class SRGame.YSCTM_IsSquadCommandAttackTarget
// 0x0004 (0x004C - 0x0048)
class UYSCTM_IsSquadCommandAttackTarget : public UYSC_TargetModifierBase
{
public:
	unsigned long                                      m_onlySureTargets : 1;                            		// 0x0048 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1995 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsSquadCommandAttackTarget::pClassPointer = NULL;

// Class SRGame.YSCTM_IsSureTarget
// 0x0000 (0x0048 - 0x0048)
class UYSCTM_IsSureTarget : public UYSC_TargetModifierBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1996 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsSureTarget::pClassPointer = NULL;

// Class SRGame.YSCTM_IsTargetPlayer
// 0x0000 (0x0048 - 0x0048)
class UYSCTM_IsTargetPlayer : public UYSC_TargetModifierBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1997 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsTargetPlayer::pClassPointer = NULL;

// Class SRGame.YSCTM_IsTargetShootingAtMe
// 0x000D (0x0055 - 0x0048)
class UYSCTM_IsTargetShootingAtMe : public UYSC_TargetModifierBase
{
public:
	float                                              m_damageTreshold;                                 		// 0x0048 (0x0004) [0x0000000000000000]              
	float                                              m_damageMaxAge;                                   		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minMidDistanceImpactCount;                      		// 0x0050 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_modifierMode;                                   		// 0x0054 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1998 ];

		return pClassPointer;
	};

};

UClass* UYSCTM_IsTargetShootingAtMe::pClassPointer = NULL;

// Class SRGame.YSeqAct_AbortBehaviorTree
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_AbortBehaviorTree : public USequenceAction
{
public:
	unsigned long                                      m_runDefaultBehavior : 1;                         		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1999 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_AbortBehaviorTree::pClassPointer = NULL;

// Class SRGame.YSeqAct_AbstractBehaviorTreeRunner
// 0x0004 (0x0108 - 0x0104)
class UYSeqAct_AbstractBehaviorTreeRunner : public USeqAct_Latent
{
public:
	unsigned long                                      m_dontCallFinished : 1;                           		// 0x0104 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_behaviorTreeIsRunning : 1;                      		// 0x0104 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2000 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_AbstractBehaviorTreeRunner::pClassPointer = NULL;

// Class SRGame.YSeqAct_GotoPosAbstractBase
// 0x0006 (0x010E - 0x0108)
class UYSeqAct_GotoPosAbstractBase : public UYSeqAct_AbstractBehaviorTreeRunner
{
public:
	unsigned long                                      m_abortBehaviorWhenTargetIsDetected : 1;          		// 0x0108 (0x0004) [0x0000000020000000] [0x00000001] ( CPF_Deprecated )
	unsigned long                                      m_abortOnEnemySeenOrHeard : 1;                    		// 0x0108 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_abortOnReactionToGrenadeOrStun : 1;             		// 0x0108 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_orientLikePosition : 1;                         		// 0x0108 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_skipStopAnimation : 1;                          		// 0x0108 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_aimToFront : 1;                                 		// 0x0108 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_mayTurnBodyForLookAimAt : 1;                    		// 0x0108 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_onlyLookAtTarget : 1;                           		// 0x0108 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_enableCrouching : 1;                            		// 0x0108 (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      m_enterCover : 1;                                 		// 0x0108 (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_runDefaultBehaviorWhenFinished : 1;             		// 0x0108 (0x0004) [0x0000000000000001] [0x00000400] ( CPF_Edit )
	unsigned char                                      m_overrideMovement;                               		// 0x010C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_kismetBehaviorState;                            		// 0x010D (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2001 ];

		return pClassPointer;
	};

	void AbortFor ( class AActor* latentActor );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_GotoPosAbstractBase::pClassPointer = NULL;

// Class SRGame.YSeqAct_EnterTurret
// 0x0013 (0x0121 - 0x010E)
class UYSeqAct_EnterTurret : public UYSeqAct_GotoPosAbstractBase
{
public:
	struct FYS_AssetReference                          m_behavior;                                       		// 0x0110 (0x000C) [0x0000000000000000]              
	class AYTurretActor*                               m_turret;                                         		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_enterTurretState;                               		// 0x0120 (0x0001) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2002 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_EnterTurret::pClassPointer = NULL;

// Class SRGame.YSeqAct_GotoPos
// 0x0000 (0x010E - 0x010E)
class UYSeqAct_GotoPos : public UYSeqAct_GotoPosAbstractBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2003 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_GotoPos::pClassPointer = NULL;

// Class SRGame.YSeqAct_GoToPosForced
// 0x000E (0x011C - 0x010E)
class UYSeqAct_GoToPosForced : public UYSeqAct_GotoPosAbstractBase
{
public:
	float                                              m_blockRadius;                                    		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_timeOut;                                        		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_stayInCover : 1;                                		// 0x0118 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2004 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_GoToPosForced::pClassPointer = NULL;

// Class SRGame.YSeqAct_Patrol
// 0x0000 (0x010E - 0x010E)
class UYSeqAct_Patrol : public UYSeqAct_GotoPosAbstractBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2005 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_Patrol::pClassPointer = NULL;

// Class SRGame.YSeqAct_StandLookAimAt
// 0x000A (0x0118 - 0x010E)
class UYSeqAct_StandLookAimAt : public UYSeqAct_GotoPosAbstractBase
{
public:
	float                                              m_minTime;                                        		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxTime;                                        		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2006 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_StandLookAimAt::pClassPointer = NULL;

// Class SRGame.YSeqAct_AI_PlayCustomAnimation
// 0x0004 (0x011C - 0x0118)
class UYSeqAct_AI_PlayCustomAnimation : public UYSeqAct_StandLookAimAt
{
public:
	class UYAI_SimpleCustomAnimation*                  m_customAnimation;                                		// 0x0118 (0x0004) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2007 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_AI_PlayCustomAnimation::pClassPointer = NULL;

// Class SRGame.YSeqAct_RunBehaviorTree
// 0x0008 (0x0110 - 0x0108)
class UYSeqAct_RunBehaviorTree : public UYSeqAct_AbstractBehaviorTreeRunner
{
public:
	class UYBT_BehaviorTreeAsset*                      m_behaviorTree;                                   		// 0x0108 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_abortOnException : 1;                           		// 0x010C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_runDefaultBehaviorWhenFinished : 1;             		// 0x010C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2008 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_RunBehaviorTree::pClassPointer = NULL;

// Class SRGame.YSeqAct_RunBehaviorTreeScripted
// 0x0010 (0x0118 - 0x0108)
class UYSeqAct_RunBehaviorTreeScripted : public UYSeqAct_AbstractBehaviorTreeRunner
{
public:
	struct FYS_AssetReference                          m_behavior;                                       		// 0x0108 (0x000C) [0x0000000000000000]              
	unsigned long                                      m_runDefaultBehaviorWhenFinished : 1;             		// 0x0114 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2009 ];

		return pClassPointer;
	};

	class AYAIFakeTarget* GetFakeTarget ( class UObject* Obj );
	class AYAICtrl_Humanoid* GetAIController ( class UObject* Obj );
	class AYGamePawn* GetGamePawn ( class UObject* Obj );
	void OnActivated ( class AYAIController* ctrl );
	void SetBehaviorFilters ( TArray< unsigned char >* filters );
	bool SetKismetTimer ( unsigned char timerid, struct FYBT_Timer* Timer );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_RunBehaviorTreeScripted::pClassPointer = NULL;

// Class SRGame.YSeqAct_ClearOverwrittenShootSet
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ClearOverwrittenShootSet : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2010 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ClearOverwrittenShootSet::pClassPointer = NULL;

// Class SRGame.YSeqAct_OverwriteShootSet
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_OverwriteShootSet : public USequenceAction
{
public:
	TArray< class UYBT_ShootSet* >                     m_overwrite;                                      		// 0x00F4 (0x000C) [0x0000000000500001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2011 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_OverwriteShootSet::pClassPointer = NULL;

// Class SRGame.YSeqAct_RunBehaviorTree_NonLatent
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_RunBehaviorTree_NonLatent : public USequenceAction
{
public:
	class UYBT_BehaviorTreeAsset*                      m_behaviorTree;                                   		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_abortOnException : 1;                           		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_runDefaultBehaviorWhenFinished : 1;             		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2012 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_RunBehaviorTree_NonLatent::pClassPointer = NULL;

// Class SRGame.YSeqAct_RunDefaultBehavior
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_RunDefaultBehavior : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2013 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_RunDefaultBehavior::pClassPointer = NULL;

// Class SRGame.YSeqAct_SendBehaviorTreeEvent
// 0x0002 (0x00F6 - 0x00F4)
class UYSeqAct_SendBehaviorTreeEvent : public USequenceAction
{
public:
	unsigned char                                      m_eventToSend;                                    		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_recvievingEntity;                               		// 0x00F5 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2014 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SendBehaviorTreeEvent::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetUserData
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_SetUserData : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2015 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SetUserData::pClassPointer = NULL;

// Class SRGame.YSeqAct_StandLookAimAt_NonLatent
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_StandLookAimAt_NonLatent : public USequenceAction
{
public:
	unsigned long                                      m_abortBehaviorWhenTargetIsDetected : 1;          		// 0x00F4 (0x0004) [0x0000000020000000] [0x00000001] ( CPF_Deprecated )
	unsigned long                                      m_abortOnEnemySeenOrHeard : 1;                    		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_abortOnReactionToGrenadeOrStun : 1;             		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_orientLikePosition : 1;                         		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_aimToFront : 1;                                 		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_mayTurnBodyForLookAimAt : 1;                    		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_onlyLookAtTarget : 1;                           		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_enableCrouching : 1;                            		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_enterCover : 1;                                 		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      m_runDefaultBehaviorWhenFinished : 1;             		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned char                                      m_overrideMovement;                               		// 0x00F8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_kismetBehaviorState;                            		// 0x00F9 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minTime;                                        		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxTime;                                        		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2016 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_StandLookAimAt_NonLatent::pClassPointer = NULL;

// Class SRGame.YSeqAct_StartFlanking
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_StartFlanking : public USequenceAction
{
public:
	unsigned char                                      m_recvievingEntity;                               		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UObject* >                           m_flankingFightAreas;                             		// 0x00F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2017 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_StartFlanking::pClassPointer = NULL;

// Class SRGame.YArsenalManager
// 0x0720 (0x0918 - 0x01F8)
class AYArsenalManager : public AActor
{
public:
	struct FName                                       m_equipSocketName;                                		// 0x01F8 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FName                                       m_equipSocketNameMirrored;                        		// 0x0200 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_isWeaponSwitching : 1;                          		// 0x0208 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_forcedWeaponSwitch : 1;                         		// 0x0208 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_initialReplicationFinished : 1;                 		// 0x0208 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_isTogglingScndMode : 1;                         		// 0x0208 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      m_allowSwitchToEmptyWeapon : 1;                   		// 0x0208 (0x0004) [0x0000000000004003] [0x00000010] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_autoSwitchFromEmptyWeapon : 1;                  		// 0x0208 (0x0004) [0x0000000000004003] [0x00000020] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_autoReloadEmptyWeapon : 1;                      		// 0x0208 (0x0004) [0x0000000000004003] [0x00000040] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_disableSwitchWeapon : 1;                        		// 0x0208 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_allowGrenades : 1;                              		// 0x0208 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_grenadeTutorialShown : 1;                       		// 0x0208 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_grenadeRaisingAnimFinished : 1;                 		// 0x0208 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_isWeaponPutAwayForAnim : 1;                     		// 0x0208 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_reequipWeaponOnAnimSkip : 1;                    		// 0x0208 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_grenadeThrowingStarted : 1;                     		// 0x0208 (0x0004) [0x0000000000000020] [0x00002000] ( CPF_Net )
	unsigned long                                      m_grenadeThrowingSkipped : 1;                     		// 0x0208 (0x0004) [0x0000000000000020] [0x00004000] ( CPF_Net )
	unsigned long                                      m_grenadeThrowingInterrupted : 1;                 		// 0x0208 (0x0004) [0x0000000000000020] [0x00008000] ( CPF_Net )
	unsigned long                                      m_grenadeThrowingFinished : 1;                    		// 0x0208 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_grenadeAnimSetsAdded : 1;                       		// 0x0208 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_pickingUpAmmo : 1;                              		// 0x0208 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_swappingWeaponPickup : 1;                       		// 0x0208 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      m_pawnAnimIsMirrored : 1;                         		// 0x0208 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_recoilDistortionActive : 1;                     		// 0x0208 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_recoilDistortionStarted : 1;                    		// 0x0208 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      m_recoilResetStarted : 1;                         		// 0x0208 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_infiniteAmmo : 1;                               		// 0x0208 (0x0004) [0x0000000000000020] [0x01000000] ( CPF_Net )
	unsigned long                                      m_infiniteGrenades : 1;                           		// 0x0208 (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      m_fakeAmmoConsumption : 1;                        		// 0x0208 (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      m_bDelayedInitialization : 1;                     		// 0x0208 (0x0004) [0x0000000000004000] [0x08000000] ( CPF_Config )
	unsigned long                                      m_performDeathDBNOSpawning : 1;                   		// 0x0208 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      m_bShouldUpdateGrenadesInHud : 1;                 		// 0x0208 (0x0004) [0x0000000000002000] [0x20000000] ( CPF_Transient )
	unsigned long                                      m_configTypeCoopLoaded : 1;                       		// 0x0208 (0x0004) [0x0000000000002000] [0x40000000] ( CPF_Transient )
	struct FString                                     m_weaponClassNames[ 0x41 ];                       		// 0x020C (0x030C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UMaterialInterface*                          m_weaponPickupMaterial[ 0x41 ];                   		// 0x0518 (0x0104) [0x0000000000000000]              
	class UMaterialInterface*                          m_grenadePickupMaterial[ 0x10 ];                  		// 0x061C (0x0040) [0x0000000000000000]              
	class UMaterialInterface*                          m_ammoPickupMaterial;                             		// 0x065C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_grenadeClasses[ 0x10 ];                         		// 0x0660 (0x0040) [0x0000000000000000]              
	TArray< class UClass* >                            m_weaponClasses;                                  		// 0x06A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AYGamePawn*                                  m_pawn;                                           		// 0x06AC (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_allowedWeaponCategories[ 0x4 ];                 		// 0x06B0 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	unsigned char                                      m_currentCategoryWeapons[ 0x4 ];                  		// 0x06B4 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_postureBeforeEquip;                             		// 0x06B8 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentGrenadeTypes[ 0x8 ];                     		// 0x06B9 (0x0008) [0x0000000000000000]              
	unsigned char                                      m_currentWeaponDetachReason;                      		// 0x06C1 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_hasExplosiveWeapon;                             		// 0x06C2 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_configTypeLoaded;                               		// 0x06C3 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class AYWeapon*                                    m_currentWeapon;                                  		// 0x06C4 (0x0004) [0x0000000000000000]              
	class AYWeapon*                                    m_currentActiveWeapon;                            		// 0x06C8 (0x0004) [0x0000000000000000]              
	class AYWeapon*                                    m_previousWeapon;                                 		// 0x06CC (0x0004) [0x0000000000000000]              
	int                                                m_replicateTogglingScndModeCounter;               		// 0x06D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       m_rifleHolsterSocket;                             		// 0x06D4 (0x0008) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FName                                       m_pistolHolsterSocket;                            		// 0x06DC (0x0008) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	class AYWeapon*                                    m_holsteredWeaponToHide;                          		// 0x06E4 (0x0004) [0x0000000000000000]              
	int                                                m_currentGrenadeCounts[ 0x8 ];                    		// 0x06E8 (0x0020) [0x0000000000000000]              
	class AYProj_Physical*                             m_currentGrenadeDefObj;                           		// 0x0708 (0x0004) [0x0000000000000000]              
	int                                                m_equippedGrenadeCount;                           		// 0x070C (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< struct FYS_ExecutionGrenadeLootProbability > m_executionGrenadeProbabilities;                  		// 0x0710 (0x000C) [0x0000000000444002]              ( CPF_Const | CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	int                                                m_startGrenadeCount;                              		// 0x071C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_maxGrenadeCount;                                		// 0x0720 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class USkeletalMeshComponent*                      m_grenadeMeshComp;                                		// 0x0724 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class USkeletalMeshComponent*                      m_weaponAnimSubMeshComp;                          		// 0x0728 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class AYWeapon*                                    m_grenadeThrowingWeapon;                          		// 0x072C (0x0004) [0x0000000000000000]              
	struct FString                                     m_grenadeFontStrings[ 0x10 ];                     		// 0x0730 (0x00C0) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_iconFontName;                                   		// 0x07F0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AYWeapon_Explosive*                          m_explosiveWeapon;                                		// 0x07FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYWeapon_Explosive*                          m_oldExplosiveWeapon;                             		// 0x0800 (0x0004) [0x0000000000000000]              
	class AYPickupActor*                               m_currentPickup;                                  		// 0x0804 (0x0004) [0x0000000000000000]              
	struct FString                                     m_currentPickupMessage;                           		// 0x0808 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AYPickupActor*                               m_currentHighlightedPickup;                       		// 0x0814 (0x0004) [0x0000000000000000]              
	class USoundCue*                                   m_autoPickupAmmoSound;                            		// 0x0818 (0x0004) [0x0000000000000000]              
	float                                              m_accuracy;                                       		// 0x081C (0x0004) [0x0000000000000000]              
	float                                              m_oldAccuracy;                                    		// 0x0820 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_accuracyLastViewRot;                            		// 0x0824 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_RecoilCurveValueSet >           m_recoilCurveValueSets;                           		// 0x0830 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FYS_OffsetRotationCurve                     m_recoilDistortionInterp;                         		// 0x083C (0x0034) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             m_recoilDoneCallbackFunction;                     		// 0x0870 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_ZoomSounds                              m_zoomSounds;                                     		// 0x087C (0x0010) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_infiniteAmmoRefCount;                           		// 0x088C (0x0004) [0x0000000000000000]              
	float                                              m_lastTickingTime;                                		// 0x0890 (0x0004) [0x0000000000000000]              
	int                                                m_ticker;                                         		// 0x0894 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_highlightingMaterial;                           		// 0x0898 (0x0004) [0x0000000000000000]              
	TArray< struct FYS_DelayedWeaponToAdd >            m_weaponsToAdd;                                   		// 0x089C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class AYWeapon*                                    m_weapons[ 0x3 ];                                 		// 0x08A8 (0x000C) [0x0000000000000020]              ( CPF_Net )
	class AYWeapon*                                    m_cutsceneWeapon;                                 		// 0x08B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYWeapon*                                    m_activeWeaponBeforeCutscene;                     		// 0x08B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_PickupSpawnInfo                         m_savedPickupSpawnInfo;                           		// 0x08BC (0x0044) [0x0000000000000000]              
	float                                              m_savedWeaponDamage;                              		// 0x0900 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_savedWeaponInterpRange;                         		// 0x0904 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             __RecoilFinished__Delegate;                       		// 0x090C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2018 ];

		return pClassPointer;
	};

	void Client_UpdateCurrentPickup ( class AYPickupActor* currentPickup );
	void Server_UpdateCurrentPickup ( class AYPickupActor* currentPickup );
	void Network_UpdateCurrentPickup ( class AYPickupActor* currentPickup );
	void ServerSetGrenadeThrowingInturrupted ( unsigned long bInturrupted );
	void SetGrenadeThrowingInturrupted ( unsigned long bInturrupted );
	bool AreAllWeaponsOutOfPrimaryAmmo ( );
	bool IsInitialReplicationFinished ( );
	bool IsInitialized ( );
	void CheckWeaponAttachmentStatus ( );
	void AdjustWeaponDueToMirror ( unsigned long mirrored );
	void Destroyed ( );
	void OnEndThrowGrenade ( );
	void SpawnGrenade ( );
	void showGrenade ( unsigned long show );
	struct FName GetGrenadeHoldingSocket ( );
	void SkipGrenadeThrow ( );
	void SkipWeaponGrenadeState ( );
	bool IsThrowingGrenade ( );
	bool FinishGrenadeThrow ( );
	void OnDetachWeaponByAnimNotify ( struct FName SocketName, struct FName ifMirrored, unsigned long reequipOnSkip, unsigned char Reason );
	void OnReequipWeaponAfterGrenadeThrow ( );
	void OnReequipWeaponByAnimNotify ( unsigned char Reason );
	void RemoveWeaponDetachReason ( unsigned char Reason );
	void SetWeaponDetachReason ( unsigned char Reason );
	void OnShowGrenade ( unsigned long shown );
	void OnEndPutAwayWeapon4Throw ( unsigned long alsoShowGrenade );
	void PutWeaponAwayForThrowInCover ( );
	void RemAdditionalGrenadeAnimSet ( );
	void AddAdditionalGrenadeAnimSet ( );
	bool PrepareGrenadeLongThrow ( unsigned long immediateThrow );
	class AYProj_Physical* GetCurrentGrenadeDefObj ( int Index, class UYProjData_Mesh** meshData );
	unsigned char GiveGrenade ( struct FString grenadeTypeStr );
	void ReplaceGrenadeTypeAtStart ( int Idx, unsigned char grndType, int Count );
	bool HasAnyGrenades ( );
	void GetGrenadeTypesAndCount ( TArray< unsigned char >* typesArray, TArray< int >* countArray );
	int FindCorrectGrenadeInsertionIndex ( unsigned char newGrenadeType, int LowestIndex, int HighestIndex, int EmptySlot );
	void FindLowestAndHighestGrenadeType ( int EmptySlot, int* Lowest, int* Highest );
	void ConditionalShowGrenadeTurorial ( );
	void InsertNewGrenade ( unsigned char newGrenadeType, int newGrenadeCount, int EmptySlot );
	void ServerPickupGrenades ( unsigned char newGrenadeType, int newGrenadeCount );
	void UpdateGrenadeMeshComponent ( class UYProjData_Mesh* meshData );
	void ToggleGrenade ( int Direction );
	void ServerPrevGrenades ( );
	void ServerToggleGrenades ( );
	bool CanToggleGrenades ( );
	void SetAIGrenadeType ( class AYProj_Physical* defObj, class UYProjData_Mesh* meshData );
	void UpdateCurrentGrenade ( );
	unsigned char GetEquippedGrenadeType ( );
	void InitGrenades ( );
	void ShowHideScndMesh ( unsigned char submeshType, unsigned long showHide, unsigned long forced );
	void ShowHideWeaponSubmesh ( unsigned char submeshType, unsigned char evtType, unsigned long byNotify );
	void InitWeaponAnimSubmesh ( );
	void OnFinishTacticalReload ( );
	int GetWeaponAmmoByCategory ( unsigned char cat );
	bool CanSwitchToCategory ( unsigned char cat );
	int GetCategoryIndex ( unsigned char cat );
	void UpdatePlayerAccuracy ( float DeltaTime );
	void Tick ( float DeltaTime );
	void TickNative ( float DeltaTime );
	void RecoilDistortionDone ( unsigned long finished );
	void InitRecoilCurveData ( int Idx );
	bool ProcessViewRotation ( float DeltaTime, class AYCamera* playerCam, struct FRotator* out_DeltaRot );
	void AddWeaponToAI ( class AYWeapon* Weapon );
	void AddWeaponsToAI ( );
	bool GetMuzzleLocation ( struct FVector* Loc, struct FRotator* Rot );
	void GetFiringLocations ( struct FVector* StartFireLoc, struct FVector* aimAtPosition );
	void FakeFireEffects ( );
	void RestoreDamageAndSpread ( );
	void RestoreFireBursts ( );
	void RestoreAutoFire ( );
	void RestoreSingleFire ( );
	void ServerStopFireSalvo ( float Duration );
	void ServerStartFireSalvo ( unsigned char refireType, float Duration, unsigned long zeroDamageAndSpread );
	void ClientStartStopFire ( unsigned char FiringMode, unsigned long Start, unsigned long byRelease );
	void ServerReleaseFireFlag ( unsigned char FiringMode );
	void ServerStopFire ( unsigned char FiringMode, unsigned long byRelease );
	void ServerStartFire ( unsigned char FiringMode, unsigned long setBlindFireFlag );
	void StopFire ( unsigned char FiringMode, unsigned long byRelease );
	void StartFire ( unsigned char FiringMode, unsigned char* bTakeUpWeapon );
	void ServerFillUpGrenades ( );
	int GetGrenadeSlot ( unsigned char grenadeType, unsigned char* newGrenadeType );
	int ServerAddGrenadesFromPickup ( class AYPickup_Grenade* Pickup );
	void SwitchToGrenadeType ( unsigned char newGrenadeType );
	int ServerAddGrenades ( unsigned char grenadeType, int Amount );
	bool CanAddGrenadesOfType ( unsigned char grndType, int* grndIdx );
	bool CanAddGrenades ( );
	bool ServerDoPickup ( );
	void ServerCallPickup ( );
	bool ClientDoPickup ( );
	bool HaveGrenadesEmptySlot ( );
	void UpdatePickups ( );
	struct FString GetGrenadeIconMarkup ( unsigned char grenadeType );
	void LootAmmoFromExecuted ( unsigned long alsoAddGrenades, float grenadeChance );
	bool CanPickupAmmo ( );
	bool CanPickupGrenades ( class AYPickup_Grenade* Pickup );
	bool CanPickupWeapon ( class AYPickup_Weapon* Pickup );
	bool AddAmmoFromPickup ( class AYPickup_Ammo* Pickup );
	bool AddAmmoFromWeaponPickup ( class AYPickup_Weapon* Pickup );
	bool CanAddAmmoFromWeaponPickup ( class AYPickup_Weapon* Pickup, int* weaponIndex, int* SecondaryWeapon );
	int GetMaxGrenades ( );
	int GetMaxWeapons ( );
	bool IsCategoryFree ( unsigned char checkCat );
	class AYWeapon* FindWeaponInAresenal ( class AYWeapon* wpArch );
	int GetCurrentWeaponCount ( );
	void GetCurrentWeapons ( TArray< class AYWeapon* >* wpArray );
	bool IsInArsenal ( class AYWeapon* wpArch );
	bool IsGrndInfinite ( );
	bool IsAmmoInfinite ( );
	class AWeapon* GiveWeapon ( struct FString WeaponClassStr );
	void AllWeapons ( );
	void EnableInfiniteAmmo ( unsigned long Enable );
	void FakeAmmo ( );
	void EmptyMagazineForCurrentWeapon ( unsigned long onlyOneBullet );
	void InfiniteGrenades ( );
	void AllAmmo ( );
	bool IsScoped ( );
	void SetSecondaryWeaponActive ( class AYWeapon* wp );
	void SwitchUnequipSlotState ( class AYWeapon* wp, unsigned long toHolster );
	struct FName FindEquipHookName ( class AYWeapon* wp, unsigned long mirrored );
	int GetBestHookIndex ( class AYWeapon* wp, struct FName* newHookName );
	void EndSwitchWeapon ( );
	void SetWeaponActive ( class AYWeapon* weaponToActivate );
	void OnEndEquipScndMode ( );
	void SkipEquipScndMode ( );
	void ClientToggleScndMode ( );
	void ServerToggleScndMode ( );
	void EquipWeapon ( class AYWeapon* Wpn );
	void UnequipWeapon ( class AYWeapon* Wpn, unsigned long noReplacement );
	void RemoveAdditionalAnimSets ( class AYWeapon* Weapon );
	class AYWeapon* GetWeaponToEquip ( );
	void SwitchWeaponsInternal ( );
	void GrabWeapon ( class AYWeapon* wp );
	void ReequipCurrentWeapon ( );
	void PutAwayWeapon ( );
	void HookUpWeapon ( class AYWeapon* wpnToHook );
	void HolsterAnimCallback ( );
	void StartSwitchWeapon ( unsigned long forced );
	void ClientUpdateWeaponStatus ( );
	class UClass* SwitchWeapon ( class UClass* newWeaponClass, unsigned long forced );
	void RemoveTurretWeaponUponDeath ( class AYWeapon* newWpn, class AYWeapon* wpnToRemove );
	bool ServerChangeWeapon ( class AYWeapon* Wpn, unsigned long forced );
	bool ServerChangeWeaponByCatIdx ( int newCatIndex );
	bool ServerChangeWeaponByCategory ( unsigned char newCategory );
	bool CanSwitchWeapon ( );
	bool SwitchToNonEmptyWeapon ( );
	bool ServerCircleWeapon ( unsigned long upDown, unsigned long forced );
	bool CanCircleWeapon ( unsigned long upDown, class UAnimSet** switchAnimSet );
	void OnEndReplicatedReloadWeaponCleanUp ( );
	void ServerStopReloadProcess ( );
	bool StopReloadProcess ( );
	void ServerStopSingleShellReload ( );
	void StopSingleShellReload ( );
	void ClientReloadWeapon ( );
	bool ServerReloadWeapon ( );
	bool CanReload ( );
	void ConsumeGrenade ( );
	bool HasGrenades ( );
	bool CanConfigWeapon ( );
	void PlayZoomSound ( unsigned long zoomIn );
	bool CanZoom ( );
	bool MayFireWeapon ( unsigned long secondary, unsigned char* blindfireOnly, unsigned char* shouldReload );
	float GetRefireInterval ( );
	void GetFiringSpecs ( unsigned char* refireType, unsigned char* onRelease );
	void DrawHUD ( class AYHUD* H );
	bool GetWeaponByCategory ( unsigned char testCategory, class AYWeapon** wp );
	bool IsAllowedCategory ( unsigned char cat );
	class AYWeapon* GetUnequippedWeapon ( );
	class AYWeapon* GetWeapon ( );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void ClientAddWeapon ( class AYWeapon* wp );
	void ClientUpdateWeaponArsenal ( );
	void ServerDropGrenadeIfRaised ( );
	void LineUpGrenades ( );
	void RemoveCurrentGrenadeTypeAndSwitchToNext ( );
	void SetEquippedGrenadeCount ( int Count );
	int GetMaxGrenadeCount ( );
	int GetEquippedGrenadeCount ( );
	void SetCurrentGrenadeCount ( int Index, int grenadeCount );
	void SetCurrentGrenadeType ( int Index, unsigned char grenadeType );
	void RemoveGrenade ( unsigned char grndType );
	void TossWeapon ( class AYPickup_Weapon* weaponPickup, class AYWeapon* Wpn );
	void ServerDropWeapon ( class AYWeapon* Weapon, class AYPickupActor* oldPickup );
	class AYPickup_WeaponSpawnable* CreatePickupActor ( unsigned long forcePersistentSpawning );
	void ServerTossPersistentWeapon ( struct FVector meshLoc, struct FRotator meshRot, float ammoCountModifier );
	void ServerTossBestWeapon ( );
	void ServerRemoveCutsceneWeapon ( class AYWeapon* Wpn );
	class AYWeapon* ServerAddCutsceneWeapon ( class UClass* WeaponClass );
	void ServerRemoveWeapon ( class AYWeapon* Wpn );
	class AYWeapon* GetFirstWeapon ( );
	void ServerClearGrenades ( );
	void ServerClearWeapons ( );
	class AYWeapon* ServerRestoreWeapon ( class UClass* WeaponClass, int AmmoInMag, int AmmoInReserve );
	class AYWeapon* ServerAddWeapon ( class UClass* WeaponClass, class AYPickup_Weapon* Pickup, class AYTurretActor* turretActor );
	void RemoveWeapon ( class AYWeapon* wpnToRemove );
	void InitializeRecoilCurves ( );
	void ReaddCurrentWeaponAnimSets ( );
	void CheckPawnsSilhouetteMaterial ( );
	void PostAnimInit ( );
	void PawnPossessedBy ( class AController* C );
	void ServerInitWeaponAmmo ( class AYWeapon* NewWeapon, int startAmmo, int startMagAmmo );
	void DelayedAddWeaponToArsenal ( struct FYS_DelayedWeaponToAdd weaponDefinition );
	class AYWeapon* ImmediateAddWeaponToArsenal ( class UClass* newWeaponClass, unsigned long equipRightAway, class AYTurretActor* turretActor, class UYWeaponDataDispatcher* dataDispatcher );
	void AddWeaponToArsenal ( class UClass* newWeaponClass, unsigned long equipRightAway, int StartMag, int startAmmo, class AYTurretActor* turretActor );
	void AddWeaponsForMultiplayer ( );
	void ServerInit ( class AYGamePawn* NewPawn );
	class AYWeapon* FindWeaponByEnum ( unsigned char classIdx );
	bool IsWeaponInList ( class AYWeapon* Wpn );
	void RemWpnFromList ( class AYWeapon* Wpn );
	void AddWpnToList ( class AYWeapon* Wpn );
	void OverloadWeaponAnims ( class AYGamePawn* Pawn, class AYWeapon* Weapon );
	void RecoilFinished ( unsigned long finished );
	void ReplicatedEvent ( struct FName VarName );
	void GetGrenadeEnumStrings ( TArray< struct FString >* enumStrings );
	void GetProjectileSpecs ( class UClass* projClass, class AYProj_Physical** grenadeDefObj, class UYProjData_Mesh** meshData, class UYProjData_GraphicsFX** gfxData, class UYProjData_SoundFX** sfxData );
	class UMaterialInterface* StaticGetAmmoPickupMaterial ( );
	class UMaterialInterface* StaticGetGrenadePickupMaterial ( unsigned char grEnum );
	class UMaterialInterface* StaticGetWeaponPickupMaterial ( unsigned char wpEnum );
	class UClass* StaticGetWeaponClassByName ( struct FString wpClassName );
	class UClass* StaticGetWeaponClass ( unsigned char wpEnum );
	class UYWeaponData_Mesh* GetWeaponMeshData ( class UClass* wpClass );
	class USkeletalMesh* GetWeaponMeshTemplate ( class UClass* wpClass );
	class AYWeapon* GetWeaponArchetype ( class UClass* wpClass, class AYWeapon* wpArch );
	void AdjustMeshPropertiesToPawnMesh ( class USkeletalMeshComponent* compToAdjust );
	void WeaponIterator ( class AYWeapon** NextWeapon );
};

UClass* AYArsenalManager::pClassPointer = NULL;

// Class SRGame.YArsMgr_Standard
// 0x0000 (0x0918 - 0x0918)
class AYArsMgr_Standard : public AYArsenalManager
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2019 ];

		return pClassPointer;
	};

};

UClass* AYArsMgr_Standard::pClassPointer = NULL;

// Class SRGame.YArsenalManager_MP
// 0x002C (0x0944 - 0x0918)
class AYArsenalManager_MP : public AYArsMgr_Standard
{
public:
	class AYWeapon*                                    m_noWeapon;                                       		// 0x0918 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class AYWeapon_Explosive* >                m_explosiveWeapons;                               		// 0x091C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AYWeapon_MPOfficerBeacon*                    m_officerBeacon;                                  		// 0x0928 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYWeapon_MPOfficerSupply*                    m_officerSupply;                                  		// 0x092C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_currentExplosiveWeapon;                         		// 0x0930 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_stoneClass;                                     		// 0x0934 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bSwitchingBackToNormalGrenades : 1;             		// 0x0938 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_primaryGrenadeAmmoCount;                        		// 0x093C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYWeapon_Explosive*                          m_lastSelectedExplosiveWeapon;                    		// 0x0940 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2020 ];

		return pClassPointer;
	};

	bool ForceNextLootCarryingWeapon ( );
	bool SelectValidDBNOWeapon ( );
	void ServerDropGrenadeIfRaised ( );
	void ServerPrevGrenades ( );
	void ServerToggleGrenades ( );
	void OnEndThrowGrenade ( );
	void ServerSwitchBackToNormalGrenade ( );
	void SwitchBackToNormalGrenade ( );
	void ClientStartStopFire ( unsigned char FiringMode, unsigned long Start, unsigned long byRelease );
	void SetMaterialScalarParameterValueOnAllWeapons ( struct FName ParmameterName, float fValue );
	void SetMaterialOnAllWeapons ( class UMaterialInterface* pMaterial );
	void DisplayDebug ( class AHUD* H, float* out_YL, float* out_YPos );
	void DrawHUD ( class AYHUD* H );
	void SkipWeaponGrenadeState ( );
	bool CanToggleGrenades ( );
	bool IsThrowingGrenade ( );
	int GetPrimaryGrenadeCount ( );
	int GetEquippedGrenadeCount ( );
	bool HasGrenades ( );
	bool MayFireWeapon ( unsigned long secondary, unsigned char* blindfireOnly, unsigned char* shouldReload );
	class AYProj_Physical* GetCurrentGrenadeDefObj ( int Index, class UYProjData_Mesh** meshData );
	void SpawnGrenade ( );
	unsigned char GetEquippedGrenadeType ( );
	void ServerInit ( class AYGamePawn* NewPawn );
	void SetupOfficerGrenades ( );
	void ServerSetOfficerBeaconWeapon ( );
	void SetOfficerBeaconWeapon ( );
	void SetActiveExplosiveWeapon ( class AYWeapon_Explosive* explosive );
	void SetActiveExplosive ( int explosiveIndex );
	void HandleRepExplosiveWeapon ( );
	void ScavengerExtraGrenade ( );
	int ServerAddGrenades ( unsigned char grenadeType, int Amount );
	void ServerStopFire ( unsigned char FiringMode, unsigned long byRelease );
	void StopFire ( unsigned char FiringMode, unsigned long byRelease );
	void ServerStartFire ( unsigned char FiringMode, unsigned long setBlindFireFlag );
	void TossWeapon ( class AYPickup_Weapon* weaponPickup, class AYWeapon* Wpn );
	void ServerTossBestWeapon ( );
	void ServerFillUpGrenades ( );
	int ServerAddGrenadesFromPickup ( class AYPickup_Grenade* Pickup );
	void RemoveCurrentGrenadeTypeAndSwitchToNext ( );
	unsigned char GiveGrenade ( struct FString grenadeTypeStr );
	void InitGrenades ( );
	void SetEquippedGrenadeCount ( int Count );
	void Destroyed ( );
	bool AddAmmoFromPickup ( class AYPickup_Ammo* Pickup );
	int GetMaxGrenadeCount ( );
	void SwitchWeaponsInternal ( );
	class UClass* SwitchWeapon ( class UClass* newWeaponClass, unsigned long forced );
	bool SwitchToNonEmptyWeapon ( );
	bool CanPickupGrenades ( class AYPickup_Grenade* Pickup );
	bool CanPickupWeapon ( class AYPickup_Weapon* Pickup );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYArsenalManager_MP::pClassPointer = NULL;

// Class SRGame.YCrosshair
// 0x0024 (0x0060 - 0x003C)
class UYCrosshair : public UObject
{
public:
	class AYWeapon*                                    m_weapon;                                         		// 0x003C (0x0004) [0x0000000000000000]              
	struct FColor                                      m_crossHairColor;                                 		// 0x0040 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_hasStaticColor : 1;                             		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_isZoomed : 1;                                   		// 0x0044 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_oldIsZoomed : 1;                                		// 0x0044 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_zoomHasChanged : 1;                             		// 0x0044 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_suppressed : 1;                                 		// 0x0044 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	float                                              m_fadeTime;                                       		// 0x0048 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_opacity;                                        		// 0x004C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_accuracy;                                       		// 0x0050 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_desaturation;                                   		// 0x0054 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_crosshairColorType;                             		// 0x0058 (0x0001) [0x0000000000000000]              
	class UYCrosshair_Indicator*                       m_crosshairIndicator;                             		// 0x005C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2021 ];

		return pClassPointer;
	};

	void Update ( struct FColor targetCrosshairColor, float DeltaTime );
	int GetCurrentIndicator ( );
	void HideIndicator ( );
	void ShowIndicator ( int Index );
	void DrawCrosshair ( class AYHUD* H, float dt );
	void Draw ( class AYHUD* H, float DeltaTime );
	void Destroy ( );
	void Init ( class AYWeapon* Weapon, class AYHUD* HUD );
};

UClass* UYCrosshair::pClassPointer = NULL;

// Class SRGame.YAnimatedCrosshair
// 0x0020 (0x0080 - 0x0060)
class UYAnimatedCrosshair : public UYCrosshair
{
public:
	TArray< struct FYS_CrosshairAnimationSequence >    m_crosshairAnimSequences;                         		// 0x0060 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_CrosshairAnimationSequence              m_crosshairSaturationSequence;                    		// 0x006C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FYMarkerAnimKeyFrame >              m_desaturationKeyFrames;                          		// 0x0074 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2022 ];

		return pClassPointer;
	};

	void SetAnimPosition ( float Position, class UYMarkerBase* marker );
	void UpdateAnimPosition ( );
	void DrawCrosshair ( class AYHUD* H, float dt );
	void Destroy ( );
	void Init ( class AYWeapon* Weapon, class AYHUD* HUD );
};

UClass* UYAnimatedCrosshair::pClassPointer = NULL;

// Class SRGame.YCrosshair_Projectile
// 0x00C8 (0x0148 - 0x0080)
class UYCrosshair_Projectile : public UYAnimatedCrosshair
{
public:
	struct FCanvasIcon                                 m_circleTopLeftIcon;                              		// 0x0080 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_circleTopRightIcon;                             		// 0x0094 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_circleBottomLeftIcon;                           		// 0x00A8 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_circleBottomRightIcon;                          		// 0x00BC (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_crossTopIcon;                                   		// 0x00D0 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_crossBottomIcon;                                		// 0x00E4 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_crossLeftIcon;                                  		// 0x00F8 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_crossRightIcon;                                 		// 0x010C (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_dotIcon;                                        		// 0x0120 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_largeCircleInTheBackground;                     		// 0x0134 (0x0014) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2023 ];

		return pClassPointer;
	};

	void DrawCrosshair ( class AYHUD* H, float dt );
};

UClass* UYCrosshair_Projectile::pClassPointer = NULL;

// Class SRGame.YCrosshair_Projectile_Simple
// 0x0028 (0x00A8 - 0x0080)
class UYCrosshair_Projectile_Simple : public UYAnimatedCrosshair
{
public:
	struct FCanvasIcon                                 m_crosshairIcon;                                  		// 0x0080 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_crosshairIconZoom;                              		// 0x0094 (0x0014) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2024 ];

		return pClassPointer;
	};

	void DrawCrosshair ( class AYHUD* H, float dt );
};

UClass* UYCrosshair_Projectile_Simple::pClassPointer = NULL;

// Class SRGame.YCrosshair_Shotgun
// 0x0050 (0x00D0 - 0x0080)
class UYCrosshair_Shotgun : public UYAnimatedCrosshair
{
public:
	struct FCanvasIcon                                 m_circleTopIcon;                                  		// 0x0080 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_circleBottomIcon;                               		// 0x0094 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_circleLeftIcon;                                 		// 0x00A8 (0x0014) [0x0000000000000002]              ( CPF_Const )
	struct FCanvasIcon                                 m_circleRightIcon;                                		// 0x00BC (0x0014) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2025 ];

		return pClassPointer;
	};

	void DrawCrosshair ( class AYHUD* H, float dt );
};

UClass* UYCrosshair_Shotgun::pClassPointer = NULL;

// Class SRGame.YCrosshair_Blindfire
// 0x0014 (0x0074 - 0x0060)
class UYCrosshair_Blindfire : public UYCrosshair
{
public:
	struct FCanvasIcon                                 m_crosshair;                                      		// 0x0060 (0x0014) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2026 ];

		return pClassPointer;
	};

	void DrawCrosshair ( class AYHUD* H, float dt );
};

UClass* UYCrosshair_Blindfire::pClassPointer = NULL;

// Class SRGame.YCrosshair_Grenade
// 0x0014 (0x0074 - 0x0060)
class UYCrosshair_Grenade : public UYCrosshair
{
public:
	struct FCanvasIcon                                 m_crosshairIcon;                                  		// 0x0060 (0x0014) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2027 ];

		return pClassPointer;
	};

	void DrawCrosshair ( class AYHUD* H, float dt );
};

UClass* UYCrosshair_Grenade::pClassPointer = NULL;

// Class SRGame.YCrosshair_GrenadeLauncher
// 0x0014 (0x0074 - 0x0060)
class UYCrosshair_GrenadeLauncher : public UYCrosshair
{
public:
	struct FCanvasIcon                                 m_crosshair;                                      		// 0x0060 (0x0014) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2028 ];

		return pClassPointer;
	};

	void DrawCrosshair ( class AYHUD* H, float dt );
};

UClass* UYCrosshair_GrenadeLauncher::pClassPointer = NULL;

// Class SRGame.YCrosshair_MachineGun
// 0x0014 (0x0074 - 0x0060)
class UYCrosshair_MachineGun : public UYCrosshair
{
public:
	struct FCanvasIcon                                 m_crosshair;                                      		// 0x0060 (0x0014) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2029 ];

		return pClassPointer;
	};

	void DrawCrosshair ( class AYHUD* H, float dt );
};

UClass* UYCrosshair_MachineGun::pClassPointer = NULL;

// Class SRGame.YCrosshair_NoCrosshair
// 0x0000 (0x0060 - 0x0060)
class UYCrosshair_NoCrosshair : public UYCrosshair
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2030 ];

		return pClassPointer;
	};

	void Draw ( class AYHUD* H, float DeltaTime );
};

UClass* UYCrosshair_NoCrosshair::pClassPointer = NULL;

// Class SRGame.YCrosshair_RPG
// 0x0014 (0x0074 - 0x0060)
class UYCrosshair_RPG : public UYCrosshair
{
public:
	struct FCanvasIcon                                 m_crosshair;                                      		// 0x0060 (0x0014) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2031 ];

		return pClassPointer;
	};

	void DrawCrosshair ( class AYHUD* H, float dt );
};

UClass* UYCrosshair_RPG::pClassPointer = NULL;

// Class SRGame.YCrosshair_SquadCommandMode
// 0x0014 (0x0074 - 0x0060)
class UYCrosshair_SquadCommandMode : public UYCrosshair
{
public:
	struct FCanvasIcon                                 m_crosshair;                                      		// 0x0060 (0x0014) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2032 ];

		return pClassPointer;
	};

	void DrawCrosshair ( class AYHUD* H, float dt );
};

UClass* UYCrosshair_SquadCommandMode::pClassPointer = NULL;

// Class SRGame.YStaticCrosshair
// 0x0014 (0x0074 - 0x0060)
class UYStaticCrosshair : public UYCrosshair
{
public:
	struct FCanvasIcon                                 m_crosshairIcon;                                  		// 0x0060 (0x0014) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2033 ];

		return pClassPointer;
	};

	void DrawCrosshair ( class AYHUD* H, float dt );
};

UClass* UYStaticCrosshair::pClassPointer = NULL;

// Class SRGame.YCrosshair_Indicator
// 0x0054 (0x0090 - 0x003C)
class UYCrosshair_Indicator : public UObject
{
public:
	struct FVector2D                                   m_indicatorSize;                                  		// 0x003C (0x0008) [0x0000000000000000]              
	int                                                m_currentIndicatorMaterialIndex;                  		// 0x0044 (0x0004) [0x0000000000000000]              
	class UMaterialInstance*                           m_indicatorMaterialsTemplate[ 0x9 ];              		// 0x0048 (0x0024) [0x0000000000000000]              
	class UMaterialInstance*                           m_indicatorMaterials[ 0x9 ];                      		// 0x006C (0x0024) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2034 ];

		return pClassPointer;
	};

};

UClass* UYCrosshair_Indicator::pClassPointer = NULL;

// Class SRGame.YCrosshair_Indicator_MP
// 0x0020 (0x00B0 - 0x0090)
class UYCrosshair_Indicator_MP : public UYCrosshair_Indicator
{
public:
	struct FVector2D                                   m_hitIndicatorSize;                               		// 0x0090 (0x0008) [0x0000000000004000]              ( CPF_Config )
	struct FVector2D                                   m_armorHitIndicatorSize;                          		// 0x0098 (0x0008) [0x0000000000004000]              ( CPF_Config )
	struct FVector2D                                   m_sonarIndicatorSize;                             		// 0x00A0 (0x0008) [0x0000000000004000]              ( CPF_Config )
	struct FVector2D                                   m_dontShootIndicatorSize;                         		// 0x00A8 (0x0008) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2035 ];

		return pClassPointer;
	};

};

UClass* UYCrosshair_Indicator_MP::pClassPointer = NULL;

// Class SRGame.YCrosshairInfo
// 0x0014 (0x0050 - 0x003C)
class UYCrosshairInfo : public UObject
{
public:
	struct FColor                                      m_crossHairColor[ 0x5 ];                          		// 0x003C (0x0014) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2036 ];

		return pClassPointer;
	};

};

UClass* UYCrosshairInfo::pClassPointer = NULL;

// Class SRGame.YDamageManager
// 0x0020 (0x005C - 0x003C)
class UYDamageManager : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x003C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	TArray< struct FYS_DamageItem >                    m_damageItems;                                    		// 0x0040 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AYGameInfo*                                  m_gameInfo;                                       		// 0x004C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_showDebugInfo : 1;                              		// 0x0050 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_mergeAllDamageForPawn : 1;                      		// 0x0050 (0x0004) [0x0000000020004000] [0x00000002] ( CPF_Config | CPF_Deprecated )
	float                                              m_KActorsImpulseMultiplier;                       		// 0x0054 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_sandPoolVictimCounter;                          		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2037 ];

		return pClassPointer;
	};

	void DamageFracturedStaticMeshActorByExplosion ( class AFracturedStaticMeshActor* fracAct, class UClass* dmgTypeClass, float Damage, struct FVector explosionLoc, float explosionStrength, float DamageRadius, class APawn* InstigatorPawn, class AController* InstigatorController );
	void ApplyDamage ( class AActor* HitActor, float DamageAmount, struct FVector HitLoc, struct FVector hitNrml, struct FVector Momentum, class UClass* dmgType, struct FTraceHitInfo traceInfo, class AActor* DamageCauser );
	void ExecuteInstantDamageItem ( struct FYS_DamageItem* instantDmgItem );
	void AddTemporalDamageItem ( struct FYS_DamageItem* tempDmgItem );
	void AddDamageItem ( class AYWeapon* wp, class AActor* damageDealer, class AActor* SourceActor, unsigned long selfDamage, unsigned long sandStun, struct FVector origLoc, struct FVector veloc, struct FVector FocusLoc, class UClass* dmgType, class UYDamageEvaluationParams* dmgEval, unsigned long rolled, class AActor* HitActor );
	void Update ( float DeltaTime );
	void Init ( class AYGameInfo* creator );
};

UClass* UYDamageManager::pClassPointer = NULL;

// Class SRGame.YDamageType_Bledout
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Bledout : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2038 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Bledout::pClassPointer = NULL;

// Class SRGame.YDamageType_Explosive
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Explosive : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2039 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Explosive::pClassPointer = NULL;

// Class SRGame.YDamageType_C4
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_C4 : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2040 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_C4::pClassPointer = NULL;

// Class SRGame.YDamageType_IED
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_IED : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2041 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_IED::pClassPointer = NULL;

// Class SRGame.YDamageType_Mine
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Mine : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2042 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Mine::pClassPointer = NULL;

// Class SRGame.YDamageType_Mortar
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Mortar : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2043 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Mortar::pClassPointer = NULL;

// Class SRGame.YDamageType_MortarBurn
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_MortarBurn : public UYDamageType_Mortar
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2044 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_MortarBurn::pClassPointer = NULL;

// Class SRGame.YDamageType_PhosphorGrenade
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_PhosphorGrenade : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2045 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_PhosphorGrenade::pClassPointer = NULL;

// Class SRGame.YDamageType_Melee
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Melee : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2046 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Melee::pClassPointer = NULL;

// Class SRGame.YDamageType_Melee_Deadly
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Melee_Deadly : public UYDamageType_Melee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2047 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Melee_Deadly::pClassPointer = NULL;

// Class SRGame.YDamageType_Projectile
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Projectile : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2048 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Projectile::pClassPointer = NULL;

// Class SRGame.YDamageType_Shotgun
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Shotgun : public UYDamageType_Projectile
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2049 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Shotgun::pClassPointer = NULL;

// Class SRGame.YDamageType_Sniper
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Sniper : public UYDamageType_Projectile
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2050 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Sniper::pClassPointer = NULL;

// Class SRGame.YDamageType_SandAvalanche
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_SandAvalanche : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2051 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_SandAvalanche::pClassPointer = NULL;

// Class SRGame.YDamageType_Stone
// 0x001C (0x00E0 - 0x00C4)
class UYDamageType_Stone : public UYDamageType
{
public:
	float                                              m_duration;                                       		// 0x00C4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_fadeOutTime;                                    		// 0x00C8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_rotHMultiplier;                                 		// 0x00CC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_rotVMultiplier;                                 		// 0x00D0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_fullThreshold;                                  		// 0x00D4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_midThreshold;                                   		// 0x00D8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_damageModifierStun;                             		// 0x00DC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2052 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Stone::pClassPointer = NULL;

// Class SRGame.YDamageType_Stun
// 0x0020 (0x00E4 - 0x00C4)
class UYDamageType_Stun : public UYDamageType
{
public:
	float                                              m_duration;                                       		// 0x00C4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_fadeOutTime;                                    		// 0x00C8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_rotHMultiplier;                                 		// 0x00CC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_rotVMultiplier;                                 		// 0x00D0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_fullThreshold;                                  		// 0x00D4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_midThreshold;                                   		// 0x00D8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_damageModifierStun;                             		// 0x00DC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_crosshairVisibleRate;                           		// 0x00E0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2053 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Stun::pClassPointer = NULL;

// Class SRGame.YExplosiveActor
// 0x006C (0x0264 - 0x01F8)
class AYExplosiveActor : public AActor
{
public:
	unsigned char                                      m_grenadeType;                                    		// 0x01F8 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_configTypeLoaded;                               		// 0x01F9 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_defaultHealth;                                  		// 0x01FC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_currentHealth;                                  		// 0x0200 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_timeBeforeNotifyingAI;                          		// 0x0204 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	float                                              m_reTriggerDelay;                                 		// 0x0208 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_lastDamageTimeStamp;                            		// 0x020C (0x0004) [0x0000000000000000]              
	class AController*                                 m_firstControllerWhoHitMe;                        		// 0x0210 (0x0004) [0x0000000000000000]              
	int                                                m_numHits;                                        		// 0x0214 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_damageType;                                     		// 0x0218 (0x0004) [0x0000000000000000]              
	struct FName                                       m_damageParamsName;                               		// 0x021C (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned long                                      m_exploded : 1;                                   		// 0x0224 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bTriggerSandPool : 1;                           		// 0x0224 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_explodingOnSandPool : 1;                        		// 0x0224 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_destroyedStatMeshEnabled : 1;                   		// 0x0224 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_destroyedStatMeshHasCollision : 1;              		// 0x0224 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_UsedBy_YEA_EXPLOSIVE : 1;                       		// 0x0224 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              m_healthReductionPerSecondAndHit;                 		// 0x0228 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UStaticMeshComponent*                        m_statMeshComp;                                   		// 0x022C (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UStaticMeshComponent*                        m_destroyedStatMeshComp;                          		// 0x0230 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UParticleSystemComponent*                    m_explPSC;                                        		// 0x0234 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_explSound;                                      		// 0x0238 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FYS_ProjGroundDecalDesc                     m_groundDecalDesc;                                		// 0x023C (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ProjGroundDecalDesc                     m_groundDecalDescSand;                            		// 0x024C (0x0010) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_groundLocCheckDistance;                         		// 0x025C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_sandFogIntensityScale;                          		// 0x0260 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2054 ];

		return pClassPointer;
	};

	void SandFogVolumeTriggerPawns ( class AYFogVolumeSandDensityInfo* hitVolume );
	class AYFogVolumeSandDensityInfo* ShowSandFogVolume ( struct FVector HitLocation );
	bool CheckAboveSand ( float MaxDist, struct FVector TestLocation, struct FVector* groundLocation, struct FVector* groundNormal );
	void Explode ( );
	void ServerExplode ( );
	void Tick ( float DeltaTime );
	void notifyAI ( );
	void TakeDamage ( int DamageAmount, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void PostBeginPlay ( );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYExplosiveActor::pClassPointer = NULL;

// Class SRGame.YGlobalWeaponIncludes
// 0x0000 (0x003C - 0x003C)
class UYGlobalWeaponIncludes : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2055 ];

		return pClassPointer;
	};

};

UClass* UYGlobalWeaponIncludes::pClassPointer = NULL;

// Class SRGame.YKAssetSpawnable
// 0x0000 (0x0208 - 0x0208)
class AYKAssetSpawnable : public AKAsset
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2056 ];

		return pClassPointer;
	};

};

UClass* AYKAssetSpawnable::pClassPointer = NULL;

// Class SRGame.YObjectPool
// 0x0658 (0x0850 - 0x01F8)
class AYObjectPool : public AActor
{
public:
	struct FYSTracerCacheEntry                         m_tracerCache[ 0x5 ];                             		// 0x01F8 (0x00A0) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYSEmitterCacheEntry >              m_emitterCache;                                   		// 0x0298 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	TArray< struct FYS_SkeletalMeshCacheEntry >        m_skelMeshCache;                                  		// 0x02A4 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	TArray< struct FYS_ParticleLightEnvironmentEntry > m_particleLECache;                                		// 0x02B0 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	class UYTracerPoolData*                            m_tracerPoolData;                                 		// 0x02BC (0x0004) [0x0000000000000000]              
	struct FYS_WeaponPickupEntry                       m_weaponPickupPool[ 0x1E ];                       		// 0x02C0 (0x01E0) [0x0000000000000000]              
	struct FYS_PawnAttachmentEntry                     m_pawnAttachmentPool[ 0x1E ];                     		// 0x04A0 (0x0258) [0x0000000000000000]              
	struct FYS_BodyPartEntry                           m_bodyPartPool[ 0x14 ];                           		// 0x06F8 (0x00F0) [0x0000000000000000]              
	TArray< class UStaticMesh* >                       m_bodyPartsLimb;                                  		// 0x07E8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_bodyPartsLimbString;                            		// 0x07F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UStaticMesh* >                       m_bodyPartsFlesh;                                 		// 0x0800 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_bodyPartsFleshString;                           		// 0x080C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_HealingSyringeEntry                     m_healingSyringePool[ 0x2 ];                      		// 0x0818 (0x0018) [0x0000000000000000]              
	class UStaticMesh*                                 m_healingSyringeMesh;                             		// 0x0830 (0x0004) [0x0000000000000000]              
	class UAnimTree*                                   m_AnimTreeTemplate;                               		// 0x0834 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< class UAnimTree* >                         m_AnimTreesUnused;                                		// 0x0838 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimTree* >                         m_AnimTreesUsed;                                  		// 0x0844 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2057 ];

		return pClassPointer;
	};

	void OnParticleSystemFinished ( class UParticleSystemComponent* PSC );
	void CleanUpPools ( );
	void Destroyed ( );
	void CreateEmitterPool ( unsigned long bIsMultiplayer );
	void CleanUpAnimTrees ( );
	void CreateAnimTrees ( );
	void ReturnHealingSyringe ( class AKActorSpawnable* Actor );
	class AKActorSpawnable* SpawnHealingSyringe ( );
	void ReturnBodyPart ( class AKActorSpawnable* Actor );
	class AKActorSpawnable* SpawnBodyPart ( );
	void CleanupPawnAttachments ( unsigned long areaBased, struct FVector Loc, float Range );
	void DestroyPawnAttachment ( class AKActorSpawnable* Actor, class AActor* User );
	void ReturnPawnAttachment ( class AKActorSpawnable* Actor );
	class AKActorSpawnable* SpawnPawnAttachment ( class AActor* User );
	void ReturnWeaponPickup ( class AYPickup_WeaponSpawnable* Pickup );
	class AYPickup_WeaponSpawnable* SpawnWeaponPickup ( struct FVector Loc, struct FRotator Rot );
	void ResetWeaponPickupPool ( );
	void CreateWeaponPickupPool ( );
	void ReturnSkeletalMeshComponent ( class USkeletalMeshComponent* smComp );
	class USkeletalMeshComponent* SpawnSkeletalMeshComponent ( class USkeletalMesh* SMTemplate, class UPhysicsAsset* PhysAsset, class UObject* inOuter );
	class UParticleSystemComponent* SpawnEmitterPS ( class UParticleSystem* PSTemplate, struct FVector SpawnLocation, struct FRotator SpawnRotation, class AActor* AttachToActor );
	void CreateSkelMesh_List ( int poolIdx, struct FString skelMeshName, struct FString physAssetName, int NumToCreate, unsigned long bForceCreate );
	void CreatePSC_List ( int poolIdx, class UParticleSystem* PSTemplate, int NumToCreate, unsigned long bDontCreateLazy, unsigned long bCreateNowIgnoreLazy );
	void CreateBodyPartPool ( unsigned long bMultiplayer );
	void CreatePools ( unsigned long bIsMultiplayer );
	void CreateTracerPool ( );
	void CleanupBodyParts ( );
	void CleanUpEmitters ( );
	void CleanUpTracers ( );
	class AYProj_Tracer* GetTracer ( class AYProj_Tracer* tracerArc );
	void CreateTracer ( unsigned char poolIdx, class AYProj_Tracer* tracerArc, unsigned char actIdx );
};

UClass* AYObjectPool::pClassPointer = NULL;

// Class SRGame.YPickupActor
// 0x00D8 (0x02D0 - 0x01F8)
class AYPickupActor : public AActor
{
public:
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x01F8 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_IYIScanable;                              		// 0x01FC (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned char                                      m_pickupAnimType;                                 		// 0x0200 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_team;                                           		// 0x0201 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMeshComponent*                      m_pickupMesh;                                     		// 0x0204 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMaterialInterface*                          m_highlightingMaterialOverride;                   		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInterface*                          m_glowMaterial;                                   		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bUseGlow : 1;                                   		// 0x0210 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_pickupHidden : 1;                               		// 0x0210 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_physicsDisabled : 1;                            		// 0x0210 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_bClientDestroy : 1;                             		// 0x0210 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      m_reportIfScanned : 1;                            		// 0x0210 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_respawnEnabled : 1;                             		// 0x0210 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_active : 1;                                     		// 0x0210 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_destroyOnReset : 1;                             		// 0x0210 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bDestroyWhenHiddenForPlayer : 1;                		// 0x0210 (0x0004) [0x0000000000004000] [0x00000100] ( CPF_Config )
	unsigned long                                      m_hasPhysAsset : 1;                               		// 0x0210 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_doCheckThisTick : 1;                            		// 0x0210 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_isSpawned : 1;                                  		// 0x0210 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      bNeedsRBStateReplication : 1;                     		// 0x0210 (0x0004) [0x0000000000002000] [0x00001000] ( CPF_Transient )
	unsigned long                                      m_usedPending : 1;                                		// 0x0210 (0x0004) [0x0000000000000000] [0x00002000] 
	struct FYS_PickupSound                             m_pickupSound;                                    		// 0x0214 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class USkeletalMesh*                               m_skelMesh;                                       		// 0x0218 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_respawnTime;                                    		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_tacIconClass;                                   		// 0x0220 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	struct FString                                     m_pickupMessage;                                  		// 0x0224 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_pickedUpMessage;                                		// 0x0230 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_ammoFullMessage;                                		// 0x023C (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	float                                              m_iconDisplayDistance;                            		// 0x0248 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ULightEnvironmentComponent*                  m_lightEnvironment;                               		// 0x024C (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_lightEnvironmentLastUpdateTime;                 		// 0x0250 (0x0004) [0x0000000000000000]              
	class UYMarkerIcon*                                m_tacIcon;                                        		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              m_destroyTimer;                                   		// 0x0258 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class AYGamePawn*                                  m_reservedForPawn;                                		// 0x025C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_lastRefillCount;                                		// 0x0260 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      UnknownData00[ 0xC ];                             		// 0x0264 (0x000C) MISSED OFFSET
	struct FRigidBodyState                             RBState;                                          		// 0x0270 (0x0040) [0x0000000000001022]              ( CPF_Const | CPF_Net | CPF_Native )
	float                                              AngErrorAccumulator;                              		// 0x02B0 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	struct FVector                                     InitialLocation;                                  		// 0x02B4 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_IntelPickupMessage;                             		// 0x02C0 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	float                                              m_locationOffsetZ;                                		// 0x02CC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2058 ];

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( struct AYPickupActor_FCheckpointRecord* Record );
	void CreateCheckpointRecord ( struct AYPickupActor_FCheckpointRecord* Record );
	bool ShouldSaveForCheckpoint ( );
	bool CheckMetalDetectorDistance ( );
	unsigned char GetScanableType ( int m_scanningTeamIdx );
	void OnScanEnded ( );
	void DoScanEffects ( );
	void OnScanned ( class AYPlayerController* PC, unsigned char Appearance, float Delay, unsigned long PlaySound );
	bool IsUsed ( );
	void OnDetected ( unsigned long detected );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	struct FBoxSphereBounds GetBounds ( );
	bool IsEnabledForTacView ( );
	void OnToggle ( class USeqAct_Toggle* seqAct );
	void SelfDestroyTimer ( );
	void InitializeSelfDestruction ( );
	struct FString GetAmmoFullMessage ( );
	struct FString GetMessage ( class AYArsenalManager* arsenalManager );
	void Reset ( );
	void GetPickupInfo ( int Index, struct FString* Message, struct FString* Icon, struct FString* message2 );
	void GetPickupInfoFromPickup ( int Index, int overrideRefillCount, struct FString* Message, struct FString* Icon, struct FString* message2 );
	void SetSkelMeshVelocities ( struct FVector LinVel, struct FVector AngVel );
	void DestroyPickup ( );
	void DisablePickup ( );
	bool DoPickup ( class AYGamePawn* Pawn );
	bool CallDoPickup ( class AYGamePawn* Pawn );
	bool DoPickupMove ( class AYGamePawn* Pawn, unsigned char specialMove );
	void SetPickupVisible ( );
	void SetPickupHidden ( );
	void ConditionalReactivatePhysics ( );
	void DoSleepActivation ( );
	void OnSleepRBPhysics ( );
	void SetPickupSkelMesh ( class USkeletalMesh* NewMesh );
	void SetPickupMesh ( );
	void InitializePickup ( );
	void PreBeginPlay ( );
	bool IsSilhouetteEnabled ( class UMaterialInterface* Material );
	void SetNewSilhouette ( class UMaterialInterface* Material );
	void EnableSilhouette ( class UMaterialInterface* Material );
	void DisableGlowSilhouette ( );
	void EnableGlowSilhouette ( );
	void OnToggleHidden ( class USeqAct_ToggleHidden* Action );
	void ReplicatedEvent ( struct FName VarName );
	void SetIsSpawned ( unsigned long bSpawned );
	bool IsSpawned ( );
};

UClass* AYPickupActor::pClassPointer = NULL;

// Class SRGame.YDeliveryPackage
// 0x0018 (0x02E8 - 0x02D0)
class AYDeliveryPackage : public AYPickupActor
{
public:
	unsigned char                                      m_packageTeam;                                    		// 0x02D0 (0x0001) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	float                                              m_timeToArm;                                      		// 0x02D4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_timeToDisarm;                                   		// 0x02D8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_timeToDetonate;                                 		// 0x02DC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_respawnDelay;                                   		// 0x02E0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bIsArmed : 1;                                   		// 0x02E4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2059 ];

		return pClassPointer;
	};

	void CreateExplosion ( );
	void TimeoutRespawn ( );
	void StopTimer ( );
	void StartTimer ( float Seconds );
	bool DoPickup ( class AYGamePawn* Pawn );
	bool DoPickupMove ( class AYGamePawn* Pawn, unsigned char specialMove );
	void RespawnMe ( );
	void Reset ( );
	struct FString GetPickupMessage ( );
	void PostBeginPlay ( );
	bool IsEnabledForTacView ( );
};

UClass* AYDeliveryPackage::pClassPointer = NULL;

// Class SRGame.YPickup_Ammo
// 0x0008 (0x02D8 - 0x02D0)
class AYPickup_Ammo : public AYPickupActor
{
public:
	unsigned long                                      m_full : 1;                                       		// 0x02D0 (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_fillUpGrenades : 1;                             		// 0x02D0 (0x0004) [0x0000000000000002] [0x00000002] ( CPF_Const )
	unsigned long                                      m_used : 1;                                       		// 0x02D0 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	class UAnimNodeSequence*                           m_openAnimSeq;                                    		// 0x02D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2060 ];

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( struct AYPickupActor_FCheckpointRecord* Record );
	void CreateCheckpointRecord ( struct AYPickupActor_FCheckpointRecord* Record );
	bool ShouldSaveForCheckpoint ( );
	unsigned char GetScanableType ( int m_scanningTeamIdx );
	bool IsUsed ( );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	struct FBoxSphereBounds GetBounds ( );
	bool IsEnabledForTacView ( );
	void GetPickupInfo ( int Index, struct FString* Message, struct FString* Icon, struct FString* message2 );
	void GetPickupInfoFromPickup ( int Index, int overrideRefillCount, struct FString* Message, struct FString* Icon, struct FString* message2 );
	struct FString GetMessage ( class AYArsenalManager* arsenalManager );
	void PlayOpenAnimFinished ( );
	void PlayOpenAnim ( );
	void ResetUsedPickup ( );
	void DisablePickup ( );
	bool DoPickup ( class AYGamePawn* Pawn );
	void SetPickupVisible ( );
	void InitializePickup ( );
};

UClass* AYPickup_Ammo::pClassPointer = NULL;

// Class SRGame.YPickup_AmmoBox
// 0x000C (0x02E4 - 0x02D8)
class AYPickup_AmmoBox : public AYPickup_Ammo
{
public:
	TArray< struct FRefillInfo >                       m_refillInfos;                                    		// 0x02D8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2061 ];

		return pClassPointer;
	};

	void GetPickupInfo ( int Index, struct FString* Message, struct FString* Icon, struct FString* message2 );
	void GetPickupInfoFromPickup ( int Index, int overrideRefillCount, struct FString* Message, struct FString* Icon, struct FString* message2 );
	void RestoreRefillInfo ( int overrideRefillCount, class APlayerController* P );
	int GetEncryptionModifier ( class AYWeapon* Weapon );
	void AddRefillInfo ( class AYWeapon* Weapon, int NumRounds );
	struct FString GetPickedUpIcon ( );
	bool DoPickupMove ( class AYGamePawn* Pawn, unsigned char specialMove );
	void InitializePickup ( );
};

UClass* AYPickup_AmmoBox::pClassPointer = NULL;

// Class SRGame.YPickup_AmmoCrate
// 0x0008 (0x02E0 - 0x02D8)
class AYPickup_AmmoCrate : public AYPickup_Ammo
{
public:
	class UAnimNodeSequence*                           m_closeAnimSeq;                                   		// 0x02D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UAnimNodeBlend*                              m_switchAnimSeq;                                  		// 0x02DC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2062 ];

		return pClassPointer;
	};

	void ResetCrate ( );
	void PlayCloseAnim ( );
	void PlayOpenAnim ( );
	void DisablePickup ( );
	bool DoPickupMove ( class AYGamePawn* Pawn, unsigned char specialMove );
	void InitializePickup ( );
};

UClass* AYPickup_AmmoCrate::pClassPointer = NULL;

// Class SRGame.YPickup_Collectable
// 0x0028 (0x02F8 - 0x02D0)
class AYPickup_Collectable : public AYPickupActor
{
public:
	class UStaticMeshComponent*                        CollectibleMeshComponent;                         		// 0x02D0 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FVector                                     MeshOffset;                                       		// 0x02D4 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_collectibleID;                                  		// 0x02E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USurface*                                    m_collectibleImage;                               		// 0x02E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYFMODResource_VSB*                          m_intelVoice;                                     		// 0x02E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_voiceUID;                                       		// 0x02EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYDataProvider_IntelCollectibles*            m_intelCollectibleProvider;                       		// 0x02F0 (0x0004) [0x0000000000000000]              
	float                                              m_showPopupDuration;                              		// 0x02F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2063 ];

		return pClassPointer;
	};

	unsigned char GetScanableType ( int m_scanningTeamIdx );
	void GetPickupInfo ( int Index, struct FString* Message, struct FString* Icon, struct FString* message2 );
	void GetPickupInfoFromPickup ( int Index, int overrideRefillCount, struct FString* Message, struct FString* Icon, struct FString* message2 );
	struct FString GetMessage ( class AYArsenalManager* arsenalManager );
	void SetPickupVisible ( );
	void SetPickupHidden ( );
	void SetPickupMesh ( );
	class UYDataProvider_IntelCollectibles* GetIntelCollectiblesDataProvider ( int collectibleID );
	void InitializePickup ( );
};

UClass* AYPickup_Collectable::pClassPointer = NULL;

// Class SRGame.YPickup_FremenLoot
// 0x0054 (0x0324 - 0x02D0)
class AYPickup_FremenLoot : public AYPickupActor
{
public:
	int                                                m_lootType[ 0x2 ];                                		// 0x02D0 (0x0008) [0x0000000000000020]              ( CPF_Net )
	int                                                m_lootProbabilityLvl1[ 0x5 ];                     		// 0x02D8 (0x0014) [0x0000000000004000]              ( CPF_Config )
	int                                                m_lootProbabilityLvl2[ 0x5 ];                     		// 0x02EC (0x0014) [0x0000000000004000]              ( CPF_Config )
	int                                                m_armorValue;                                     		// 0x0300 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_ammoMultiplier;                                 		// 0x0304 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_lifeTime;                                       		// 0x0308 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maxDisplayDistance;                             		// 0x030C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_scanTime;                                       		// 0x0310 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UYSoundCueFMOD*                              m_ammoSound;                                      		// 0x0314 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_explosivesSound;                                		// 0x0318 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_armorSound;                                     		// 0x031C (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_scanSound;                                      		// 0x0320 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2064 ];

		return pClassPointer;
	};

	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	struct FBoxSphereBounds GetBounds ( );
	bool IsEnabledForTacView ( );
	void Tick ( float DeltaTime );
	void CheckMeshVisibility ( );
	int GetLootType ( class AYPawn_Multiplayer* pwnFremen );
	void ApplyIconMaterial ( );
	void ReplicatedEvent ( struct FName VarName );
	void UnTouch ( class AActor* Other );
	void Touch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	bool GiveScan ( class AYPawn_Multiplayer* P );
	bool GiveArmor ( class AYPawn_Multiplayer* P );
	bool GiveExplosive ( class AYPawn_Multiplayer* P );
	bool GiveAmmo ( class AYPawn_Multiplayer* P );
	bool GiveHealth ( class AYPawn_Multiplayer* P );
	void InitializePickup ( );
};

UClass* AYPickup_FremenLoot::pClassPointer = NULL;

// Class SRGame.YPickup_Grenade
// 0x006C (0x033C - 0x02D0)
class AYPickup_Grenade : public AYPickupActor
{
public:
	unsigned char                                      m_grenadeType;                                    		// 0x02D0 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_numRemainingGrenades;                           		// 0x02D1 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_ammoType;                                       		// 0x02D2 (0x0001) [0x0000000000000000]              
	class USkeletalMesh*                               m_grenadeBoxMesh;                                 		// 0x02D4 (0x0004) [0x0000000000000000]              
	class UPhysicsAsset*                               m_grenadeBoxPhysics;                              		// 0x02D8 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_openAnimSeq;                                    		// 0x02DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_used : 1;                                       		// 0x02E0 (0x0004) [0x0000000000000000] [0x00000001] 
	class UAnimTree*                                   m_animtree;                                       		// 0x02E4 (0x0004) [0x0000000000000000]              
	class UAnimSet*                                    m_animSet;                                        		// 0x02E8 (0x0004) [0x0000000000000000]              
	class USkeletalMesh*                               m_beltMesh;                                       		// 0x02EC (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	class UPhysicsAsset*                               m_beltPhysics;                                    		// 0x02F0 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	struct FName                                       m_beltSocketNames[ 0x5 ];                         		// 0x02F4 (0x0028) [0x0000000020000000]              ( CPF_Deprecated )
	class USkeletalMeshComponent*                      m_grenadeMeshes[ 0x5 ];                           		// 0x031C (0x0014) [0x0000000024080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline | CPF_Deprecated )
	TArray< struct FString >                           m_grenadesFullMessages;                           		// 0x0330 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2065 ];

		return pClassPointer;
	};

	unsigned char GetScanableType ( int m_scanningTeamIdx );
	bool IsUsed ( );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	struct FBoxSphereBounds GetBounds ( );
	bool IsEnabledForTacView ( );
	void ApplyCheckpointRecord ( struct AYPickupActor_FCheckpointRecord* Record );
	void CreateCheckpointRecord ( struct AYPickupActor_FCheckpointRecord* Record );
	bool ShouldSaveForCheckpoint ( );
	void PlayOpenAnimFinished ( );
	void PlayOpenAnim ( );
	void ResetUsedPickup ( );
	void DisablePickup ( );
	void SetPickupVisible ( );
	struct FString GetAmmoFullMessage ( );
	void GetPickupInfo ( int Index, struct FString* Message, struct FString* Icon, struct FString* message2 );
	void GetPickupInfoFromPickup ( int Index, int overrideRefillCount, struct FString* Message, struct FString* Icon, struct FString* message2 );
	struct FString GetMessage ( class AYArsenalManager* arsenalManager );
	bool DoPickup ( class AYGamePawn* Pawn );
	void InitializePickup ( );
};

UClass* AYPickup_Grenade::pClassPointer = NULL;

// Class SRGame.YPickup_Weapon
// 0x002C (0x02FC - 0x02D0)
class AYPickup_Weapon : public AYPickupActor
{
public:
	unsigned char                                      m_weaponEnum;                                     		// 0x02D0 (0x0001) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	class UClass*                                      m_weaponClass;                                    		// 0x02D4 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	class UYWeaponData_Mesh*                           m_weaponMeshData;                                 		// 0x02D8 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_ammoInMagazine;                                 		// 0x02DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_ammoInReserve;                                  		// 0x02E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_ammoInMagazineScnd;                             		// 0x02E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_ammoInReserveScnd;                              		// 0x02E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_scndModeActivated : 1;                          		// 0x02EC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_weaponHasScndMode : 1;                          		// 0x02EC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_weaponRack : 1;                                 		// 0x02EC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_allowNonWeaponMesh : 1;                         		// 0x02EC (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	class AYWeapon*                                    m_weapon;                                         		// 0x02F0 (0x0004) [0x0000000000000000]              
	class AYGamePawn*                                  m_KillerPawn;                                     		// 0x02F4 (0x0004) [0x0000000000000000]              
	class AYGamePawn*                                  m_DroppedByPawn;                                  		// 0x02F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2066 ];

		return pClassPointer;
	};

	void ApplyCheckpointRecord ( struct AYPickupActor_FCheckpointRecord* Record );
	void CreateCheckpointRecord ( struct AYPickupActor_FCheckpointRecord* Record );
	bool ShouldSaveForCheckpoint ( );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	struct FBoxSphereBounds GetBounds ( );
	bool IsEnabledForTacView ( );
	void OnPickupEmpty ( );
	void OnAmmoTakenByWeapon ( class AYGamePawn* Pawn, int refillAmount, unsigned long bSecondaryMode );
	void GetPickupInfo ( int Index, struct FString* Message, struct FString* Icon, struct FString* message2 );
	void GetPickupInfoFromPickup ( int Index, int overrideRefillCount, struct FString* Message, struct FString* Icon, struct FString* message2 );
	struct FString GetMessage ( class AYArsenalManager* arsenalManager );
	void SetPickupSkelMesh ( class USkeletalMesh* NewMesh );
	void InitializeFromWeaponToss ( class AYWeapon* Wpn );
	bool DoPickup ( class AYGamePawn* Pawn );
	bool DoPickupMove ( class AYGamePawn* Pawn, unsigned char specialMove );
	void InitializePickup ( );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYPickup_Weapon::pClassPointer = NULL;

// Class SRGame.YPickup_WeaponSpawnable
// 0x001C (0x0318 - 0x02FC)
class AYPickup_WeaponSpawnable : public AYPickup_Weapon
{
public:
	unsigned long                                      m_initTemporarily : 1;                            		// 0x02FC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_droppedByPlayer : 1;                            		// 0x02FC (0x0004) [0x0000000000000000] [0x00000002] 
	struct FVector                                     m_replicateLinVelocity;                           		// 0x0300 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_replicateAngVelocity;                           		// 0x030C (0x000C) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2067 ];

		return pClassPointer;
	};

	void ReplicatedEvent ( struct FName VarName );
	void SetSkelMeshVelocities ( struct FVector LinVel, struct FVector AngVel );
	bool ShouldSaveForCheckpoint ( );
	void OutsideWorldBounds ( );
	void FellOutOfWorld ( class UClass* dmgType );
	void DestroyPickup ( );
	void DisablePickup ( );
	void SetPickupVisible ( );
	void StartPhysic ( );
	void HideAmmoMesh ( );
	void SetPickupSkelMesh ( class USkeletalMesh* NewMesh );
	void InitializePickup ( );
};

UClass* AYPickup_WeaponSpawnable::pClassPointer = NULL;

// Class SRGame.YPickupGold
// 0x0054 (0x0324 - 0x02D0)
class AYPickupGold : public AYPickupActor
{
public:
	int                                                m_GoldAmount;                                     		// 0x02D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_goldSize;                                       		// 0x02D4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_used : 1;                                       		// 0x02D8 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      bDropped : 1;                                     		// 0x02D8 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      bScoring : 1;                                     		// 0x02D8 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	class UYMarkerBase*                                m_TacBase;                                        		// 0x02DC (0x0004) [0x0000000000000000]              
	int                                                m_scoringTeam;                                    		// 0x02E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYPlayerReplicationInfo_SW*                  m_droppedPRI;                                     		// 0x02E4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYGamePawn*                                  m_PickupPawn;                                     		// 0x02E8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_LastPickupSpot;                                 		// 0x02EC (0x000C) [0x0000000000000000]              
	struct FVector                                     m_meshLocation;                                   		// 0x02F8 (0x000C) [0x0000000000000000]              
	int                                                m_MedGoldAmount;                                  		// 0x0304 (0x0004) [0x0000000000000000]              
	int                                                m_LargeGoldAmount;                                		// 0x0308 (0x0004) [0x0000000000000000]              
	struct FString                                     m_sameTeamPickupMessage;                          		// 0x030C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_goldFullMessage;                                		// 0x0318 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2068 ];

		return pClassPointer;
	};

	void VolumeBasedDestroy ( class APhysicsVolume* PV );
	void OutsideWorldBounds ( );
	void FellOutOfWorld ( class UClass* dmgType );
	void SetSkelMesh ( );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	void DisablePickup ( );
	void SetPickupVisible ( );
	void PostBeginPlay ( );
	void GetPickupInfo ( int Index, struct FString* Message, struct FString* Icon, struct FString* message2 );
	void GetPickupInfoFromPickup ( int Index, int overrideRefillCount, struct FString* Message, struct FString* Icon, struct FString* message2 );
	struct FString GetMessage ( class AYArsenalManager* arsenalManager );
	void ResetUsedPickup ( );
	struct FString GetAmmoFullMessage ( );
	bool DoPickupMove ( class AYGamePawn* Pawn, unsigned char specialMove );
	void SpawnAtNewSpot ( struct FVector pos );
	void Respawn ( );
	struct FString getlocationstring ( );
	bool DoPickup ( class AYGamePawn* Pawn );
	bool IsEnabledForTacView ( );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYPickupGold::pClassPointer = NULL;

// Class SRGame.YProjectile
// 0x01A8 (0x03DC - 0x0234)
class AYProjectile : public AProjectile
{
public:
	struct FVector                                     m_lastHitNormal;                                  		// 0x0234 (0x000C) [0x0000000000000000]              
	class USkeletalMeshComponent*                      m_projSkelMesh;                                   		// 0x0240 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_speed;                                          		// 0x0244 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_acceleration;                                   		// 0x0248 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x024C (0x0004) MISSED OFFSET
	struct FRigidBodyState                             RBState;                                          		// 0x0250 (0x0040) [0x0000000000001022]              ( CPF_Const | CPF_Net | CPF_Native )
	float                                              AngErrorAccumulator;                              		// 0x0290 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	float                                              m_moveTimeLeft;                                   		// 0x0294 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_isShutDown : 1;                                 		// 0x0298 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_onlyDirectDamage : 1;                           		// 0x0298 (0x0004) [0x0000000000004001] [0x00000002] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_noRadialDamage : 1;                             		// 0x0298 (0x0004) [0x0000000000004001] [0x00000004] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_suppressDamage : 1;                             		// 0x0298 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_standardEffectOrientationUpwards : 1;           		// 0x0298 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_waitForEffects : 1;                             		// 0x0298 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_explodingOnSand : 1;                            		// 0x0298 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_explodingOnSandPool : 1;                        		// 0x0298 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_spawnFlightParticles : 1;                       		// 0x0298 (0x0004) [0x0000000000004000] [0x00000100] ( CPF_Config )
	unsigned long                                      m_spawnAttractionActor : 1;                       		// 0x0298 (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_attractorStrengthByDistance : 1;                		// 0x0298 (0x0004) [0x0000000000004001] [0x00000400] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_attractorAffectBaseVelocity : 1;                		// 0x0298 (0x0004) [0x0000000000004001] [0x00000800] ( CPF_Edit | CPF_Config )
	unsigned char                                      m_mode;                                           		// 0x029C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_myGrenadeType;                                  		// 0x029D (0x0001) [0x0000000000000000]              
	unsigned char                                      m_attractionType;                                 		// 0x029E (0x0001) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class AActor*                                      m_DirectDamageActor;                              		// 0x02A0 (0x0004) [0x0000000000000000]              
	float                                              m_directDamageValue;                              		// 0x02A4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UYDamageEvaluationParams*                    m_postImpactParams;                               		// 0x02A8 (0x0004) [0x0000000000000000]              
	struct FName                                       m_postImpactParamsName;                           		// 0x02AC (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FName                                       m_overridenPostImpactParamsNameForMP;             		// 0x02B4 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UYDamageEvaluationParams*                    m_secondPostImpactParams;                         		// 0x02BC (0x0004) [0x0000000000000000]              
	struct FName                                       m_secondPostImpactParamsName;                     		// 0x02C0 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UYProjectileDataDispatcher*                  m_dataDispatcher;                                 		// 0x02C8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UYProjData_Mesh*                             m_myMeshData;                                     		// 0x02CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYProjData_GraphicsFX*                       m_myGfxData;                                      		// 0x02D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYProjData_SoundFX*                          m_mySfxData;                                      		// 0x02D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UParticleSystem*                             m_explosionEffectTemplate;                        		// 0x02D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_explosionEffectTemplateOnSand;                  		// 0x02DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_explosionEffectTemplateHit;                     		// 0x02E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_explosionEffectTemplateHitOnSand;               		// 0x02E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_particleSystemUsed4Explosion;                   		// 0x02E8 (0x0004) [0x0000000000000000]              
	class USoundCue*                                   m_explosionSound;                                 		// 0x02EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USoundCue*                                   m_explosionSoundOnSand;                           		// 0x02F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USoundCue*                                   m_explosionNonPlayerSound;                        		// 0x02F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USoundCue*                                   m_explosionNonPlayerSoundOnSand;                  		// 0x02F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ProjGroundDecalDesc                     m_explosionGroundDecal;                           		// 0x02FC (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ProjGroundDecalDesc                     m_explosionGroundDecalOnSand;                     		// 0x030C (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_groundLocationBeneath;                          		// 0x031C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_groundNormalBeneath;                            		// 0x0328 (0x000C) [0x0000000000000000]              
	float                                              m_groundLocCheckDistance;                         		// 0x0334 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_explLocation;                                   		// 0x0338 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_explNormal;                                     		// 0x0344 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FRotator                                    m_explRotation;                                   		// 0x0350 (0x000C) [0x0000000000000000]              
	TArray< class UParticleSystemComponent* >          m_particles;                                      		// 0x035C (0x000C) [0x0000000024480008]              ( CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline | CPF_Deprecated )
	class UParticleSystemComponent*                    m_flightPSC;                                      		// 0x0368 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class UAudioComponent* >                   m_flyingSounds;                                   		// 0x036C (0x000C) [0x0000000024480008]              ( CPF_ExportObject | CPF_Component | CPF_NeedCtorLink | CPF_EditInline | CPF_Deprecated )
	class UAudioComponent*                             m_flyingSound;                                    		// 0x0378 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UPointLightComponent*                        m_explosionLight;                                 		// 0x037C (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_explosionLightDuration;                         		// 0x0380 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FString                                     m_projectileName;                                 		// 0x0384 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FVector                                     m_attractionDrawScale3D;                          		// 0x0390 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_attractorStrength;                              		// 0x039C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_attractorVelocityInfluence;                     		// 0x03A0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_attractorCollisionDamping;                      		// 0x03A4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_attractorLifeSpan;                              		// 0x03A8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_oldBouncePos;                                   		// 0x03AC (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_grenadeAlertDisplayDistancePerk;                		// 0x03B8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_grenadeAlertDisplayDistanceOwner;               		// 0x03BC (0x0004) [0x0000000000004020]              ( CPF_Net | CPF_Config )
	float                                              m_grenadeAlertDisplayDistanceMax;                 		// 0x03C0 (0x0004) [0x0000000000004020]              ( CPF_Net | CPF_Config )
	float                                              m_grenadeAlertDisplayExtensionFactor;             		// 0x03C4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_grenadeAlertDisplaySpecialWpnPerkFactor;        		// 0x03C8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_grenadeAlertDisplayDamageRange;                 		// 0x03CC (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FDecalJobInfo >                     m_pendingDecalJob;                                		// 0x03D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2069 ];

		return pClassPointer;
	};

	void HideProjectile ( );
	void TornOff ( );
	void Tick ( float DeltaTime );
	void ShutDown ( );
	void KillFlightEffects ( );
	void SendExplosionEvents ( );
	void InformPawnsAboutExplosion ( );
	bool CheckLineData ( struct FVector testStart, struct FVector testDir, struct FVector* HitLocation, struct FVector* HitNormal, class UPrimitiveComponent** HitComponent, unsigned char* onSand );
	bool CheckAboveSand ( float MaxDist, struct FVector TestLocation, struct FVector* groundLocation, struct FVector* groundNormal );
	void UpdateDecals ( );
	void SpawnDecal ( struct FVector testStart, struct FVector testDir );
	void SwitchOffExplosionLight ( );
	void PlayExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
	void CheckGroundBeneath ( );
	void SpawnAttractionActor ( struct FVector SpawnLocation );
	void Explode ( struct FVector HitLocation, struct FVector HitNormal );
	void OnExplode ( );
	void InitTracer ( struct FVector StartLoc, struct FVector endLoc, class AYGamePawn* causer );
	void InitTracerNative ( struct FVector StartLoc, struct FVector endLoc, class AYGamePawn* causer );
};

UClass* AYProjectile::pClassPointer = NULL;

// Class SRGame.YProj_Physical
// 0x029C (0x0678 - 0x03DC)
class AYProj_Physical : public AYProjectile
{
public:
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x03DC (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned long                                      bPerformGravity : 1;                              		// 0x03E0 (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_isSimulatingPhyics : 1;                         		// 0x03E0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_isThrownZoomed : 1;                             		// 0x03E0 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_explodeOnContact : 1;                           		// 0x03E0 (0x0004) [0x0000000000004001] [0x00000008] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_explodeOnPawnContact : 1;                       		// 0x03E0 (0x0004) [0x0000000000004001] [0x00000010] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_completelyRandomSpin : 1;                       		// 0x03E0 (0x0004) [0x0000000000004001] [0x00000020] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_predictionIsSliding : 1;                        		// 0x03E0 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_canTriggerGrenadeAchievements : 1;              		// 0x03E0 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_isSliding : 1;                                  		// 0x03E0 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_justBouncedInSim : 1;                           		// 0x03E0 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bouncedOnSand : 1;                              		// 0x03E0 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_causesBloodEffects : 1;                         		// 0x03E0 (0x0004) [0x0000000000004001] [0x00000800] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_exploded : 1;                                   		// 0x03E0 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_spawnLocIndependentFromPawn : 1;                		// 0x03E0 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bIsSimulating : 1;                              		// 0x03E0 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bShowSimulatedEndPosition : 1;                  		// 0x03E0 (0x0004) [0x0000000000000001] [0x00008000] ( CPF_Edit )
	unsigned long                                      m_showSimulationEnd : 1;                          		// 0x03E0 (0x0004) [0x0000000000004000] [0x00010000] ( CPF_Config )
	unsigned long                                      m_tooCloseToWall : 1;                             		// 0x03E0 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_bStartTrail : 1;                                		// 0x03E0 (0x0004) [0x0000000000000020] [0x00040000] ( CPF_Net )
	unsigned long                                      m_bExplodeWhenTakingDamage : 1;                   		// 0x03E0 (0x0004) [0x0000000000000001] [0x00080000] ( CPF_Edit )
	unsigned long                                      m_bDetectable : 1;                                		// 0x03E0 (0x0004) [0x0000000000004000] [0x00100000] ( CPF_Config )
	unsigned long                                      m_bHideTacIconIfStill : 1;                        		// 0x03E0 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_mergeAllDamageForPawn : 1;                      		// 0x03E0 (0x0004) [0x0000000000004000] [0x00400000] ( CPF_Config )
	unsigned long                                      m_ignoreSamePawnBounces : 1;                      		// 0x03E0 (0x0004) [0x0000000000004001] [0x00800000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_bIsBeingDefused : 1;                            		// 0x03E0 (0x0004) [0x0000000000000020] [0x01000000] ( CPF_Net )
	unsigned long                                      m_isMPCustomGrenade : 1;                          		// 0x03E0 (0x0004) [0x0000000000000002] [0x02000000] ( CPF_Const )
	unsigned long                                      m_bForceTriggerSandPool : 1;                      		// 0x03E0 (0x0004) [0x0000000000000000] [0x04000000] 
	float                                              GravityScale;                                     		// 0x03E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              SimFixedTimeStep;                                 		// 0x03E8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              TimeTilNextGravUpdate;                            		// 0x03EC (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              SimInternalGravityAdvanceTime;                    		// 0x03F0 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	struct FVector                                     m_lastGrenadeSimNormal;                           		// 0x03F4 (0x000C) [0x0000000000000000]              
	float                                              m_pitchAngleOffsetThrow;                          		// 0x0400 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAngleOffsetRoll;                           		// 0x0404 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAngleOffsetThrowZoomed;                    		// 0x0408 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAngleOffsetRollZoomed;                     		// 0x040C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAngleOffsetReductionStartAngle;            		// 0x0410 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchAngleOffsetReductionEndAngle;              		// 0x0414 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchDependentYawAdaptionStartPitchAngle;       		// 0x0418 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchDependentYawAdaptionEndPitchAngle;         		// 0x041C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pitchDependentYawAdaptionMaxYawAngle;           		// 0x0420 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_throwHeightOffsetMultiplyer;                    		// 0x0424 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_throwDurationTime;                              		// 0x0428 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minKeepRollingVelocity;                         		// 0x042C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lifeTimeRoll;                                   		// 0x0430 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lifeTimeThrow;                                  		// 0x0434 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_gravityScaleRoll;                               		// 0x0438 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_gravityScaleThrow;                              		// 0x043C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_gravityScaleRollZoomed;                         		// 0x0440 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_gravityScaleThrowZoomed;                        		// 0x0444 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_numBouncesMaxRoll;                              		// 0x0448 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_numBouncesMaxThrow;                             		// 0x044C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_numBouncesMaxSand;                              		// 0x0450 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_startSpeedRoll;                                 		// 0x0454 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_startSpeedThrow;                                		// 0x0458 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_startSpeedRollZoomed;                           		// 0x045C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_startSpeedThrowZoomed;                          		// 0x0460 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_bounceMinAngleRoll;                             		// 0x0464 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_bounceMinValueRoll;                             		// 0x0468 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_bounceMaxAngleRoll;                             		// 0x046C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_bounceMaxValueRoll;                             		// 0x0470 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_bounceMinAngleThrow;                            		// 0x0474 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_bounceMinValueThrow;                            		// 0x0478 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_bounceMaxAngleThrow;                            		// 0x047C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_bounceMaxValueThrow;                            		// 0x0480 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sandRestitutionFactor;                          		// 0x0484 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pawnHitRestitutionFactor;                       		// 0x0488 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pawnVelocityInfluenceRollX;                     		// 0x048C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pawnVelocityInfluenceRollY;                     		// 0x0490 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pawnVelocityInfluenceThrowX;                    		// 0x0494 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_pawnVelocityInfluenceThrowY;                    		// 0x0498 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FRotator                                    m_randomSpinMin;                                  		// 0x049C (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FRotator                                    m_randomSpinMax;                                  		// 0x04A8 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_predictionBounceFactor;                         		// 0x04B4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_predictionGravityFactor;                        		// 0x04B8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_predictionTimeStep;                             		// 0x04BC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_predictionDampingFactor;                        		// 0x04C0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_numPredictionStepsPerFrame;                     		// 0x04C4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_predictedVelocity;                              		// 0x04C8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_predictedLocation;                              		// 0x04D4 (0x000C) [0x0000000000000000]              
	float                                              m_currentPredictionTime;                          		// 0x04E0 (0x0004) [0x0000000000000000]              
	int                                                m_currentNumPredictionBounces;                    		// 0x04E4 (0x0004) [0x0000000000000000]              
	float                                              m_startTime;                                      		// 0x04E8 (0x0004) [0x0000000000000000]              
	int                                                m_killCount;                                      		// 0x04EC (0x0004) [0x0000000000000000]              
	float                                              m_zRestitutionThreshold;                          		// 0x04F0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_lastDebugPosition;                              		// 0x04F4 (0x000C) [0x0000000000000000]              
	int                                                m_debugCounter;                                   		// 0x0500 (0x0004) [0x0000000000000000]              
	float                                              m_individualLifeTime;                             		// 0x0504 (0x0004) [0x0000000000000000]              
	float                                              m_standardLifeTime;                               		// 0x0508 (0x0004) [0x0000000000000000]              
	float                                              m_maxLifetime;                                    		// 0x050C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxLifetimeRoll;                                		// 0x0510 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_startGrenadeCount;                              		// 0x0514 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_numBounces;                                     		// 0x0518 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_groundNormalAccel;                              		// 0x051C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_locationOfLastBounce;                           		// 0x0528 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_normalOfLastBounce;                             		// 0x0534 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_lastBouncePosition;                             		// 0x0540 (0x000C) [0x0000000000000000]              
	float                                              m_plentyBloodEffectsRadius;                       		// 0x054C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_mediumBloodEffectsRadius;                       		// 0x0550 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_fewBloodEffectsRadius;                          		// 0x0554 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_plentyBloodEffectsCount;                        		// 0x0558 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_mediumBloodEffectsCount;                        		// 0x055C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_fewBloodEffectsCount;                           		// 0x0560 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UYSoundCueFMOD*                              m_bounceSound;                                    		// 0x0564 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_bounceSoundOnSand;                              		// 0x0568 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_activationSound;                                		// 0x056C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_lastPosition;                                   		// 0x0570 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_camAttractDistance;                             		// 0x057C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_camAttractVelocity;                             		// 0x0588 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_moveAmountDone;                                 		// 0x0594 (0x000C) [0x0000000000000000]              
	float                                              m_timeToReachCameraLine;                          		// 0x05A0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UParticleSystem*                             PS_Simulatedarc;                                  		// 0x05A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_interpolatedNormalEndPosition;                  		// 0x05A8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class AController*                                 m_causer;                                         		// 0x05B4 (0x0004) [0x0000000000000000]              
	TArray< class AController* >                       m_detectedByList;                                 		// 0x05B8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UParticleSystem*                             PS_SimulatedEnd;                                  		// 0x05C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AYGamePawn*                                  m_causerPawn;                                     		// 0x05C8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class APlayerReplicationInfo*                      m_causerPawnPRI;                                  		// 0x05CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UParticleSystemComponent*                    m_spawnPSC;                                       		// 0x05D0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_minRequiredFlightDistance;                      		// 0x05D4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FVector                                     m_spawnLocation;                                  		// 0x05D8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_oldLocation;                                    		// 0x05E4 (0x000C) [0x0000000000000000]              
	float                                              m_grenadeLifeSpan;                                		// 0x05F0 (0x0004) [0x0000000000000000]              
	float                                              m_currentSimulationTime;                          		// 0x05F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_lastSimPosition;                                		// 0x05F8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class AEmitter*                                    m_grenadeTrail;                                   		// 0x0604 (0x0004) [0x0000000000000000]              
	class UParticleSystem*                             m_grenadeTrailTemplate;                           		// 0x0608 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInterface*                          m_ArcEndSpotMaterialParent;                       		// 0x060C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UDynamicLightEnvironmentComponent*           m_lightEnvironment;                               		// 0x0610 (0x0004) [0x000000000408000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMaterialInterface*                          m_silhouetteMaterial;                             		// 0x0614 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_tacIconClass;                                   		// 0x0618 (0x0004) [0x0000000000000000]              
	class UYMarkerBase*                                m_tacIcon;                                        		// 0x061C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_tacIconDisplay;                                 		// 0x0620 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_aiImpactType;                                   		// 0x0621 (0x0001) [0x0000000000000000]              
	struct FTextureCoordinates                         m_texCoords;                                      		// 0x0624 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FTextureCoordinates                         m_texCoordsInactive;                              		// 0x0634 (0x0010) [0x0000000000004000]              ( CPF_Config )
	class AYGamePawn*                                  m_stuckToPawn;                                    		// 0x0644 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_collisionRadius;                                		// 0x0648 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_pickupMaterial;                                 		// 0x064C (0x0004) [0x0000000000000000]              
	float                                              m_grenadeMarkerDelay;                             		// 0x0650 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_markerTime;                                     		// 0x0654 (0x0004) [0x0000000000000000]              
	class AYGamePawn*                                  m_lastHitPawn;                                    		// 0x0658 (0x0004) [0x0000000000000000]              
	float                                              m_lastHitPawnFirstBounceTime;                     		// 0x065C (0x0004) [0x0000000000000000]              
	float                                              m_hitSamePawnDamageInterval;                      		// 0x0660 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sandFogIntensityScale;                          		// 0x0664 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class AActor*                                      m_ownerForSpecialWeapon;                          		// 0x0668 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FScriptDelegate                             __OnExploding__Delegate;                          		// 0x066C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2070 ];

		return pClassPointer;
	};

	bool CheckMetalDetectorDistance ( );
	void AdjustEndPosition ( struct FVector StartLoc, struct FVector* endLoc );
	void GetAnimProperties ( struct FName SequenceName, float* SequenceLength, struct FVector* RootMotion );
	void GetAnimRootMotion ( class UAnimSequence* Sequence, struct FVector* RootMotion );
	void InitGrenade ( class AActor* callActorMethodsHere, class AYProj_Physical* spawnedGrenade, unsigned char throwMode, struct FVector Start, struct FVector End, struct FVector AimDir );
	void OnDetected ( unsigned long detected );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	struct FBoxSphereBounds GetBounds ( );
	bool IsEnabledForTacView ( );
	void OnToggle ( class USeqAct_Toggle* seqAct );
	void Tick ( float DeltaTime );
	bool IsDetected ( class AYGamePawn* myPawn );
	void OnExploding ( );
	void TakeDamage ( int DamageAmount, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void OnStopMove ( );
	void RaiseAIGrenadeBounceEvent ( );
	void HitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void SpawnHitOnSurfaceEmitter ( struct FVector HitNormal, unsigned long bAboveSand );
	bool StickOnBone ( struct FVector HitNormal, class AActor* Pawn, class UPrimitiveComponent* Comp );
	void StickAndAlignOnSurface ( struct FVector HitNormal );
	void StickOnSurface ( struct FVector HitNormal );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void DoPrediction ( );
	void RandSpinNative ( float spinRate );
	void Bounce ( struct FVector HitNormal, class AActor* HitActor, unsigned long isPrediction, struct FVector* vel, int* currentNumBounces );
	void StopTrail ( );
	void StartTrail ( );
	void InitTracerExact ( struct FVector StartLoc, struct FVector endLoc, unsigned long exact, class AYGamePawn* causer );
	void InitCauser ( class AController* C );
	float GetThrowSpeedModifier ( class AYGamePawn* ThrowingPawn );
	void InitTracer ( struct FVector StartLoc, struct FVector endLoc, class AYGamePawn* causer );
	void CalcExactCurve ( struct FVector StartLoc, struct FVector endLoc, float* startSpeed, struct FVector* AimDir );
	struct FVector CalculateTracerVectorByTime ( float timeTilImpact, struct FVector StartLoc, struct FVector endLoc, float* startSpeed );
	struct FVector CalculateTracerVectorBySpeed ( struct FVector StartLoc, struct FVector endLoc, float* startSpeed );
	float CalculateTracerSpeed ( struct FVector AimDir, struct FVector StartLoc, struct FVector endLoc );
	void InitForSimulation ( class AYGamePawn* Pawn, unsigned long noOnlyOwnerSee, unsigned long noVisuals );
	void SetupForSimulation ( unsigned long bSimulating, unsigned long noVisuals );
	void PlayExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
	void Explode ( struct FVector HitLocation, struct FVector HitNormal );
	void TimeExplosion ( class AYGamePawn* ThrowingPawn );
	struct FVector GetExplosionOriginOffset ( );
	struct FVector GetExplosionNormal ( );
	void OnExplode ( );
	void SandFogVolumeTriggerPawns ( class AYFogVolumeSandDensityInfo* hitVolume );
	class AYFogVolumeSandDensityInfo* ShowSandFogVolume ( struct FVector HitLocation );
	void SendStickyExplodedEvent ( class AYGamePawn* Pawn );
	void UpdateGrenadeTargetMarker ( class AYGamePawn* Pawn );
	bool RunPhysicsSimulation ( int iterations, unsigned long onlyMinFlightDistance, class AYGamePawn* Pawn );
	float GetEstimatedAimingPlaneContactDist ( struct FVector AimDir, struct FVector CamLoc, unsigned long zoomed );
	void ScoreKill ( );
	float GetLifeTimeThrow ( unsigned long simMode );
	void StartTrailIfAllowed ( );
	void EnableSilhouette ( class UMaterialInterface* Mat );
	void FinishDefusing ( );
	void SetIsBeingDefused ( unsigned long in_IsBeingDefused );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYProj_Physical::pClassPointer = NULL;

// Class SRGame.YProj_MPFragGrenade
// 0x0000 (0x0678 - 0x0678)
class AYProj_MPFragGrenade : public AYProj_Physical
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2071 ];

		return pClassPointer;
	};

};

UClass* AYProj_MPFragGrenade::pClassPointer = NULL;

// Class SRGame.YProj_MPOfficerBeacon
// 0x0018 (0x0690 - 0x0678)
class AYProj_MPOfficerBeacon : public AYProj_Physical
{
public:
	class UParticleSystem*                             m_beaconRadiusFx;                                 		// 0x0678 (0x0004) [0x0000000000000000]              
	float                                              m_timeBetweenBeaconEffects;                       		// 0x067C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_beaconLifetime;                                 		// 0x0680 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_effectiveDistance;                              		// 0x0684 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_DamageReduction;                                		// 0x0688 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_DamageIncrease;                                 		// 0x068C (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2072 ];

		return pClassPointer;
	};

	void TimeExplosion ( class AYGamePawn* ThrowingPawn );
	void OnBeaconDone ( );
	void PlayBeaconEffect ( );
	void RemoveTeamBeacon ( );
	void CheckTeamDistance ( );
	void Destroyed ( );
	void InitForSimulation ( class AYGamePawn* Pawn, unsigned long noOnlyOwnerSee, unsigned long noVisuals );
	void PostBeginPlay ( );
	void ServerRemoveExistingObjectivesBySameOwner ( );
	void InitCauser ( class AController* C );
	bool IsEnabledForTacView ( );
};

UClass* AYProj_MPOfficerBeacon::pClassPointer = NULL;

// Class SRGame.YProj_MPOfficerSupply
// 0x001C (0x0694 - 0x0678)
class AYProj_MPOfficerSupply : public AYProj_Physical
{
public:
	class UParticleSystem*                             m_supplyRadiusFx;                                 		// 0x0678 (0x0004) [0x0000000000000000]              
	float                                              m_timeBetweenSupplyEffects;                       		// 0x067C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_effectiveDistance;                              		// 0x0680 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_supplyLifetime;                                 		// 0x0684 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FUniqueNetId >                      m_playersAffected;                                		// 0x0688 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2073 ];

		return pClassPointer;
	};

	void TimeExplosion ( class AYGamePawn* ThrowingPawn );
	void OnSupplyDone ( );
	void PlaySupplyEffect ( );
	void RemoveTeamSupply ( );
	void CheckTeamDistance ( );
	void Destroyed ( );
	void InitGrenade ( class AActor* callActorMethodsHere, class AYProj_Physical* spawnedGrenade, unsigned char throwMode, struct FVector Start, struct FVector End, struct FVector AimDir );
	void InitForSimulation ( class AYGamePawn* Pawn, unsigned long noOnlyOwnerSee, unsigned long noVisuals );
	void PostBeginPlay ( );
	void Bounce ( struct FVector HitNormal, class AActor* HitActor, unsigned long isPrediction, struct FVector* vel, int* currentNumBounces );
	void ServerRemoveExistingSuppliesBySameOwner ( );
	void InitCauser ( class AController* C );
	bool IsEnabledForTacView ( );
};

UClass* AYProj_MPOfficerSupply::pClassPointer = NULL;

// Class SRGame.YProj_MPPercussionGrenade
// 0x0000 (0x0678 - 0x0678)
class AYProj_MPPercussionGrenade : public AYProj_Physical
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2074 ];

		return pClassPointer;
	};

};

UClass* AYProj_MPPercussionGrenade::pClassPointer = NULL;

// Class SRGame.YProj_PhosphorGrenade_SP
// 0x0024 (0x069C - 0x0678)
class AYProj_PhosphorGrenade_SP : public AYProj_Physical
{
public:
	float                                              m_minHurtingAreaHeight;                           		// 0x0678 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maxHurtingAreaHeight;                           		// 0x067C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minHurtingAreaRadius;                           		// 0x0680 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maxHurtingAreaRadius;                           		// 0x0684 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_groundDistForMinRadius;                         		// 0x0688 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_groundDistForMaxRadius;                         		// 0x068C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_hurtAreaDmgPerSec;                              		// 0x0690 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_hurtAreaLifeTime;                               		// 0x0694 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_speedToReachGround;                             		// 0x0698 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2075 ];

		return pClassPointer;
	};

	void PlayExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
};

UClass* AYProj_PhosphorGrenade_SP::pClassPointer = NULL;

// Class SRGame.YProj_ProxyGrenade
// 0x0020 (0x0698 - 0x0678)
class AYProj_ProxyGrenade : public AYProj_Physical
{
public:
	float                                              m_proximationRange;                               		// 0x0678 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_activationTime;                                 		// 0x067C (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	class UCylinderComponent*                          m_explodeComponent;                               		// 0x0680 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned long                                      m_bMineActivated : 1;                             		// 0x0684 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bActiationVictimLocationSet : 1;                		// 0x0684 (0x0004) [0x0000000000000000] [0x00000002] 
	class APawn*                                       m_pVictim;                                        		// 0x0688 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_ActivationVictimLocation;                       		// 0x068C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2076 ];

		return pClassPointer;
	};

	bool IsEnabledForTacView ( );
	bool IsDetected ( class AYGamePawn* myPawn );
	void Activate ( );
	void OnStopMove ( );
	void Bounce ( struct FVector HitNormal, class AActor* HitActor, unsigned long isPrediction, struct FVector* vel, int* currentNumBounces );
};

UClass* AYProj_ProxyGrenade::pClassPointer = NULL;

// Class SRGame.YProj_RemoteGrenade
// 0x000C (0x0684 - 0x0678)
class AYProj_RemoteGrenade : public AYProj_Physical
{
public:
	float                                              m_activationTime;                                 		// 0x0678 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	class UCylinderComponent*                          m_explodeComponent;                               		// 0x067C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class AYGamePawn*                                  m_pawnToStickOn;                                  		// 0x0680 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2077 ];

		return pClassPointer;
	};

	void FinishDefusing ( );
	struct FVector GetExplosionOriginOffset ( );
	bool IsDetected ( class AYGamePawn* myPawn );
	struct FVector GetExplosionNormal ( );
	void HitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void StartExplosionProcess ( );
	float GetLifeTimeThrow ( unsigned long simMode );
	void Explode ( struct FVector HitLocation, struct FVector HitNormal );
	void Bounce ( struct FVector HitNormal, class AActor* HitActor, unsigned long isPrediction, struct FVector* vel, int* currentNumBounces );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYProj_RemoteGrenade::pClassPointer = NULL;

// Class SRGame.YProj_StickyGrenade_Base
// 0x001C (0x0694 - 0x0678)
class AYProj_StickyGrenade_Base : public AYProj_Physical
{
public:
	int                                                m_updateCounter;                                  		// 0x0678 (0x0004) [0x0000000000000000]              
	float                                              m_lastUpdate;                                     		// 0x067C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsSoundPlaying : 1;                            		// 0x0680 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_debugView : 1;                                  		// 0x0680 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_wallHit : 1;                                    		// 0x0680 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_lifeTimeWhenAttachedToPawn;                     		// 0x0684 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_nudgeFactor;                                    		// 0x0688 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_magRange;                                       		// 0x068C (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UAudioComponent*                             m_activationSoundComponent;                       		// 0x0690 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2078 ];

		return pClassPointer;
	};

	void PlayExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
	void OnExplode ( );
	void CheckEnemies ( struct FVector sourcePos );
	void Bounce ( struct FVector HitNormal, class AActor* HitActor, unsigned long isPrediction, struct FVector* vel, int* currentNumBounces );
	void HitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void Tick ( float DeltaTime );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void InitTracer ( struct FVector StartLoc, struct FVector endLoc, class AYGamePawn* causer );
};

UClass* AYProj_StickyGrenade_Base::pClassPointer = NULL;

// Class SRGame.YProj_Tracer
// 0x0054 (0x0430 - 0x03DC)
class AYProj_Tracer : public AYProjectile
{
public:
	class UStaticMeshComponent*                        m_projMesh;                                       		// 0x03DC (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ULightComponent*                             m_flightLight;                                    		// 0x03E0 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_minDistanceToSpawnTracer;                       		// 0x03E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_wakeProjectileFnc;                              		// 0x03E8 (0x0008) [0x0000000000000000]              
	struct FName                                       m_sleepProjectileFnc;                             		// 0x03F0 (0x0008) [0x0000000000000000]              
	struct FVector                                     m_destinationLoc;                                 		// 0x03F8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_accelRate;                                      		// 0x0404 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_meshScaleUpTime;                                		// 0x0408 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_meshScaleDownTime;                              		// 0x040C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bScaledUp : 1;                                  		// 0x0410 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bScalingDown : 1;                               		// 0x0410 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_curScale;                                       		// 0x0414 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_tracerDrawScale3D;                              		// 0x0418 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_saveVelocity;                                   		// 0x0424 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2079 ];

		return pClassPointer;
	};

	void Explode ( struct FVector HitLocation, struct FVector HitNormal );
	void KillTracer ( );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void Tick ( float DeltaTime );
	void Reset ( );
	void OutsideWorldBounds ( );
	void SleepProjectile ( );
	void WakeProjectile ( );
	void Update ( float DeltaTime );
	void KillProjectile ( );
	void ScaleUpFinishedNotify ( );
	void ScaleDownFinishedNotify ( );
	void Recycle ( );
};

UClass* AYProj_Tracer::pClassPointer = NULL;

// Class SRGame.YTracerAsset
// 0x0009 (0x0045 - 0x003C)
class UYTracerAsset : public UObject
{
public:
	class AYProj_Tracer*                               m_projectileTracerArchetype;                      		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AYOPEmitter*                                 m_emitterTracerArchetype;                         		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_tracerCategory;                                 		// 0x0044 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2080 ];

		return pClassPointer;
	};

};

UClass* UYTracerAsset::pClassPointer = NULL;

// Class SRGame.YTracerPoolData
// 0x000C (0x0048 - 0x003C)
class UYTracerPoolData : public UObject
{
public:
	TArray< struct FYS_TracerPoolEntry >               m_tracerEntries;                                  		// 0x003C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2081 ];

		return pClassPointer;
	};

};

UClass* UYTracerPoolData::pClassPointer = NULL;

// Class SRGame.YTurretActor
// 0x00D0 (0x0304 - 0x0234)
class AYTurretActor : public ASkeletalMeshActor
{
public:
	struct FPointer                                    VfTable_IYIScanable;                              		// 0x0234 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x0238 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class USkeletalMeshComponent*                      m_mountComponent;                                 		// 0x023C (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class USkeletalMeshComponent*                      m_turretComponent;                                		// 0x0240 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned char                                      m_mountType;                                      		// 0x0244 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_turretType;                                     		// 0x0245 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_turretWeaponClasses[ 0x8 ];                     		// 0x0246 (0x0008) [0x0000000000000000]              
	unsigned char                                      m_weaponClass;                                    		// 0x024E (0x0001) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned char                                      m_camMode;                                        		// 0x024F (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_camTraceOffsets[ 0x8 ];                         		// 0x0250 (0x0060) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_showShield : 1;                                 		// 0x02B0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_occupied : 1;                                   		// 0x02B0 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_silhouetteShowing : 1;                          		// 0x02B0 (0x0004) [0x0000000000000000] [0x00000004] 
	class UYWeaponDataDispatcher*                      m_dataDispatcher;                                 		// 0x02B4 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	float                                              m_FOVOverride;                                    		// 0x02B8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_FOVOverrideAiming;                              		// 0x02BC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMesh*                               m_mountMeshes[ 0x2 ];                             		// 0x02C0 (0x0008) [0x0000000000000000]              
	class UPhysicsAsset*                               m_mountPhysics[ 0x2 ];                            		// 0x02C8 (0x0008) [0x0000000000000000]              
	struct FName                                       m_mountSocketName;                                		// 0x02D0 (0x0008) [0x0000000000000000]              
	class UYOverheating*                               m_overHeating;                                    		// 0x02D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_heatLevel;                                      		// 0x02DC (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UYSkelControlLookAt* >               m_lookAtSkelCtrls;                                		// 0x02E0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             m_lookAtSkelCtrlNames;                            		// 0x02EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UClass*                                      m_tacIconClass;                                   		// 0x02F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYMarkerBase*                                m_tacIcon;                                        		// 0x02FC (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_silhouetteMaterial;                             		// 0x0300 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2082 ];

		return pClassPointer;
	};

	void OnDetected ( unsigned long detected );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	struct FBoxSphereBounds GetBounds ( );
	bool IsEnabledForTacView ( );
	void SetSilhouetteMaterial ( class UMaterialInterface* Mat );
	void EnableSilhouette ( unsigned long Enable );
	void OnToggle ( class USeqAct_Toggle* Action );
	void OnDestroy ( class USeqAct_Destroy* Action );
	void DoKismetAttachment ( class AActor* Attachment, class USeqAct_AttachToActor* Action );
	unsigned char GetScanableType ( int m_scanningTeamIdx );
	void OnScanEnded ( );
	void DoScanEffects ( );
	void OnScanned ( class AYPlayerController* PC, unsigned char Appearance, float Delay, unsigned long PlaySound );
	float TransferRemainingOverheatTimer ( );
	void Destroyed ( );
	void Tick ( float DeltaTime );
	void SetHeatLevel ( float heatLevel );
	void Occupy ( unsigned long bOccupy );
	int GetCameraMode ( unsigned long Crouched, unsigned long aiming, int* baseOffsetIndex );
	void StraightenLookAtControls ( );
	void HideTurretMesh ( unsigned long Hidden );
	void PostBeginPlay ( );
};

UClass* AYTurretActor::pClassPointer = NULL;

// Class SRGame.YWeapon
// 0x0AB0 (0x0CA8 - 0x01F8)
class AYWeapon : public AActor
{
public:
	struct FString                                     m_weaponName;                                     		// 0x01F8 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_ammoName;                                       		// 0x0204 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	TArray< struct FYS_AIWeaponDesc >                  m_aiWeaponDescs;                                  		// 0x0210 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      m_aiWeaponType;                                   		// 0x021C (0x0001) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	unsigned char                                      m_myWeaponEnum;                                   		// 0x021D (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_killAchievCategory[ 0x2 ];                      		// 0x021E (0x0002) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	unsigned char                                      m_scndModePurpose;                                		// 0x0220 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_activeSecondaryMode;                            		// 0x0221 (0x0001) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	unsigned char                                      m_refireType;                                     		// 0x0222 (0x0001) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned char                                      m_aimReferenceBone;                               		// 0x0223 (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_weaponCategory;                                 		// 0x0224 (0x0001) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned char                                      m_pickupCleanupPrioAgePower;                      		// 0x0225 (0x0001) [0x0000000000044003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_GlobalConfig )
	unsigned char                                      m_pickupCleanupPrioCountPower;                    		// 0x0226 (0x0001) [0x0000000000044003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_GlobalConfig )
	unsigned char                                      m_pickupCleanupPrioDistancePower;                 		// 0x0227 (0x0001) [0x0000000000044003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_GlobalConfig )
	unsigned char                                      m_tossingPriority;                                		// 0x0228 (0x0001) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	unsigned char                                      m_currentFiringSoundState;                        		// 0x0229 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_isSecondary;                                    		// 0x022A (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_frontFallOffType;                               		// 0x022B (0x0001) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned char                                      m_crosshairColorType;                             		// 0x022C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_frontFallOffTypeAI;                             		// 0x022D (0x0001) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned char                                      m_currentFireMode;                                		// 0x022E (0x0001) [0x0000000000000000]              
	unsigned char                                      m_officerSupplyRefillType;                        		// 0x022F (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_tracerInfrequency;                              		// 0x0230 (0x0001) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned char                                      m_tracerCounter;                                  		// 0x0231 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_crosshairBehavior[ 0x5 ];                       		// 0x0232 (0x0005) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_grenadeThrowMode;                               		// 0x0237 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_grenadeSimState;                                		// 0x0238 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_pickupTeam;                                     		// 0x0239 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_forceLaserSight;                                		// 0x023A (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_configTypeLoaded;                               		// 0x023B (0x0001) [0x0000000000002000]              ( CPF_Transient )
	TArray< class USoundCue* >                         m_scndModeTogglingSounds;                         		// 0x023C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UClass*                                      m_damageType;                                     		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              m_aiDPS;                                          		// 0x024C (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_burstFireRounds;                                		// 0x0250 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FYS_WeaponScndMode                          m_standardScndMode;                               		// 0x0254 (0x0008) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	class UYWeaponDataDispatcher*                      m_dataDispatcher;                                 		// 0x025C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned long                                      m_dispatcherProvidedByLevelmap : 1;               		// 0x0260 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	unsigned long                                      m_doNotSuppressImpactByDistance : 1;              		// 0x0260 (0x0004) [0x0000000000004002] [0x00000002] ( CPF_Const | CPF_Config )
	unsigned long                                      m_showImpactsOnlyOnPawnsAndCheapShooters : 1;     		// 0x0260 (0x0004) [0x0000000000004002] [0x00000004] ( CPF_Const | CPF_Config )
	unsigned long                                      m_alwaysRaised : 1;                               		// 0x0260 (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	unsigned long                                      m_canAimOutWhenPeeked : 1;                        		// 0x0260 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_canBlindFire : 1;                               		// 0x0260 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_canRefireInBlindFirePose : 1;                   		// 0x0260 (0x0004) [0x0000000000004001] [0x00000040] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_hasAnyPrimaryAmmo : 1;                          		// 0x0260 (0x0004) [0x0000000000004001] [0x00000080] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_doesSilencedShots : 1;                          		// 0x0260 (0x0004) [0x0000000000004001] [0x00000100] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_bValidForDBNO : 1;                              		// 0x0260 (0x0004) [0x0000000000004001] [0x00000200] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_lowAmmoWarningActivated : 1;                    		// 0x0260 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_isLimitedUse : 1;                               		// 0x0260 (0x0004) [0x0000000000004001] [0x00000800] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_frictionEnabledZoomed : 1;                      		// 0x0260 (0x0004) [0x0000000000004001] [0x00001000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_frictionEnabledUnzoomed : 1;                    		// 0x0260 (0x0004) [0x0000000000004001] [0x00002000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_adhesionEnabledZoomed : 1;                      		// 0x0260 (0x0004) [0x0000000000004001] [0x00004000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_adhesionEnabledUnzoomed : 1;                    		// 0x0260 (0x0004) [0x0000000000004001] [0x00008000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_flipAdhesionDirOnRelativeVelocity : 1;          		// 0x0260 (0x0004) [0x0000000000004001] [0x00010000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_aimSnapOnActiveByDefault : 1;                   		// 0x0260 (0x0004) [0x0000000000004001] [0x00020000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_kismetControlled : 1;                           		// 0x0260 (0x0004) [0x0000000000000020] [0x00040000] ( CPF_Net )
	unsigned long                                      m_kismetFires : 1;                                		// 0x0260 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      m_kismetTargetLikeWeapon : 1;                     		// 0x0260 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_suppressDamage : 1;                             		// 0x0260 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_suppressMuzzleFlash : 1;                        		// 0x0260 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      m_suppressMuzzleAudio : 1;                        		// 0x0260 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_suppressTracers : 1;                            		// 0x0260 (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      m_suppressImpactFX : 1;                           		// 0x0260 (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      m_initialized : 1;                                		// 0x0260 (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      m_autoEquipOnPickup : 1;                          		// 0x0260 (0x0004) [0x0000000000000002] [0x08000000] ( CPF_Const )
	unsigned long                                      m_bPickupNeverDisapear : 1;                       		// 0x0260 (0x0004) [0x0000000000004003] [0x10000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_removeAnimSetWhileGrenadeThrowing : 1;          		// 0x0260 (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      m_oneHandWeapon : 1;                              		// 0x0260 (0x0004) [0x0000000000004003] [0x40000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_hasZoomPostures : 1;                            		// 0x0260 (0x0004) [0x0000000000000003] [0x80000000] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_allowInputToUseAimingProperties : 1;            		// 0x0264 (0x0004) [0x0000000000004002] [0x00000001] ( CPF_Const | CPF_Config )
	unsigned long                                      m_useAimingDOFPostFX : 1;                         		// 0x0264 (0x0004) [0x0000000000004002] [0x00000002] ( CPF_Const | CPF_Config )
	unsigned long                                      m_useComparedSoundCue : 1;                        		// 0x0264 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_isWaitingForBlindfire2Ready : 1;                		// 0x0264 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_replicateInitSecondaryWeaponFlag : 1;           		// 0x0264 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_shareAmmoOnBothFireModes : 1;                   		// 0x0264 (0x0004) [0x0000000000004001] [0x00000020] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_isEquipped : 1;                                 		// 0x0264 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_isToEquip : 1;                                  		// 0x0264 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      m_isActiveMode : 1;                               		// 0x0264 (0x0004) [0x0000000000000020] [0x00000100] ( CPF_Net )
	unsigned long                                      m_deadlyHeadShot : 1;                             		// 0x0264 (0x0004) [0x0000000000004003] [0x00000200] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_deadlyHeadShotAI : 1;                           		// 0x0264 (0x0004) [0x0000000000004003] [0x00000400] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_shotPending : 1;                                		// 0x0264 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_emptySoundPending : 1;                          		// 0x0264 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_isFiring : 1;                                   		// 0x0264 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_useStopFireHack : 1;                            		// 0x0264 (0x0004) [0x0000000000000002] [0x00004000] ( CPF_Const )
	unsigned long                                      m_stopFireHackCheckActive : 1;                    		// 0x0264 (0x0004) [0x0000000000000002] [0x00008000] ( CPF_Const )
	unsigned long                                      m_useExactLoopEnds : 1;                           		// 0x0264 (0x0004) [0x0000000000004001] [0x00010000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_dontRefireScnd : 1;                             		// 0x0264 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_playsRefireAnim : 1;                            		// 0x0264 (0x0004) [0x0000000000004002] [0x00040000] ( CPF_Const | CPF_Config )
	unsigned long                                      m_blendRecoilDefIntoRefireAnim : 1;               		// 0x0264 (0x0004) [0x0000000000004002] [0x00080000] ( CPF_Const | CPF_Config )
	unsigned long                                      m_theLoadedBulletIsTheMagazine : 1;               		// 0x0264 (0x0004) [0x0000000000004002] [0x00100000] ( CPF_Const | CPF_Config )
	unsigned long                                      m_hideAmmoMesh : 1;                               		// 0x0264 (0x0004) [0x0000000000000020] [0x00200000] ( CPF_Net )
	unsigned long                                      m_showAmmoInHUD : 1;                              		// 0x0264 (0x0004) [0x0000000000004001] [0x00400000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_refilledAdditionalBullet : 1;                   		// 0x0264 (0x0004) [0x0000000000000020] [0x00800000] ( CPF_Net )
	unsigned long                                      m_replicatedProjectile : 1;                       		// 0x0264 (0x0004) [0x0000000000004003] [0x01000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_tacticalReloadEnabled : 1;                      		// 0x0264 (0x0004) [0x0000000000004003] [0x02000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_singleShellReload : 1;                          		// 0x0264 (0x0004) [0x0000000000004003] [0x04000000] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_singleShellReloadStarted : 1;                   		// 0x0264 (0x0004) [0x0000000000000020] [0x08000000] ( CPF_Net )
	unsigned long                                      m_singleShellReloadFinished : 1;                  		// 0x0264 (0x0004) [0x0000000000000020] [0x10000000] ( CPF_Net )
	unsigned long                                      m_waitingForServerSingleShellReloadToStop : 1;    		// 0x0264 (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      m_reloadSkipped : 1;                              		// 0x0264 (0x0004) [0x0000000000000020] [0x40000000] ( CPF_Net )
	unsigned long                                      m_isReloading : 1;                                		// 0x0264 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      m_hasRefilledAmmo : 1;                            		// 0x0268 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_adviseReloadAfterFiring : 1;                    		// 0x0268 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_tryWeaponSwitchAfterFiring : 1;                 		// 0x0268 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_spawnTracerOnServer : 1;                        		// 0x0268 (0x0004) [0x0000000000004003] [0x00000008] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_firingStopped : 1;                              		// 0x0268 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_recoilResetAfterFire : 1;                       		// 0x0268 (0x0004) [0x0000000000004003] [0x00000020] ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_doBurst : 1;                                    		// 0x0268 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_isWindingUp : 1;                                		// 0x0268 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_isWindingDown : 1;                              		// 0x0268 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_overheated : 1;                                 		// 0x0268 (0x0004) [0x0000000000000020] [0x00000200] ( CPF_Net )
	unsigned long                                      m_addsPistolGrenadeAnimSet : 1;                   		// 0x0268 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_grenadeSimCalcFinished : 1;                     		// 0x0268 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_canTakeUpWeapon : 1;                            		// 0x0268 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bSimulating : 1;                                		// 0x0268 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bHideAmmocounter : 1;                           		// 0x0268 (0x0004) [0x0000000000004000] [0x00004000] ( CPF_Config )
	unsigned long                                      m_bHideAmmoReserveCounter : 1;                    		// 0x0268 (0x0004) [0x0000000000004000] [0x00008000] ( CPF_Config )
	unsigned long                                      m_causeHeadshotSound : 1;                         		// 0x0268 (0x0004) [0x0000000000004001] [0x00010000] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_isPistol : 1;                                   		// 0x0268 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_makePawnAnimParent : 1;                         		// 0x0268 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_bHidden : 1;                                    		// 0x0268 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      m_noShells : 1;                                   		// 0x0268 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      m_shootIfTriggerIsReleasedBeforeRaise : 1;        		// 0x0268 (0x0004) [0x0000000000004000] [0x00200000] ( CPF_Config )
	unsigned long                                      m_makesHeadExplode : 1;                           		// 0x0268 (0x0004) [0x0000000000004000] [0x00400000] ( CPF_Config )
	unsigned long                                      m_bulletBarTwoRows : 1;                           		// 0x0268 (0x0004) [0x0000000000004000] [0x00800000] ( CPF_Config )
	unsigned long                                      m_pickupDroppingDisabled : 1;                     		// 0x0268 (0x0004) [0x0000000000000000] [0x01000000] 
	struct FName                                       m_dataDispatcherPathName;                         		// 0x026C (0x0008) [0x0000000000000002]              ( CPF_Const )
	class UYWeaponDataDispatcher*                      m_myDispatcher;                                   		// 0x0274 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UYWeaponData_Mesh*                           m_myMeshD;                                        		// 0x0278 (0x0004) [0x0000000000000000]              
	class UYWeaponData_MuzzleGfx*                      m_myGfxD;                                         		// 0x027C (0x0004) [0x0000000000000000]              
	class UYWeaponData_MuzzleSfx*                      m_mySfxD;                                         		// 0x0280 (0x0004) [0x0000000000000000]              
	class UYWeaponData_Tracer*                         m_myTracerD;                                      		// 0x0284 (0x0004) [0x0000000000000000]              
	TArray< int >                                      m_tracerCounters;                                 		// 0x0288 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UForceFeedbackWaveform*                      m_firingForceFeedbackCurve;                       		// 0x0294 (0x0004) [0x0000000000000000]              
	TArray< class UCameraAnim* >                       m_scopeStandCamShake;                             		// 0x0298 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UCameraAnim* >                       m_scopeWalkCamShake;                              		// 0x02A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UCameraAnim*                                 m_firingCamShake[ 0x3 ];                          		// 0x02B0 (0x000C) [0x0000000000000000]              
	class UCameraAnim*                                 m_zoomedFiringCamShake[ 0x3 ];                    		// 0x02BC (0x000C) [0x0000000000000000]              
	class UYWeaponAttachment*                          m_weaponAttachment;                               		// 0x02C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYGamePawn*                                  m_pawn;                                           		// 0x02CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYTurretActor*                               m_turret;                                         		// 0x02D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYCheapShooter*                              m_cheapShooter;                                   		// 0x02D4 (0x0004) [0x0000000000000000]              
	float                                              m_pawnSpeedModifier;                              		// 0x02D8 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_takeOverPawnSpeedReductionFactor;               		// 0x02DC (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	class USkeletalMeshComponent*                      m_weaponMeshComp;                                 		// 0x02E0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_raiseWeaponTestLength;                          		// 0x02E4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FName                                       m_muzzleBoneName;                                 		// 0x02E8 (0x0008) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FName                                       m_laserScopeBoneName;                             		// 0x02F0 (0x0008) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_refireInterval;                                 		// 0x02F8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_refireIntervalAudio;                            		// 0x02FC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UParticleSystem*                             m_laserPointerTemplate;                           		// 0x0300 (0x0004) [0x0000000000000000]              
	class UParticleSystem*                             m_laserSightPSCTemplate;                          		// 0x0304 (0x0004) [0x0000000000000000]              
	struct FYS_RecoilDef                               m_weaponRecoilDef;                                		// 0x0308 (0x0070) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FYS_RecoilDef                               m_spineRecoilDef;                                 		// 0x0378 (0x0070) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FYS_RecoilDef                               m_leftShoulderRecoilDef;                          		// 0x03E8 (0x0070) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FYS_RecoilDef                               m_rightShoulderRecoilDef;                         		// 0x0458 (0x0070) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FTextureCoordinates                         m_texCoords;                                      		// 0x04C8 (0x0010) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maxFrictionTargetAngleY;                        		// 0x04D8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxFrictionTargetAngleZ;                        		// 0x04DC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxFrictionDistance;                            		// 0x04E0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_peakFrictionDistance;                           		// 0x04E4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minFrictionDistance;                            		// 0x04E8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_frictionTargetOffset;                           		// 0x04EC (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_frictionMultiplierRange;                        		// 0x04F8 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_frictionMultiplierRangeZoomed;                  		// 0x0500 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_peakFrictionRadiusScale;                        		// 0x0508 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_peakFrictionHeightScale;                        		// 0x050C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minRawInputToKickinAdhesion;                    		// 0x0510 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxRawInputToKickinAdhesion;                    		// 0x0514 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAdhesionDistance;                            		// 0x0518 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAdhesionAimAngleH;                           		// 0x051C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAdhesionAimAngleV;                           		// 0x0520 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAdhesionAimDistY;                            		// 0x0524 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAdhesionAimDistZ;                            		// 0x0528 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAdhesionAimDistZOffset;                      		// 0x052C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhMinHeatToKeepIt;                             		// 0x0530 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhHeatIncreaseGeneral;                         		// 0x0534 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhHeatResetBeforeIncrease;                     		// 0x0538 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhHeatDecreaseByDisabling;                     		// 0x053C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhHeatDecreaseByBeingOffside;                  		// 0x0540 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhHeatDecreaseByMissingLoS;                    		// 0x0544 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhHeatDecreaseByExceedingInput;                		// 0x0548 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhHeatDecreaseByZeroInput;                     		// 0x054C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_adhesionScaleRange;                             		// 0x0550 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_adhesionScaleRangeZoomed;                       		// 0x0558 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minRelativeVelocityToFlipAdhesion;              		// 0x0560 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minTargetVelocityToFlipAdhesion;                		// 0x0564 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minAdhesionTargetVelocity;                      		// 0x0568 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minAdhesionVelocityH;                           		// 0x056C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minAdhesionVelocityV;                           		// 0x0570 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minAdhesionPlayerVelocity;                      		// 0x0574 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_adhesionHotZone;                                		// 0x0578 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_assumedCamZSpeed4Transition;                    		// 0x0580 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhesionMaxValueH;                              		// 0x0584 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhesionMaxValueV;                              		// 0x0588 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhesionMaxValueZoomedH;                        		// 0x058C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_adhesionMaxValueZoomedV;                        		// 0x0590 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_ValueMappingRule                        m_angleDistanceInfluence;                         		// 0x0594 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_ValueMappingRule                        m_TargetToPawnDistanceInfluence;                  		// 0x05A4 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_ValueMappingRule                        m_TargetToAimLocDistanceInfluence;                		// 0x05B4 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_ValueMappingRule                        m_TargetVelocityInfluence;                        		// 0x05C4 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_ValueMappingRule                        m_angleVelocityInfluence;                         		// 0x05D4 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_ValueMappingRule                        m_stickInputInfluence;                            		// 0x05E4 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAimSnapOnDistY;                              		// 0x05F4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAimSnapOnDistZ;                              		// 0x05F8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAimSnapOnDistZOffset;                        		// 0x05FC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAimSnapOnDistance;                           		// 0x0600 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxAimSnapOnCameraMoveDistance;                 		// 0x0604 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_aimSnapOnCameraMoveSpeed;                       		// 0x0608 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_aimSnapOnCoolDownTime;                          		// 0x060C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class AYArsenalManager*                            m_arsenalManager;                                 		// 0x0610 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_kismetAccuracy;                                 		// 0x0614 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_kismetTargetLoc;                                		// 0x0618 (0x000C) [0x0000000000000000]              
	class UYDamageManager*                             m_damageManager;                                  		// 0x0624 (0x0004) [0x0000000000000000]              
	struct FName                                       m_attachBoneOrSocket;                             		// 0x0628 (0x0008) [0x0000000000000000]              
	struct FVector                                     m_relativeLocation;                               		// 0x0630 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_relativeRotation;                               		// 0x063C (0x000C) [0x0000000000000000]              
	float                                              m_pickupCleanupPrioAgeMultiplyer;                 		// 0x0648 (0x0004) [0x0000000000044003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_GlobalConfig )
	float                                              m_pickupCleanupPrioCountMultiplyer;               		// 0x064C (0x0004) [0x0000000000044003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_GlobalConfig )
	float                                              m_pickupCleanupPrioDistanceMultiplyer;            		// 0x0650 (0x0004) [0x0000000000044003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_GlobalConfig )
	float                                              m_pickupCleanupPrioPlayerDroppedBonus;            		// 0x0654 (0x0004) [0x0000000000044003]              ( CPF_Edit | CPF_Const | CPF_Config | CPF_GlobalConfig )
	float                                              m_pickupCleanupPrioWeaponBaseValue;               		// 0x0658 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	TArray< struct FYS_AnimSet >                       m_additionalPawnAnimSets;                         		// 0x065C (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	TArray< struct FYS_AnimSet >                       m_pistolSpecificAdditionalPawnAnimSets;           		// 0x0668 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	TArray< struct FYS_AimingSet >                     m_additionalPawnAimingSets;                       		// 0x0674 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	float                                              m_takeUpWeaponBlendTime;                          		// 0x0680 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_standardFOV;                                    		// 0x0684 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_zoomFOV;                                        		// 0x0688 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_zoomTransitionSmoothIntoTime;                   		// 0x068C (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_zoomTransitionAtFullSpeedTime;                  		// 0x0690 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FYS_LowAmmoSounds                           m_lowAmmoSounds;                                  		// 0x0694 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FYS_LastShotInformation                     m_lastShotInformation;                            		// 0x06A0 (0x0028) [0x0000000000000000]              
	class AYWeapon*                                    m_SecondaryWeapon;                                		// 0x06C8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYWeapon*                                    m_baseWeapon;                                     		// 0x06CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_replicateInitSecondaryWeaponCounter;            		// 0x06D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYWeapon*                                    m_ammoSource;                                     		// 0x06D4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_maxTraceRange;                                  		// 0x06D8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxWeaponRange;                                 		// 0x06DC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_rangeOfMaxEfficiency;                           		// 0x06E0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_minEfficiencyRatio;                             		// 0x06E4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_whiteXHairRange;                                		// 0x06E8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_crosshairRangeDesaturationModifier;             		// 0x06EC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_crosshairRangeDesaturation;                     		// 0x06F0 (0x0004) [0x0000000000000000]              
	float                                              m_maxCrosshairRangePerSandStormForce[ 0x4 ];      		// 0x06F4 (0x0010) [0x0000000000044002]              ( CPF_Const | CPF_Config | CPF_GlobalConfig )
	float                                              m_damage;                                         		// 0x0704 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lethalHeadShotRange;                            		// 0x0708 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxHeadHitRange;                                		// 0x070C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_lethalHeadShotRangeZoomed;                      		// 0x0710 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxHeadHitRangeZoomed;                          		// 0x0714 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_headShotModifier;                               		// 0x0718 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_highEfficiencyRange;                            		// 0x071C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_highEfficiencyRate;                             		// 0x0720 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_headShotModifierAI;                             		// 0x0724 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxWeaponRangeAI;                               		// 0x0728 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_rangeOfMaxEfficiencyAI;                         		// 0x072C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_minEfficiencyRatioAI;                           		// 0x0730 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_lastFiringTimeStamp;                            		// 0x0734 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_startFireTimeStamp;                             		// 0x0738 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_shotsFiredThisSalvo;                            		// 0x073C (0x0004) [0x0000000000000000]              
	float                                              m_stopFireHackCheckInterval;                      		// 0x0740 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_weaponSoundLoopThreshold;                       		// 0x0744 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_weaponSoundTailBlendTime;                       		// 0x0748 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_burstRefireDelay;                               		// 0x074C (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_earlyRefireTolerance;                           		// 0x0750 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FName                                       m_reloadEndTimerName;                             		// 0x0754 (0x0008) [0x0000000000000000]              
	int                                                m_maxAmmoCount;                                   		// 0x075C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_startAmmoCount;                                 		// 0x0760 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_currentAmmoCount;                               		// 0x0764 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_useAmmoCount;                                   		// 0x0768 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_maxMagazines;                                   		// 0x076C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_startMagsIfInDefaultArsenal;                    		// 0x0770 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_startMagsIfInDefaultArsenalHeavyTrooper;        		// 0x0774 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_currentMagAmmo;                                 		// 0x0778 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_currentMagCount;                                		// 0x077C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_genericAmmoPickedUp;                            		// 0x0780 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_minDroppedInReserve;                            		// 0x0784 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_maxDroppedInReserve;                            		// 0x0788 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_minDroppedCurrentlyLoaded;                      		// 0x078C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_maxDroppedCurrentlyLoaded;                      		// 0x0790 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_lootFromExecutedEnemies;                        		// 0x0794 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	class UClass*                                      m_projectileClass;                                		// 0x0798 (0x0004) [0x0000000000000000]              
	class AYProj_Physical*                             m_projectileArch;                                 		// 0x079C (0x0004) [0x0000000000000000]              
	class AYProj_Physical*                             m_lastLaunchedProjectile;                         		// 0x07A0 (0x0004) [0x0000000000000000]              
	float                                              m_reloadDuration;                                 		// 0x07A4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_reloadStartTimeStamp;                           		// 0x07A8 (0x0004) [0x0000000000000000]              
	float                                              m_blockReloadFromStoppingDuration;                		// 0x07AC (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_lowAmmoWarningThreshold;                        		// 0x07B0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_lowAmmoForGameStats;                            		// 0x07B4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_lastTracerTimeStamp;                            		// 0x07B8 (0x0004) [0x0000000000000000]              
	TArray< struct FVector >                           m_lastFrameShots;                                 		// 0x07BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FVector >                           m_lastFrameAims;                                  		// 0x07C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AYPhosphorHazardArea*                        m_lastPhosphorHurtArea;                           		// 0x07D4 (0x0004) [0x0000000000000000]              
	float                                              m_firingCamShakeStrength;                         		// 0x07D8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_firingCamShakeRate;                             		// 0x07DC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_recoilDistortionRange[ 0x3 ];                   		// 0x07E0 (0x0018) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_recoilDistortionTendency[ 0x3 ];                		// 0x07F8 (0x0018) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FName                                       m_recoilValueSetName[ 0x3 ];                      		// 0x0810 (0x0018) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FName                                       m_recoilValueSetNameScoped[ 0x3 ];                		// 0x0828 (0x0018) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_recoilCurveValueIndex[ 0x6 ];                   		// 0x0840 (0x0018) [0x0000000000000000]              
	float                                              m_recoilDistortionCurveLength[ 0x3 ];             		// 0x0858 (0x000C) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_recoilDistortionCurveAttack[ 0x3 ];             		// 0x0864 (0x000C) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_recoilDistortionCurveDecay[ 0x3 ];              		// 0x0870 (0x000C) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_mod_recoilDistortion_Crouched;                  		// 0x087C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_mod_recoilDistortion_InCover;                   		// 0x0880 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_mod_recoilDistortion_Targeting;                 		// 0x0884 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_recoilResetAfterFire_ReturnSpeed;               		// 0x0888 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_recoilResetDelay;                               		// 0x088C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_recoilResetEndTolerance;                        		// 0x0890 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	class UClass*                                      m_standardCrosshairClass;                         		// 0x0898 (0x0004) [0x0000000000000000]              
	class UYCrosshair*                                 m_standardCrossHair;                              		// 0x089C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_bracketCrosshairClass;                          		// 0x08A0 (0x0004) [0x0000000000000000]              
	class UYCrosshair*                                 m_bracketCrossHair;                               		// 0x08A4 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_noCrosshairClass;                               		// 0x08A8 (0x0004) [0x0000000000000000]              
	class UYCrosshair*                                 m_noCrossHair;                                    		// 0x08AC (0x0004) [0x0000000000000000]              
	class UYCrosshair*                                 m_currentCrossHair;                               		// 0x08B0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_bulletAttractionMultiplier;                     		// 0x08B4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_bulletAttractionMaxRange;                       		// 0x08B8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_rangeOfMaxBulletAttraction;                     		// 0x08BC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_base_Acc_Standing;                              		// 0x08C0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_base_Acc_Crouched;                              		// 0x08C4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_base_Acc_InCover;                               		// 0x08C8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_base_Acc_StandingTarget;                        		// 0x08CC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_base_Acc_CrouchedTarget;                        		// 0x08D0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_base_Acc_InCoverTarget;                         		// 0x08D4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_base_Acc_BlindFire;                             		// 0x08D8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_mod_Acc_Move;                                   		// 0x08DC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_mod_Acc_ViewTurn;                               		// 0x08E0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_accZoomMultiplier;                              		// 0x08E4 (0x0004) [0x0000000000000000]              
	float                                              m_base_Interp_Speed;                              		// 0x08E8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_mod_Interp_BlindFire;                           		// 0x08EC (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_mod_Interp_Move;                                		// 0x08F0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_mul_Interp_ViewTurn;                            		// 0x08F4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_mod_Acc_SandStorm[ 0x4 ];                       		// 0x08F8 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_interpRange;                                    		// 0x0908 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_accuracyScale_BlindFire;                        		// 0x0910 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_aimErrorRange;                                  		// 0x0914 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector2D                                   m_aimErrorRangeAimed;                             		// 0x091C (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FVector                                     m_xHairAccCalibration;                            		// 0x0924 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_spreadAI;                                       		// 0x0930 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_degreeOfCentricSpreadMassing;                   		// 0x0934 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_base_Interp_SpeedUp[ 0x3 ];                     		// 0x0938 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_base_Interp_SpeedDown[ 0x3 ];                   		// 0x0944 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_acc_burstAmplitude[ 0x3 ];                      		// 0x0950 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_acc_burstModifierTargeting;                     		// 0x095C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_targetBurstError;                               		// 0x0960 (0x0004) [0x0000000000000000]              
	float                                              m_timeToReachTargetBurstError;                    		// 0x0964 (0x0004) [0x0000000000000000]              
	float                                              m_timeOfLastBurstErrorDirectionChange;            		// 0x0968 (0x0004) [0x0000000000000000]              
	float                                              m_lastBurstError;                                 		// 0x096C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_burstError;                                     		// 0x0970 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_hookIndex;                                      		// 0x0974 (0x0004) [0x0000000000000000]              
	struct FName                                       m_hookName;                                       		// 0x0978 (0x0008) [0x0000000000000020]              ( CPF_Net )
	TArray< struct FYS_WeaponAnimModifierInfo >        m_animModifierInfos;                              		// 0x0980 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< struct FName >                             m_weaponAnimNodeNames;                            		// 0x098C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_windingChangeEndTime;                           		// 0x0998 (0x0004) [0x0000000000000000]              
	float                                              m_currentWindingSpeed;                            		// 0x099C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_windupTime;                                     		// 0x09A0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_winddownTime;                                   		// 0x09A4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_heatLevel;                                      		// 0x09A8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_heatAddedPerShot;                               		// 0x09AC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_heatReductionPerSecond;                         		// 0x09B0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_overheatDisabledDuration;                       		// 0x09B4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	class UYOverheating*                               m_overHeating;                                    		// 0x09B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_leftHandThrowBone;                              		// 0x09BC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_rightHandThrowBone;                             		// 0x09C4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_spineBone;                                      		// 0x09CC (0x0008) [0x0000000000000000]              
	struct FName                                       m_grenadeHoldingSocketL;                          		// 0x09D4 (0x0008) [0x0000000000000000]              
	struct FName                                       m_grenadeHoldingSocketR;                          		// 0x09DC (0x0008) [0x0000000000000000]              
	float                                              m_grenadeTriggerTime;                             		// 0x09E4 (0x0004) [0x0000000000000000]              
	TArray< struct FYS_AnimSet >                       m_additionalGrenadeAnimSet;                       		// 0x09E8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_grenadeSimMaxIterations;                        		// 0x09F4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_grenade_MinStandCoverDistance;                  		// 0x09F8 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffset_Stand;                            		// 0x09FC (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffset_Crouch;                           		// 0x0A08 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffset_StandCover;                       		// 0x0A14 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffset_StandCoverEdge;                   		// 0x0A20 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffset_StandCoverLookBackwards;          		// 0x0A2C (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffset_CrouchCover;                      		// 0x0A38 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffset_CrouchCoverEdge;                  		// 0x0A44 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffset_CrouchCoverLookBackwards;         		// 0x0A50 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_grenadeOffset_PitchDamping;                     		// 0x0A5C (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_Stand;                        		// 0x0A60 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_Crouch;                       		// 0x0A6C (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_StandCover;                   		// 0x0A78 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_StandCoverEdge;               		// 0x0A84 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_StandCoverAimAroundEdge;      		// 0x0A90 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_StandCoverLookBackwards;      		// 0x0A9C (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_CrouchCover;                  		// 0x0AA8 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_CrouchCoverOver;              		// 0x0AB4 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_CrouchCoverEdge;              		// 0x0AC0 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_CrouchCoverAimAroundEdge;     		// 0x0ACC (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeOffsetRoll_CrouchCoverLookBackwards;     		// 0x0AD8 (0x000C) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	class AYProj_Physical*                             m_simulatedGrenade;                               		// 0x0AE4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_simulationStart;                                		// 0x0AE8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_simulationDir;                                  		// 0x0AF4 (0x000C) [0x0000000000000000]              
	class UClass*                                      m_pickupMarkerIconClass;                          		// 0x0B00 (0x0004) [0x0000000000000000]              
	float                                              m_grenadeShort2LongTime;                          		// 0x0B04 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_grenadeZoomFOV;                                 		// 0x0B08 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	struct FVector                                     m_grenadeSpawningCheckExtent;                     		// 0x0B0C (0x000C) [0x0000000000000000]              
	struct FString                                     m_weaponCharacter;                                		// 0x0B18 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_iconFontName;                                   		// 0x0B24 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                m_StartAmmoForHeavy;                              		// 0x0B30 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_FontPackageIndex;                               		// 0x0B34 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UClass*                                      m_scopeClass;                                     		// 0x0B38 (0x0004) [0x0000000000000000]              
	class UYScope*                                     m_scope;                                          		// 0x0B3C (0x0004) [0x0000000000000000]              
	int                                                m_wallOffset;                                     		// 0x0B40 (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             m_wpMuzzleAudioComponent;                         		// 0x0B44 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_spinningAudioComponent;                         		// 0x0B48 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class USoundCue*                                   m_shellBounceOnGroundSound;                       		// 0x0B4C (0x0004) [0x0000000000000000]              
	class USoundCue*                                   m_shellBounceOnSandSound;                         		// 0x0B50 (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             m_shellBounceAudioComponent;                      		// 0x0B54 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FName                                       m_pawnSocketToAttachWeaponTo;                     		// 0x0B58 (0x0008) [0x0000000000000000]              
	struct FName                                       m_holsterSocketName;                              		// 0x0B60 (0x0008) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	class UYWeaponSubmeshData*                         m_subMeshData[ 0x2 ];                             		// 0x0B68 (0x0008) [0x0000000000000000]              
	struct FName                                       m_weaponSilencerBoneName;                         		// 0x0B70 (0x0008) [0x0000000000000000]              
	class USkeletalMesh*                               m_ammoBoxMesh;                                    		// 0x0B78 (0x0004) [0x0000000000000000]              
	int                                                m_mainEffectFrequency;                            		// 0x0B7C (0x0004) [0x0000000000000000]              
	int                                                m_shellsEffectFrequency;                          		// 0x0B80 (0x0004) [0x0000000000000000]              
	class UParticleSystemComponent*                    m_wpStickyMuzzleFXComponent;                      		// 0x0B84 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UParticleSystem*                             m_playersMuzzleFireTemplate;                      		// 0x0B88 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_effectDuration;                                 		// 0x0B8C (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UParticleSystemComponent*                    m_wpSandMuzzleFXComponent;                        		// 0x0B90 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UParticleSystem*                             m_sandMuzzleFxTemplate;                           		// 0x0B94 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UParticleSystemComponent*                    m_wpShellFXComponent;                             		// 0x0B98 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UParticleSystem*                             m_playersShellFxTemplate;                         		// 0x0B9C (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_shellEjectionSocket;                            		// 0x0BA0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	class UParticleSystem*                             m_overheatFXTemplate;                             		// 0x0BA8 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_muzzleLightDuration;                            		// 0x0BAC (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_muzzleLightActivationThresholdStart;            		// 0x0BB0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_muzzleLightActivationThresholdEnd;              		// 0x0BB4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UPointLightComponent*                        m_wpMuzzleLightComponent;                         		// 0x0BB8 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_randomBrightnessModifierMin;                    		// 0x0BBC (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_randomBrightnessModifierMax;                    		// 0x0BC0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_baseBrightness;                                 		// 0x0BC4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_meleeAttackDist;                                		// 0x0BC8 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_WeaponMeleeInfo                         m_meleeInfo;                                      		// 0x0BCC (0x0018) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FS_MaterialInstanceConstantInfo             m_bulletBar;                                      		// 0x0BE4 (0x0094) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_supportedExecutionTypes;                        		// 0x0C78 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	float                                              m_TurnSpeedModifier_H;                            		// 0x0C84 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_TurnSpeedModifier_V;                            		// 0x0C88 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_ZoomNoScopeTurnSpeedModifer_H;                  		// 0x0C8C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_ZoomNoScopeTurnSpeedModifer_V;                  		// 0x0C90 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_CoverTurnSpeedModifier_H;                       		// 0x0C94 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_CoverTurnSpeedModifier_V;                       		// 0x0C98 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_CoverZoomNoScopeTurnSpeedModifer_H;             		// 0x0C9C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_CoverZoomNoScopeTurnSpeedModifer_V;             		// 0x0CA0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_numShotsFiredThisTick;                          		// 0x0CA4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2083 ];

		return pClassPointer;
	};

	float GetZoomTransitionSmoothIntoTime ( );
	float GetZoomTransitionAtFullSpeedTime ( );
	struct FString GetWeaponIconMarkup ( );
	float GetMaxCrosshairTraceRange ( );
	void DropGrenade ( );
	class AYProj_Physical* SpawnGrenadeToDrop ( struct FVector StartLoc );
	void ServerSetSimulationStart ( struct FVector simulationStart );
	void Tick ( float DeltaTime );
	void GetCameraRotationModifier ( float* turnH, float* turnV );
	bool IsFiring ( unsigned char FiringMode );
	bool IsActive ( );
	void SetBurstParams ( );
	void DoKismetAttachment ( class AActor* Attachment, class USeqAct_AttachToActor* Action );
	void DisplayDebug ( class AHUD* H, float* out_YL, float* out_YPos );
	void DrawHUD ( class AYHUD* HUD );
	void Destroyed ( );
	void StopFiringEffectsOnDestroy ( );
	void Cleanup ( );
	int AddGenericAmmo ( unsigned long full );
	bool CanAddGenericAmmo ( );
	bool HasAnyAmmo ( );
	int GetMaxAmmoCount ( );
	int GetAmmoCount ( );
	bool HasAmmo ( unsigned char FiringMode );
	void CheckAdviseReload ( );
	void CheckLowAmmoWarning ( );
	void ClientUpdateAmmo ( unsigned long bCheckForReload );
	void ConsumeAmmo ( unsigned char FiringMode );
	bool AreShotsPending ( );
	void Refire ( );
	void ApplyDamage ( class AActor* HitActor, float DamageAmount, struct FVector HitLoc, struct FVector hitNrml, struct FVector Momentum, class UClass* dmgType, struct FTraceHitInfo traceInfo, class AActor* DamageCauser );
	void StopGenericWeaponAnim ( );
	void StartGenericWeaponAnim ( struct FName AnimSeqName );
	class AController* GetDamageInstigator ( );
	bool PlayFireEffect ( struct FImpactInfo impInfo, float DamageAmount, class UClass* dmgTypeClass, int repFlags );
	bool ContainsRepFlag ( int repFlags, unsigned char flagToTest );
	void FakeFireEffects ( );
	void PlayFireEffects ( struct FImpactInfo impInfo, struct FYS_LastShotInformation lastShotInfo );
	class UYCrosshair* ResolveCrosshair ( unsigned char xhState, class AYHUD* HUD );
	void ServerKillEnemyCoop ( class AYGamePawn* pawnToKill );
	void CoopKillNotification ( class AYGamePawn* hitPawn );
	void ClientOnEnemyHit ( class AYGamePawn* hitPawn );
	void ServerOnEnemyHit ( float PercentRaysHit, class AYGamePawn* hitPawn );
	void DeactivateOverheated ( );
	void ActivateOverheated ( float remainingDuration );
	void TriggerReload ( );
	void HideAmmoMesh ( unsigned long Hidden );
	void CheckHideAmmoMesh ( );
	void ServerOnShotFired ( unsigned long bIsHit );
	class AYProjectile* ServerFireSingleShot ( );
	void SetMeshOwnerToSelf ( );
	void StartDummyFire ( );
	bool SetShotPending ( unsigned long newPending );
	float UpdateCrosshairSaturation ( float Distance, unsigned char crosshairColorType );
	float CalcRangeEfficiencyLoss ( float Range, float MaxRange, float minRange );
	void ClientStopFire ( unsigned char FiringMode, unsigned long byRelease );
	void ClientStartFire ( unsigned char FiringMode );
	void OnEndThrowGrenade ( );
	void SkipGrenadeThrow ( );
	void GoToThrowingState ( );
	void FireGrenade ( );
	bool UseGrenadeSimulation ( );
	void ClientStopSimulation ( );
	void StopSimulation ( );
	void SimulateTrajectoryNative ( unsigned long checkForCloseWallOnly );
	void SetGrenadeLocAndDir ( class AYProj_Physical* grenadeArch, unsigned long simulatedThrow, class AYProj_Physical** grenadeActor, struct FVector* StartLoc, struct FVector* AimDir );
	void StaticSetGrenadeLocAndDir ( class AActor* callActorMethodsHere, class AYProj_Physical* grenadeArch, struct FVector StartLoc, struct FVector StartFireLoc, struct FVector aimAtPosition, unsigned long simulatedThrow, unsigned char grenadeThrowMode, class AActor* SpawnOwner, unsigned long zoomModifier, float aimZ, class AYProj_Physical** grenadeActor, struct FVector* AimDir );
	struct FVector GetExplosiveSpawnLocation ( struct FRotator povRotation );
	struct FVector GetExplosiveSpawnLocationNative ( struct FRotator povRotation );
	void SpawnGrenade ( );
	void RemAdditionalGrenadeAnimSet ( );
	void AddAdditionalGrenadeAnimSet ( );
	void ServerStopFire ( unsigned char FiringMode, unsigned long byRelease );
	void ServerStartFire ( unsigned char FiringMode );
	bool IsAutoReloading ( );
	bool TriggerSwitchFromEmptyWeapon ( );
	void UpdateAmmoData ( );
	bool ReceiveLootFromExecutedEnemyCoop ( class AYHUD* HUD, int* refillEncryption );
	bool ReceiveLootFromExecutedEnemy ( class AYHUD* HUD );
	void MaxAmmo ( unsigned long onlyClip, unsigned long onlyMag );
	int AddAmmoMagazines ( int additionalMagAmmo );
	void OnFinishTacticalReload ( );
	int AmmoToRefill ( );
	void ClientSetHasRefilledAmmo ( unsigned long val );
	bool RefillAmmo ( );
	void CheckFiringInputAfterReload ( );
	void ClientReloadDone ( unsigned long forced );
	void ClientReloadWeapon ( );
	bool IsReloading ( );
	bool IsReloadStopBlocked ( );
	void EndSingleShellReload ( );
	void StopSingleShellReload ( );
	void ServerLeaveReloadState ( unsigned long forced );
	void ServerReloadDone ( unsigned long interrupted );
	bool ServerReloadWeapon ( );
	bool CancelReload ( );
	bool CanReload ( unsigned long ignoreEquippedStatus );
	bool CanPickupMagazine ( int Amount );
	void OnOverheatedFiringFailed ( );
	void OnEmptyFire ( );
	bool MayStopFireWhenDead ( );
	bool MayStopFire ( unsigned char FiringMode, unsigned long byRelease );
	bool MayFire ( unsigned char FiringMode );
	class USkeletalMesh* ShowHideWeaponSubmesh ( unsigned char submeshType, unsigned char HideMesh, unsigned long spawnActor, unsigned long spawnFromHand, unsigned long mirrored, struct FName* pawnSocketName );
	void ChangeWeaponAnim ( unsigned char newWeaponAnim, float InRate );
	void ToggleComparedFiringSound ( );
	void StopFiringSound ( );
	void ServerChangeFiringSound ( unsigned char newFiringSound );
	void UpdateRefireType ( unsigned char newRefireType );
	bool OverrideFOV ( float* FOV );
	void GetFiringSpecs ( unsigned char* refireType, unsigned char* onRelease );
	void TriggerKismetEquipEvent ( int equipped );
	void UnequipWeapon ( );
	void EquipWeapon ( );
	class UClass* GetPickupClass ( );
	void ToggleScopeScene ( unsigned long Enable );
	void OnScndModeActivated ( unsigned long Enable );
	void CheckHideSecondarySubmesh ( unsigned long Hidden );
	void ActivateSecondaryWeapon ( unsigned long Enable, unsigned long isEquipped );
	class USoundCue* GetScndToggleSoundCue ( );
	bool ScndModeIsInstantChanged ( );
	bool IsScndModeActivated ( );
	bool HasScndMode ( );
	void SetBaseWeapon ( class AYWeapon* baseWp );
	class AYWeapon* GetActiveWeapon ( );
	class AYWeapon* GetSecondaryWeapon ( );
	void ClientRegisterSecondaryWeapon ( class AYWeapon* wp );
	bool AddSecondaryWeapon ( class UClass* wpClass, class AYWeapon* replicatedWeapon );
	void InitSecondaryAmmo ( int startAmmo, int startMagAmmo );
	void InitAmmo ( int startAmmo, int startMagAmmo );
	void HideWeaponMesh ( unsigned long Hidden );
	bool AdjustWeaponDueToMirror ( unsigned long mirrored );
	bool ChangeAttachment ( struct FName hookName );
	void AttachToBoneOrSocket ( unsigned long takeOverTurretMesh, struct FName hookName );
	void InitWeaponMesh ( struct FName hookName );
	void SaveObjConf ( struct FString ObjName );
	void InitProjectileArchetype ( );
	void InitSecondaryWeapon ( );
	void Init ( class AYArsenalManager* newArsenalManager, class AYGamePawn* NewPawn, class AYCheapShooter* cheapShooter, struct FName hookName );
	void InitMeshData ( struct FName hookName );
	void InitMPAmmoCount ( );
	void SetIsToEquip ( unsigned long bToEquip );
	float GetRefireIntervalAudio ( );
	float GetRefireInterval ( );
	int GetStartMagsCount ( );
	int GetMaxSpareAmmoCount ( );
	int GetMaxLoadedAmmoCount ( unsigned long bCountReloadExtraBullet );
	void AddSpareAmmo ( int ammoDelta );
	void AddLoadedAmmo ( int ammoDelta );
	void SetSpareAmmoCount ( int ammoCount );
	void SetLoadedAmmoCount ( int ammoCount, unsigned long allowExtraAmmoCount );
	void StopMuzzleEffect ( );
	void InitWeaponData ( );
	void CalcWeaponFire ( struct FVector StartTrace, struct FVector EndTrace, struct FImpactInfo* impInfo );
	void CalcAimAttraction ( struct FVector StartLoc, struct FVector aimDirection, float curMaxSpread, float weaponMultiplyer, struct FVector* shotDirection );
	void CalcAimAttractionOriginal ( struct FVector StartLoc, struct FVector aimDirection, float curMaxSpread, float weaponMultiplyer, struct FVector* shotDirection );
	void AdjustMeshPropertiesToPawnMesh ( class USkeletalMeshComponent* compToAdjust );
	void StopAutoFireSound ( );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYWeapon::pClassPointer = NULL;

// Class SRGame.YWeapon_Explosive
// 0x0001 (0x0CA9 - 0x0CA8)
class AYWeapon_Explosive : public AYWeapon
{
public:
	unsigned char                                      m_grenadeType;                                    		// 0x0CA8 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2084 ];

		return pClassPointer;
	};

	bool MayFire ( unsigned char FiringMode );
	void OnPawnDie ( );
	void OnEndThrowGrenade ( );
	void DrawHUD ( class AYHUD* HUD );
	bool IsLastLaunchedProjectileValid ( );
	void RemAdditionalExplosiveAnimSets ( class AYWeapon* mainWeapon );
	void AddAdditionalExplosiveAnimSets ( class AYWeapon* mainWeapon );
};

UClass* AYWeapon_Explosive::pClassPointer = NULL;

// Class SRGame.YWeapon_Expl_C4
// 0x0007 (0x0CB0 - 0x0CA9)
class AYWeapon_Expl_C4 : public AYWeapon_Explosive
{
public:
	unsigned long                                      m_bProjectileLaunched : 1;                        		// 0x0CAC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2085 ];

		return pClassPointer;
	};

	class AController* GetDamageInstigator ( );
	void OnPawnDie ( );
	void OnRemoteGrenadeExplode ( );
	bool HasAmmo ( unsigned char FiringMode );
	void ClientStartFire ( unsigned char FiringMode );
	void ServerStartFire ( unsigned char FiringMode );
};

UClass* AYWeapon_Expl_C4::pClassPointer = NULL;

// Class SRGame.YWeapon_Expl_Mine
// 0x000B (0x0CB4 - 0x0CA9)
class AYWeapon_Expl_Mine : public AYWeapon_Explosive
{
public:
	struct FYS_ControlRestrictions                     m_mineControlRestrictions;                        		// 0x0CAC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_additionalExplosiveAnimSetsAdded : 1;           		// 0x0CB0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2086 ];

		return pClassPointer;
	};

	struct FVector GetExplosiveSpawnLocationNative ( struct FRotator povRotation );
	bool UseGrenadeSimulation ( );
	void RemAdditionalExplosiveAnimSets ( class AYWeapon* mainWeapon );
	void AddAdditionalExplosiveAnimSets ( class AYWeapon* mainWeapon );
};

UClass* AYWeapon_Expl_Mine::pClassPointer = NULL;

// Class SRGame.YWeapon_MPCustom
// 0x000B (0x0CB4 - 0x0CA9)
class AYWeapon_MPCustom : public AYWeapon_Explosive
{
public:
	unsigned long                                      m_bCanFire : 1;                                   		// 0x0CAC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_startCoolDownOnFiring : 1;                      		// 0x0CAC (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fCooldownTime;                                  		// 0x0CB0 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2087 ];

		return pClassPointer;
	};

	void ClientStartCooldown ( );
	void ServerStartCooldown ( );
	void ServerStartFire ( unsigned char FiringMode );
	void CanFire ( );
	bool MayFire ( unsigned char FiringMode );
};

UClass* AYWeapon_MPCustom::pClassPointer = NULL;

// Class SRGame.YWeapon_MPOfficerBeacon
// 0x0000 (0x0CB4 - 0x0CB4)
class AYWeapon_MPOfficerBeacon : public AYWeapon_MPCustom
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2088 ];

		return pClassPointer;
	};

	void SkipGrenadeThrow ( );
	void OnEndThrowGrenade ( );
	void SwitchBackToNormalGrenades ( );
	void ConsumeAmmo ( unsigned char FiringMode );
	class AController* GetDamageInstigator ( );
	bool HasAmmo ( unsigned char FiringMode );
};

UClass* AYWeapon_MPOfficerBeacon::pClassPointer = NULL;

// Class SRGame.YWeapon_MPOfficerSupply
// 0x0004 (0x0CB8 - 0x0CB4)
class AYWeapon_MPOfficerSupply : public AYWeapon_MPCustom
{
public:
	float                                              m_fCooldownTimeLevel2;                            		// 0x0CB4 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2089 ];

		return pClassPointer;
	};

	void SkipGrenadeThrow ( );
	void OnEndThrowGrenade ( );
	void SwitchBackToNormalGrenades ( );
	void DropOfficerSupply ( );
	void ClientStartCooldown ( );
	void ServerStartCooldown ( );
	class AController* GetDamageInstigator ( );
};

UClass* AYWeapon_MPOfficerSupply::pClassPointer = NULL;

// Class SRGame.YWeapon_Shotgun
// 0x0070 (0x0D18 - 0x0CA8)
class AYWeapon_Shotgun : public AYWeapon
{
public:
	int                                                m_numShotsPerCircle[ 0x3 ];                       		// 0x0CA8 (0x000C) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	int                                                m_numShotsSum;                                    		// 0x0CB4 (0x0004) [0x0000000000000000]              
	float                                              m_partialDamage;                                  		// 0x0CB8 (0x0004) [0x0000000000000000]              
	float                                              m_angleOfInnerCircle;                             		// 0x0CBC (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_angleOfOuterCircle;                             		// 0x0CC0 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_startOffsetAngleInner;                          		// 0x0CC4 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_startOffsetAngleOuter;                          		// 0x0CC8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_patternScaling;                                 		// 0x0CCC (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_maxDistanceToClusterImpacts;                    		// 0x0CD4 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_shotgunStartLocOffset;                          		// 0x0CD8 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	TArray< struct FVector2D >                         m_innerDeviations;                                		// 0x0CDC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FVector2D >                         m_outerDeviations;                                		// 0x0CE8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_singleTraceMaxDeviation;                        		// 0x0CF4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_RandomNumberTriplet                     m_randomizedDistances;                            		// 0x0CF8 (0x0010) [0x0000000000000020]              ( CPF_Net )
	struct FYS_RandomNumberTriplet                     m_randomizedAngles;                               		// 0x0D08 (0x0010) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2090 ];

		return pClassPointer;
	};

	void CalcShotGunHits ( struct FVector StartFireLoc, struct FVector aimAtPosition, TArray< struct FYS_SingleActorImpacts >* actorImpacts );
	struct FVector DeviateShotDirection ( unsigned char shotIdx, unsigned long inner, struct FVector StartFireLoc, struct FVector shotLoc );
	void Init ( class AYArsenalManager* newArsenalManager, class AYGamePawn* NewPawn, class AYCheapShooter* cheapShooter, struct FName hookName );
};

UClass* AYWeapon_Shotgun::pClassPointer = NULL;

// Class SRGame.YWeapon_Sniper
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Sniper : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2091 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Sniper::pClassPointer = NULL;

// Class SRGame.YWeaponAttachment
// 0x00C0 (0x00FC - 0x003C)
class UYWeaponAttachment : public UObject
{
public:
	class AYWeapon*                                    m_myWeapon;                                       		// 0x003C (0x0004) [0x0000000000000000]              
	int                                                m_muzzleBoneIndex;                                		// 0x0040 (0x0004) [0x0000000000000000]              
	class UParticleSystemComponent*                    m_stickyMuzzleFXComponent;                        		// 0x0044 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_stickyMuzzleFXDuration;                         		// 0x0048 (0x0004) [0x0000000000000000]              
	class UParticleSystemComponent*                    m_sandMuzzleFXComponent;                          		// 0x004C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_muzzleFrequencyCounter;                         		// 0x0050 (0x0004) [0x0000000000000000]              
	class UParticleSystemComponent*                    m_shellFXComponent;                               		// 0x0054 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_shellFrequencyCounter;                          		// 0x0058 (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             m_muzzleAudioComponent;                           		// 0x005C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class USkeletalMeshComponent*                      m_ammoSkelMeshComp;                               		// 0x0060 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned long                                      m_ammoSkelMeshShown : 1;                          		// 0x0064 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_laserSightEnabled : 1;                          		// 0x0064 (0x0004) [0x0000000000000000] [0x00000002] 
	class UParticleSystemComponent*                    m_laserPointer;                                   		// 0x0068 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FName                                       m_laserTargetSocket;                              		// 0x006C (0x0008) [0x0000000000000000]              
	class UParticleSystemComponent*                    m_laserSightPSC;                                  		// 0x0074 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FVector                                     m_laserSightTraceStart;                           		// 0x0078 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_laserSightTraceDest;                            		// 0x0084 (0x000C) [0x0000000000000000]              
	struct FName                                       m_muzzleBone;                                     		// 0x0090 (0x0008) [0x0000000000000000]              
	class USkeletalMeshComponent*                      m_muzzleBoneMesh;                                 		// 0x0098 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FName                                       m_laserScopeBone;                                 		// 0x009C (0x0008) [0x0000000000000000]              
	TArray< struct FYS_WeaponAnimInfo >                m_weaponAnimInfos;                                		// 0x00A4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_firingStartedTimeStamp;                         		// 0x00B0 (0x0004) [0x0000000000000000]              
	struct FName                                       m_stopMuzzleFunctionName;                         		// 0x00B4 (0x0008) [0x0000000000000002]              ( CPF_Const )
	class UPointLightComponent*                        m_muzzleLightComponent;                           		// 0x00BC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FScriptDelegate                             m_muzzleLightEndCallback;                         		// 0x00C0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class USoundCue*                                   m_firingCentralSoundCue[ 0x3 ];                   		// 0x00CC (0x000C) [0x0000000000000000]              
	class USoundCue*                                   m_firingNonOwningSoundCue[ 0x3 ];                 		// 0x00D8 (0x000C) [0x0000000000000000]              
	float                                              m_firingSoundDuration[ 0x3 ];                     		// 0x00E4 (0x000C) [0x0000000000000000]              
	unsigned char                                      m_shouldStopSoundNextTick;                        		// 0x00F0 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentFiringSoundMode;                         		// 0x00F1 (0x0001) [0x0000000000000000]              
	class USoundCue*                                   m_currentFiringSound;                             		// 0x00F4 (0x0004) [0x0000000000000000]              
	float                                              ticker;                                           		// 0x00F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2092 ];

		return pClassPointer;
	};

	void SetFiringSoundParameter ( struct FName ParamName, float ParamValue );
	void TickWeaponAttachment ( float DeltaTime );
	void Cleanup ( );
	void DrawLaserPointer ( );
	bool GetMuzzleLocation ( struct FVector* Loc, struct FRotator* rotat );
	void InitMuzzleData ( struct FName BoneName );
	void UpdateFiringSound ( unsigned char newSoundState );
	void ChangeWeaponAnim ( unsigned char newWeaponAnim, float InRate );
	void InitAnimations ( );
	void StopFiringSound ( );
	void StartFiringSound ( );
	void FiringSoundChanged ( );
	void TriggerImpactEffect ( struct FImpactInfo impInfo, float DamageAmount, class UClass* dmgTypeClass, int repFlags );
	bool StartTracerEffect ( struct FImpactInfo* impInfo );
	void StopMuzzleLight ( unsigned long finished );
	void StartMuzzleLight ( );
	void UpdateMuzzleLight ( float DeltaTime );
	void StopMuzzleEffect ( );
	void StartMuzzleEffect ( struct FVector SpawnLoc );
	void PlayMuzzleEffect ( struct FImpactInfo impInfo, class UClass* dmgTypeClass, unsigned long delayed );
	void ResetComponentReferences ( unsigned long firstAttach );
	void InitWeaponAttachmentNative ( );
	void InitWeaponAttachment ( );
};

UClass* UYWeaponAttachment::pClassPointer = NULL;

// Class SRGame.YWeaponConfigObject
// 0x0000 (0x003C - 0x003C)
class UYWeaponConfigObject : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2093 ];

		return pClassPointer;
	};

};

UClass* UYWeaponConfigObject::pClassPointer = NULL;

// Class SRGame.YDamageEvaluationParams
// 0x0058 (0x0094 - 0x003C)
class UYDamageEvaluationParams : public UYWeaponConfigObject
{
public:
	float                                              m_baseDamage;                                     		// 0x003C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned char                                      m_damageSpace;                                    		// 0x0040 (0x0001) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned char                                      m_coneFallOffToSides;                             		// 0x0041 (0x0001) [0x0000000020004001]              ( CPF_Edit | CPF_Config | CPF_Deprecated )
	unsigned char                                      m_sideFalloffCalcMode;                            		// 0x0042 (0x0001) [0x0000000020004001]              ( CPF_Edit | CPF_Config | CPF_Deprecated )
	unsigned char                                      m_rangeTimeRelation;                              		// 0x0043 (0x0001) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned char                                      m_frontFallOffType;                               		// 0x0044 (0x0001) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxRange;                                       		// 0x0048 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxLevelGeometryRange;                          		// 0x004C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxRangeRolled;                                 		// 0x0050 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minRange;                                       		// 0x0054 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_forceDamageMaxDistanceH;                        		// 0x0058 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_forceDamageMaxDistanceV;                        		// 0x005C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_enemyAIRangeModifier;                           		// 0x0060 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_expansionSpeed;                                 		// 0x0064 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_knockDownStrength;                              		// 0x0068 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_coneAngle;                                      		// 0x006C (0x0004) [0x0000000020004001]              ( CPF_Edit | CPF_Config | CPF_Deprecated )
	float                                              m_coneStartWidth;                                 		// 0x0070 (0x0004) [0x0000000020004001]              ( CPF_Edit | CPF_Config | CPF_Deprecated )
	float                                              m_minSideFallOffRatio;                            		// 0x0074 (0x0004) [0x0000000020004001]              ( CPF_Edit | CPF_Config | CPF_Deprecated )
	float                                              m_minFrontFallOffRatio;                           		// 0x0078 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sandStunEffectRange;                            		// 0x007C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sandStunEffectRangeAI;                          		// 0x0080 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_camshakeStrengthModifier;                       		// 0x0084 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned long                                      m_damageOriginator : 1;                           		// 0x0088 (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_damagePawns : 1;                                		// 0x0088 (0x0004) [0x0000000000004001] [0x00000002] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_damageYDOs : 1;                                 		// 0x0088 (0x0004) [0x0000000000004001] [0x00000004] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_damageOnlyYDOs : 1;                             		// 0x0088 (0x0004) [0x0000000000004001] [0x00000008] ( CPF_Edit | CPF_Config )
	float                                              m_effectsOmitRate;                                		// 0x008C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_fracturedStaticMeshDamageRadius;                		// 0x0090 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2094 ];

		return pClassPointer;
	};

	class UYDamageEvaluationParams* StaticGetDmgParamsByName ( struct FName paramsName );
};

UClass* UYDamageEvaluationParams::pClassPointer = NULL;

// Class SRGame.YWeaponDataAssetBase
// 0x0010 (0x004C - 0x003C)
class UYWeaponDataAssetBase : public UObject
{
public:
	TArray< struct FYS_WeaponDispatcherVersion >       m_additionalVersions;                             		// 0x003C (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	class UYWeaponDataAssetBase*                       m_useThisAssetByStandard;                         		// 0x0048 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2095 ];

		return pClassPointer;
	};

};

UClass* UYWeaponDataAssetBase::pClassPointer = NULL;

// Class SRGame.YProjData_GraphicsFX
// 0x0054 (0x00A0 - 0x004C)
class UYProjData_GraphicsFX : public UYWeaponDataAssetBase
{
public:
	class UParticleSystem*                             m_explosionEffectTemplate;                        		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_standardEffectOrientationUpwards : 1;           		// 0x0050 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_explosionLightEnabled : 1;                      		// 0x0050 (0x0004) [0x0000000000000003] [0x00000002] ( CPF_Edit | CPF_Const )
	class UParticleSystem*                             m_explosionEffectTemplateOnGround;                		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_explosionEffectTemplateOnSand;                  		// 0x0058 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_explosionEffectTemplateHit;                     		// 0x005C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_explosionEffectTemplateHitOnSand;               		// 0x0060 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_explosionEffectTemplateSandStorm;               		// 0x0064 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ProjGroundDecalDesc                     m_explosionGroundDecal;                           		// 0x0068 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ProjGroundDecalDesc                     m_explosionGroundDecalOnSand;                     		// 0x0078 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_flightParticleSystem;                           		// 0x0088 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_spawnParticleSystem;                            		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_explosionLightRadius;                           		// 0x0090 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_explosionLightBrightness;                       		// 0x0094 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FColor                                      m_explosionLightColor;                            		// 0x0098 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_explosionLightDuration;                         		// 0x009C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2096 ];

		return pClassPointer;
	};

};

UClass* UYProjData_GraphicsFX::pClassPointer = NULL;

// Class SRGame.YProjData_Mesh
// 0x000C (0x0058 - 0x004C)
class UYProjData_Mesh : public UYWeaponDataAssetBase
{
public:
	class USkeletalMesh*                               m_projectileSkelMeshTemplate;                     		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMesh*                               m_projectileSkelMeshInHand;                       		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UPhysicsAsset*                               m_projectilePhysAsset;                            		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2097 ];

		return pClassPointer;
	};

};

UClass* UYProjData_Mesh::pClassPointer = NULL;

// Class SRGame.YProjData_SoundFX
// 0x001C (0x0068 - 0x004C)
class UYProjData_SoundFX : public UYWeaponDataAssetBase
{
public:
	class UYSoundCueFMOD*                              m_explosionSound;                                 		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_explosionSoundOnSand;                           		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_explosionNonPlayerSound;                        		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_explosionNonPlayerSoundOnSand;                  		// 0x0058 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_flyingSound;                                    		// 0x005C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_bounceSound;                                    		// 0x0060 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_bounceSoundOnSand;                              		// 0x0064 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2098 ];

		return pClassPointer;
	};

};

UClass* UYProjData_SoundFX::pClassPointer = NULL;

// Class SRGame.YProjectileDataDispatcher
// 0x001C (0x0068 - 0x004C)
class UYProjectileDataDispatcher : public UYWeaponDataAssetBase
{
public:
	class UClass*                                      m_usingClass;                                     		// 0x004C (0x0004) [0x0000000000022001]              ( CPF_Edit | CPF_Transient | CPF_EditConst )
	class UClass*                                      m_parentClass;                                    		// 0x0050 (0x0004) [0x0000000000022001]              ( CPF_Edit | CPF_Transient | CPF_EditConst )
	class UYProjectileDataDispatcher*                  m_parentDispatcher;                               		// 0x0054 (0x0004) [0x0000000000022001]              ( CPF_Edit | CPF_Transient | CPF_EditConst )
	class UYProjData_Mesh*                             m_meshDataAsset;                                  		// 0x0058 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_inheritMeshFromParent : 1;                      		// 0x005C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_inheritGfxFromParent : 1;                       		// 0x005C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_inheritSfxFromParent : 1;                       		// 0x005C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	class UYProjData_GraphicsFX*                       m_gfxDataAsset;                                   		// 0x0060 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYProjData_SoundFX*                          m_sfxDataAsset;                                   		// 0x0064 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2099 ];

		return pClassPointer;
	};

};

UClass* UYProjectileDataDispatcher::pClassPointer = NULL;

// Class SRGame.YWeaponData_Mesh
// 0x0064 (0x00B0 - 0x004C)
class UYWeaponData_Mesh : public UYWeaponDataAssetBase
{
public:
	unsigned long                                      m_isSecondaryAndHasSubmesh : 1;                   		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_makePawnAnimParent : 1;                         		// 0x004C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_takeOverTurretMesh : 1;                         		// 0x004C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bHidden : 1;                                    		// 0x004C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	class USkeletalMesh*                               m_meshTemplate;                                   		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_pawnSocketToAttachWeaponTo;                     		// 0x0054 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UPhysicsAsset*                               m_physicsAsset;                                   		// 0x005C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UMaterialInterface* >                m_overrideMaterials;                              		// 0x0060 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UAnimTree*                                   m_animtree;                                       		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UAnimSet* >                          m_animSets;                                       		// 0x0070 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FYS_AnimSet >                       m_additionalPawnAnimSets;                         		// 0x007C (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	TArray< struct FYS_AnimSet >                       m_pistolSpecificAdditionalPawnAnimSets;           		// 0x0088 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	TArray< struct FYS_AimingSet >                     m_additionalPawnAimingSets;                       		// 0x0094 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	class USkeletalMesh*                               m_ammoBoxMesh;                                    		// 0x00A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UStaticMesh*                                 m_shieldMesh;                                     		// 0x00A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_socketToAttachShieldTo;                         		// 0x00A8 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2100 ];

		return pClassPointer;
	};

};

UClass* UYWeaponData_Mesh::pClassPointer = NULL;

// Class SRGame.YWeaponData_MuzzleGfx
// 0x0044 (0x0090 - 0x004C)
class UYWeaponData_MuzzleGfx : public UYWeaponDataAssetBase
{
public:
	int                                                m_mainEffectFrequency;                            		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_shellsEffectFrequency;                          		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_standardMuzzleFireTemplate;                     		// 0x0054 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UParticleSystem*                             m_playersMuzzleFireTemplate;                      		// 0x0058 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_effectDuration;                                 		// 0x005C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UParticleSystem*                             m_standardShellFxTemplate;                        		// 0x0060 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UParticleSystem*                             m_playersShellFxTemplate;                         		// 0x0064 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FName                                       m_shellEjectionSocket;                            		// 0x0068 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UParticleSystem*                             m_overheatFXTemplate;                             		// 0x0070 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UParticleSystem*                             m_overheatingFXTemplate;                          		// 0x0074 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_muzzleLightDuration;                            		// 0x0078 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_muzzleLightActivationThresholdStart;            		// 0x007C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_muzzleLightActivationThresholdEnd;              		// 0x0080 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class APointLight*                                 m_muzzleLightArchetype;                           		// 0x0084 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_randomBrightnessModifierMin;                    		// 0x0088 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_randomBrightnessModifierMax;                    		// 0x008C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2101 ];

		return pClassPointer;
	};

};

UClass* UYWeaponData_MuzzleGfx::pClassPointer = NULL;

// Class SRGame.YWeaponData_MuzzleSfx
// 0x0024 (0x0070 - 0x004C)
class UYWeaponData_MuzzleSfx : public UYWeaponDataAssetBase
{
public:
	class USoundCue*                                   m_firingSoundCue;                                 		// 0x004C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class USoundCue*                                   m_firingNonOwningSoundCue;                        		// 0x0050 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class USoundCue*                                   m_comparedFiringSoundCue;                         		// 0x0054 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class USoundCue*                                   m_tailSoundCue;                                   		// 0x0058 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_firingSoundDuration;                            		// 0x005C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class USoundCue*                                   m_spinningSound;                                  		// 0x0060 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class USoundCue*                                   m_overheatedSound;                                		// 0x0064 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class USoundCue*                                   m_overheatingSound;                               		// 0x0068 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class USoundCue*                                   m_overheatedFiringFailedSound;                    		// 0x006C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2102 ];

		return pClassPointer;
	};

};

UClass* UYWeaponData_MuzzleSfx::pClassPointer = NULL;

// Class SRGame.YWeaponData_Tracer
// 0x000C (0x0058 - 0x004C)
class UYWeaponData_Tracer : public UYWeaponDataAssetBase
{
public:
	TArray< struct FYS_TracerDefinition >              m_tracers;                                        		// 0x004C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2103 ];

		return pClassPointer;
	};

};

UClass* UYWeaponData_Tracer::pClassPointer = NULL;

// Class SRGame.YWeaponDataDispatcher
// 0x0030 (0x007C - 0x004C)
class UYWeaponDataDispatcher : public UYWeaponDataAssetBase
{
public:
	unsigned long                                      m_inheritMeshFromParent : 1;                      		// 0x004C (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_inheritMuzzleGfxFromParent : 1;                 		// 0x004C (0x0004) [0x0000000000000003] [0x00000002] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_inheritMuzzleSfxFromParent : 1;                 		// 0x004C (0x0004) [0x0000000000000003] [0x00000004] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_inheritTracerFromParent : 1;                    		// 0x004C (0x0004) [0x0000000000000003] [0x00000008] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_inheritForceFeedbackFromParent : 1;             		// 0x004C (0x0004) [0x0000000000000003] [0x00000010] ( CPF_Edit | CPF_Const )
	class UYWeaponData_Mesh*                           m_meshDataAsset;                                  		// 0x0050 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UYWeaponData_MuzzleGfx*                      m_muzzleGfxDataAsset;                             		// 0x0054 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UYWeaponData_MuzzleSfx*                      m_muzzleSfxDataAsset;                             		// 0x0058 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UYWeaponData_Tracer*                         m_tracerDataAsset;                                		// 0x005C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UForceFeedbackWaveform*                      m_firingForceFeedbackCurve;                       		// 0x0060 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	TArray< class UCameraAnim* >                       m_scopeStandCamShakes;                            		// 0x0064 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	TArray< class UCameraAnim* >                       m_scopeWalkCamShakes;                             		// 0x0070 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2104 ];

		return pClassPointer;
	};

};

UClass* UYWeaponDataDispatcher::pClassPointer = NULL;

// Class SRGame.YRecoil
// 0x0000 (0x003C - 0x003C)
class UYRecoil : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2105 ];

		return pClassPointer;
	};

	bool Update ( float DeltaSeconds, struct FYS_RecoilDef* Recoil );
	void Start ( struct FYS_RecoilDef* Recoil );
};

UClass* UYRecoil::pClassPointer = NULL;

// Class SRGame.YSkelControlAimAt
// 0x0058 (0x0144 - 0x00EC)
class UYSkelControlAimAt : public USkelControlSingleBone
{
public:
	struct FVector                                     m_targetLocation;                                 		// 0x00EC (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_lookAtTargetLocation : 1;                       		// 0x00F8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_controlEnabled : 1;                             		// 0x00F8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_mirrorAimAt : 1;                                		// 0x00F8 (0x0004) [0x0000000000000003] [0x00000004] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_trackTarget : 1;                                		// 0x00F8 (0x0004) [0x0000000000002002] [0x00000008] ( CPF_Const | CPF_Transient )
	struct FVector                                     m_currentTargetLocation;                          		// 0x00FC (0x000C) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_aimAtAxis;                                      		// 0x0108 (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_turnAxis;                                       		// 0x0109 (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_referenceFrame;                                 		// 0x010A (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FRotator                                    m_rotationOffset;                                 		// 0x010C (0x000C) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FName                                       m_referenceBoneName;                              		// 0x0118 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_minAngle;                                       		// 0x0120 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_maxAngle;                                       		// 0x0124 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_maxTurnSpeed;                                   		// 0x0128 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_smoothingFactor;                                		// 0x012C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_forceDisableDuration;                           		// 0x0130 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_forceDisableTime;                               		// 0x0134 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              m_prevAngle;                                      		// 0x0138 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_currentVelocity;                                		// 0x013C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_referenceLimitOffset;                           		// 0x0140 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2106 ];

		return pClassPointer;
	};

	void ClearTargetLocation ( );
	void SetTargetLocation ( struct FVector TargetLocation );
	void EnableControl ( unsigned long Enable );
};

UClass* UYSkelControlAimAt::pClassPointer = NULL;

// Class SRGame.YSkelControlAimAtTracking
// 0x001C (0x0160 - 0x0144)
class UYSkelControlAimAtTracking : public UYSkelControlAimAt
{
public:
	class AActor*                                      m_targetActor;                                    		// 0x0144 (0x0004) [0x0000000000000000]              
	struct FName                                       m_targetBoneName;                                 		// 0x0148 (0x0008) [0x0000000000000000]              
	struct FVector                                     m_localOffset;                                    		// 0x0150 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMeshComponent*                      m_skeletalMeshComponent;                          		// 0x015C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2107 ];

		return pClassPointer;
	};

	class AActor* GetTargetActor ( );
	void SetTargetActor ( class AActor* TargetActor, struct FName BoneName, struct FVector localOffset );
};

UClass* UYSkelControlAimAtTracking::pClassPointer = NULL;

// Class SRGame.YSkelControlFootPlacement
// 0x0080 (0x01A0 - 0x0120)
class UYSkelControlFootPlacement : public USkelControlFootPlacement
{
public:
	float                                              m_lastLegHeightAdjustment;                        		// 0x0120 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_currentGroundNormal;                            		// 0x0124 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_groundNormalVel;                                		// 0x0130 (0x000C) [0x0000000000000000]              
	float                                              m_normalSmoothingFactor;                          		// 0x013C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxUpDownVelocity;                              		// 0x0140 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_footRotationDistanceTolerance;                  		// 0x0144 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_crouchHeightOffset;                             		// 0x0148 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_hitLocation;                                    		// 0x014C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_interpolatedHitNormal;                          		// 0x0158 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_realHitNormal;                                  		// 0x0164 (0x000C) [0x0000000000000000]              
	class AActor*                                      m_hitActor;                                       		// 0x0170 (0x0004) [0x0000000000000000]              
	class UPhysicalMaterial*                           m_hitPhysMat;                                     		// 0x0174 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_raycastHasHit : 1;                              		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_enableSinking : 1;                              		// 0x0178 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_useAsyncLineChecks : 1;                         		// 0x0178 (0x0004) [0x0000000000004001] [0x00000004] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_justActivated : 1;                              		// 0x0178 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	float                                              m_maxSinkDepth;                                   		// 0x017C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sinkInSpeed;                                    		// 0x0180 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sinkOutSpeed;                                   		// 0x0184 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_groundNormalInfluence;                          		// 0x0188 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_currentSinkDepth;                               		// 0x018C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_raycastTimeInterval;                            		// 0x0190 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lastRaycastTime;                                		// 0x0194 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastRaycastResult;                              		// 0x0198 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_asyncLineCheck;                                 		// 0x019C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2108 ];

		return pClassPointer;
	};

	void EnableSkelControl ( unsigned long bInActive );
};

UClass* UYSkelControlFootPlacement::pClassPointer = NULL;

// Class SRGame.YSkelControlLookAt
// 0x0050 (0x0180 - 0x0130)
class UYSkelControlLookAt : public USkelControlLookAt
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x0130 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	unsigned long                                      m_lookAtTargetLocation : 1;                       		// 0x0134 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_isBeyondLimit : 1;                              		// 0x0134 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	class AActor*                                      m_targetActor;                                    		// 0x0138 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_localOffset;                                    		// 0x013C (0x000C) [0x0000000000000000]              
	struct FName                                       m_targetBoneName;                                 		// 0x0148 (0x0008) [0x0000000000000000]              
	class USkeletalMeshComponent*                      m_targetSkelMeshComponent;                        		// 0x0150 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	struct FRotator                                    m_limitsRotationOffset;                           		// 0x0154 (0x000C) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FVector2D                                   m_currentVelocity;                                		// 0x0160 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_smoothingFactor;                                		// 0x0168 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_targetRotationOffset;                           		// 0x016C (0x000C) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_lookAtDisableCount;                             		// 0x0178 (0x0004) [0x0000000000000000]              
	float                                              m_desiredLookAtAlpha;                             		// 0x017C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2109 ];

		return pClassPointer;
	};

	int GetLookAtDisabledCount ( );
	bool IsLookAtDisabled ( );
	void DisableLookAt ( unsigned long Disable );
	bool GetLookAtLocation ( struct FVector* lookAtLocation );
	class AActor* GetTargetActor ( );
	void SetTargetActor ( class AActor* TargetActor, struct FName BoneName, struct FVector localOffset );
	bool IsLookingAtTargetLocation ( );
	void ClearTargetLocation ( );
	void SetLookAtTargetLocation ( struct FVector NewTargetLocation );
};

UClass* UYSkelControlLookAt::pClassPointer = NULL;

// Class SRGame.YSkelControlPrune
// 0x0014 (0x00D0 - 0x00BC)
class UYSkelControlPrune : public USkelControlBase
{
public:
	struct FName                                       m_startBoneName;                                  		// 0x00BC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_cachedStartBoneIndex;                           		// 0x00C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_numAffectedBones;                               		// 0x00C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_prunedBoneScale;                                		// 0x00CC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2110 ];

		return pClassPointer;
	};

};

UClass* UYSkelControlPrune::pClassPointer = NULL;

// Class SRGame.YSkelControlRecoil
// 0x0090 (0x014C - 0x00BC)
class UYSkelControlRecoil : public USkelControlBase
{
public:
	class AYGamePawn*                                  m_pawn;                                           		// 0x00BC (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	struct FYS_RecoilDef                               m_recoilDef;                                      		// 0x00C0 (0x0070) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_aim;                                            		// 0x0130 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_playRecoil : 1;                                 		// 0x0138 (0x0004) [0x0000000000002001] [0x00000001] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_applyControl : 1;                               		// 0x0138 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_applyAmplitudeDirectly : 1;                     		// 0x0138 (0x0004) [0x0000000000002001] [0x00000004] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_playBurst : 1;                                  		// 0x0138 (0x0004) [0x0000000000002001] [0x00000008] ( CPF_Edit | CPF_Transient )
	int                                                m_burstFireRounds;                                		// 0x013C (0x0004) [0x0000000000000000]              
	float                                              m_refireInterval;                                 		// 0x0140 (0x0004) [0x0000000000000000]              
	int                                                m_burstFireRoundsToGo;                            		// 0x0144 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_refireIntervalToGo;                             		// 0x0148 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2111 ];

		return pClassPointer;
	};

	void PlayRecoil ( );
};

UClass* UYSkelControlRecoil::pClassPointer = NULL;

// Class SRGame.YSkelControlRope
// 0x005C (0x0118 - 0x00BC)
class UYSkelControlRope : public USkelControlBase
{
public:
	int                                                m_numIterations;                                  		// 0x00BC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_damping;                                        		// 0x00C0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_gravityScaling;                                 		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_numRopeBones;                                   		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_lastVisibleBone;                                		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_drawDebugTripods : 1;                           		// 0x00D0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_rebuildParticlesNextTick : 1;                   		// 0x00D0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_rebuildVisibilityNextTick : 1;                  		// 0x00D0 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_needToWakeUp : 1;                               		// 0x00D0 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_sleeping : 1;                                   		// 0x00D0 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_justFellAsleep : 1;                             		// 0x00D0 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	float                                              m_integrationTimeStep;                            		// 0x00D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxIterations;                                  		// 0x00D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FYS_VerletParticle >                m_particles;                                      		// 0x00DC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FYS_VerletConstraint >              m_constraints;                                    		// 0x00E8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_timeLeft;                                       		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_topmostBoneIndex;                               		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class AYVerletParticleCollisionActor* >    m_collisionActors;                                		// 0x00FC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FBoneAtom >                         m_SleepingBoneCache;                              		// 0x0108 (0x000C) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	float                                              m_startupBlockSleepingTime;                       		// 0x0114 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2112 ];

		return pClassPointer;
	};

};

UClass* UYSkelControlRope::pClassPointer = NULL;

// Class SRGame.UTGameUISceneClient
// 0x0044 (0x01E4 - 0x01A0)
class UUTGameUISceneClient : public UGameUISceneClient
{
public:
	unsigned long                                      bShowRenderTimes : 1;                             		// 0x01A0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bInMovie : 1;                                     		// 0x01A0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      bPerformedMinSpecCheck : 1;                       		// 0x01A0 (0x0004) [0x0000000000044000] [0x00000004] ( CPF_Config | CPF_GlobalConfig )
	float                                              PreRenderTime;                                    		// 0x01A4 (0x0004) [0x0000000000000000]              
	float                                              RenderTime;                                       		// 0x01A8 (0x0004) [0x0000000000000000]              
	float                                              TickTime;                                         		// 0x01AC (0x0004) [0x0000000000000000]              
	float                                              AnimTime;                                         		// 0x01B0 (0x0004) [0x0000000000000000]              
	float                                              AvgTime;                                          		// 0x01B4 (0x0004) [0x0000000000000000]              
	float                                              AvgRenderTime;                                    		// 0x01B8 (0x0004) [0x0000000000000000]              
	float                                              FrameCount;                                       		// 0x01BC (0x0004) [0x0000000000000000]              
	float                                              StringRenderTime;                                 		// 0x01C0 (0x0004) [0x0000000000000000]              
	struct FString                                     MissionText;                                      		// 0x01C4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     MovieName;                                        		// 0x01D0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              TimeTillAttractMovie;                             		// 0x01DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              TimeElapsed;                                      		// 0x01E0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2113 ];

		return pClassPointer;
	};

	void UpdateMovieStatus ( );
	void StopMovie ( );
	void StartMovie ( );
	bool IsUIAcceptingInput ( );
	void NotifyGameSessionEnded ( );
	bool IsInSeamlessTravel ( );
	class AWorldInfo* GetWorldInfo ( );
};

UClass* UUTGameUISceneClient::pClassPointer = NULL;

// Class SRGame.UTGameViewportClient
// 0x004C (0x017C - 0x0130)
class UUTGameViewportClient : public UGameViewportClient
{
public:
	struct FString                                     LevelActionMessages[ 0x6 ];                       		// 0x0130 (0x0048) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	unsigned long                                      bHasNotifiedConnectionError : 1;                  		// 0x0178 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_useSecondCamera : 1;                            		// 0x0178 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2114 ];

		return pClassPointer;
	};

	void NotifyConnectionError ( struct FString Message, struct FString Title, unsigned long bAllowSecondAcceptInviteAttempt );
	void SetProgressMessage ( unsigned char MessageType, struct FString Message, struct FString Title, unsigned long bIgnoreFutureNetworkMessages, unsigned long bAllowSecondAcceptInviteAttempt );
	void LayoutPlayers ( );
	void SetSplitscreenConfiguration ( unsigned char SplitType );
	void DrawTransition ( class UCanvas* Canvas );
	void DisplayProgressMessage ( class UCanvas* Canvas );
	void PostRender ( class UCanvas* Canvas );
	bool DoesAllowInput ( );
};

UClass* UUTGameViewportClient::pClassPointer = NULL;

// Class SRGame.UTUI_Widget
// 0x0008 (0x0478 - 0x0470)
class UUTUI_Widget : public UUIObject
{
public:
	unsigned long                                      bRequiresTick : 1;                                		// 0x0470 (0x0004) [0x0000000000000000] [0x00000001] 
	class UYUIScenes*                                  UTSceneOwner;                                     		// 0x0474 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2115 ];

		return pClassPointer;
	};

	int GetPlayerControllerId ( int PlayerIndex );
	class UUIDataStore* FindDataStore ( struct FName DataStoreTag );
	void NotifyGameSessionEnded ( );
};

UClass* UUTUI_Widget::pClassPointer = NULL;

// Class SRGame.UTUIButtonBar
// 0x0018 (0x0490 - 0x0478)
class UUTUIButtonBar : public UUTUI_Widget
{
public:
	class UUTUIButtonBarButton*                        Buttons[ 0x6 ];                                   		// 0x0478 (0x0018) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2116 ];

		return pClassPointer;
	};

	bool CanAcceptFocus ( int PlayerIndex, unsigned long bIncludeParentVisibility );
	void ToggleButton ( int ButtonIdx, unsigned long bActive );
	void Clear ( );
	void ClearButton ( int buttonIndex );
	void SetButton ( int buttonIndex, struct FString ButtonTextMarkup, struct FScriptDelegate ButtonDelegate );
	int AppendButton ( struct FString ButtonTextMarkup, struct FScriptDelegate ButtonDelegate );
	void PlayUIAnimation ( struct FName AnimName, class UUIAnimationSeq* AnimSeqTemplate, unsigned char OverrideLoopMode, float PlaybackRate, float InitialPosition, unsigned long bSetAnimatingFlag );
	void PostInitialize ( );
};

UClass* UUTUIButtonBar::pClassPointer = NULL;

// Class SRGame.UTUIButtonBarButton
// 0x0000 (0x04B4 - 0x04B4)
class UUTUIButtonBarButton : public UUILabelButton
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2117 ];

		return pClassPointer;
	};

	bool CanAcceptFocus ( int PlayerIndex, unsigned long bIncludeParentVisibility );
};

UClass* UUTUIButtonBarButton::pClassPointer = NULL;

// Class SRGame.YAdjustableSafeRegionPanel
// 0x0004 (0x0488 - 0x0484)
class UYAdjustableSafeRegionPanel : public UUISafeRegionPanel
{
public:
	unsigned long                                      bForce16x9AspectRatio : 1;                        		// 0x0484 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2118 ];

		return pClassPointer;
	};

	void DoRefresh ( );
};

UClass* UYAdjustableSafeRegionPanel::pClassPointer = NULL;

// Class SRGame.YContextCommands
// 0x0104 (0x0140 - 0x003C)
class UYContextCommands : public UObject
{
public:
	struct FVisibilityFlags                            m_flags;                                          		// 0x003C (0x0004) [0x0000000000000000]              
	TArray< struct FYS_ContextCommandInfo >            m_contextCommands;                                		// 0x0040 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	class AYPlayerController*                          m_ctrl;                                           		// 0x004C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_forceCommandRebuild : 1;                        		// 0x0050 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_squadCanOpenFire : 1;                           		// 0x0050 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_squadCanStunEnemies : 1;                        		// 0x0050 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_attackCommandRunning : 1;                       		// 0x0050 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_healCommandRunning : 1;                         		// 0x0050 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_openFireCommandRunning : 1;                     		// 0x0050 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_stunEnemiesCommandRunning : 1;                  		// 0x0050 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_oldAttackMarkingMode : 1;                       		// 0x0050 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_isFocusedCtxCommand : 1;                        		// 0x0050 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_isDownButNotOut : 1;                            		// 0x0050 (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	unsigned long                                      m_squadMateDown : 1;                              		// 0x0050 (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      m_squadDown : 1;                                  		// 0x0050 (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      m_squadDownChanged : 1;                           		// 0x0050 (0x0004) [0x0000000000002000] [0x00001000] ( CPF_Transient )
	unsigned long                                      m_wantsToShowPOI : 1;                             		// 0x0050 (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      m_commandsAlwaysVisible : 1;                      		// 0x0050 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned char                                      m_kismetOverrideCommand;                          		// 0x0054 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_kismetOverrideCommandOld;                       		// 0x0055 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_focusedCtxCommand;                              		// 0x0056 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_cmdToIssue;                                     		// 0x0057 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      m_focusedMarkable;                                		// 0x0058 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_ContextCommandInfo                      m_cmdInfoToIssue;                                 		// 0x005C (0x00D8) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UYSoundCueFMOD*                              m_issueCommandSound;                              		// 0x0134 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_newCommandSound;                                		// 0x0138 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_cantIssueCommandSound;                          		// 0x013C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2119 ];

		return pClassPointer;
	};

	void ClearLevelReferences ( );
	void BindContextCommand ( unsigned char Cmd, struct FString txt, struct FString Desc, class UMaterialInstanceConstant* Icon );
	void EndIssueCommand ( );
	void BeginIssueCommand ( );
	unsigned char GetAvailableGenericCommand ( );
	bool GetBoundContextCommandInfo ( struct FYS_ContextCommandInfo* cmdInfo );
	unsigned char GetBoundContextCommand ( );
	void GetContextCommandInfo ( unsigned char Cmd, struct FYS_ContextCommandInfo* cmdInfo );
};

UClass* UYContextCommands::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStats
// 0x002C (0x0114 - 0x00E8)
class UYDataStore_OnlineStats : public UUIDataStore_OnlineStats
{
public:
	TArray< struct FLevelIconMapping >                 SpecopsLevelIconMappings;                         		// 0x00E8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	TArray< struct FLevelIconMapping >                 KonradLevelIconMappings;                          		// 0x00F4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned long                                      bInRead : 1;                                      		// 0x0100 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_IsTopOfList : 1;                                		// 0x0100 (0x0004) [0x0000000000000000] [0x00000002] 
	class USettings*                                   LeaderboardSettings;                              		// 0x0104 (0x0004) [0x0000000000000000]              
	struct FUniqueNetId                                myID;                                             		// 0x0108 (0x0008) [0x0000000000000000]              
	class UClass*                                      LeaderboardSettingsClass;                         		// 0x0110 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2120 ];

		return pClassPointer;
	};

	void OnReadComplete ( unsigned long bWasSuccessful );
	bool RefreshStats ( unsigned char ControllerIndex );
	void SetStatsReadInfo ( );
};

UClass* UYDataStore_OnlineStats::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsKills
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsKills : public UYDataStore_OnlineStats
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2121 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsKills::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsMode
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsMode : public UYDataStore_OnlineStats
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2122 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsMode::pClassPointer = NULL;

// Class SRGame.YDirectionIndicator
// 0x0030 (0x006C - 0x003C)
class UYDirectionIndicator : public UObject
{
public:
	struct FYS_ArrowStyle                              m_style;                                          		// 0x003C (0x0030) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2123 ];

		return pClassPointer;
	};

	void GetScreenDir ( struct FVector shootDir, struct FRotator playerRotation2d, struct FVector screenMid, struct FVector* screenDir, float* Angle );
	void InitArrowMaterial ( class UMaterialInstanceConstant* P );
};

UClass* UYDirectionIndicator::pClassPointer = NULL;

// Class SRGame.YFourthWallHealthFeedback
// 0x00A8 (0x00E4 - 0x003C)
class UYFourthWallHealthFeedback : public UObject
{
public:
	int                                                numbuckets;                                       		// 0x003C (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                numpanelstages;                                   		// 0x0040 (0x0004) [0x0000000000000000]              
	int                                                numbucketstages;                                  		// 0x0044 (0x0004) [0x0000000000000000]              
	float                                              m_maxHealthModifier;                              		// 0x0048 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_lastWarningHealthPct;                           		// 0x004C (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_recoverLIFO : 1;                                		// 0x0050 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_showlastWarning : 1;                            		// 0x0050 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_debugMode : 1;                                  		// 0x0050 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_debugBucketSizeInitialized : 1;                 		// 0x0050 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              m_midScreenSplashDelay;                           		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_midScreenSplashLockedAngle;                     		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fadeInSpeed;                                    		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fadeOutSpeed;                                   		// 0x0060 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FYS_Impact >                        m_impacts;                                        		// 0x0064 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_HitBucket >                     m_buckets;                                        		// 0x0070 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_bucketStack;                                    		// 0x007C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UMaterialInstanceConstant* >         m_bucketMIC;                                      		// 0x0088 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_FeedbackStage                           m_feedbackStage;                                  		// 0x0094 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UUIImage*                                    m_lastWarning;                                    		// 0x00A0 (0x0004) [0x0000000000000000]              
	class UYUIScene_Hud*                               m_feedbackSceneTemplate;                          		// 0x00A4 (0x0004) [0x0000000000000000]              
	class UYUIScene_Hud*                               m_openedFeedbackScene;                            		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              m_unusedTakenDamage;                              		// 0x00AC (0x0004) [0x0000000000000000]              
	float                                              m_pawnHealthSnapshot;                             		// 0x00B0 (0x0004) [0x0000000000000000]              
	float                                              m_damageStep;                                     		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                m_maxBucketStages;                                		// 0x00B8 (0x0004) [0x0000000000000000]              
	float                                              m_lockedAngleRange;                               		// 0x00BC (0x0004) [0x0000000000000000]              
	float                                              m_lastMidscreenSplashTime;                        		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              m_hueShiftStartAmt;                               		// 0x00C4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_hueShiftEndAmt;                                 		// 0x00C8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_currentHueShiftValue;                           		// 0x00CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_oldHueShiftValue;                               		// 0x00D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_hueShiftMatInstParent;                          		// 0x00D4 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_hueShiftMatInst;                                		// 0x00D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_borderSegmentThickness;                         		// 0x00DC (0x0004) [0x0000000000000000]              
	float                                              m_impactScaleOffset;                              		// 0x00E0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2124 ];

		return pClassPointer;
	};

	void DebugInitBorderSegmentSizes ( class AYHUD* HUD );
	void DrawDebugBorderSegments ( class AYHUD* HUD, float deltaSec );
	void DrawDebugHitFeedback ( class AYHUD* HUD, float deltaSec );
	void SetOverallOpacity ( float Value );
	void DrawImpacts ( class AYHUD* HUD, float deltaSec );
	void TickBuckets ( float DeltaTime );
	int GetStackCount ( int Idx );
	void VerifyBacketStack ( );
	void UpdateHealthHueChangePostFX ( );
	void InstantRecoverBuckets ( );
	void TurnOff ( );
	void SetBucketVisibility ( int Idx, unsigned long visible );
	void DecreaseBucketDamage ( int bucketindex );
	void DisplayAllBucketsForDBNO ( );
	void AddLocation ( struct FVector HitLoc, int Damage, struct FVector Momentum );
	void AddHit ( class AActor* Inst, int Damage, struct FVector Momentum );
	void UpdateDirectionVectorToMIC ( );
	class UMaterialInstanceConstant* CreateRunTimeMIC ( class UMaterialInstanceConstant* mic );
	void SetHueShiftMatInst ( );
	void Initialize ( class AYGamePawn* pwn );
};

UClass* UYFourthWallHealthFeedback::pClassPointer = NULL;

// Class SRGame.YGreenRedDisplay
// 0x0028 (0x0064 - 0x003C)
class UYGreenRedDisplay : public UObject
{
public:
	float                                              m_PosX;                                           		// 0x003C (0x0004) [0x0000000000000000]              
	float                                              m_PosY;                                           		// 0x0040 (0x0004) [0x0000000000000000]              
	float                                              m_SizeW;                                          		// 0x0044 (0x0004) [0x0000000000000000]              
	float                                              m_SizeH;                                          		// 0x0048 (0x0004) [0x0000000000000000]              
	float                                              m_PointerPos;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_GuidRedGreenMat;                                		// 0x0050 (0x0004) [0x0000000000000000]              
	struct FColor                                      m_PointerColor;                                   		// 0x0054 (0x0004) [0x0000000000000000]              
	struct FString                                     m_HeadText;                                       		// 0x0058 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2125 ];

		return pClassPointer;
	};

	void Draw ( class UCanvas* C, float ppos );
	void Init ( struct FString hText, float X, float Y );
};

UClass* UYGreenRedDisplay::pClassPointer = NULL;

// Class SRGame.YHUD_MP
// 0x007F (0x0750 - 0x06D1)
class AYHUD_MP : public AYHUD
{
public:
	float                                              m_matchResultDelay;                               		// 0x06D4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     BleedOutDeathMessage;                             		// 0x06D8 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_FriendlyHVTDestroyable;                         		// 0x06E4 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EnemyHVTDestroyable;                            		// 0x06F0 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_RepairOfflineStationMessage;                    		// 0x06FC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_WaitForRoundOver;                               		// 0x0708 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	unsigned long                                      bHudMessageRendered : 1;                          		// 0x0714 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bPlayerExperienceInitialised : 1;               		// 0x0714 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bGameTypeInitialised : 1;                       		// 0x0714 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bHasShownModeInstructionPanel : 1;              		// 0x0714 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bIsShowningModeInstructionPanel : 1;            		// 0x0714 (0x0004) [0x0000000000000000] [0x00000010] 
	struct FVector2D                                   ClockPosition;                                    		// 0x0718 (0x0008) [0x0000000000000000]              
	class UYUIScenes*                                  MatchResultSceneTemplate;                         		// 0x0720 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_iStartUpMsgRemainingTime;                       		// 0x0724 (0x0004) [0x0000000000000000]              
	class UFont*                                       m_PlayerNameFont;                                 		// 0x0728 (0x0004) [0x0000000000000000]              
	struct FString                                     m_PlayerFontName;                                 		// 0x072C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_sLocRevegeRound;                                		// 0x0738 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fRoundMessageDuration;                          		// 0x0744 (0x0004) [0x0000000000000000]              
	float                                              m_fRoundMessagefadeOut;                           		// 0x0748 (0x0004) [0x0000000000000000]              
	float                                              m_reticuleHitIndicatorDuration;                   		// 0x074C (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2126 ];

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	void HideReticuleHitIndicator ( );
	void FlashReticuleHitIndicator ( );
	void HideModeMessagePanel ( );
	void ShowMustWaitForNextRoundMessage ( );
	void ShowRepairOfflineStationMessage ( );
	void ShowHVTWeaponsFree ( unsigned long myTeam );
	void ShowHVTUnderAttackMessage ( );
	void ShowVitalPointUnderAttackMessage ( );
	void ShowVitalPointDestroyedMessage ( class APlayerReplicationInfo* destroyer );
	void ShowVitalPointRepairedMessage ( class APlayerReplicationInfo* repairer );
	void ShowStationRepairedMessage ( unsigned long sameTeam, class APlayerReplicationInfo* repairer );
	void ShowStationSabotageMessage ( unsigned long sameTeam, class APlayerReplicationInfo* repairer );
	void ShowRoundBeginMessage ( struct FString sMessage );
	void ShowModeMessage ( struct FString Message, float Duration );
	void HideModeInstructionPanel ( );
	void ShowModeInstructionPanel ( );
	void AddIntelEventMessage ( class AYPickup_Collectable* collectiblePickup );
	void AddObjectiveEventMessage ( struct FString Header, struct FString Objective, unsigned long complete );
	void AddPickupEventMessage ( struct FString Message, struct FString Icon, struct FString msg2 );
	void AddSquadEventMessage ( struct FString squadStatus );
	void SetCommandMessage ( struct FString msg );
	void NotifyHUDMatchStart ( );
	void NotifyShowMidGameMenu ( );
	void NotifyHideMidGameMenu ( );
	void AddMessage ( struct FString Message, int colorID );
	void LocalizedMessage ( class UClass* InMessageClass, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, struct FString CriticalString, int Switch, float Position, float Lifetime, int FontSize, struct FColor DrawColor, class UObject* OptionalObject );
	void UpdateRemingTimeMessage ( );
	void SetStartUpMessage ( unsigned char iMsgType, struct FString sMessage );
	void UpdatefollowingPlayer ( );
	void UpdateScorePanel ( );
	void YDrawActorOverlays ( );
	void UpdateGameHUD ( unsigned long bUpdateHUD );
	void ShowScoreScene ( unsigned long bShow, class UYUIScenes* Template );
	void OpenSpectatorScene ( unsigned long bOpen, unsigned long bShowCameraCycle, unsigned long bOpenReminder );
	void SetPawn ( class APawn* Pawn );
	void HideKillerInfos ( );
	void ShowKillerInfos ( );
	void SetKillerWeaponInfos ( unsigned char primary, unsigned char secondary, unsigned char explosive );
	void SetKillerInfos ( struct FString sName, unsigned char eTeam, unsigned char eMajorPerk, int iPerkLevel, unsigned char ePerkMinor1, unsigned char ePerkMinor2, unsigned char ePerkMinor3 );
	void SetXPMessage ( struct FString Message, int iEarnedXP );
	void SetPlayerExperience ( int iXP, int iCollectedXP );
	void SetMinorPerks ( unsigned char eMinorPerk1, unsigned char eMinorPerk2, unsigned char eMinorPerk3 );
	void SetMajorPerk ( unsigned char ePerk, int iPerkLevel );
	void SetCharacterName ( struct FString sName );
	void InitCharacter ( );
	void InitSceneGameType ( );
	unsigned char GetMultiplayerModeId ( );
	void ShowMatchEndScoreboard ( );
	void SetShowObjectives ( unsigned long bNewValue );
	void SetShowScores ( unsigned long bNewValue );
	void Timer ( );
	void DisplayLocalMessagesForMatchResult ( );
	void DrawTacticalView ( float dt );
	struct FVector2D ResolveHUDPosition ( struct FVector2D Position, float Width, float Height );
	struct FString GetPermanentScoreString ( );
	void DisplayPermanentScore ( );
	void DisplayClock ( );
	bool ShouldDisplayWaitingForMatch ( );
	void DrawGameHud ( float dt );
	void PostRender ( );
	class UFont* GetFontForDistanceOverlays ( );
	class UFont* GetFontForActorOverlays ( );
	void DisplayHudMessage ( struct FString Message, float XOffsetPct, float YOffsetPct );
	void PostBeginPlay ( );
};

UClass* AYHUD_MP::pClassPointer = NULL;

// Class SRGame.YITacticalMarkable
// 0x0000 (0x003C - 0x003C)
class UYITacticalMarkable : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2127 ];

		return pClassPointer;
	};

	void OnDetected ( unsigned long detected );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	struct FBoxSphereBounds GetBounds ( );
	bool IsEnabledForTacView ( );
	void OnToggle ( class USeqAct_Toggle* seqAct );
};

UClass* UYITacticalMarkable::pClassPointer = NULL;

// Class SRGame.YMarkerAnimation
// 0x0000 (0x003C - 0x003C)
class UYMarkerAnimation : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2128 ];

		return pClassPointer;
	};

};

UClass* UYMarkerAnimation::pClassPointer = NULL;

// Class SRGame.YMarkerAnimationSeq
// 0x0024 (0x0060 - 0x003C)
class UYMarkerAnimationSeq : public UYMarkerAnimation
{
public:
	struct FName                                       SeqName;                                          		// 0x003C (0x0008) [0x0000000000000000]              
	float                                              SeqDuration;                                      		// 0x0044 (0x0004) [0x0000000000000000]              
	TArray< struct FYMarkerAnimTrack >                 Tracks;                                           		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      bAbsolutePositioning : 1;                         		// 0x0054 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_cuedAnimShouldLoop : 1;                         		// 0x0054 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FName                                       m_nextAnimName;                                   		// 0x0058 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2129 ];

		return pClassPointer;
	};

	void ApplyAnimation ( class UYMarkerBase* TargetWidget, int TrackIndex, float Position, int LFI, int NFI, struct FYMarkerAnimSeqRef* AnimRefInst );
};

UClass* UYMarkerAnimationSeq::pClassPointer = NULL;

// Class SRGame.YMarkerBase
// 0x0118 (0x0154 - 0x003C)
class UYMarkerBase : public UObject
{
public:
	struct FName                                       m_rotationName;                                   		// 0x003C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_opacityName;                                    		// 0x0044 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_flashName;                                      		// 0x004C (0x0008) [0x0000000000000002]              ( CPF_Const )
	class AYHUD*                                       m_hud;                                            		// 0x0054 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_upperLeftDrawPos;                               		// 0x0058 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_lowerRightDrawPos;                              		// 0x0060 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_markerSize;                                     		// 0x0068 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_pivot;                                          		// 0x0070 (0x0008) [0x0000000000000000]              
	float                                              m_markerScaleX;                                   		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              m_markerScaleY;                                   		// 0x007C (0x0004) [0x0000000000000000]              
	float                                              m_markerScaleModifier;                            		// 0x0080 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FVector2D                                   m_selectorOffset;                                 		// 0x0084 (0x0008) [0x0000000000000000]              
	unsigned long                                      m_wasDrawn : 1;                                   		// 0x008C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_visible : 1;                                    		// 0x008C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_showInRestrictedMode : 1;                       		// 0x008C (0x0004) [0x0000000000000000] [0x00000004] 
	struct FVector2D                                   m_distScaleDistances;                             		// 0x0090 (0x0008) [0x0000000000004000]              ( CPF_Config )
	struct FVector2D                                   m_distScaleSizes;                                 		// 0x0098 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_distance;                                       		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              m_markerRotation;                                 		// 0x00A4 (0x0004) [0x0000000000000000]              
	struct FColor                                      m_color;                                          		// 0x00A8 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_animScale;                                      		// 0x00AC (0x0008) [0x0000000000000000]              
	float                                              m_transparency;                                   		// 0x00B4 (0x0004) [0x0000000000000000]              
	float                                              m_screenToWorldBlending;                          		// 0x00B8 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_animUpperLeftPos;                               		// 0x00BC (0x000C) [0x0000000000000000]              
	struct FVector                                     m_animLowerRightPos;                              		// 0x00C8 (0x000C) [0x0000000000000000]              
	struct FVector2D                                   m_animOrigin;                                     		// 0x00D4 (0x0008) [0x0000000000000000]              
	struct FVector                                     m_offset3D;                                       		// 0x00DC (0x000C) [0x0000000000000000]              
	struct FVector2D                                   m_offset2D;                                       		// 0x00E8 (0x0008) [0x0000000000000000]              
	class UYMarkerBase*                                AnimationParent;                                  		// 0x00F0 (0x0004) [0x0000000000000000]              
	struct FVector                                     AnimationPosition;                                		// 0x00F4 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYMarkerAnimSeqRef >                AnimStack;                                        		// 0x0100 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FYS_AnimSoundDef >                  m_sounds;                                         		// 0x010C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UMaterialInstanceConstant* >         m_markerMaterialTemplates;                        		// 0x0118 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UMaterialInstanceConstant* >         m_markerMaterials;                                		// 0x0124 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_markerMaterial;                                 		// 0x0130 (0x0004) [0x0000000000000000]              
	class UTexture2D*                                  m_markerTexture;                                  		// 0x0134 (0x0004) [0x0000000000000000]              
	struct FTextureCoordinates                         m_markerTexCoord;                                 		// 0x0138 (0x0010) [0x0000000000000000]              
	struct FScriptDelegate                             __OnUIAnimEnd__Delegate;                          		// 0x0148 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2130 ];

		return pClassPointer;
	};

	void TickAnim ( float DeltaTime );
	void OnUIAnimEnd ( class UYMarkerBase* AnimTarget, int AnimIndex, class UYMarkerAnimationSeq* AnimSeq );
	void UIAnimEnd ( int SeqIndex );
	void ClearUIAnimation ( struct FName AnimName, class UYMarkerAnimationSeq* AnimSeq );
	void StopUIAnimation ( struct FName AnimName, class UYMarkerAnimationSeq* AnimSeq, unsigned long bFinalize );
	void StopAllAnimations ( );
	void PlayUIAnimation ( struct FName AnimName, class UYMarkerAnimationSeq* AnimSeqTemplate, float PlaybackRate, unsigned long bLoop, float InitialPosition );
	void Draw ( class AYHUD* HUD );
	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
	void BeginDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
	void GetScreenPos ( struct FVector2D* upperLeft, struct FVector2D* lowerRight, float* Distance );
	void Offset ( struct FVector2D Offset );
	void Destroy ( );
	void Initialize ( class AYHUD* HUD );
};

UClass* UYMarkerBase::pClassPointer = NULL;

// Class SRGame.YMarker
// 0x000C (0x0160 - 0x0154)
class UYMarker : public UYMarkerBase
{
public:
	class UClass*                                      m_arrowClass;                                     		// 0x0154 (0x0004) [0x0000000000000000]              
	class UYMarkerArrow*                               m_arrow;                                          		// 0x0158 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bArrowVisible : 1;                              		// 0x015C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2131 ];

		return pClassPointer;
	};

	void Destroy ( );
	void BeginDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
	void Initialize ( class AYHUD* HUD );
};

UClass* UYMarker::pClassPointer = NULL;

// Class SRGame.YMarkerBracket
// 0x0010 (0x0170 - 0x0160)
class UYMarkerBracket : public UYMarker
{
public:
	unsigned long                                      m_useFixedSize : 1;                               		// 0x0160 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FVector                                     m_fixedSizeExtents;                               		// 0x0164 (0x000C) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2132 ];

		return pClassPointer;
	};

	void Draw ( class AYHUD* HUD );
};

UClass* UYMarkerBracket::pClassPointer = NULL;

// Class SRGame.YMarkerBracket2D
// 0x0000 (0x0170 - 0x0170)
class UYMarkerBracket2D : public UYMarkerBracket
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2133 ];

		return pClassPointer;
	};

	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
};

UClass* UYMarkerBracket2D::pClassPointer = NULL;

// Class SRGame.YMarkerBracket3D
// 0x0000 (0x0170 - 0x0170)
class UYMarkerBracket3D : public UYMarkerBracket
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2134 ];

		return pClassPointer;
	};

	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
};

UClass* UYMarkerBracket3D::pClassPointer = NULL;

// Class SRGame.YIcon_InvisibleBlock
// 0x0000 (0x0170 - 0x0170)
class UYIcon_InvisibleBlock : public UYMarkerBracket3D
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2135 ];

		return pClassPointer;
	};

	void Draw ( class AYHUD* HUD );
};

UClass* UYIcon_InvisibleBlock::pClassPointer = NULL;

// Class SRGame.YMarkerIcon
// 0x0048 (0x01A8 - 0x0160)
class UYMarkerIcon : public UYMarker
{
public:
	unsigned char                                      m_pawnBone;                                       		// 0x0160 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_displayTeam;                                    		// 0x0161 (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bDrawDistanceText : 1;                          		// 0x0164 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bAttachToArrow : 1;                             		// 0x0164 (0x0004) [0x0000000000000000] [0x00000002] 
	struct FVector2D                                   m_distanceTextOffset;                             		// 0x0168 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDisplayDistance;                             		// 0x0170 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_distFromArrow;                                  		// 0x0174 (0x0004) [0x0000000000000000]              
	class UFont*                                       m_DistanceTextFont;                               		// 0x0178 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_DistanceTextScale;                              		// 0x017C (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FFontRenderInfo                             m_renderInfo;                                     		// 0x0180 (0x0028) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2136 ];

		return pClassPointer;
	};

	void Draw ( class AYHUD* HUD );
	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
	void BeginDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
};

UClass* UYMarkerIcon::pClassPointer = NULL;

// Class SRGame.YIcon_AmmoPickup
// 0x033C (0x04E4 - 0x01A8)
class UYIcon_AmmoPickup : public UYMarkerIcon
{
public:
	struct FYS_MaterialData                            m_grenadeMaterialData;                            		// 0x01A8 (0x0054) [0x0000000000004000]              ( CPF_Config )
	struct FYS_MaterialData                            m_C4MaterialData;                                 		// 0x01FC (0x0054) [0x0000000000004000]              ( CPF_Config )
	struct FYS_MaterialData                            m_extClipMaterialData;                            		// 0x0250 (0x0054) [0x0000000000004000]              ( CPF_Config )
	struct FYS_MaterialData                            m_bulletMaterialData;                             		// 0x02A4 (0x0054) [0x0000000000004000]              ( CPF_Config )
	struct FYS_MaterialData                            m_medkitMaterialData;                             		// 0x02F8 (0x0054) [0x0000000000004000]              ( CPF_Config )
	struct FYS_MaterialData                            m_weaponMaterialData;                             		// 0x034C (0x0054) [0x0000000000004000]              ( CPF_Config )
	struct FYS_MaterialData                            m_armorMaterialData;                              		// 0x03A0 (0x0054) [0x0000000000004000]              ( CPF_Config )
	struct FYS_MaterialData                            m_scanMaterialData;                               		// 0x03F4 (0x0054) [0x0000000000004000]              ( CPF_Config )
	struct FYS_MaterialData                            m_mineMaterialData;                               		// 0x0448 (0x0054) [0x0000000000004000]              ( CPF_Config )
	struct FName                                       ParamName1;                                       		// 0x049C (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName2;                                       		// 0x04A4 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName3;                                       		// 0x04AC (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName4;                                       		// 0x04B4 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName5;                                       		// 0x04BC (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName6;                                       		// 0x04C4 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName7;                                       		// 0x04CC (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName8;                                       		// 0x04D4 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName9;                                       		// 0x04DC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2137 ];

		return pClassPointer;
	};

	void ApplyMaterialConstants ( unsigned char ammoType, int overrideTeamNum, float weaponViewDistanceOverride );
};

UClass* UYIcon_AmmoPickup::pClassPointer = NULL;

// Class SRGame.YIcon_CP_MainObjective
// 0x0008 (0x01B0 - 0x01A8)
class UYIcon_CP_MainObjective : public UYMarkerIcon
{
public:
	struct FVector2D                                   m_markerSizeOOS;                                  		// 0x01A8 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2138 ];

		return pClassPointer;
	};

	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
};

UClass* UYIcon_CP_MainObjective::pClassPointer = NULL;

// Class SRGame.YIcon_HD_CaptureZone
// 0x00BC (0x0264 - 0x01A8)
class UYIcon_HD_CaptureZone : public UYMarkerIcon
{
public:
	struct FLinearColor                                m_scoringColorStart[ 0x3 ];                       		// 0x01A8 (0x0030) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_scoringColorEnd[ 0x3 ];                         		// 0x01D8 (0x0030) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_scoringColorText[ 0x3 ];                        		// 0x0208 (0x0030) [0x0000000000004000]              ( CPF_Config )
	struct FName                                       ParamName_Color;                                  		// 0x0238 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName_Color2;                                 		// 0x0240 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName_Broken;                                 		// 0x0248 (0x0008) [0x0000000000000000]              
	struct FName                                       ParamName_Scoring;                                		// 0x0250 (0x0008) [0x0000000000000000]              
	struct FString                                     m_commandMessage;                                 		// 0x0258 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2139 ];

		return pClassPointer;
	};

	void SetBroken ( unsigned long broken );
	void SetTeamScoring ( unsigned char Team, unsigned char localPlayerTeam );
};

UClass* UYIcon_HD_CaptureZone::pClassPointer = NULL;

// Class SRGame.YIcon_HD_Radio
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_HD_Radio : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2140 ];

		return pClassPointer;
	};

};

UClass* UYIcon_HD_Radio::pClassPointer = NULL;

// Class SRGame.YIcon_MP_DBNO
// 0x0010 (0x01B8 - 0x01A8)
class UYIcon_MP_DBNO : public UYMarkerIcon
{
public:
	struct FYS_DBNOMaterialData                        m_materialData[ 0x2 ];                            		// 0x01A8 (0x0008) [0x0000000000004000]              ( CPF_Config )
	struct FName                                       ParamName_Silhouette;                             		// 0x01B0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2141 ];

		return pClassPointer;
	};

	void ApplyTexture ( unsigned char Type );
};

UClass* UYIcon_MP_DBNO::pClassPointer = NULL;

// Class SRGame.YIcon_MP_GrenadeThrow
// 0x0050 (0x01F8 - 0x01A8)
class UYIcon_MP_GrenadeThrow : public UYMarkerIcon
{
public:
	struct FVector2D                                   m_markerSizeOOS;                                  		// 0x01A8 (0x0008) [0x0000000000000000]              
	unsigned long                                      m_isBlinking : 1;                                 		// 0x01B0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_wasBlinkingBefore : 1;                          		// 0x01B0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	struct FLinearColor                                m_redColor;                                       		// 0x01B4 (0x0010) [0x0000000000000000]              
	struct FLinearColor                                m_whiteColor;                                     		// 0x01C4 (0x0010) [0x0000000000000000]              
	struct FLinearColor                                m_settingArrowBlink;                              		// 0x01D4 (0x0010) [0x0000000000000000]              
	struct FLinearColor                                m_settingArrowNotBlink;                           		// 0x01E4 (0x0010) [0x0000000000000000]              
	float                                              m_coopDisplayDistanceModifier;                    		// 0x01F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2142 ];

		return pClassPointer;
	};

	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
	void BeginDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
};

UClass* UYIcon_MP_GrenadeThrow::pClassPointer = NULL;

// Class SRGame.YIcon_MP_Hostile
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_MP_Hostile : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2143 ];

		return pClassPointer;
	};

	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
};

UClass* UYIcon_MP_Hostile::pClassPointer = NULL;

// Class SRGame.YIcon_SquadDBNO
// 0x0010 (0x01B8 - 0x01A8)
class UYIcon_SquadDBNO : public UYMarkerIcon
{
public:
	struct FVector2D                                   m_markerSizeOOS;                                  		// 0x01A8 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_pivotOOS;                                       		// 0x01B0 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2144 ];

		return pClassPointer;
	};

	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
};

UClass* UYIcon_SquadDBNO::pClassPointer = NULL;

// Class SRGame.YMarkerArrow
// 0x0014 (0x0168 - 0x0154)
class UYMarkerArrow : public UYMarkerBase
{
public:
	float                                              m_scaleOffset;                                    		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              m_scaleOffsetY;                                   		// 0x0158 (0x0004) [0x0000000000000000]              
	float                                              m_arrowRotation;                                  		// 0x015C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bUseSafeArea : 1;                               		// 0x0160 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_animScaleOffset;                                		// 0x0164 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2145 ];

		return pClassPointer;
	};

	void Draw ( class AYHUD* HUD );
	void CalcArrowPositon ( class AYHUD* HUD, class UCanvas* Canvas, struct FVector ScreenPos, float CenterX, float CenterY );
	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
};

UClass* UYMarkerArrow::pClassPointer = NULL;

// Class SRGame.YArrow_ExplosiveThrow
// 0x0004 (0x016C - 0x0168)
class UYArrow_ExplosiveThrow : public UYMarkerArrow
{
public:
	int                                                m_grenadeDisplayRadius;                           		// 0x0168 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2146 ];

		return pClassPointer;
	};

	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
};

UClass* UYArrow_ExplosiveThrow::pClassPointer = NULL;

// Class SRGame.YArrow_SquadMember
// 0x0010 (0x0178 - 0x0168)
class UYArrow_SquadMember : public UYMarkerArrow
{
public:
	struct FName                                       m_goDownFlashAnimName;                            		// 0x0168 (0x0008) [0x0000000000000002]              ( CPF_Const )
	class AYGamePawn*                                  m_pawn;                                           		// 0x0170 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_wasDownButNotOut : 1;                           		// 0x0174 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2147 ];

		return pClassPointer;
	};

	bool PreDraw ( class AActor* Target, class AActor* observer, class AYHUD* HUD, unsigned long tacViewOn );
	void Initialize ( class AYHUD* HUD );
};

UClass* UYArrow_SquadMember::pClassPointer = NULL;

// Class SRGame.YSeqAct_Fade
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_Fade : public USequenceAction
{
public:
	float                                              m_fadeAlpha;                                      		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeTarget;                                     		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeTime;                                       		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_pulse : 1;                                      		// 0x0100 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2148 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_Fade::pClassPointer = NULL;

// Class SRGame.YSeqEvent_ContextCommand
// 0x0008 (0x0118 - 0x0110)
class UYSeqEvent_ContextCommand : public USequenceEvent
{
public:
	unsigned char                                      m_specificCommand;                                		// 0x0110 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      isAttached : 1;                                   		// 0x0114 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2149 ];

		return pClassPointer;
	};

	void RegisterEvent ( );
	int GetObjClassVersion ( );
};

UClass* UYSeqEvent_ContextCommand::pClassPointer = NULL;

// Class SRGame.YShootable
// 0x0000 (0x003C - 0x003C)
class UYShootable : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2150 ];

		return pClassPointer;
	};

	bool GetCrosshairColorType ( class AYGamePawn* shootingPawn, unsigned char* colorType );
	bool IsDead ( );
	bool IsMissileLocked ( );
	void SetMissileLocked ( unsigned long newLockingStatus );
	bool IsMissileLockable ( );
	bool IsExecutable ( class AYGamePawn* executor );
	bool IsRevivable ( class AYGamePawn* Reviver );
	bool IsMeleeAttackable ( class AYGamePawn* attacker, unsigned long checkStanding, unsigned char specificAttackType );
	bool SupportsAutoAiming ( class AYGamePawn* shootingPawn );
};

UClass* UYShootable::pClassPointer = NULL;

// Class SRGame.YTacticalMarker
// 0x00E8 (0x02E0 - 0x01F8)
class AYTacticalMarker : public AActor
{
public:
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x01F8 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FVector                                     m_boxExtent;                                      		// 0x01FC (0x000C) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_tacIconClass;                                   		// 0x0208 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	class UYMarkerBase*                                m_tacIcon;                                        		// 0x020C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_enabled : 1;                                    		// 0x0210 (0x0004) [0x0000000000000021] [0x00000001] ( CPF_Edit | CPF_Net )
	unsigned long                                      m_isInActivationRange : 1;                        		// 0x0210 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_isInFocus : 1;                                  		// 0x0210 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_onlyShowInMarkingMode : 1;                      		// 0x0210 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	float                                              m_maxDistance;                                    		// 0x0214 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	class UYDrawBoxComponent*                          m_boxComponent;                                   		// 0x0218 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned char                                      m_contextCommand;                                 		// 0x021C (0x0001) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	unsigned char                                      m_team;                                           		// 0x021D (0x0001) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	struct FString                                     m_text;                                           		// 0x0220 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     m_description;                                    		// 0x022C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UYTacticalMarkerConnector*                   m_connector;                                      		// 0x0238 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UYSpecialActionSet* >                m_specialActionSets;                              		// 0x023C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UYSoundCueFMOD*                              m_activationSoundCue;                             		// 0x0248 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FS_MaterialInstanceConstantInfo             m_icon;                                           		// 0x024C (0x0094) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2151 ];

		return pClassPointer;
	};

	class UYTacticalMarkerConnector* GetMarkerConnector ( );
	void OnDetected ( unsigned long detected );
	void OverrideTextsForContextCommand ( struct FYS_ContextCommandInfo* contextAction );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	struct FBoxSphereBounds GetBounds ( );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	void OnToggle ( class USeqAct_Toggle* Action );
	bool IsEnabledForTacView ( );
	void NativePostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void RegisterToPostRender ( );
	void PlayActivationSound ( );
	void UnregisterToPostRender ( );
	void Destroyed ( );
	void PostBeginPlay ( );
};

UClass* AYTacticalMarker::pClassPointer = NULL;

// Class SRGame.YTacticalInfo_ContextObject
// 0x0000 (0x02E0 - 0x02E0)
class AYTacticalInfo_ContextObject : public AYTacticalMarker
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2152 ];

		return pClassPointer;
	};

	void NativePostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
};

UClass* AYTacticalInfo_ContextObject::pClassPointer = NULL;

// Class SRGame.YTacticalInfo_Waypoint
// 0x0000 (0x02E0 - 0x02E0)
class AYTacticalInfo_Waypoint : public AYTacticalMarker
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2153 ];

		return pClassPointer;
	};

};

UClass* AYTacticalInfo_Waypoint::pClassPointer = NULL;

// Class SRGame.YAnimTestTacInfo
// 0x0004 (0x02E4 - 0x02E0)
class AYAnimTestTacInfo : public AYTacticalInfo_Waypoint
{
public:
	int                                                m_iconIndex;                                      		// 0x02E0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2154 ];

		return pClassPointer;
	};

	void KillInfo ( class UYMarkerBase* AnimTarget, int AnimIndex, class UYMarkerAnimationSeq* AnimSeq );
	void StartAnimating ( class UClass* C, class AYPlayerController* PC );
	class UYMarkerBase* GetMarkerIcon ( class AYPlayerController* checker );
};

UClass* AYAnimTestTacInfo::pClassPointer = NULL;

// Class SRGame.YTacticalMarkerConnector
// 0x0004 (0x0040 - 0x003C)
class UYTacticalMarkerConnector : public UObject
{
public:
	class UObject*                                     m_tacticalMarker;                                 		// 0x003C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2155 ];

		return pClassPointer;
	};

};

UClass* UYTacticalMarkerConnector::pClassPointer = NULL;

// Class SRGame.YUI_Widget
// 0x0008 (0x0478 - 0x0470)
class UYUI_Widget : public UUIObject
{
public:
	unsigned long                                      bRequiresTick : 1;                                		// 0x0470 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	class UYUIScenes*                                  YSceneOwner;                                      		// 0x0474 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2156 ];

		return pClassPointer;
	};

	class AYPlayerController* GetPlayerController ( );
};

UClass* UYUI_Widget::pClassPointer = NULL;

// Class SRGame.YUIDrawPanel
// 0x0024 (0x049C - 0x0478)
class UYUIDrawPanel : public UYUI_Widget
{
public:
	class UCanvas*                                     Canvas;                                           		// 0x0478 (0x0004) [0x0000000000000000]              
	float                                              pLeft;                                            		// 0x047C (0x0004) [0x0000000000000000]              
	float                                              pTop;                                             		// 0x0480 (0x0004) [0x0000000000000000]              
	float                                              pWidth;                                           		// 0x0484 (0x0004) [0x0000000000000000]              
	float                                              pHeight;                                          		// 0x0488 (0x0004) [0x0000000000000000]              
	float                                              ResolutionScale;                                  		// 0x048C (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __DrawDelegate__Delegate;                         		// 0x0490 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2157 ];

		return pClassPointer;
	};

	void DrawPanel ( );
	bool DrawDelegate ( class UCanvas* C );
};

UClass* UYUIDrawPanel::pClassPointer = NULL;

// Class SRGame.YMarkerPanel
// 0x0008 (0x04A4 - 0x049C)
class UYMarkerPanel : public UYUIDrawPanel
{
public:
	float                                              m_deltaTime;                                      		// 0x049C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_tacticalMarkersEnabledForMultiplayer : 1;       		// 0x04A0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2158 ];

		return pClassPointer;
	};

	void DrawPanel ( );
	void DrawTacticalInfos ( );
};

UClass* UYMarkerPanel::pClassPointer = NULL;

// Class SRGame.YSimpleList
// 0x0230 (0x06CC - 0x049C)
class UYSimpleList : public UYUIDrawPanel
{
public:
	struct FYSimpleListStyleData                       StyleData[ 0x5 ];                                 		// 0x049C (0x0154) [0x0000000000000000]              
	unsigned long                                      m_bStyleUpdated : 1;                              		// 0x05F0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bUseSeparatorTextSize : 1;                      		// 0x05F0 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bHorizontalList : 1;                            		// 0x05F0 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bWrapList : 1;                                  		// 0x05F0 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bHotTracking : 1;                               		// 0x05F0 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bInvalidated : 1;                               		// 0x05F0 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      bTransitioning : 1;                               		// 0x05F0 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      bUpArrowPressed : 1;                              		// 0x05F0 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      bDownArrowPressed : 1;                            		// 0x05F0 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      bDragging : 1;                                    		// 0x05F0 (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	unsigned long                                      bIsMouseOverMenu : 1;                             		// 0x05F0 (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      bIsUsingMouseNavigation : 1;                      		// 0x05F0 (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      m_bSkipMouseWheelInput : 1;                       		// 0x05F0 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_ButtonWasPressed : 1;                           		// 0x05F0 (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      m_WasMouseSelected : 1;                           		// 0x05F0 (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      m_UsingScrollFrame : 1;                           		// 0x05F0 (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	unsigned long                                      m_loadingContent : 1;                             		// 0x05F0 (0x0004) [0x0000000000002000] [0x00010000] ( CPF_Transient )
	unsigned long                                      m_ScaleProportionally : 1;                        		// 0x05F0 (0x0004) [0x0000000000000001] [0x00020000] ( CPF_Edit )
	unsigned long                                      m_bHighlight : 1;                                 		// 0x05F0 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_useMouseSelectionListHeightCalcFix : 1;         		// 0x05F0 (0x0004) [0x0000000000000000] [0x00080000] 
	struct FVector2D                                   ResolutionScaling;                                		// 0x05F4 (0x0008) [0x0000000000000000]              
	float                                              m_fSeparatorHeightPercentage;                     		// 0x05FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fSeparatorSize;                                 		// 0x0600 (0x0004) [0x0000000000000000]              
	float                                              m_fTransitionTime;                                		// 0x0604 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FYSimpleListData >                  List;                                             		// 0x0608 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	int                                                m_iSelection;                                     		// 0x0614 (0x0004) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )
	float                                              m_SelectionPos;                                   		// 0x0618 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_OldSelection;                                   		// 0x061C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              WindowTop;                                        		// 0x0620 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              WindowHeight;                                     		// 0x0624 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              TargetWindowTop;                                  		// 0x0628 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              TargetWindowTopDelta;                             		// 0x062C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              WindowTopTransitionTime;                          		// 0x0630 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fDefaultTransitionTime;                         		// 0x0634 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              UpArrowBounds[ 0x4 ];                             		// 0x0638 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	float                                              DownArrowBounds[ 0x4 ];                           		// 0x0648 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	float                                              StartSelectionTime;                               		// 0x0658 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              SelectionAlpha;                                   		// 0x065C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              OldBarPosition;                                   		// 0x0660 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              BarPosition;                                      		// 0x0664 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              DragAdjustment;                                   		// 0x0668 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              LastMouseUpdate;                                  		// 0x066C (0x0004) [0x0000000000000000]              
	struct FString                                     m_lockedItemText;                                 		// 0x0670 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_lockedItemWidth;                                		// 0x067C (0x0004) [0x0000000000000000]              
	float                                              m_LastMousePositionY;                             		// 0x0680 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_ListHeightInPixels;                             		// 0x0684 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_SelectedPosition;                               		// 0x0688 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIScrollFrame*                              m_scrollFrame;                                    		// 0x068C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             __OnDrawItem__Delegate;                           		// 0x0690 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnPostDrawSelectionBar__Delegate;               		// 0x069C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnItemChosen__Delegate;                         		// 0x06A8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnSelectionChange__Delegate;                    		// 0x06B4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __IsDisableItemDelegate__Delegate;                		// 0x06C0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2159 ];

		return pClassPointer;
	};

	void RestartAnimSelector ( );
	void SetText ( int ItemIndex, struct FString Text );
	void CreateMaterialInstanceTimeVarying ( );
	unsigned char GetCurrentItemState ( int ItemIndex );
	void SetBlinkingItem ( struct FName ItemTag, unsigned long IsBlinking );
	struct FVector2D ApplyPaddingAndAlignment ( int ItemIndex, unsigned char CurrentItemState, float YPos );
	void DrawText ( int ItemIndex, float XPos, float* YPos );
	void DrawBackground ( int ItemIndex, float XPos, float YPos );
	float CalculateSelectionBGPosition ( int SelectedIdx );
	void SetTextBoundaries ( int StyleIndex );
	void RecalcItemDimensions ( );
	void SetStyleDataForState ( unsigned char StyleState );
	void UpdateStyleData ( );
	void DrawPanel ( );
	void SelectFirstItem ( );
	void SizeList ( );
	void SetItemSelectionIndex ( float SelectionIndex );
	void OnMouseOverMenu ( unsigned long bIsOverMenu );
	void RefreshBarPosition ( );
	void UpdateScrollZone ( );
	void SelectItem ( int NewSelection, unsigned long WasMouseSelected );
	void ToStrings ( unsigned long bAppend, TArray< struct FString >* StringList );
	struct FString ResolveText ( struct FString markup );
	void PgDn ( );
	void PgUp ( );
	bool SelectUnderCursor ( );
	bool CursorCheck ( float X1, float Y1, float X2, float Y2 );
	bool ProcessInputAxis ( struct FSubscribedInputEventParameters* EventParms );
	void UpdateMouseOverMenu ( );
	bool IsWithinScrollFrame ( );
	bool IsMouseOverMenu ( );
	bool MouseInBounds ( );
	void ItemChosen ( int PlayerIndex );
	bool HandleWrongAxisNavigation ( struct FSubscribedInputEventParameters* EventParms );
	bool ProcessInputKey ( struct FSubscribedInputEventParameters* EventParms );
	bool IsGameInFocus ( );
	int NextItem ( int iItem );
	int PreviousItem ( int iItem );
	bool IsDisableItem ( int iItem );
	struct FVector GetMousePosition ( );
	void SetHotTracking ( unsigned long bHotTracking );
	int GetSelection ( );
	void ExternalUIchanged ( unsigned long bIsOpen );
	void GetSupportedUIActionKeyNames ( TArray< struct FName >* out_KeyNames );
	void RemoveExternalUIChangeDelegate ( );
	void AddExternalUIChangeDelegate ( );
	void OwnerSceneActivated ( class UUIScene* DeactivatedScene, unsigned long bInitialActivation );
	void OwnerSceneDeactivated ( class UUIScene* DeactivatedScene );
	void PostInitialize ( );
	bool IsDisableItemDelegate ( class UYSimpleList* SourceList, int Item );
	void OnSelectionChange ( class UYSimpleList* SourceList, int NewSelectedIndex );
	void OnItemChosen ( class UYSimpleList* SourceList, int SelectedIndex, int PlayerIndex );
	bool OnPostDrawSelectionBar ( class UYSimpleList* SimpleList, float YPos, float Width, float Height );
	bool OnDrawItem ( class UYSimpleList* SimpleList, int ItemIndex, float XPos, float* YPos );
	void RemoveItem ( int IndexToRemove );
	void AddItem ( struct FString Text, struct FName ItemTag, float fHeightFactor );
	void InsertItem ( int Index, struct FString Text, struct FName ItemTag, float fHeightFactor );
	void Empty ( );
	void UnactivatedSelector ( );
	void ActivatedSelector ( );
	void UpdateAnimation ( float DeltaTime );
	void SortList ( );
	int FindTag ( struct FName SearchTag );
	int Find ( struct FString SearchText );
};

UClass* UYSimpleList::pClassPointer = NULL;

// Class SRGame.YUIMenuList
// 0x0114 (0x07E0 - 0x06CC)
class UYUIMenuList : public UYSimpleList
{
public:
	struct FPointer                                    VfTable_IUIDataStoreSubscriber;                   		// 0x06CC (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FUIDataStoreBinding                         DataSource;                                       		// 0x06D0 (0x0030) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UUIListElementProvider*                      DataProvider;                                     		// 0x0700 (0x0008) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0704 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FUIDataStoreBinding                         SelectedIndexDataSource;                          		// 0x0708 (0x0030) [0x0000000000420001]              ( CPF_Edit | CPF_EditConst | CPF_NeedCtorLink )
	TArray< struct FYMenuListData >                    m_MenuList;                                       		// 0x0738 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      bIsRotating : 1;                                  		// 0x0744 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bStartDisplayDescriptionInit : 1;               		// 0x0744 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bFadeInStarted : 1;                             		// 0x0744 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bFadeOutStarted : 1;                            		// 0x0744 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	float                                              StartRotationTime;                                		// 0x0748 (0x0004) [0x0000000000000000]              
	struct FName                                       m_widgetBackgroundDescriptionName;                		// 0x074C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_widgetLabelDescriptionName;                     		// 0x0754 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UUIImage*                                    m_imgBackgroundDescription;                       		// 0x075C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblDescription;                                 		// 0x0760 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fStartDisplayDescription;                       		// 0x0764 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceTimeVarying*                m_BackgroundDescMaterial;                         		// 0x0768 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_MaterialFadeInParameterName;                    		// 0x076C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_MaterialFadeOutParameterName;                   		// 0x0774 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_CycleTimeIn;                                    		// 0x077C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FInterpCurveFloat                           m_CurveFadeIn;                                    		// 0x0780 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_CycleTimeOut;                                   		// 0x0790 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FInterpCurveFloat                           m_CurveFadeOut;                                   		// 0x0794 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FInterpCurveFloat                           m_CurveConstant;                                  		// 0x07A4 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FInterpCurveFloat                           m_CurveConstantNull;                              		// 0x07B4 (0x0010) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_fDescriptionFadeInDelay;                        		// 0x07C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FScriptDelegate                             __OnSubmitSelection__Delegate;                    		// 0x07C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnOptionsRegenerated__Delegate;                 		// 0x07D4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2160 ];

		return pClassPointer;
	};

	void InitDescriptionAnimationAtStart ( );
	void StartDescriptionAnimationOut ( );
	void StartDescriptionAnimationIn ( );
	void UpdateDescription ( );
	void SetTimeUpdateDescriptionWidget ( );
	void DrawPanel ( );
	void SceneLoseFocus ( );
	void SceneGiveFocus ( );
	void SelectItem ( int NewSelection, unsigned long WasMouseSelected );
	void ItemChosen ( int PlayerIndex );
	void SetIndex ( int NewIndex );
	struct FName GetItemTag ( int iSelection );
	int GetItemDataIndex ( int ItemIndex );
	struct FName GetCurrentItemTag ( );
	int GetCurrentItem ( );
	void InitDescriptionWidget ( );
	void InitWidgetReferences ( );
	void PostInitialize ( );
	bool GetCellFieldString ( class UUIObject* InList, struct FName InCellTag, int InListIndex, struct FString* OutValue );
	void NotifyDataStoreValueUpdated ( class UUIDataStore* SourceDataStore, unsigned long bValuesInvalidated, struct FName PropertyTag, class UUIDataProvider* SourceProvider, int ArrayIndex );
	void ClearBoundDataStores ( );
	void GetBoundDataStores ( TArray< class UUIDataStore* >* out_BoundDataStores );
	bool RefreshSubscriberValue ( int BindingIndex );
	struct FString GetDataStoreBinding ( int BindingIndex );
	void SetDataStoreBinding ( struct FString MarkupText, int BindingIndex );
	int FindCellFieldString ( class UUIObject* InObject, struct FName InCellTag, struct FString FindValue, unsigned long bCaseSensitive );
	void RegenerateOptions ( );
	bool GetCellFieldValue ( class UUIObject* InList, struct FName InCellTag, int InListIndex, struct FUIProviderFieldValue* OutValue );
	void OnOptionsRegenerated ( class UUIObject* Sender );
	void OnSubmitSelection ( class UUIObject* Sender, int PlayerIndex );
};

UClass* UYUIMenuList::pClassPointer = NULL;

// Class SRGame.YUIEventTracker
// 0x0178 (0x0614 - 0x049C)
class UYUIEventTracker : public UYUIDrawPanel
{
public:
	unsigned long                                      m_rightAligned : 1;                               		// 0x049C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_lugoAlive : 1;                                  		// 0x049C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	float                                              m_textScale;                                      		// 0x04A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_iconScale;                                      		// 0x04A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_barScale;                                       		// 0x04A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_weaponIconScale;                                		// 0x04AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FFontRenderInfo                             m_renderInfo;                                     		// 0x04B0 (0x0028) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lineSpacing;                                    		// 0x04D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_linePaddingVertical;                            		// 0x04DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_linePaddingHorizontal;                          		// 0x04E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_maxlines;                                       		// 0x04E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lineLifeTime;                                   		// 0x04E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lineIntelLifeTime;                              		// 0x04EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_intelBarColor;                                  		// 0x04F0 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lineFadeTime;                                   		// 0x0500 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   m_lineBackground;                                 		// 0x0504 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_backgroundSizePercentage;                       		// 0x0508 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FColor                                      m_colors[ 0x6 ];                                  		// 0x050C (0x0018) [0x0000000000000001]              ( CPF_Edit )
	class UFont*                                       m_textFont;                                       		// 0x0524 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UFont*                                       m_iconFont;                                       		// 0x0528 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_sliderSize;                                     		// 0x052C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_sliderPadding;                                  		// 0x0534 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_sliderMarkerPadding;                            		// 0x053C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_sliderMarkerColor;                              		// 0x0544 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_sliderBackgroundColor;                          		// 0x0554 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	class UFont*                                       m_consoleFont;                                    		// 0x0564 (0x0004) [0x0000000000000000]              
	class UTexture2D*                                  m_texture;                                        		// 0x0568 (0x0004) [0x0000000000000000]              
	class UFont*                                       m_intelAccessorFont;                              		// 0x056C (0x0004) [0x0000000000000000]              
	struct FString                                     m_intelAccessorKey;                               		// 0x0570 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_intelAccessorScaleModifier;                     		// 0x057C (0x0004) [0x0000000000000000]              
	struct FString                                     m_objectiveAdded;                                 		// 0x0580 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_objectiveComplete;                              		// 0x058C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_foundIntel;                                     		// 0x0598 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_accessIntel;                                    		// 0x05A4 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_unknownKillerName;                              		// 0x05B0 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_radioSpeakerDestroyed;                          		// 0x05BC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_teamKilled;                                     		// 0x05C8 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_spawnKilled;                                    		// 0x05D4 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_Kicked;                                         		// 0x05E0 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_Banned;                                         		// 0x05EC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_IdleKicked;                                     		// 0x05F8 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	TArray< struct FYS_EventLine >                     m_lines;                                          		// 0x0604 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_lineHeight;                                     		// 0x0610 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2161 ];

		return pClassPointer;
	};

	bool HasGamePadConnected ( );
	void OnOverridePlatformChanged ( );
	void UpdateIntelAccessorKey ( );
	void InitIntelAccessorKey ( );
	float GetTimeSeconds ( );
	void ForceLayout ( );
	void OnNotifyResolutionChanged ( struct FVector2D* OldViewportsize, struct FVector2D* NewViewportSize );
	void DrawPanel ( );
	void ClearEventMessages ( );
	void AddObjectiveEvent ( struct FString Header, struct FString Objective, unsigned long completed );
	void AddSlider ( int Idx, int Cnt, int total );
	void AddRadioSpeakerEvent ( int numFound, int numTotal );
	void AddIntelEvent ( struct FString Message, int numFound, int numTotal );
	void AddAchievementEvent ( struct FString AchievementName, int numFound, int numTotal );
	void AddSquadEvent ( struct FString squadStatus, unsigned long lugoAlive );
	void AddMessageEvent ( struct FString Evt, int colorName );
	void AddGenericEvent ( struct FString Evt );
	void AddKillEventInternal ( struct FString Killer, struct FString specialKillerMsg, int killerCol, struct FString Victim, struct FString specialVictimMsg, int victimCol, struct FString dmgIcon, struct FString specialIcon, int dmgIconFontIdx );
	unsigned char GetColorIndex ( class APlayerReplicationInfo* PRI );
	bool HasPerk_UnknownKiller ( class APlayerReplicationInfo* PRI );
	void AddKillEventMP ( class APlayerReplicationInfo* Killer, class APlayerReplicationInfo* Victim, class APlayerReplicationInfo* Own, class UYDeathMessageParams* Params );
	void AddKillEvent ( class APlayerReplicationInfo* Killer, class APlayerReplicationInfo* Victim, class UYDeathMessageParams* Params );
	void AddPickupEvent ( struct FString Message, struct FString Icon, struct FString WeaponName );
	int PlaceBar ( int lineIdx );
	void AddEventLine ( int numParts, unsigned long bIsIntel, int* lineIdx, int* firstPartIdx );
	void AddDummy ( );
	void InitializeWidget ( );
};

UClass* UYUIEventTracker::pClassPointer = NULL;

// Class SRGame.YUIObjectList
// 0x00EC (0x0588 - 0x049C)
class UYUIObjectList : public UYUIDrawPanel
{
public:
	struct FPointer                                    VfTable_IUIDataStoreSubscriber;                   		// 0x049C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	int                                                CurrentIndex;                                     		// 0x04A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                PreviousIndex;                                    		// 0x04A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FGeneratedOptionInfo >              GeneratedObjects;                                 		// 0x04A8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FUIDataStoreBinding                         DataSource;                                       		// 0x04B4 (0x0030) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UUIListElementProvider*                      DataProvider;                                     		// 0x04E4 (0x0008) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x04E8 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FUIScreenValue_Extent                       OptionVerticalPadding;                            		// 0x04EC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FUIScreenValue_Extent                       OptionRightPadding;                               		// 0x04F4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FUIScreenValue_Extent                       OptionHeight;                                     		// 0x04FC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FUIScreenValue_Extent                       OptionWidth;                                      		// 0x0504 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       LabelStringStyleName;                             		// 0x050C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       LabelStringStyleResolverName;                     		// 0x0514 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       LabelBackgroundStyleName;                         		// 0x051C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bClosedListNavigation : 1;                        		// 0x0524 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bRepositionOptions : 1;                           		// 0x0524 (0x0004) [0x0000000000002003] [0x00000002] ( CPF_Edit | CPF_Const | CPF_Transient )
	unsigned long                                      bRegenOptions : 1;                                		// 0x0524 (0x0004) [0x0000000000002003] [0x00000004] ( CPF_Edit | CPF_Const | CPF_Transient )
	unsigned long                                      bUseSmallFriendlyName : 1;                        		// 0x0524 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	int                                                MaxVisibleItems;                                  		// 0x0528 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      SpinnerClass;                                     		// 0x052C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      SliderClass;                                      		// 0x0530 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      EditboxClass;                                     		// 0x0534 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      CheckboxClass;                                    		// 0x0538 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      ComboBoxClass;                                    		// 0x053C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      ConsoleOptionClass;                               		// 0x0540 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_ArrowWidthFactor;                               		// 0x0544 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UUIScrollFrame*                              m_scrollFrame;                                    		// 0x0548 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             __OnOptionFocused__Delegate;                      		// 0x054C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnOptionChanged__Delegate;                      		// 0x0558 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnListOptionSubmitted__Delegate;                		// 0x0564 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnAcceptOptions__Delegate;                      		// 0x0570 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnRegeneratedOptions__Delegate;                 		// 0x057C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2162 ];

		return pClassPointer;
	};

	void RemovedFromParent ( class UUIScreenObject* WidgetOwner );
	void GetSupportedUIActionKeyNames ( TArray< struct FName >* out_KeyNames );
	void PostInitialize ( );
	void ClearBoundDataStores ( );
	void GetBoundDataStores ( TArray< class UUIDataStore* >* out_BoundDataStores );
	void NotifyDataStoreValueUpdated ( class UUIDataStore* SourceDataStore, unsigned long bValuesInvalidated, struct FName PropertyTag, class UUIDataProvider* SourceProvider, int ArrayIndex );
	bool RefreshSubscriberValue ( int BindingIndex );
	struct FString GetDataStoreBinding ( int BindingIndex );
	void SetDataStoreBinding ( struct FString MarkupText, int BindingIndex );
	bool ProcessInputKey ( struct FSubscribedInputEventParameters* EventParms );
	void OnOption_PositionChanged ( class UUIScreenObject* Sender );
	void OnOption_NotifyActiveStateChanged ( class UUIScreenObject* Sender, int PlayerIndex, class UUIState* NewlyActiveState, class UUIState* PreviouslyActiveState );
	void ListSelectionSubmitted ( class UUIList* Sender, int PlayerIndex );
	void OnValueChanged ( class UUIObject* Sender, int PlayerIndex );
	void OnStateChanged ( class UUIScreenObject* Sender, int PlayerIndex, class UUIState* NewlyActiveState, class UUIState* PreviouslyActiveState );
	bool CursorCheck ( float X1, float Y1, float X2, float Y2 );
	struct FVector GetMousePosition ( );
	bool SelectPreviousItem ( unsigned long bWrap, int PlayerIndex );
	bool SelectNextItem ( unsigned long bWrap, int PlayerIndex );
	bool SelectItem ( int OptionIdx, int PlayerIndex, unsigned long bClampValue );
	bool EnableItemAtIndex ( int PlayerIndex, int OptionIdx, unsigned long bShouldEnable );
	bool EnableItem ( int PlayerIndex, class UUIObject* ChosenObj, unsigned long bShouldEnable );
	class UUIObject* GetCurrentlySelectedOption ( );
	int GetObjectInfoIndexFromObject ( class UUIObject* Sender );
	int GetObjectInfoIndexFromName ( struct FName ProviderName );
	void RefreshAllOptions ( );
	void SaveAllOptions ( );
	void SetupOptionBindings ( );
	class UUIObject* GetSelectedOption ( );
	int FindObjectIndexByRef ( class UUIObject* SearchObj );
	int FindObjectIndexByName ( struct FName ProviderName );
	bool IsValidListOption ( class UUIObject* CheckObj );
	void InitializeComboboxWidgets ( );
	void SetSelectedOptionIndex ( int OptionIdx );
	void RequestOptionListRegeneration ( );
	void RequestOptionListReformat ( );
	void OnRegeneratedOptions ( class UYUIObjectList* ObjectList );
	void OnAcceptOptions ( class UUIScreenObject* InObject, int PlayerIndex );
	void OnListOptionSubmitted ( class UUIList* InListObject, struct FName OptionName, int PlayerIndex );
	void OnOptionChanged ( class UUIScreenObject* InObject, struct FName OptionName, int PlayerIndex );
	void OnOptionFocused ( class UUIScreenObject* InObject, class UUIDataProvider* OptionProvider );
};

UClass* UYUIObjectList::pClassPointer = NULL;

// Class SRGame.YUIKeyBindingList
// 0x00D0 (0x0658 - 0x0588)
class UYUIKeyBindingList : public UYUIObjectList
{
public:
	int                                                NumButtons;                                       		// 0x0588 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      bCurrentlyBindingKey : 1;                         		// 0x058C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_DropShadows : 1;                                		// 0x058C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	class UUIObject*                                   CurrentlyBindingObject;                           		// 0x0590 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIMessageBoxBase*                           MessageBoxReference;                              		// 0x0594 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIMessageBoxBase*                           NonIntrusiveMessageBoxScene;                      		// 0x0598 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FString >                           CurrentBindings;                                  		// 0x059C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FString >                           StoredBindings;                                   		// 0x05A8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FString >                           LocalizedFriendlyNames;                           		// 0x05B4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_currentSelected;                                		// 0x05C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_excistingKeyIndex;                              		// 0x05C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_OptionOffsetPercentage;                         		// 0x05C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_OptionButtonPadding;                            		// 0x05CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_currentRealPosition;                            		// 0x05D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_TargetRealPosition;                             		// 0x05D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_OptionItemWidth;                                		// 0x05D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              WidgetHeight;                                     		// 0x05DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              OptionOffsetPercentage;                           		// 0x05E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              OptionButtonPadding;                              		// 0x05E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              Optionspacing;                                    		// 0x05E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< unsigned long >                            CrucialBindValues;                                		// 0x05EC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FBindKeyData                                CurrKeyBindData;                                  		// 0x05F8 (0x0024) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_backgroundStyleName;                            		// 0x061C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     m_labelStyleName;                                 		// 0x0628 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     m_labelButtonStyleName;                           		// 0x0634 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnKeyBindingsRegenerated__Delegate;             		// 0x0640 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnKeyDialogFinished__Delegate;                  		// 0x064C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2163 ];

		return pClassPointer;
	};

	bool IsWithinScrollFrame ( class UUIScrollFrame* ScrollFrame );
	bool ShouldIgnoreButtonClick ( );
	bool HandleMouseWheelScrolling ( struct FSubscribedInputEventParameters* EventParms );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void OnBindDialogSceneDeactivated ( class UUIScene* DeactivatedScene );
	bool OnBindKey_InputKey ( struct FInputEventParameters* EventParms );
	void RefreshBindingDataStore ( );
	void FinishBinding ( );
	void FinishKeyDialog ( unsigned long bPromptForBindStomp );
	bool OnClicked ( class UUIScreenObject* Sender, int PlayerIndex );
	void UnbindKey ( struct FName BindName );
	void CancelKeyBind ( );
	void BindKey ( );
	void AttemptKeyBind ( );
	void OnStompBindDialogSceneDeactivated ( class UUIScene* DeactivatedScene );
	void SpawnBindStompWarningMessage ( );
	void OnBindStompWarning_Closed ( );
	bool OnMenu_BindOverwrite_Confirm ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	bool IsAlreadyBound ( struct FName KeyName );
	bool BindingsHaveChanged ( );
	int GetFirstUnboundCrucialBind ( );
	bool OnButton_InputKey ( struct FInputEventParameters* EventParms );
	void InitItemVariables ( );
	void SetupOptionBindings ( );
	void SetScrollFrameOffset ( struct FVector2D* ScrolledRegion );
	struct FString GetBindKeyFromCommand ( class UPlayerInput* PInput, struct FString Command, int* StartIdx );
	void RefreshBindingLabels ( );
	void RepositionOptions ( );
	void RegenerateOptions ( );
	void ReloadDefaults ( );
	class UPlayerInput* GetPlayerInput ( );
	void OnKeyDialogFinished ( );
	void OnKeyBindingsRegenerated ( class UUIObject* Sender );
};

UClass* UYUIKeyBindingList::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel
// 0x0150 (0x05EC - 0x049C)
class UYUIScoreboardPanel : public UYUIDrawPanel
{
public:
	class UMaterialInstance*                           m_HeaderBackgroundMat;                            		// 0x049C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstance*                           m_RowBackgroundMat;                               		// 0x04A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstance*                           m_RowHighlightMat;                                		// 0x04A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstance*                           m_ConnectionIconMat;                              		// 0x04A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstance*                           m_RankIconMat;                                    		// 0x04AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ScoreboardFontData                      m_HeaderFont;                                     		// 0x04B0 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ScoreboardFontData                      m_CellFont;                                       		// 0x04C0 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ScoreboardFontData                      m_CellSymbolsFont;                                		// 0x04D0 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_HeaderTextColor;                                		// 0x04E0 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_CellTextSpecopsColor;                           		// 0x04F0 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_CellTextKonradColor;                            		// 0x0500 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_CellGlowColor;                                  		// 0x0510 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_CellPlayerColor;                                		// 0x0520 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_ShowHeader : 1;                                 		// 0x0530 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_ShowSpecopsPlayers : 1;                         		// 0x0530 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_ShowKonradPlayers : 1;                          		// 0x0530 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_RequestLayoutUpdate : 1;                        		// 0x0530 (0x0004) [0x0000000000002002] [0x00000008] ( CPF_Const | CPF_Transient )
	unsigned long                                      m_ShowColumnLayout : 1;                           		// 0x0530 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	int                                                m_MinRows;                                        		// 0x0534 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_MaxRows;                                        		// 0x0538 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_HeaderPadding;                                  		// 0x053C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_RowPadding;                                     		// 0x0540 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_RowSpacing;                                     		// 0x0544 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_RowHeight;                                      		// 0x0548 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              m_RowsHeight;                                     		// 0x054C (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	TArray< struct FYS_ScoreboardColumn >              m_Columns;                                        		// 0x0550 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UYScoreboardPlayerInfo*                      m_OwnerPRI;                                       		// 0x055C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UYScoreboardPlayerInfo* >            m_PRIArray;                                       		// 0x0560 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UMaterialInstanceConstant* >         m_RowBackgroundMatInstArray;                      		// 0x056C (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	TArray< class UMaterialInstanceConstant* >         m_ConnectionIconMatInstArray;                     		// 0x0578 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_RowHighlightMatInst;                            		// 0x0584 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	TArray< class UMaterialInstanceConstant* >         m_RankIconMatInstArray;                           		// 0x0588 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	class UYUIScoreboardPanel*                         m_TopLinkedPanel;                                 		// 0x0594 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScoreboardPanel*                         m_BottomLinkedPanel;                              		// 0x0598 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_RowSelectionParams                      m_SelectionParams;                                		// 0x059C (0x0008) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_RowSelection                            m_Selection;                                      		// 0x05A4 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	struct FVector2D                                   m_MousePos;                                       		// 0x05AC (0x0008) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	TArray< int >                                      m_WeaponEnumTable;                                		// 0x05B4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_NumFakePlayers;                                 		// 0x05C0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     m_FakePlayerInfo;                                 		// 0x05C4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     m_FakeTeamInfo;                                   		// 0x05D0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_FakePing;                                       		// 0x05DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FScriptDelegate                             __ScoreboardInfoProvider__Delegate;               		// 0x05E0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2164 ];

		return pClassPointer;
	};

	void DrawWeaponIcon ( );
	struct FString GetPlayerKillDeathRatio ( struct FYS_CellInputParams* Params );
	struct FString GetPlayerDeaths ( struct FYS_CellInputParams* Params );
	struct FString GetPlayerKills ( struct FYS_CellInputParams* Params );
	struct FString GetPlayerScore ( struct FYS_CellInputParams* Params );
	struct FString GetPlayerName ( struct FYS_CellInputParams* Params );
	struct FString GetPlayerRankLevel ( struct FYS_CellInputParams* Params );
	struct FString GetPlayerTeam ( struct FYS_CellInputParams* Params );
	struct FString GetPlayerXP ( struct FYS_CellInputParams* Params );
	struct FString GetModeExtraData1 ( struct FYS_CellInputParams* Params );
	struct FString GetModeExtraData2 ( struct FYS_CellInputParams* Params );
	struct FString GetModeExtraData3 ( struct FYS_CellInputParams* Params );
	struct FString GetPlayerMatchRank ( struct FYS_CellInputParams* Params );
	struct FString GetPlayerLootStat ( struct FYS_CellInputParams* Params );
	void ShowGamercard ( class UYScoreboardPlayerInfo* PRI );
	class UYScoreboardPlayerInfo* GetLocalSelectedPRI ( );
	int GetLocalSelectedRow ( );
	class UYScoreboardPlayerInfo* GetSelectedPRI ( class UYUIScoreboardPanel* Sender );
	int GetSelectedRow ( class UYUIScoreboardPanel* Sender );
	void ClearSelection ( class UYUIScoreboardPanel* Sender );
	bool SetSelectedRow ( class UYUIScoreboardPanel* Sender, int RowIndex );
	void SetSelectionTarget ( class UYUIScoreboardPanel* Sender, class UYScoreboardPlayerInfo* PRI );
	void SetBottomLinkedPanel ( class UYUIScoreboardPanel* scoreboardPanel );
	void SetTopLinkedPanel ( class UYUIScoreboardPanel* scoreboardPanel );
	void DrawColumnData ( struct FVector2D* currentPos );
	void DrawRows ( struct FVector2D* currentPos );
	void DrawHeader ( struct FVector2D* currentPos );
	void DrawPanel ( );
	bool RefreshPlayerList ( );
	void SetColumnData ( int ColumnIndex, int columnDataIndex, struct FScriptDelegate infoProvider, struct FYS_ScoreboardFontData* TextFont, struct FLinearColor* textSpecopsColor, struct FLinearColor* textKonradColor, struct FLinearColor* GlowColor, struct FLinearColor* playerColor );
	void SetExtraColumns ( );
	void SetupScoreboard ( );
	struct FString ScoreboardInfoProvider ( struct FYS_CellInputParams* Params );
};

UClass* UYUIScoreboardPanel::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_KillsLeaderboard
// 0x0030 (0x061C - 0x05EC)
class UYUIScoreboardPanel_KillsLeaderboard : public UYUIScoreboardPanel
{
public:
	class UYDataStore_OnlineStats*                     StatsDataStore;                                   		// 0x05EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_LeaderboardColumn >             m_leaderColumns;                                  		// 0x05F0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FLinearColor                                m_CellTextColor;                                  		// 0x05FC (0x0010) [0x0000000000000000]              
	int                                                m_currentRow;                                     		// 0x060C (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __LeaderboardInfoProvider__Delegate;              		// 0x0610 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2165 ];

		return pClassPointer;
	};

	void DrawPanel ( );
	bool RefreshPlayerList ( );
	struct FString GetLeaderboardRatio ( struct FYS_CellParams* Params );
	struct FString GetStreak ( struct FYS_CellParams* Params );
	struct FString GetDeaths ( struct FYS_CellParams* Params );
	struct FString GetKills ( struct FYS_CellParams* Params );
	struct FString GetLosses ( struct FYS_CellParams* Params );
	struct FString GetWins ( struct FYS_CellParams* Params );
	struct FString GetLeaderboardPosition ( struct FYS_CellParams* Params );
	struct FString GetLeaderboardPlayerName ( struct FYS_CellParams* Params );
	void ChangeToMode ( );
	void ChangeToKills ( );
	void SetupScoreboard ( );
	void DrawColumnData ( struct FVector2D* currentPos );
	void DrawHeader ( struct FVector2D* currentPos );
	void SetLeaderColumnData ( int ColumnIndex, int columnDataIndex, struct FScriptDelegate infoProvider, struct FYS_ScoreboardFontData* TextFont, struct FLinearColor* TextColor );
	void SetDataStore ( class UYDataStore_OnlineStats* DStore );
	void UpdateLayout ( unsigned long ForceUpdate );
	struct FString LeaderboardInfoProvider ( struct FYS_CellParams* Params );
};

UClass* UYUIScoreboardPanel_KillsLeaderboard::pClassPointer = NULL;

// Class SRGame.YUIW_CharacterEquipmentSelect
// 0x0084 (0x04FC - 0x0478)
class UYUIW_CharacterEquipmentSelect : public UYUI_Widget
{
public:
	class UYUIEquipmentButton*                         m_lEquipmentButton[ 0x7 ];                        		// 0x0478 (0x001C) [0x0000000002000002]              ( CPF_Const | CPF_NoClear )
	class UUIImage*                                    m_factionPerkLockImage;                           		// 0x0494 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_ActiveEquipmentButton;                          		// 0x0498 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_EquipmentClass                          m_EquipmentSelected;                              		// 0x049C (0x001C) [0x0000000000002000]              ( CPF_Transient )
	struct FLinearColor                                m_PerkColor;                                      		// 0x04B8 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_WeaponColor;                                    		// 0x04C8 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FScriptDelegate                             __OnEquipmentTypeSelected__Delegate;              		// 0x04D8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnSelectionChange__Delegate;                    		// 0x04E4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnLoseFocus__Delegate;                          		// 0x04F0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2166 ];

		return pClassPointer;
	};

	void UpdateWeaponIconMaterial ( class UMaterialInstanceConstant* MatInstConstant, class UYUIDataProvider_Weapons* ProviderWeapon );
	void UpdatePerkIconStateMaterial ( class UMaterialInstanceConstant* MatInstConstant, class UYUIDataProvider_Perks* ProviderPerk, unsigned char ElementState );
	void UpdatePerkIconMaterial ( class UMaterialInstanceConstant* MatInstConstant, class UYUIDataProvider_Perks* ProviderPerk, int iPerkLevel );
	void UpdateWeaponIconColor ( class UMaterialInstanceConstant* MatInstConstant );
	void UpdatePerkIconColor ( class UMaterialInstanceConstant* MatInstConstant );
	void UpdateWeaponIconsColor ( );
	void UpdatePerkIconsColor ( );
	void SetEqPerkIcon ( class UYUIEquipmentButton* EqButton, unsigned char ePerk );
	void SetEqWeaponIconAndName ( class UYUIEquipmentButton* EqButton, unsigned char eWeapon );
	void UnSelectEquipmentButton ( );
	bool SelectNextEquipment ( );
	void SetSelectedEquipment ( unsigned char EqSlot );
	void SetValidateEquimentButton ( class UYUIEquipmentButton* EqButton );
	void SelectedEquimentButtonChanged ( class UYUIEquipmentButton* EqButton );
	class UYUIEquipmentButton* GetSelectedEquipementButton ( );
	void CloseWidget ( );
	void InitFocus ( );
	void InitEquipement ( struct FYS_EquipmentClass equipment );
	void ClearDelegate ( );
	void PostInitialize ( );
	void OnLoseFocus ( );
	void OnSelectionChange ( unsigned char EQType );
	void OnEquipmentTypeSelected ( unsigned char EQType );
};

UClass* UYUIW_CharacterEquipmentSelect::pClassPointer = NULL;

// Class SRGame.YUIW_SelectEquipment
// 0x0048 (0x04C0 - 0x0478)
class UYUIW_SelectEquipment : public UYUI_Widget
{
public:
	class UUILabel*                                    m_Title;                                          		// 0x0478 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	unsigned char                                      m_EquipmentClass;                                 		// 0x047C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_EquipmentSlot;                                  		// 0x047D (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_teamID;                                         		// 0x047E (0x0001) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_EqProviderTag;                                  		// 0x0480 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_NewEquipmentClass;                              		// 0x0488 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_UnLockIconRef;                                  		// 0x048C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< int >                                      m_lUnlockedItem;                                  		// 0x0490 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnSelectionValidated__Delegate;                 		// 0x049C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __ValidateNewEquipment__Delegate;                 		// 0x04A8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __GetCurrentEquipmentClass__Delegate;             		// 0x04B4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2167 ];

		return pClassPointer;
	};

	void UpdateUnlockedItem ( class UUIList* List );
	void HideLockIcon ( int iIndex );
	bool IsJustUnlocked ( class UUIList* Sender, int ElementIndex );
	void UpdateCursorPosition ( class UUIList* lList, class UUIImage* imgCursor );
	bool ShouldDisableEquipment ( class UUIList* Sender, int ElementIndex );
	class UYUIDataProvider_Equipment* GetEquipmentProvider ( class UUIList* EquipmentList, int ElementIndex );
	class UClass* GetEquipmentSelectedClass ( class UUIList* EquipmentList, int ElementIndex );
	class UYProfileSettings* GetProfile ( );
	void OnEqListSubmitSelection ( class UUIList* Sender, int PlayerIndex );
	void OnEqListDoubleClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void UpdateEquipmentWidget ( );
	void UpdateEquipment ( class UUIList* eqList );
	void ValidateSelection ( );
	void ValidateNewEquipmentSelected ( );
	void BackPressed ( );
	void ValidatePressed ( );
	class UClass* GetDefaultEquipment ( );
	class UClass* GetEquipmentWithIndex ( int iEqIndex, struct FName ProviderName );
	class UClass* GetEquipment ( struct FString SeqName, struct FName ProviderName );
	unsigned char GetEquipmentSlot ( );
	unsigned char GetEquipmentClass ( );
	struct FString GetTeamPrefix ( );
	void SetTeamID ( unsigned char TeamID );
	void SetEquipementClass ( unsigned char EquipmentClass );
	void SetEquipementSlot ( unsigned char EquipmentSlot );
	bool CanCancelEquipmentSelection ( );
	bool CanValidateEquipmentSelection ( );
	void CloseWidget ( );
	void InitWidgetList ( class UUIList* lEquipment, struct FName ProviderName, class UClass* ClassName );
	void InitWidgetContent ( );
	void ClearDelegate ( );
	void InitWidgetRef ( );
	void PostInitialize ( );
	class UClass* GetCurrentEquipmentClass ( unsigned char NewEquipmentType );
	void ValidateNewEquipment ( unsigned char EquipmentSlot, class UClass* NewEquipmentClass );
	void OnSelectionValidated ( );
};

UClass* UYUIW_SelectEquipment::pClassPointer = NULL;

// Class SRGame.YUIW_SelectMajorPerk
// 0x0080 (0x0540 - 0x04C0)
class UYUIW_SelectMajorPerk : public UYUIW_SelectEquipment
{
public:
	class UYUIListMajorPerk*                           m_lMajorPerk;                                     		// 0x04C0 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblPerkName;                                    		// 0x04C4 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblPerkDescription;                             		// 0x04C8 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblPerkLevel1Title;                             		// 0x04CC (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblPerkLevel1Description;                       		// 0x04D0 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblPerkLevel2Title;                             		// 0x04D4 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblPerkLevel2Description;                       		// 0x04D8 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIImage*                                    m_lblPerkLevel2Lock;                              		// 0x04DC (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	struct FYS_MajorPerkAligment                       m_WidgetAligment;                                 		// 0x04E0 (0x0038) [0x0000000004000003]              ( CPF_Edit | CPF_Const | CPF_EditInline )
	class UUIImage*                                    m_imgMajorPerkSelector;                           		// 0x0518 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_LockIcons[ 0x9 ];                               		// 0x051C (0x0024) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2168 ];

		return pClassPointer;
	};

	void UpdateCursorDisplay ( );
	void OnListPerkStateChange ( );
	void OnPerkValueChanged ( class UUIObject* Sender, int PlayerIndex );
	void HideCursor ( );
	void ShowCursor ( );
	void UpdatePerksIcons ( );
	void UpdateLockIconFaction ( class UUIImage* Image );
	void HideLockIcon ( int iIndex );
	void InitLockIcon ( class UUIImage* Image );
	void UpdateEquipmentWidget ( );
	void CloseWidget ( );
	void InitWidgetRef ( );
	void InitWidgetContent ( );
	unsigned char GetEquipmentSlot ( );
	void ClearDelegate ( );
};

UClass* UYUIW_SelectMajorPerk::pClassPointer = NULL;

// Class SRGame.YUIW_SelectMinorPerk
// 0x0054 (0x0514 - 0x04C0)
class UYUIW_SelectMinorPerk : public UYUIW_SelectEquipment
{
public:
	class UYUIListMinorPerks*                          m_lMinorPerks;                                    		// 0x04C0 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIPanel*                                    m_pnlPerkInfos;                                   		// 0x04C4 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblMinorPerkIcon;                               		// 0x04C8 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblMinorPerkName;                               		// 0x04CC (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIImage*                                    m_imgMinorPerkIcon;                               		// 0x04D0 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblPerkDescription;                             		// 0x04D4 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIImage*                                    m_LockIcons[ 0xB ];                               		// 0x04D8 (0x002C) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_LockIconRef;                                    		// 0x0504 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   m_CheckIconRef;                                   		// 0x0508 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   m_LockSpecops;                                    		// 0x050C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_LockKonrad;                                     		// 0x0510 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2169 ];

		return pClassPointer;
	};

	void PerformScrolling ( unsigned long bScrollUp );
	void HideLockIcon ( int iIndex );
	void OnPerkValueChanged ( class UUIObject* Sender, int PlayerIndex );
	bool ShouldDisableEquipment ( class UUIList* Sender, int ElementIndex );
	bool IsAlreadySelected ( class UUIList* Sender, int ElementIndex );
	void UpdateLockIcons ( );
	void UpdateEquipmentWidget ( );
	void CreateMaterialInstance ( );
	void CloseWidget ( );
	void InitWidgetRef ( );
	void InitWidgetContent ( );
	unsigned char GetEquipmentSlot ( );
	unsigned char GetEquipmentClass ( );
	void ClearDelegate ( );
};

UClass* UYUIW_SelectMinorPerk::pClassPointer = NULL;

// Class SRGame.YUIW_SelectPrimaryWeapon
// 0x00B0 (0x0570 - 0x04C0)
class UYUIW_SelectPrimaryWeapon : public UYUIW_SelectEquipment
{
public:
	struct FPointer                                    VfTable_IUIDataStoreSubscriber;                   		// 0x04C0 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class UYUIListWeaponCategories*                    m_lWeaponsCategories;                             		// 0x04C4 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UYUIListWeapon*                              m_lWeaponsList;                                   		// 0x04C8 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIImage*                                    m_imgWeapon;                                      		// 0x04CC (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIPanel*                                    m_pnlWeaponInfos;                                 		// 0x04D0 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblWeaponName;                                  		// 0x04D4 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblRange;                                       		// 0x04D8 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblDamage;                                      		// 0x04DC (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblAccuracy;                                    		// 0x04E0 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblFireRate;                                    		// 0x04E4 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIProgressBar*                              m_barRange;                                       		// 0x04E8 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIProgressBar*                              m_barDamage;                                      		// 0x04EC (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIProgressBar*                              m_barAccuracy;                                    		// 0x04F0 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIProgressBar*                              m_barFireRate;                                    		// 0x04F4 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_lblDescription;                                 		// 0x04F8 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIImage*                                    m_imgWeaponCategCursor;                           		// 0x04FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_LockIcons[ 0x4 ];                               		// 0x0500 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_LockIconRef;                                    		// 0x0510 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   m_LockIcon;                                       		// 0x0514 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_CheckIconRef;                                   		// 0x0518 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_CurrentWeaponCategory;                          		// 0x051C (0x0001) [0x0000000000000002]              ( CPF_Const )
	struct FUIDataStoreBinding                         DataSource;                                       		// 0x0520 (0x0030) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UUIListElementProvider*                      DataProvider;                                     		// 0x0550 (0x0008) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0554 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FString                                     m_sCategoriesDataStoreBinding;                    		// 0x0558 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_sWeaponsDataStoreBinding;                       		// 0x0564 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2170 ];

		return pClassPointer;
	};

	void HideLockIcon ( int iIndex );
	void UpdateCursorDisplay ( );
	void OnWeaponCategoryStateChange ( );
	void HideCursor ( );
	void ShowCursor ( );
	void UpdateWeaponList ( );
	bool CanCancelEquipmentSelection ( );
	bool CanValidateEquipmentSelection ( );
	void BackPressed ( );
	void ValidatePressed ( );
	void OnWeaponCancel ( class UUIList* Sender, int PlayerIndex );
	void OnWeaponCategoryDoubleClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnWeaponCategorySubmitSelection ( class UUIList* Sender, int PlayerIndex );
	void OnWeaponCategoryValueChanged ( class UUIObject* Sender, int PlayerIndex );
	void OnWeaponValueChanged ( class UUIObject* Sender, int PlayerIndex );
	bool ShouldDisableEquipment ( class UUIList* Sender, int ElementIndex );
	void ShowWeaponInfos ( unsigned long bVisibility );
	void ShowExplosiveInfos ( unsigned long bVisibility );
	bool IsAlreadySelected ( class UUIList* Sender, int ElementIndex );
	void UpdateEquipmentWidget ( );
	void UpdateEquipmentInfosDisplay ( );
	bool HaveAccessToExtendSecondaryWeapon ( );
	bool HaveAccessToHeavyWeapon ( );
	void UpdateDataStoreBinding ( );
	void CloseWidget ( );
	void InitWidgetListCategory ( class UUIList* lEquipment, struct FName ProviderName, class UClass* WeaponClass );
	void InitWidgetContent ( );
	void InitWidgetRef ( );
	void SetEquipementClass ( unsigned char EquipmentClass );
	class UClass* GetDefaultEquipment ( );
	unsigned char GetEquipmentSlot ( );
	void ClearDelegate ( );
	void SetWeaponCategory ( unsigned char weaponCategory );
	void ClearBoundDataStores ( );
	void GetBoundDataStores ( TArray< class UUIDataStore* >* out_BoundDataStores );
	void NotifyDataStoreValueUpdated ( class UUIDataStore* SourceDataStore, unsigned long bValuesInvalidated, struct FName PropertyTag, class UUIDataProvider* SourceProvider, int ArrayIndex );
	bool RefreshSubscriberValue ( int BindingIndex );
	struct FString GetDataStoreBinding ( int BindingIndex );
	void SetDataStoreBinding ( struct FString MarkupText, int BindingIndex );
};

UClass* UYUIW_SelectPrimaryWeapon::pClassPointer = NULL;

// Class SRGame.YUIAction_Fade
// 0x0010 (0x0108 - 0x00F8)
class UYUIAction_Fade : public UUIAction
{
public:
	float                                              m_fadeAlpha;                                      		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeTarget;                                     		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeTime;                                       		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_pulse : 1;                                      		// 0x0104 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2171 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	bool IsValidUISequenceObject ( class UUIScreenObject* TargetObject );
};

UClass* UYUIAction_Fade::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_Equipment
// 0x0170 (0x01EC - 0x007C)
class UYUIDataProvider_Equipment : public UUIResourceDataProvider
{
public:
	struct FString                                     ClassName;                                        		// 0x007C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     FriendlyName;                                     		// 0x0088 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     Description;                                      		// 0x0094 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	TArray< struct FName >                             m_DisableForMap;                                  		// 0x00A0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	TArray< struct FName >                             m_DisableForGameType;                             		// 0x00AC (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned char                                      m_AutorisedSection;                               		// 0x00B8 (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_UnlockSection;                                  		// 0x00B9 (0x0001) [0x0000000000004000]              ( CPF_Config )
	int                                                m_UnlockLevel;                                    		// 0x00BC (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_UnlockByPrestige : 1;                           		// 0x00C0 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	struct FS_MaterialInstanceConstantInfo             m_MatInfoIconBig;                                 		// 0x00C4 (0x0094) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FS_MaterialInstanceConstantInfo             m_MatInfoIconSmall;                               		// 0x0158 (0x0094) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2172 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_Equipment::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_Badges
// 0x0014 (0x0200 - 0x01EC)
class UYUIDataProvider_Badges : public UYUIDataProvider_Equipment
{
public:
	unsigned char                                      m_ChallengeEnum;                                  		// 0x01EC (0x0001) [0x0000000000004000]              ( CPF_Config )
	int                                                m_index;                                          		// 0x01F0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_sImage;                                         		// 0x01F4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2173 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_Badges::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_ChallengeSections
// 0x0005 (0x01F1 - 0x01EC)
class UYUIDataProvider_ChallengeSections : public UYUIDataProvider_Equipment
{
public:
	int                                                m_iProfileUniqueNumber;                           		// 0x01EC (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_ChallengeSection;                               		// 0x01F0 (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2174 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_ChallengeSections::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CharacterKitCategories
// 0x0010 (0x01FC - 0x01EC)
class UYUIDataProvider_CharacterKitCategories : public UYUIDataProvider_Equipment
{
public:
	unsigned char                                      m_KitCategoryEnum;                                		// 0x01EC (0x0001) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_sPreviewImage;                                  		// 0x01F0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2175 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_CharacterKitCategories::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CharacterSlots
// 0x0001 (0x01ED - 0x01EC)
class UYUIDataProvider_CharacterSlots : public UYUIDataProvider_Equipment
{
public:
	unsigned char                                      m_CharacterSlotEnum;                              		// 0x01EC (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2176 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_CharacterSlots::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_Perks
// 0x00FC (0x02E8 - 0x01EC)
class UYUIDataProvider_Perks : public UYUIDataProvider_Equipment
{
public:
	unsigned char                                      m_EPerkName;                                      		// 0x01EC (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_PerkType;                                       		// 0x01ED (0x0001) [0x0000000000000002]              ( CPF_Const )
	struct FString                                     m_sDescriptionLevel1;                             		// 0x01F0 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_sDescriptionLevel2;                             		// 0x01FC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_sSpecopsImage;                                  		// 0x0208 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_sKonradImage;                                   		// 0x0214 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_sSpecopsImageSmall;                             		// 0x0220 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_sKonradImageSmall;                              		// 0x022C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FS_MaterialInstanceConstantInfo             m_MatInfoIconRespawn;                             		// 0x0238 (0x0094) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                m_specopsTextureChannel;                          		// 0x02CC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_specopsTextureU;                                		// 0x02D0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_specopsTextureV;                                		// 0x02D4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_konradTextureChannel;                           		// 0x02D8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_konradTextureU;                                 		// 0x02DC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_konradTextureV;                                 		// 0x02E0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minorPerkIndex;                                 		// 0x02E4 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2177 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_Perks::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MajorPerks
// 0x0040 (0x0328 - 0x02E8)
class UYUIDataProvider_MajorPerks : public UYUIDataProvider_Perks
{
public:
	struct FString                                     m_sPreviewCharacterImage;                         		// 0x02E8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_sPreviewCharacterImageLevel2;                   		// 0x02F4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_sPreviewCharacterMesh;                          		// 0x0300 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_sPreviewCharacterMeshLevel2;                    		// 0x030C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                m_UnlockLevel2;                                   		// 0x0318 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_ContentPack;                                    		// 0x031C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2178 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MajorPerks::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MinorPerks
// 0x0004 (0x02EC - 0x02E8)
class UYUIDataProvider_MinorPerks : public UYUIDataProvider_Perks
{
public:
	int                                                m_PlayTimeForLevel2;                              		// 0x02E8 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2179 ];

		return pClassPointer;
	};

	int GetLevel2PlayTimeSeconds ( );
};

UClass* UYUIDataProvider_MinorPerks::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_Titles
// 0x0020 (0x020C - 0x01EC)
class UYUIDataProvider_Titles : public UYUIDataProvider_Equipment
{
public:
	unsigned char                                      m_ChallengeEnum;                                  		// 0x01EC (0x0001) [0x0000000000004000]              ( CPF_Config )
	int                                                m_index;                                          		// 0x01F0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_sImage;                                         		// 0x01F4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_sTitleName;                                     		// 0x0200 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2180 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_Titles::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_WeaponCategories
// 0x0018 (0x0204 - 0x01EC)
class UYUIDataProvider_WeaponCategories : public UYUIDataProvider_Equipment
{
public:
	unsigned char                                      m_MPWeaponCategory;                               		// 0x01EC (0x0001) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_sImage;                                         		// 0x01F0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FName                                       m_MenuName;                                       		// 0x01FC (0x0008) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2181 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_WeaponCategories::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_Weapons
// 0x0020 (0x020C - 0x01EC)
class UYUIDataProvider_Weapons : public UYUIDataProvider_Equipment
{
public:
	unsigned char                                      m_MPWeaponCategory;                               		// 0x01EC (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_weaponClassEnum;                                		// 0x01ED (0x0001) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fRangeFactor;                                   		// 0x01F0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fDamageFactor;                                  		// 0x01F4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fAccuracyFactor;                                		// 0x01F8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fFireRateFactor;                                		// 0x01FC (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_sPreviewWeaponImage;                            		// 0x0200 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2182 ];

		return pClassPointer;
	};

	unsigned char StaticGetWeaponCategory ( struct FString sWeaponCategoryEnum );
};

UClass* UYUIDataProvider_Weapons::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MissionBase
// 0x0040 (0x00BC - 0x007C)
class UYUIDataProvider_MissionBase : public UUIResourceDataProvider
{
public:
	struct FString                                     m_name;                                           		// 0x007C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_description;                                    		// 0x0088 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_sImagePreview;                                  		// 0x0094 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_sPositionsWidgetName;                           		// 0x00A0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FS_TextureField                             m_ImageEmpty;                                     		// 0x00AC (0x0004) [0x0000000000000000]              
	struct FString                                     m_sEmpty;                                         		// 0x00B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2183 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MissionBase::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_Chapter
// 0x0018 (0x00D4 - 0x00BC)
class UYUIDataProvider_Chapter : public UYUIDataProvider_MissionBase
{
public:
	struct FString                                     m_SubName;                                        		// 0x00BC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	TArray< class UYUIDataProvider_Mission* >          m_Missions;                                       		// 0x00C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2184 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_Chapter::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_Mission
// 0x0024 (0x00E0 - 0x00BC)
class UYUIDataProvider_Mission : public UYUIDataProvider_MissionBase
{
public:
	unsigned char                                      m_ModeMission;                                    		// 0x00BC (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_gameMission;                                    		// 0x00BD (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_gameChapter;                                    		// 0x00BE (0x0001) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_MapName;                                        		// 0x00C0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_SubName;                                        		// 0x00CC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FName                                       m_ChapterTag;                                     		// 0x00D8 (0x0008) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2185 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_Mission::pClassPointer = NULL;

// Class SRGame.YUIDataStore_Equipment
// 0x09C0 (0x0A84 - 0x00C4)
class UYUIDataStore_Equipment : public UUIDataStore_GameResource
{
public:
	struct FPointer                                    VfTable_IUIListElementCellProvider;               		// 0x00C4 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FString                                     m_EqTypeTitle;                                    		// 0x00C8 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EqTypeBadge;                                    		// 0x00D4 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EqTypeMajorPerk;                                		// 0x00E0 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EqTypeMinorPerk;                                		// 0x00EC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EqTypeAssaultRifle;                             		// 0x00F8 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EqTypeSubmachineGun;                            		// 0x0104 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EqTypeShotgun;                                  		// 0x0110 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EqTypeSniperRifle;                              		// 0x011C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EqTypeHeavyWeapon;                              		// 0x0128 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EqTypeHandgun;                                  		// 0x0134 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_EqTypeExplosive;                                		// 0x0140 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_TypeCharacterSlot;                              		// 0x014C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_TypeChallengeSection;                           		// 0x0158 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_TypeSpecialUnlockable;                          		// 0x0164 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FName                                       m_SearchTagFriendlyName;                          		// 0x0170 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_SearchTagClassName;                             		// 0x0178 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_SearchTagPerkName;                              		// 0x0180 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_SearchTagPreview;                               		// 0x0188 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_SearchTagPreviewLevel2;                         		// 0x0190 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_SearchTagPreviewMesh;                           		// 0x0198 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_SearchTagPreviewMeshLevel2;                     		// 0x01A0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagWeapons;                             		// 0x01A8 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagPrimWeapons;                         		// 0x01B0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagPrimWeaponsForHeavy;                 		// 0x01B8 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagSecWeapons;                          		// 0x01C0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagSecWeaponsForHeavy;                  		// 0x01C8 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagExplosives;                          		// 0x01D0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagMajorPerks;                          		// 0x01D8 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagMinorPerks;                          		// 0x01E0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagTitles;                              		// 0x01E8 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagBadges;                              		// 0x01F0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	TArray< struct FName >                             m_lBaseTag;                                       		// 0x01F8 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< struct FName >                             m_lSpecOpsTag;                                    		// 0x0204 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< struct FName >                             m_lKonradTag;                                     		// 0x0210 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	struct FName                                       m_ProviderTagCharacterSlots;                      		// 0x021C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagChallengeSections;                   		// 0x0224 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagSpecialUnlockables;                  		// 0x022C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagWeaponCategories;                    		// 0x0234 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagPrimaryWeaponCategories;             		// 0x023C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagSecondaryWeaponCategories;           		// 0x0244 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagPrimaryWeaponCategoriesForHeavy;     		// 0x024C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagSecondaryWeaponCategoriesForHeavy;   		// 0x0254 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagExplosivesWeaponCategories;          		// 0x025C (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_ProviderTagCharacterKitCategories;              		// 0x0264 (0x0008) [0x0000000000000002]              ( CPF_Const )
	class UYUIDataProvider_CharacterSlots*             m_lProvider_SO_CharacterSlots[ 0x5 ];             		// 0x026C (0x0014) [0x0000000000000002]              ( CPF_Const )
	class UYUIDataProvider_CharacterSlots*             m_lProvider_KO_CharacterSlots[ 0x5 ];             		// 0x0280 (0x0014) [0x0000000000000002]              ( CPF_Const )
	class UYUIDataProvider_CharacterKitCategories*     m_lProviderKitCategories[ 0x5 ];                  		// 0x0294 (0x0014) [0x0000000000000002]              ( CPF_Const )
	class UYUIDataProvider_Perks*                      m_lProviderPerks[ 0x46 ];                         		// 0x02A8 (0x0118) [0x0000000000000002]              ( CPF_Const )
	class UYUIDataProvider_Weapons*                    m_lProviderWeapons[ 0x41 ];                       		// 0x03C0 (0x0104) [0x0000000000000002]              ( CPF_Const )
	class UYUIDataProvider_Titles*                     m_lProviderTitles[ 0xAF ];                        		// 0x04C4 (0x02BC) [0x0000000000000002]              ( CPF_Const )
	class UYUIDataProvider_Badges*                     m_lProviderBadges[ 0x91 ];                        		// 0x0780 (0x0244) [0x0000000000000002]              ( CPF_Const )
	class UYUIDataProvider_WeaponCategories*           m_lProviderWeaponCategories[ 0x7 ];               		// 0x09C4 (0x001C) [0x0000000000000002]              ( CPF_Const )
	TArray< unsigned char >                            m_lPrimaryWeaponCategories;                       		// 0x09E0 (0x000C) [0x0000000000404002]              ( CPF_Const | CPF_Config | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_lSecondaryWeaponCategories;                     		// 0x09EC (0x000C) [0x0000000000404002]              ( CPF_Const | CPF_Config | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_lExplosiveWeaponCategories;                     		// 0x09F8 (0x000C) [0x0000000000404002]              ( CPF_Const | CPF_Config | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_lPrimaryWeaponCategoriesForHeavy;               		// 0x0A04 (0x000C) [0x0000000000404002]              ( CPF_Const | CPF_Config | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_lSecondaryWeaponCategoriesForHeavy;             		// 0x0A10 (0x000C) [0x0000000000404002]              ( CPF_Const | CPF_Config | CPF_NeedCtorLink )
	TArray< int >                                      m_lMajorPerkEnum;                                 		// 0x0A1C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_lMinorPerkEnum;                                 		// 0x0A28 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_lWeaponsEnum;                                   		// 0x0A34 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_lPrimaryWeaponsEnum;                            		// 0x0A40 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_lPrimaryWeaponsForHeavyEnum;                    		// 0x0A4C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_lSecondaryWeaponsEnum;                          		// 0x0A58 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_lSecondaryWeaponsForHeavyEnum;                  		// 0x0A64 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_lExplosivesWeaponsEnum;                         		// 0x0A70 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	int                                                m_numTitles;                                      		// 0x0A7C (0x0004) [0x0000000000000000]              
	int                                                m_numBadges;                                      		// 0x0A80 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2186 ];

		return pClassPointer;
	};

	bool IsSecondaryWeapon ( unsigned char eWeapon );
	bool IsPrimaryWeapon ( unsigned char eWeapon );
	bool GetRankUnlockedItem ( int TeamID, int rankLevel, class UYUIDataProvider_Equipment** OutProvider, struct FName* OutProviderTag );
	void GetItemsAvailability ( struct FName ProviderTag, int rankLevel, int prestigeLevel, unsigned long bCheckLevel2, TArray< int >* ItemsAvailability );
	void GetChallengeSectionsAvailability ( int rankLevel, int prestigeLevel, TArray< int >* ItemsAvailability );
	void GetExplosivesAvailability ( int rankLevel, int prestigeLevel, TArray< int >* ItemsAvailability );
	void GetSecondaryWeaponsAvailability ( int rankLevel, int prestigeLevel, TArray< int >* ItemsAvailability );
	void GetPrimaryWeaponsAvailability ( int rankLevel, int prestigeLevel, TArray< int >* ItemsAvailability );
	void GetMinorPerksAvailability ( int rankLevel, int prestigeLevel, int* perkUseTimes, TArray< int >* ItemsAvailability, TArray< unsigned char >* ItemsNameCache );
	void GetMajorPerksAvailability ( int rankLevel, int prestigeLevel, TArray< int >* ItemsAvailability );
	int GetMinorPerkUnlockedLevel ( class UYProfileSettings* Profile, unsigned char perk, int rankLevel, int prestigeLevel, int TeamID );
	int GetMajorPerkUnlockedLevel ( unsigned char perk, int rankLevel, int prestigeLevel );
	int GetItemUnlockedLevel ( class UYUIDataProvider_Equipment* Provider, int rankLevel, int prestigeLevel );
	bool IsItemUnlocked ( class UYUIDataProvider_Equipment* Provider, int rankLevel, int prestigeLevel );
	bool StaticIsUnlockedPrestigeOnly ( unsigned char ItemUnlockSection, int ItemUnlockLevel, unsigned long bItemUnlockByPrestige, int rankLevel, int prestigeLevel );
	bool StaticIsUnlocked ( unsigned char ItemUnlockSection, int ItemUnlockLevel, unsigned long bItemUnlockByPrestige, int rankLevel, int prestigeLevel );
	class UYUIDataStore_Equipment* GetEquipmentDataStore ( );
	class UYUIDataProvider_WeaponCategories* GetWeaponCategorieProvider ( unsigned char eWeaponCategory );
	class UClass* GetWeaponClass ( unsigned char WeaponEnum );
	bool GetWeaponValueString ( unsigned char eWeapon, struct FName SearchTag, struct FString* OutValue );
	class UYUIDataProvider_Weapons* GetWeaponProvider ( unsigned char eWeapon );
	int GetWeaponDataStoreIndex ( unsigned char eWeapon, struct FName FieldName );
	class UYUIDataProvider_CharacterKitCategories* GetCharacterKitCategoryProvider ( int iIndex );
	int GetCollectableProviderCount ( unsigned char Item );
	class UYUIDataProvider_Badges* GetBadgeProvider ( int iIndex );
	class UYUIDataProvider_Titles* GetTitleProvider ( int iIndex );
	struct FString GetPerkCharacterPreviewMesh ( unsigned char perkEnum, int iLevel );
	struct FString GetPerkCharacterPreviewImage ( unsigned char perkEnum, int iLevel );
	class UClass* GetPerkClass ( unsigned char perkEnum );
	bool GetPerkValueString ( unsigned char ePerk, struct FName SearchTag, struct FString* OutValue );
	class UYUIDataProvider_Perks* GetPerkProvider ( unsigned char ePerk );
	int GetPerkDataStoreIndex ( unsigned char ePerk );
	class UYUIDataProvider_CharacterSlots* GetCharacterSlotProvider ( int slotNum, unsigned char Team );
	class UYUIDataProvider_Equipment* GetEquipmentProviders ( struct FName ProviderTag, int iDataStoreIndex );
	bool GetEqProviderFieldValue ( struct FName ProviderTag, struct FName SearchField, int ProviderIndex, struct FUIProviderScriptFieldValue* out_FieldValue );
	int GetProviderSetElementCount ( struct FName ProviderFieldName );
	bool GetProviderSet ( struct FName ProviderFieldName, TArray< class UUIResourceDataProvider* >* OutProviders );
	bool GetValueFromProviderSet ( struct FName ProviderFieldName, struct FName SearchTag, int ListIndex, struct FString* OutValue );
	int FindValueInProviderSet ( struct FName ProviderFieldName, struct FName SearchTag, struct FString SearchValue );
	void GetAllResourceDataProviders ( class UClass* ProviderClass, TArray< class UUIResourceDataProvider* >* providers );
	bool IsProviderFiltered ( struct FName FieldName, int ProviderIdx );
	int GetProviderCount ( struct FName ProviderTag );
};

UClass* UYUIDataStore_Equipment::pClassPointer = NULL;

// Class SRGame.YUIDataStore_MenuItems
// 0x0008 (0x00CC - 0x00C4)
class UYUIDataStore_MenuItems : public UUIDataStore_GameResource
{
public:
	struct FPointer                                    VfTable_IUIListElementCellProvider;               		// 0x00C4 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned long                                      m_unlockAllIntelCollectibles : 1;                 		// 0x00C8 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2187 ];

		return pClassPointer;
	};

	bool IsMapUnlocked ( int ListIndex, int AchievedCommunityChallengesBitField, int ExodusCoopProgressLevel );
	bool IsGameModeUnlocked ( int ListIndex, int AchievedCommunityChallengesBitField, int ExodusCoopProgressLevel );
	class UUIResourceDataProvider* GetProviderByTagAndNameScript ( struct FName provider_tag, struct FName provider_name );
	bool GetProviderSet ( struct FName ProviderFieldName, TArray< class UYUIResourceDataProvider* >* OutProviders );
	bool GetValueFromProviderSet ( struct FName ProviderFieldName, struct FName SearchTag, int ListIndex, struct FString* OutValue );
	int FindValueInProviderSet ( struct FName ProviderFieldName, struct FName SearchTag, struct FString SearchValue );
	void GetAllResourceDataProviders ( class UClass* ProviderClass, TArray< class UYUIResourceDataProvider* >* providers );
	bool IsProviderFiltered ( struct FName FieldName, int ProviderIdx );
	int GetProviderCount ( struct FName ProviderTag );
};

UClass* UYUIDataStore_MenuItems::pClassPointer = NULL;

// Class SRGame.YUIDataStore_Missions
// 0x0008 (0x00CC - 0x00C4)
class UYUIDataStore_Missions : public UUIDataStore_GameResource
{
public:
	struct FPointer                                    VfTable_IUIListElementCellProvider;               		// 0x00C4 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned long                                      m_unlockAllMissions : 1;                          		// 0x00C8 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2188 ];

		return pClassPointer;
	};

	class UYUIDataProvider_Mission* GetMissionProviderByMission ( unsigned char MissionId );
	class UYUIDataProvider_Mission* GetMissionProvider ( int iChapterIndex, int iMissionIndex );
	class UYUIDataProvider_Chapter* GetChapterProvider ( int iChapterIndex );
	void GetAllResourceDataProviders ( class UClass* ProviderClass, TArray< class UYUIResourceDataProvider* >* providers );
	bool IsProviderFiltered ( struct FName FieldName, int ProviderIdx );
	int GetProviderCount ( struct FName ProviderTag );
	class UYUIDataStore_Missions* GetMissionsDataStore ( );
	int GetMaxMissionFinished ( );
};

UClass* UYUIDataStore_Missions::pClassPointer = NULL;

// Class SRGame.YUIDataStore_PCKeys
// 0x0084 (0x00FC - 0x0078)
class UYUIDataStore_PCKeys : public UUIDataStore
{
public:
	struct FString                                     m_errorString;                                    		// 0x0078 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FMap_Mirror                                 m_keyBindings;                                    		// 0x0084 (0x003C) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	struct FMap_Mirror                                 m_rawKeyNames;                                    		// 0x00C0 (0x003C) [0x0000000000002002]              ( CPF_Const | CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2189 ];

		return pClassPointer;
	};

	void RebuildPCKeys ( class AYPlayerController* PC );
};

UClass* UYUIDataStore_PCKeys::pClassPointer = NULL;

// Class SRGame.YUIDataStore_PlayerActionMessage
// 0x0000 (0x00C4 - 0x00C4)
class UYUIDataStore_PlayerActionMessage : public UUIDataStore_StringAliasMap
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2190 ];

		return pClassPointer;
	};

	int GetStringWithFieldName ( struct FString FieldName, struct FString* MappedString );
};

UClass* UYUIDataStore_PlayerActionMessage::pClassPointer = NULL;

// Class SRGame.YUIDataStore_PlayerClasses
// 0x001C (0x00E0 - 0x00C4)
class UYUIDataStore_PlayerClasses : public UUIDataStore_GameResource
{
public:
	struct FYS_EquipmentClass                          m_lastEquipment;                                  		// 0x00C4 (0x001C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2191 ];

		return pClassPointer;
	};

};

UClass* UYUIDataStore_PlayerClasses::pClassPointer = NULL;

// Class SRGame.YUIDataStore_Scale
// 0x0000 (0x0078 - 0x0078)
class UYUIDataStore_Scale : public UUIDataStore
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2192 ];

		return pClassPointer;
	};

};

UClass* UYUIDataStore_Scale::pClassPointer = NULL;

// Class SRGame.YUIEquipmentButton
// 0x0060 (0x04DC - 0x047C)
class UYUIEquipmentButton : public UUIButton
{
public:
	struct FPointer                                    VfTable_IUIDataStorePublisher;                    		// 0x047C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FUIDataStoreBinding                         m_CaptionEqSource;                                		// 0x0480 (0x0030) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UUIComp_DrawString*                          m_StringEqRenderComponent;                        		// 0x04B0 (0x0004) [0x000000000608000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_EqIconLabel;                                    		// 0x04B4 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUIImage*                                    m_imgEqIcon;                                      		// 0x04B8 (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	class UUILabel*                                    m_EqNameLabel;                                    		// 0x04BC (0x0004) [0x0000000006000003]              ( CPF_Edit | CPF_Const | CPF_NoClear | CPF_EditInline )
	unsigned long                                      m_bIsSelected : 1;                                		// 0x04C0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bIsEQWeaponButton : 1;                          		// 0x04C0 (0x0004) [0x0000000000000003] [0x00000002] ( CPF_Edit | CPF_Const )
	struct FScriptDelegate                             __OnSelectEquipment__Delegate;                    		// 0x04C4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnFocusedEquipment__Delegate;                   		// 0x04D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2193 ];

		return pClassPointer;
	};

	bool OnButtonClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void CreateMaterialInstanceConstant ( );
	class UMaterialInstanceConstant* GetMaterialInstanceConstant ( );
	bool IsSelected ( );
	void SetSelected ( unsigned long _bSelected );
	void SetEqNameValue ( struct FString sNewValue );
	void SetEqIconValue ( struct FString sNewValue );
	void SetEqValue ( struct FString sNewValue );
	void OnFocusedEquipment ( class UYUIEquipmentButton* Sender );
	void OnSelectEquipment ( class UYUIEquipmentButton* Sender );
	void SetTextAlignment ( unsigned char Horizontal, unsigned char Vertical );
	bool SaveSubscriberValue ( int BindingIndex, TArray< class UUIDataStore* >* out_BoundDataStores );
	void ClearBoundDataStores ( );
	void GetBoundDataStores ( TArray< class UUIDataStore* >* out_BoundDataStores );
	void NotifyDataStoreValueUpdated ( class UUIDataStore* SourceDataStore, unsigned long bValuesInvalidated, struct FName PropertyTag, class UUIDataProvider* SourceProvider, int ArrayIndex );
	bool RefreshSubscriberValue ( int BindingIndex );
	struct FString GetDataStoreBinding ( int BindingIndex );
	void SetDataStoreBinding ( struct FString MarkupText, int BindingIndex );
};

UClass* UYUIEquipmentButton::pClassPointer = NULL;

// Class SRGame.YUIListMajorPerk
// 0x0000 (0x080C - 0x080C)
class UYUIListMajorPerk : public UUIObjectList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2194 ];

		return pClassPointer;
	};

};

UClass* UYUIListMajorPerk::pClassPointer = NULL;

// Class SRGame.YUIListMinorPerks
// 0x0000 (0x080C - 0x080C)
class UYUIListMinorPerks : public UUIList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2195 ];

		return pClassPointer;
	};

	void PerformMousewheelScrolling ( unsigned long bScrollUp );
};

UClass* UYUIListMinorPerks::pClassPointer = NULL;

// Class SRGame.YUIListWeapon
// 0x0000 (0x080C - 0x080C)
class UYUIListWeapon : public UUIList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2196 ];

		return pClassPointer;
	};

	bool CanAcceptFocus ( int PlayerIndex, unsigned long bIncludeParentVisibility );
};

UClass* UYUIListWeapon::pClassPointer = NULL;

// Class SRGame.YUIListWeaponCategories
// 0x0000 (0x080C - 0x080C)
class UYUIListWeaponCategories : public UUIList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2197 ];

		return pClassPointer;
	};

	bool CanAcceptFocus ( int PlayerIndex, unsigned long bIncludeParentVisibility );
};

UClass* UYUIListWeaponCategories::pClassPointer = NULL;

// Class SRGame.YUIMessageBox
// 0x004C (0x04BC - 0x0470)
class UYUIMessageBox : public UUIObject
{
public:
	struct FPointer                                    VfTable_IUIMultipleStringSubscriber;              		// 0x0470 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_IUIStringRenderer;                        		// 0x0474 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class UUIComp_DrawMultipleString*                  StringRenderComponent;                            		// 0x0478 (0x0004) [0x000000000608000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_NoClear | CPF_EditInline )
	float                                              m_fMessageDuration;                               		// 0x047C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fMessageFadeOutDuration;                        		// 0x0480 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fWidgetFadeInDuration;                          		// 0x0484 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fWidgetFadeOutDuration;                         		// 0x0488 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	TArray< struct FYS_MessageBox_Message >            m_listMessages;                                   		// 0x048C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_fEdTimeLastMessageAdded;                        		// 0x0498 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              m_fEdTimeLastMessageRemove;                       		// 0x049C (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	unsigned long                                      m_bEdFakeMessageActive : 1;                       		// 0x04A0 (0x0004) [0x0000000000002003] [0x00000001] ( CPF_Edit | CPF_Const | CPF_Transient )
	int                                                m_iEdMaxMessage;                                  		// 0x04A4 (0x0004) [0x0000000000002003]              ( CPF_Edit | CPF_Const | CPF_Transient )
	float                                              m_fEdTimeBetweenMessage;                          		// 0x04A8 (0x0004) [0x0000000000002003]              ( CPF_Edit | CPF_Const | CPF_Transient )
	class UUIImage*                                    m_imgCursor;                                      		// 0x04AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matCursor;                                      		// 0x04B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgBackground;                                  		// 0x04B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matBackground;                                  		// 0x04B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2198 ];

		return pClassPointer;
	};

	float GetOpacity ( int ElementIndex );
	void SetTextAlignment ( unsigned char Horizontal, unsigned char Vertical );
	void AddNewMessage ( struct FString sMessage );
};

UClass* UYUIMessageBox::pClassPointer = NULL;

// Class SRGame.YUIOptionList
// 0x001C (0x0560 - 0x0544)
class UYUIOptionList : public UUIOptionList
{
public:
	int                                                m_ProfileSettingID;                               		// 0x0544 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_preventZeroSelection : 1;                       		// 0x0548 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_SwitcherLeftAlign;                              		// 0x054C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_SwitcherRightAlign;                             		// 0x0550 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FScriptDelegate                             __OnSwitcherAlignmentChanged__Delegate;           		// 0x0554 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2199 ];

		return pClassPointer;
	};

	void SetCurrentIndexIgnorePreventZeroSelection ( int NewIndex );
	void SetCurrentIndex ( int NewIndex );
	void UpdateButtonsState ( unsigned long bShowButtons );
	void OnSwitcherAlignmentChanged ( );
};

UClass* UYUIOptionList::pClassPointer = NULL;

// Class SRGame.YUIResourceDataProvider
// 0x0010 (0x008C - 0x007C)
class UYUIResourceDataProvider : public UUIResourceDataProvider
{
public:
	unsigned long                                      bSearchAllInis : 1;                               		// 0x007C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bRemoveOn360 : 1;                                 		// 0x007C (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      bRemoveOnPC : 1;                                  		// 0x007C (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      bRemoveOnPS3 : 1;                                 		// 0x007C (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	struct FString                                     IniName;                                          		// 0x0080 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2200 ];

		return pClassPointer;
	};

	bool IsFiltered ( );
};

UClass* UYUIResourceDataProvider::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CharacterClass
// 0x0070 (0x00FC - 0x008C)
class UYUIDataProvider_CharacterClass : public UYUIResourceDataProvider
{
public:
	struct FString                                     CharacterName;                                    		// 0x008C (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	float                                              AiSelectionWeight;                                		// 0x0098 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_PrimaryWeapon;                                  		// 0x009C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_SecondaryWeapon;                                		// 0x00A8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_Explosives;                                     		// 0x00B4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_MajorPerk;                                      		// 0x00C0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                m_MajorPerkLevel;                                 		// 0x00CC (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_MinorPerk1;                                     		// 0x00D0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_MinorPerk2;                                     		// 0x00DC (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_MinorPerk3;                                     		// 0x00E8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                m_restrictionCount;                               		// 0x00F4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bMustBeSelectedByOnePlayer : 1;                 		// 0x00F8 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2201 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_CharacterClass::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_ClassList
// 0x0010 (0x009C - 0x008C)
class UYUIDataProvider_ClassList : public UYUIResourceDataProvider
{
public:
	TArray< struct FName >                             m_classes;                                        		// 0x008C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned long                                      m_bLockByRank : 1;                                		// 0x0098 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2202 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_ClassList::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_KeyBinding
// 0x001C (0x00A8 - 0x008C)
class UYUIDataProvider_KeyBinding : public UYUIResourceDataProvider
{
public:
	struct FString                                     FriendlyName;                                     		// 0x008C (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     Command;                                          		// 0x0098 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned long                                      bIsCrucialBind : 1;                               		// 0x00A4 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      bAllowsMouseWheelBind : 1;                        		// 0x00A4 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2203 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_KeyBinding::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MapCharacterList
// 0x004C (0x00D8 - 0x008C)
class UYUIDataProvider_MapCharacterList : public UYUIResourceDataProvider
{
public:
	TArray< struct FName >                             m_SOCharacterList;                                		// 0x008C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	TArray< struct FName >                             m_KREliteCharacterList;                           		// 0x0098 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	TArray< struct FName >                             m_KRBossCharacterList;                            		// 0x00A4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	TArray< struct FYS_ChallengeDefinition >           m_eliteChallenges;                                		// 0x00B0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                m_eliteChallengeResetIndex;                       		// 0x00BC (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_ChallengeDefinition                     m_bossChallenge;                                  		// 0x00C0 (0x0014) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bOnelifeBossChallenge : 1;                      		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2204 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MapCharacterList::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MenuItems
// 0x0030 (0x00BC - 0x008C)
class UYUIDataProvider_MenuItems : public UYUIResourceDataProvider
{
public:
	struct FString                                     FriendlyName;                                     		// 0x008C (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     Description;                                      		// 0x0098 (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     PreviewImageMarkup;                               		// 0x00A4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FName                                       TagItem;                                          		// 0x00B0 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fSeparatorSize;                                 		// 0x00B8 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2205 ];

		return pClassPointer;
	};

	bool IsItemCompatibleWithGameMode ( struct FString ItemPrefixes, struct FString GameModePrefixes );
};

UClass* UYUIDataProvider_MenuItems::pClassPointer = NULL;

// Class SRGame.YDataProvider_IntelCollectibles
// 0x0028 (0x00E4 - 0x00BC)
class UYDataProvider_IntelCollectibles : public UYUIDataProvider_MenuItems
{
public:
	int                                                m_collectibleID;                                  		// 0x00BC (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_voiceUID;                                       		// 0x00C0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     ImageDesc;                                        		// 0x00C4 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     IntelImage;                                       		// 0x00D0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned char                                      m_gameMission;                                    		// 0x00DC (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_isUnLocked : 1;                                 		// 0x00E0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2206 ];

		return pClassPointer;
	};

};

UClass* UYDataProvider_IntelCollectibles::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CustomMatchMenuItems
// 0x0004 (0x00C0 - 0x00BC)
class UYUIDataProvider_CustomMatchMenuItems : public UYUIDataProvider_MenuItems
{
public:
	unsigned long                                      bOnlineOnly : 1;                                  		// 0x00BC (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      bLANOnly : 1;                                     		// 0x00BC (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      bChangeSettingsOnly : 1;                          		// 0x00BC (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      bNotInChangeSettings : 1;                         		// 0x00BC (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	unsigned long                                      bExodusOnly : 1;                                  		// 0x00BC (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	unsigned long                                      bCompetitiveOnly : 1;                             		// 0x00BC (0x0004) [0x0000000000004000] [0x00000020] ( CPF_Config )
	unsigned long                                      bExodusVersusOnly : 1;                            		// 0x00BC (0x0004) [0x0000000000004000] [0x00000040] ( CPF_Config )
	unsigned long                                      bExodusCoopOnly : 1;                              		// 0x00BC (0x0004) [0x0000000000004000] [0x00000080] ( CPF_Config )
	unsigned long                                      bNotExodusCoop : 1;                               		// 0x00BC (0x0004) [0x0000000000004000] [0x00000100] ( CPF_Config )
	unsigned long                                      bFiltreOnPrivateOrPublic : 1;                     		// 0x00BC (0x0004) [0x0000000000004000] [0x00000200] ( CPF_Config )
	unsigned long                                      bPublicMatch : 1;                                 		// 0x00BC (0x0004) [0x0000000000004000] [0x00000400] ( CPF_Config )
	unsigned long                                      bPrivateMatch : 1;                                		// 0x00BC (0x0004) [0x0000000000004000] [0x00000800] ( CPF_Config )
	unsigned long                                      bPrivateHostOnly : 1;                             		// 0x00BC (0x0004) [0x0000000000004000] [0x00001000] ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2207 ];

		return pClassPointer;
	};

	bool ShouldBeFiltered ( );
	bool IsFiltered ( );
};

UClass* UYUIDataProvider_CustomMatchMenuItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MatchSetting
// 0x000C (0x00C8 - 0x00BC)
class UYUIDataProvider_MatchSetting : public UYUIDataProvider_MenuItems
{
public:
	struct FString                                     FriendlyNameSmall;                                		// 0x00BC (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2208 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MatchSetting::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_GameModeInfo
// 0x0078 (0x0140 - 0x00C8)
class UYUIDataProvider_GameModeInfo : public UYUIDataProvider_MatchSetting
{
public:
	struct FString                                     GameMode;                                         		// 0x00C8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned char                                      MPModeId;                                         		// 0x00D4 (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      bIsMainType : 1;                                  		// 0x00D8 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      bFriendlyFire : 1;                                		// 0x00D8 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      bRevenge : 1;                                     		// 0x00D8 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      bCustomCharacters : 1;                            		// 0x00D8 (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	unsigned long                                      bMapTravel : 1;                                   		// 0x00D8 (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	unsigned long                                      bKillCam : 1;                                     		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      bHighlightAllies : 1;                             		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      bHudOn : 1;                                       		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      bTeamKillPenalty : 1;                             		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      bHeadshotsOnly : 1;                               		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      bNoPerks : 1;                                     		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      bSandAlwaysOn : 1;                                		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      bVoiceChatEnabled : 1;                            		// 0x00D8 (0x0004) [0x0000000000000000] [0x00001000] 
	int                                                DLCRequired;                                      		// 0x00DC (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     Prefixes;                                         		// 0x00E0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                SpecOpsTeamSize;                                  		// 0x00EC (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                KonradsTeamSize;                                  		// 0x00F0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                KonradsMaxPlayers;                                		// 0x00F4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                MaxPlayers;                                       		// 0x00F8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                MinNetPlayers;                                    		// 0x00FC (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                NumRounds;                                        		// 0x0100 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                TimeLimit;                                        		// 0x0104 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                ScoreLimit;                                       		// 0x0108 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                AIDifficulty;                                     		// 0x010C (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                PlayerHealthModifier;                             		// 0x0110 (0x0004) [0x0000000000000000]              
	struct FString                                     ShortDescription;                                 		// 0x0114 (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     attacker;                                         		// 0x0120 (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     defender;                                         		// 0x012C (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	int                                                RequiredCommunityChallenge;                       		// 0x0138 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                RequiredExodusCoopProgression;                    		// 0x013C (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2209 ];

		return pClassPointer;
	};

	bool ShouldBeFiltered ( );
	bool IsFiltered ( );
};

UClass* UYUIDataProvider_GameModeInfo::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MapInfo
// 0x006C (0x0134 - 0x00C8)
class UYUIDataProvider_MapInfo : public UYUIDataProvider_MatchSetting
{
public:
	struct FString                                     Prefixes;                                         		// 0x00C8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned long                                      bUseSinglePersistent : 1;                         		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      bCampaign : 1;                                    		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	struct FString                                     BaseMapName;                                      		// 0x00D8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                DLCRequired;                                      		// 0x00E4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      MPMapId;                                          		// 0x00E8 (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      CampaignId;                                       		// 0x00E9 (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_difficultyLevel_COOP_only;                      		// 0x00EA (0x0001) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     CampaignName;                                     		// 0x00EC (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FName                                       OverridenCharacterListName;                       		// 0x00F8 (0x0008) [0x0000000000004000]              ( CPF_Config )
	int                                                RequiredCommunityChallenge;                       		// 0x0100 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                RequiredProgressLevel;                            		// 0x0104 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     MinimapImage;                                     		// 0x0108 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     MinimapImageSmall;                                		// 0x0114 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                MapChannel;                                       		// 0x0120 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                MapChannelSmall;                                  		// 0x0124 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              MinimapXOffset;                                   		// 0x0128 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              MinimapYOffset;                                   		// 0x012C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              MinimapScale;                                     		// 0x0130 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2210 ];

		return pClassPointer;
	};

	bool IsMapCompatibleWithGameMode ( struct FString GameModePrefixes );
	bool ShouldBeFiltered ( );
	bool IsFiltered ( );
};

UClass* UYUIDataProvider_MapInfo::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MenuOptionItems
// 0x0038 (0x0100 - 0x00C8)
class UYUIDataProvider_MenuOptionItems : public UYUIDataProvider_MatchSetting
{
public:
	unsigned char                                      OptionType;                                       		// 0x00C8 (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      EditboxAllowedChars;                              		// 0x00C9 (0x0001) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     DataStoreMarkup;                                  		// 0x00CC (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned long                                      bEditableCombo : 1;                               		// 0x00D8 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      bNumericCombo : 1;                                		// 0x00D8 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	int                                                EditBoxMaxLength;                                 		// 0x00DC (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FUIRangeData                                RangeData;                                        		// 0x00E0 (0x0014) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FName >                             SchemaCellFields;                                 		// 0x00F4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2211 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MenuOptionItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_OptionItems
// 0x0004 (0x0104 - 0x0100)
class UYUIDataProvider_OptionItems : public UYUIDataProvider_MenuOptionItems
{
public:
	unsigned long                                      bFilterFrontend : 1;                              		// 0x0100 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      bFilterMPGame : 1;                                		// 0x0100 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      bFilterSPGame : 1;                                		// 0x0100 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      bFilterPrologue : 1;                              		// 0x0100 (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2212 ];

		return pClassPointer;
	};

	bool ShouldBeFiltered ( );
	bool IsFiltered ( );
};

UClass* UYUIDataProvider_OptionItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_RuleInfo
// 0x000C (0x010C - 0x0100)
class UYUIDataProvider_RuleInfo : public UYUIDataProvider_MenuOptionItems
{
public:
	struct FString                                     Prefixes;                                         		// 0x0100 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2213 ];

		return pClassPointer;
	};

	bool ShouldBeFiltered ( );
	bool IsFiltered ( );
};

UClass* UYUIDataProvider_RuleInfo::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_PlaylistEntry
// 0x0018 (0x00E0 - 0x00C8)
class UYUIDataProvider_PlaylistEntry : public UYUIDataProvider_MatchSetting
{
public:
	unsigned char                                      GameMode;                                         		// 0x00C8 (0x0001) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      Map;                                              		// 0x00C9 (0x0001) [0x0000000000004000]              ( CPF_Config )
	int                                                TimeLimit;                                        		// 0x00CC (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                ScoreLimit;                                       		// 0x00D0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      bFriendlyFire : 1;                                		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      bRevenge : 1;                                     		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      bKillCam : 1;                                     		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      bHighlightAllies : 1;                             		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	unsigned long                                      bHudOn : 1;                                       		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	unsigned long                                      bTeamKillPenalty : 1;                             		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000020] ( CPF_Config )
	unsigned long                                      bHeadshotsOnly : 1;                               		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000040] ( CPF_Config )
	unsigned long                                      bNoPerks : 1;                                     		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000080] ( CPF_Config )
	unsigned long                                      bSandAlwaysOn : 1;                                		// 0x00D4 (0x0004) [0x0000000000004000] [0x00000100] ( CPF_Config )
	int                                                PlayerHealthModifier;                             		// 0x00D8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                NumRounds;                                        		// 0x00DC (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2214 ];

		return pClassPointer;
	};

	struct FYS_RuleSettings GetRules ( );
};

UClass* UYUIDataProvider_PlaylistEntry::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_PlaylistInfo
// 0x0019 (0x00E1 - 0x00C8)
class UYUIDataProvider_PlaylistInfo : public UYUIDataProvider_MatchSetting
{
public:
	TArray< struct FString >                           PlaylistEntryList;                                		// 0x00C8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                MPPlaylistId;                                     		// 0x00D4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                DLCRequired;                                      		// 0x00D8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_UnlockLevel;                                    		// 0x00DC (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_PlaylistType;                                   		// 0x00E0 (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2215 ];

		return pClassPointer;
	};

	bool ShouldBeFiltered ( );
	bool IsFiltered ( );
};

UClass* UYUIDataProvider_PlaylistInfo::pClassPointer = NULL;

// Class SRGame.YUIScenes
// 0x0054 (0x0744 - 0x06F0)
class UYUIScenes : public UUIScene
{
public:
	unsigned long                                      bEditorRealTimePreview : 1;                       		// 0x06F0 (0x0004) [0x0000000000002001] [0x00000001] ( CPF_Edit | CPF_Transient )
	unsigned long                                      bSkipPendingCloseSceneNotify : 1;                 		// 0x06F0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_gamePadConnectedPC : 1;                         		// 0x06F0 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	class UUIScene*                                    MessageBoxScene;                                  		// 0x06F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIScene*                                    PendingOpenScene;                                 		// 0x06F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIScene*                                    PendingCloseScene;                                		// 0x06FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       ButtonBarButtonBGStyleName;                       		// 0x0700 (0x0008) [0x0000000000000000]              
	struct FName                                       ButtonBarButtonTextStyleName;                     		// 0x0708 (0x0008) [0x0000000000000000]              
	struct FName                                       ButtonBarButtonBGStyleNamePC;                     		// 0x0710 (0x0008) [0x0000000000000000]              
	struct FName                                       ButtonBarButtonTextStyleNamePC;                   		// 0x0718 (0x0008) [0x0000000000000000]              
	struct FString                                     m_languageExtension;                              		// 0x0720 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnShowAnimationEnded__Delegate;                 		// 0x072C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnHideAnimationEnded__Delegate;                 		// 0x0738 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2216 ];

		return pClassPointer;
	};

	void UpdateButtonStylesForPanel ( class UUICalloutButtonPanel* panel );
	void ReCreateCalloutButtonsForPanel ( class UUICalloutButtonPanel* panel );
	bool IsControllerInput ( struct FName KeyName );
	void CreateOnlineGameCompleteCheckpoint ( struct FName SessionName, unsigned long bWasSuccessful );
	void StartGameFromCheckpoint ( );
	class AYGameInfo_Menu* GetMenuGameInfo ( );
	class AYGameInfo* GetCurrentGameInfo ( );
	void OnOverridePlatformChanged ( );
	class UUTGameInteraction* GetUTInteraction ( );
	bool OnLoginError_Confirm ( class UUIMessageBoxBase* MessageBox, struct FName SelectedItem, int PlayerIndex );
	void DisplayMessageBox ( struct FName MessageBoxTag, struct FString Title, struct FString Message, struct FScriptDelegate SelectionCallback );
	class UOnlineSystemInterface* GetOnlineSystemInterface ( );
	void StopCurrentUISound ( );
	void PlayAsCurrentUISound ( class USoundCue* InSoundCue );
	void PlaySound ( class USoundCue* InSoundCue );
	class UUIDataStore* FindDataStore ( struct FName DataStoreTag, class ULocalPlayer* InPlayerOwner );
	bool BeginHideAnimation ( unsigned long bClosingScene );
	bool BeginShowAnimation ( unsigned long bInitialActivation, unsigned long bBypassAnimation );
	void FinishCloseScene ( class UUIScene* SceneToClose, unsigned long bSkipAnimations, unsigned long bSkipKismetNotify, unsigned long bCloseChildScenes );
	void OnPendingCloseScene_HideAnimationEnded ( );
	bool CloseScene ( class UUIScene* SceneToClose, unsigned long bCloseChildScenes, unsigned long bForceCloseImmediately );
	void OpenCommunitySessionsUI ( );
	void OpenInvitePartyMenu ( );
	void OpenInviteFriendsMenu ( );
	bool IsLoggedIn ( int ControllerId, unsigned long bRequireOnlineLogin );
	void SceneActivated ( unsigned long bInitialActivation );
	struct FString FloatToString ( float fIn );
	void ActivateLevelEvent ( struct FName EventName );
	void SetAudioDeviceToUse ( struct FString InAudioDevice );
	int GetDefaultGPUCompatibilityLevel ( );
	bool IsBelowMinSpecs ( );
	struct FString GetCurrentAudioDevice ( );
	void GetPossibleAudioDevices ( TArray< struct FString >* OutResults );
	int GetUserCompatSetting ( );
	int GetTextureQuality ( int compatLevel );
	int GetShadowQuality ( int compatLevel );
	bool GetAmbientOcclusionDefaultValue ( int GPUCompatLevel );
	bool IsAmbientOcclusionEnabled ( int compatLevel );
	bool IsFullScreenEnabled ( );
	bool IsVSyncEnabled ( int compatLevel );
	int GetPossibleMSAALevels ( TArray< struct FString >* OutResults );
	int GetPossibleScreenResolutions ( TArray< struct FString >* OutResults );
	bool IsGame ( );
	class AYPlayerReplicationInfo* GetPRIOwner ( );
	class AYGamePawn* GetPawnOwner ( );
	class AYPlayerController* GetYPlayerOwner ( int PlayerIndex );
	void SetUserCompatSetting ( int compatLevelToStore, int compatLevelToApply );
	void SetTextureQuality ( int qualityLevel );
	void SetShadowQuality ( int qualityLevel );
	void SetAmbientOcclusion ( unsigned long Enable );
	void SetFullScreen ( unsigned long Enable );
	void SetVSync ( unsigned long Enable );
	void SetMSAALevel ( int Level );
	void UpdateLanguageExt ( );
	void SetScreenResolution ( int ResX, int ResY );
	void OnHideAnimationEnded ( );
	void OnShowAnimationEnded ( );
};

UClass* UYUIScenes::pClassPointer = NULL;

// Class SRGame.YUIScene_Hud
// 0x001C (0x0760 - 0x0744)
class UYUIScene_Hud : public UYUIScenes
{
public:
	class AYPlayerController*                          m_ctrl;                                           		// 0x0744 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_shouldBeVisible : 1;                            		// 0x0748 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_oldShouldBeVisible : 1;                         		// 0x0748 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_squadMateDown : 1;                              		// 0x0748 (0x0004) [0x0000000020000000] [0x00000004] ( CPF_Deprecated )
	unsigned long                                      m_squadDown : 1;                                  		// 0x0748 (0x0004) [0x0000000020000000] [0x00000008] ( CPF_Deprecated )
	unsigned long                                      m_squadDownChanged : 1;                           		// 0x0748 (0x0004) [0x0000000020000000] [0x00000010] ( CPF_Deprecated )
	unsigned long                                      m_hideOnScoping : 1;                              		// 0x0748 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_showSpectateCameraMessage : 1;                  		// 0x0748 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_showRespawnMessage : 1;                         		// 0x0748 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_forcedVisibility : 1;                           		// 0x0748 (0x0004) [0x0000000000000000] [0x00000100] 
	float                                              m_previousFadeAlpha;                              		// 0x074C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_desiredFadeAlpha;                               		// 0x0750 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fadeAlpha;                                      		// 0x0754 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fadeAlphaTime;                                  		// 0x0758 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_desiredFadeAlphaTime;                           		// 0x075C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2217 ];

		return pClassPointer;
	};

	class AYPlayerController* GetPlayerController ( int PlayerIndex );
	void InitScene ( );
	void NotifyGameSessionEnded ( );
	void PostInitialize ( );
};

UClass* UYUIScene_Hud::pClassPointer = NULL;

// Class SRGame.YUIScene_BloodHUD
// 0x0000 (0x0760 - 0x0760)
class UYUIScene_BloodHUD : public UYUIScene_Hud
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2218 ];

		return pClassPointer;
	};

};

UClass* UYUIScene_BloodHUD::pClassPointer = NULL;

// Class SRGame.YUIScene_HUD_Life_Base
// 0x010C (0x086C - 0x0760)
class UYUIScene_HUD_Life_Base : public UYUIScene_Hud
{
public:
	struct FLinearColor                                m_SpecopsColor;                                   		// 0x0760 (0x0010) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FLinearColor                                m_KonradColor;                                    		// 0x0770 (0x0010) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_EdArsenalWeapon;                                		// 0x0780 (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_EdArsenalGrenade;                               		// 0x0781 (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_PlayerTeamId;                                   		// 0x0782 (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdArsenalWeaponClipAmmoCount;                   		// 0x0784 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdArsenalWeaponStockAmmoCount;                  		// 0x0788 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdArsenalGrenadeStockCount;                     		// 0x078C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned long                                      m_EdArsenalC4Launched : 1;                        		// 0x0790 (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_EdPlayerAlive : 1;                              		// 0x0790 (0x0004) [0x0000000000000003] [0x00000002] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_bGrenadeCountUpdateFrozen : 1;                  		// 0x0790 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bArsenalWeaponTypeInitialise : 1;               		// 0x0790 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_bArsenalWeaponAmmoCountInitialise : 1;          		// 0x0790 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_bArsenalGrenadeTypeInitialise : 1;              		// 0x0790 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_bArsenalGrenadeCountInitialise : 1;             		// 0x0790 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	struct FYS_DBNOTeamDisplay                         m_EdTeammateStatus[ 0x2 ];                        		// 0x0794 (0x0020) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FString                                     m_EdInteractionMessage;                           		// 0x07B4 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	struct FString                                     m_EdSubtitle;                                     		// 0x07C0 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	class UUIPanel*                                    m_pnlInteractionMessage;                          		// 0x07CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgInteractionMessageBG;                        		// 0x07D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblInteractionMessage;                          		// 0x07D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSubtitles;                                   		// 0x07D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSubtitlesBG;                                 		// 0x07DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSubtitles;                                   		// 0x07E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgArsenalBG;                                   		// 0x07E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgWeaponIcon;                                  		// 0x07E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblWeaponClipAmmoCount;                         		// 0x07EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgGrenadeIcon;                                 		// 0x07F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlC4Launched;                                  		// 0x07F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlArsenal;                                     		// 0x07F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgWeaponMode;                                  		// 0x07FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblWeaponMode;                                  		// 0x0800 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblWeaponStockAmmoCount;                        		// 0x0804 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblWeaponIcon;                                  		// 0x0808 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgWeaponAmmoCount;                             		// 0x080C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblWeaponName;                                  		// 0x0810 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlExplosives;                                  		// 0x0814 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblGrenadeCount;                                		// 0x0818 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblGrenadeIcon;                                 		// 0x081C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSpecialGrenadeIcon;                          		// 0x0820 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblGrenadeName;                                 		// 0x0824 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_grenadePanel;                                   		// 0x0828 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgGrenadeIndicator;                            		// 0x082C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSpecialIcon;                                 		// 0x0830 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgGoldIcon;                                    		// 0x0834 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UFont*                                       m_WeaponImgFontPackages[ 0x2 ];                   		// 0x0838 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UUIPanel*                                    m_pnlCPTeam;                                      		// 0x0840 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSquadmate[ 0x2 ];                            		// 0x0844 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSquadmate[ 0x2 ];                            		// 0x084C (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgDBNOWarning;                                 		// 0x0854 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_lowAmmoWarning;                                 		// 0x0858 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblReloadMessage;                               		// 0x085C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCancelGrenadeThrow;                          		// 0x0860 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlEventTracker;                                		// 0x0864 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIEventTracker*                            m_eventTracker;                                   		// 0x0868 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2219 ];

		return pClassPointer;
	};

	void UpdateKeyBoundStrings ( );
	void AddKillEventMessage ( class AYPlayerReplicationInfo* killerPRI, class AYPlayerReplicationInfo* victimPRI, class UYDeathMessageParams* Params );
	void OnOverridePlatformChanged ( );
	void UpdateSquadPortrait ( int pwnDown );
	void SetSquadmateStatus ( int iTeammateNumber, unsigned long bIsInDbno, float fBleedOutPercentage, float fRelativeAngle, unsigned long bIsCritical );
	void SetSquadmateIcon ( int iTeammateNumber, class UTexture2D* Icon );
	void SetPawnInfoVisibility ( unsigned long bVisibility );
	bool ArsenalInfosAreInitialised ( );
	void SetC4Launched ( unsigned long bC4Active );
	void SetGrenadeCount ( int iGrenadeCount );
	void SetArsenalGrenade ( unsigned char eGrenade );
	void SetWeaponAmmoCount ( int iClipAmmoCount, int iStockAmmoCount );
	void SetArsenalWeapon ( unsigned char eWeapon );
	void SetSubtitles ( struct FString sSubtitle );
	void SetInteractionMessage ( struct FString sMessage );
	void SetTeamID ( unsigned char TeamID );
	void Update ( );
	struct FLinearColor GetTeamColor ( );
};

UClass* UYUIScene_HUD_Life_Base::pClassPointer = NULL;

// Class SRGame.YUIScene_HUD_Life_MP
// 0x0648 (0x0EB4 - 0x086C)
class UYUIScene_HUD_Life_MP : public UYUIScene_HUD_Life_Base
{
public:
	float                                              m_ScavengerOpacityActive;                         		// 0x086C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_ScavengerOpacityUnactive;                       		// 0x0870 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_XPEventDuration;                                		// 0x0874 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_XPEventFadeOutDuration;                         		// 0x0878 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_GameInfoType;                                   		// 0x087C (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_EdMajorPerk;                                    		// 0x087D (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_EdMinorPerk1;                                   		// 0x087E (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_EdMinorPerk2;                                   		// 0x087F (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_EdMinorPerk3;                                   		// 0x0880 (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fMatchMessageFadeOutDuration;                   		// 0x0884 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdMajorPerkLevel;                               		// 0x0888 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdExperienceXP;                                 		// 0x088C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdExperienceXPCollected;                        		// 0x0890 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned long                                      m_EdScavengerArmorGauge : 1;                      		// 0x0894 (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_EdScavengerAmmoPlus : 1;                        		// 0x0894 (0x0004) [0x0000000000000003] [0x00000002] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_EdScavengerGrenadePlus : 1;                     		// 0x0894 (0x0004) [0x0000000000000003] [0x00000004] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_EdPlayerShowSpectator : 1;                      		// 0x0894 (0x0004) [0x0000000000000003] [0x00000008] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_bPromotion : 1;                                 		// 0x0894 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_minimapPlayerEnabled : 1;                       		// 0x0894 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_MinimapStaticFlashing : 1;                      		// 0x0894 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_minimapPulseEnabled : 1;                        		// 0x0894 (0x0004) [0x0000000000004001] [0x00000080] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_isMinimapZoomedIn : 1;                          		// 0x0894 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bCharacterMajorPerkInitialised : 1;             		// 0x0894 (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	unsigned long                                      m_bCharacterMinorPerksInitialised : 1;            		// 0x0894 (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      m_bCharacterExperienceInitialised : 1;            		// 0x0894 (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      m_bGameTypeInitialised : 1;                       		// 0x0894 (0x0004) [0x0000000000002000] [0x00001000] ( CPF_Transient )
	unsigned long                                      m_bGameScoreInitialised : 1;                      		// 0x0894 (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      m_bGameTimerInitialised : 1;                      		// 0x0894 (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      m_bShowTeamSwitchMessage : 1;                     		// 0x0894 (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	TArray< struct FString >                           m_EdMessageBoxMessages;                           		// 0x0898 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	struct FString                                     m_EdGameInfoCPObjectif;                           		// 0x08A4 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	int                                                m_EdGameInfoFFAPlayerScore;                       		// 0x08B0 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdGameInfoFFAPlayerRank;                        		// 0x08B4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdGameInfoFFANbPlayers;                         		// 0x08B8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdGameInfoTeamScoreSpecops;                     		// 0x08BC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdGameInfoTeamScoreKonrads;                     		// 0x08C0 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FString                                     m_EdXPEventMessage;                               		// 0x08C4 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	int                                                m_EdXPEventAmount;                                		// 0x08D0 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdChallengeEliteAmount;                         		// 0x08D4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdChallengeEliteMax;                            		// 0x08D8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdChallengeBossAmount;                          		// 0x08DC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdChallengeBossMax;                             		// 0x08E0 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FString                                     m_EdCharacterName;                                		// 0x08E4 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	struct FString                                     m_EdSquadRespawnTimerMessage;                     		// 0x08F0 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	int                                                m_EdSquadRespawnTimer;                            		// 0x08FC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdCPKonradPlayerScore;                          		// 0x0900 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdCPKonradPlayerRank;                           		// 0x0904 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdCPKonradPlayersCount;                         		// 0x0908 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                m_EdCPKonradClassLevel;                           		// 0x090C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UUIPanel*                                    m_pnlCharacterInfo;                               		// 0x0910 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMajorPerk;                                   		// 0x0914 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMinorPerk[ 0x3 ];                            		// 0x0918 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlExperiences;                                 		// 0x0924 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgExperienceProgress;                          		// 0x0928 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgExperienceProgressBG;                        		// 0x092C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblXP;                                          		// 0x0930 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblExperenceRankStart;                          		// 0x0934 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblExperenceRankEnd;                            		// 0x0938 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgClassCooldown1;                              		// 0x093C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgClassCooldown2;                              		// 0x0940 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matClassCooldown1;                              		// 0x0944 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matClassCooldown2;                              		// 0x0948 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgBuff[ 0x4 ];                                 		// 0x094C (0x0010) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matBuff[ 0x4 ];                                 		// 0x095C (0x0010) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_buffIndexLastFrame;                             		// 0x096C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlScavenger;                                   		// 0x0970 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_ScavengerImages[ 0x5 ];                         		// 0x0974 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UYUIEventTracker*                            m_GameMessageBox;                                 		// 0x0988 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlGameInfoPanel;                               		// 0x098C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgGameInfoPanelBG;                             		// 0x0990 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlTeamScoreShared;                             		// 0x0994 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlTeamGameInfoPanel;                           		// 0x0998 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSpoilsOfWarScore;                            		// 0x099C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlBuriedScore;                                 		// 0x09A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlChopperScore;                                		// 0x09A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlDeliveryScore;                               		// 0x09A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlOfflineScore;                                		// 0x09AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlAttritionScore;                              		// 0x09B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlTacticalMutinyScore;                         		// 0x09B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlRallyPointScore;                             		// 0x09B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlFFAGameInfoPanel;                            		// 0x09BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlCPGameInfoPanel;                             		// 0x09C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFFATimer;                                    		// 0x09C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFFAPlayerScore;                              		// 0x09C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFFALeaderScore;                              		// 0x09CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFFAPlayerRank;                               		// 0x09D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFFANbPlayers;                                		// 0x09D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFFASlash;                                    		// 0x09D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgFFACOASpecops;                               		// 0x09DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgFFACOAKonrad;                                		// 0x09E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTeamTimer;                                   		// 0x09E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblYourTeamScore;                               		// 0x09E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblEnemyTeamScore;                              		// 0x09EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblYourUnbankedScore;                           		// 0x09F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblEnemyUnbankedScore;                          		// 0x09F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgTeamSeparator;                               		// 0x09F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPTimer;                                     		// 0x09FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPObjectif;                                  		// 0x0A00 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCPSeparator;                                 		// 0x0A04 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMatchMessage;                                		// 0x0A08 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblLootBankIn;                                  		// 0x0A0C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblLootBankInTime;                              		// 0x0A10 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlXPEvent;                                     		// 0x0A14 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblXPEventType;                                 		// 0x0A18 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblXPEventAmount;                               		// 0x0A1C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlLevelUp;                                     		// 0x0A20 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlCPEliteChallenge;                            		// 0x0A24 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlCPBossChallenge;                             		// 0x0A28 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCPEliteChallenge;                            		// 0x0A2C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCPBossChallenge;                             		// 0x0A30 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPEliteChallengeDisplay;                     		// 0x0A34 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPEliteCumulateChallenge;                    		// 0x0A38 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPEliteMaxChallenge;                         		// 0x0A3C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPEliteCompleted;                            		// 0x0A40 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPBossCumulateChallenge;                     		// 0x0A44 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPBossMaxChallenge;                          		// 0x0A48 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPBossCompleted;                             		// 0x0A4C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatInfoCPEliteChallenge;                        		// 0x0A50 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatInfoCPBossChallenge;                         		// 0x0A54 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlCPKonradInfo;                                		// 0x0A58 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPKonradPlayerScore;                         		// 0x0A5C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPKonradPlayerRank;                          		// 0x0A60 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPKonradPlayersNumber;                       		// 0x0A64 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPKonradClassLevelUnlocked;                  		// 0x0A68 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSpectator;                                   		// 0x0A6C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRespawnTime;                                 		// 0x0A70 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTimeToRespawn;                               		// 0x0A74 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFollowingPlayerMessage;                      		// 0x0A78 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFollowingPlayerName;                         		// 0x0A7C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSpectatorCamera;                             		// 0x0A80 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRespawn;                                     		// 0x0A84 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSkipKillCam;                                 		// 0x0A88 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTeamSwitch;                                  		// 0x0A8C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlCameraCycle;                                 		// 0x0A90 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblClassSelection;                              		// 0x0A94 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCycleCamera;                                 		// 0x0A98 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSkipChoreo;                                  		// 0x0A9C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSkipChoreo;                                  		// 0x0AA0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_pnlModeInstructions;                            		// 0x0AA4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblModeInstructions;                            		// 0x0AA8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblModeName;                                    		// 0x0AAC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_modeInstructionDuration;                        		// 0x0AB0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UUILabel*                                    m_lblModeMessages;                                		// 0x0AB4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlCharacterReminder;                           		// 0x0AB8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMajorPerkReminder;                           		// 0x0ABC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMinorPerkReminder[ 0x3 ];                    		// 0x0AC0 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCharacterName;                               		// 0x0ACC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCharacterRemider;                            		// 0x0AD0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSquadRespawnPanel;                           		// 0x0AD4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSquadRespawnTimerMessage;                    		// 0x0AD8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSquadRespawnTimer;                           		// 0x0ADC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblEnemyRespawnTimer;                           		// 0x0AE0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRallyPointTimerMessage;                      		// 0x0AE4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRallyPointTimer;                             		// 0x0AE8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSquadDMPlayerAlive;                          		// 0x0AEC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSpecopsAlive;                                		// 0x0AF0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSpecopsAliveNum;                             		// 0x0AF4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKonradAlive;                                 		// 0x0AF8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKonradAliveNum;                              		// 0x0AFC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlKillerCam;                                   		// 0x0B00 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKillerName;                                  		// 0x0B04 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgKillerMajorPerk;                             		// 0x0B08 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatKillerMajorPerk;                             		// 0x0B0C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgKillerMinorPerk1;                            		// 0x0B10 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgKillerMinorPerk2;                            		// 0x0B14 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgKillerMinorPerk3;                            		// 0x0B18 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_imgKillerWeaponPrimary;                         		// 0x0B1C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_imgKillerWeaponSecondary;                       		// 0x0B20 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_imgKillerWeaponExplosive;                       		// 0x0B24 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKillerWeaponPrimary;                         		// 0x0B28 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKillerWeaponSecondary;                       		// 0x0B2C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKillerWeaponExplosive;                       		// 0x0B30 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKillCamTitleText;                            		// 0x0B34 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgKillCamTitleBanner;                          		// 0x0B38 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKillCamLevel;                                		// 0x0B3C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgKillCamLevelIcon;                            		// 0x0B40 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgKillCamBadge;                                		// 0x0B44 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlCPTeamInviteMessage;                         		// 0x0B48 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPSpecopsInviteMsg;                          		// 0x0B4C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPKonradInviteMsg;                           		// 0x0B50 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCPEndMatchMsg;                               		// 0x0B54 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgYourTeamScoreImage;                          		// 0x0B58 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgEnemyTeamScoreImage;                         		// 0x0B5C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matInstYourTeamScore;                           		// 0x0B60 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_sMatInstYourTeamScore;                          		// 0x0B64 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_matInstEnemyTeamScore;                          		// 0x0B70 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_sMatInstEnemyTeamScore;                         		// 0x0B74 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUILabel*                                    m_lblYouScoreDescription;                         		// 0x0B80 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblEnemyScoreDescription;                       		// 0x0B84 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matOfflineStationIcon[ 0x6 ];                   		// 0x0B88 (0x0018) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgOfflineStation[ 0x6 ];                       		// 0x0BA0 (0x0018) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblYouHVT;                                      		// 0x0BB8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblEnemyHVT;                                    		// 0x0BBC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblYouHVTHealth;                                		// 0x0BC0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblEnemyHVTHealth;                              		// 0x0BC4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgBuriedBase[ 0xA ];                           		// 0x0BC8 (0x0028) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matBuriedBase[ 0xA ];                           		// 0x0BF0 (0x0028) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgChopperAttackIcons[ 0xA ];                   		// 0x0C18 (0x0028) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matChopperAttackIcons[ 0xA ];                   		// 0x0C40 (0x0028) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblNumChoppers;                                 		// 0x0C68 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgChopperIcon;                                 		// 0x0C6C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matChopperIcon;                                 		// 0x0C70 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgDeliveryBombMarker;                          		// 0x0C74 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgTeamDeliveryBombMarker;                      		// 0x0C78 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matDeliveryBombMarker;                          		// 0x0C7C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matDeliveryTeamBombMarker;                      		// 0x0C80 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matDeliveryDroppedBombMarker;                   		// 0x0C84 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblYourLootAmount;                              		// 0x0C88 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgYourFirstPickup;                             		// 0x0C8C (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_imgYourSecondPickup;                            		// 0x0C90 (0x0004) [0x0000000000000000]              
	class UUIPanel*                                    m_pnlMinimap;                                     		// 0x0C94 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMinimap;                                     		// 0x0C98 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMinimapOverlay;                              		// 0x0C9C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMinimapCone;                                 		// 0x0CA0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatMinimap;                                     		// 0x0CA4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatMinimapOverlay;                              		// 0x0CA8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatMinimapCone;                                 		// 0x0CAC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMinimapBlips[ 0x1E ];                        		// 0x0CB0 (0x0078) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMinimapPing;                                 		// 0x0D28 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_MatMinimapBlips[ 0x1E ];                        		// 0x0D2C (0x0078) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matMinimapPing;                                 		// 0x0DA4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMinimapStatic;                               		// 0x0DA8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_blipIndexLastFrame;                             		// 0x0DAC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_minimapZoomInPPM;                               		// 0x0DB0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minimapZoomOutPPM;                              		// 0x0DB4 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UTexture*                                    m_minimapBlipTexture;                             		// 0x0DB8 (0x0004) [0x0000000000000000]              
	class UTexture*                                    m_minimapBlipChopperTexture;                      		// 0x0DBC (0x0004) [0x0000000000000000]              
	class UTexture*                                    m_minimapBlipDownTexture;                         		// 0x0DC0 (0x0004) [0x0000000000000000]              
	class UTexture*                                    m_minimapBlipShieldTexture;                       		// 0x0DC4 (0x0004) [0x0000000000000000]              
	class UTexture*                                    m_minimapBlipUpTexture;                           		// 0x0DC8 (0x0004) [0x0000000000000000]              
	class UTexture*                                    m_minimapBlipVPTexture;                           		// 0x0DCC (0x0004) [0x0000000000000000]              
	class UTexture*                                    m_minimapBlipXTexture;                            		// 0x0DD0 (0x0004) [0x0000000000000000]              
	class UTexture*                                    m_minimapBlipCallTexture;                         		// 0x0DD4 (0x0004) [0x0000000000000000]              
	class UTexture*                                    m_minimapBlipBombTexture;                         		// 0x0DD8 (0x0004) [0x0000000000000000]              
	class UTexture*                                    m_minimapBlipDBNOTexture;                         		// 0x0DDC (0x0004) [0x0000000000000000]              
	float                                              m_minimapHeightDifferenceForArrows;               		// 0x0DE0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FLinearColor                                m_teamBaseColor;                                  		// 0x0DE4 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FLinearColor                                m_enemyBaseColor;                                 		// 0x0DF4 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FLinearColor                                m_enemyColor;                                     		// 0x0E04 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FLinearColor                                m_destroyedBaseColor;                             		// 0x0E14 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FLinearColor                                m_neutralBaseColor;                               		// 0x0E24 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FLinearColor                                m_pickupColor;                                    		// 0x0E34 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FLinearColor                                m_chopperColor;                                   		// 0x0E44 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FLinearColor                                m_flashColor;                                     		// 0x0E54 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FLinearColor                                m_flashColor2;                                    		// 0x0E64 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minimapXOffset;                                 		// 0x0E74 (0x0004) [0x0000000000000000]              
	float                                              m_minimapYOffset;                                 		// 0x0E78 (0x0004) [0x0000000000000000]              
	float                                              m_minimapScale;                                   		// 0x0E7C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_matRockIcon;                                    		// 0x0E80 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matOfficerOrderIcon;                            		// 0x0E84 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_matOfficerSupplyDropIcon;                       		// 0x0E88 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_officerPanel;                                   		// 0x0E8C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgReticuleHitIndicator;                        		// 0x0E90 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fXPEventTimeStartFadeOut;                       		// 0x0E94 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fTimeEndMatch;                                  		// 0x0E98 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fTimeEndMatchMessage;                           		// 0x0E9C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fTimeEndCPMessage;                              		// 0x0EA0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fTimeCPMessageFateOut;                          		// 0x0EA4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_RPChangeMessage;                                		// 0x0EA8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2220 ];

		return pClassPointer;
	};

	void AddKillEventMessage ( class AYPlayerReplicationInfo* killerPRI, class AYPlayerReplicationInfo* victimPRI, class UYDeathMessageParams* Params );
	void ToggleMinimapZoom ( );
	void ToggleMinimap ( );
	void AddMessage ( struct FString sMessage, int colorName );
	void OnOverridePlatformChanged ( );
	void SetExperience ( int iXP, int iCollectedXP );
	void SetCPEndMessage ( struct FString sMessage, float fTimeToDisplay, float fTimeFadeOut );
	void SetTeamMessage ( struct FString sMessage, float fTimeToDisplay, float fTimeFadeOut );
	void SetCPKonradPanelVisibility ( unsigned long bVisibility );
	void SetSquadAlivePlayer ( int iNumSpecops, int iNumKonrad );
	void DisplayKillerInfo ( unsigned long bShow );
	void SetKillerWeaponInfos ( unsigned char primary, unsigned char secondary, unsigned char explosive );
	void SetKillerInfos ( struct FString sName, unsigned char eTeam, unsigned char ePerk, int iPerkLevel, unsigned char ePerkMinor1, unsigned char ePerkMinor2, unsigned char ePerkMinor3 );
	void SetSpectatorSkipChoreo ( struct FString sMessage );
	void SetGameMatchMessage ( struct FString sMessage, float fDuration );
	void SetRallyPointTimer ( struct FString sMessage, int iTime );
	void SetGameTimer ( struct FString sMessage, int iTime );
	void SetFollowingPlayer ( struct FString sName );
	void SetSpectatorInfoVisibility ( unsigned long bShowSpectate, unsigned long bShowCameraCycle, unsigned long bShowCharacterRemider );
	void SetGameInfosVisibility ( unsigned long bVisibility );
	bool CharacterInfosIsInitialise ( );
	void SetCPKonradScore ( int iScore, int iPlayerRank, int iPlayersCount, int iClassLevel );
	void SetChallengeBoss ( int iXPAmount, int iXPMax );
	void SetChallengeElite ( struct FString sChallengeLabel, int iXPAmount, int iXPMax );
	void SetXPEvent ( struct FString sEventMessage, int iXPAmount );
	void SetGameInfoObjectif ( struct FString objectif );
	void SetScoreTeam ( int iKonradScore, int iSpecopsScore );
	void SetRankPlayer ( int iRank, int iNbPlayers );
	void SetScorePlayer ( int iScore );
	void SetGameType ( unsigned char GameInfoType );
	void SetScavengerOptionsActive ( unsigned long bArmorPlus, unsigned long bAmmoPlus, unsigned long bExplosivePlus );
	void SetExperienceProgressBar ( int iXP, int iCollectedXP, int iNewXP, int iNewRank, int iNewRankMinXP, int iNewRankMaxXP );
	void SetCharacterName ( struct FString sName );
	void SetMinorPerk ( unsigned char ePerk, int iIndex );
	void SetMajorPerk ( unsigned char ePerk, int iPerkLevel );
	void SetGrenadeCount ( int iGrenadeCount );
	void SetMinimapBackground ( );
};

UClass* UYUIScene_HUD_Life_MP::pClassPointer = NULL;

// Class SRGame.YUIScene_HUD_Life_SP
// 0x0228 (0x0A94 - 0x086C)
class UYUIScene_HUD_Life_SP : public UYUIScene_HUD_Life_Base
{
public:
	unsigned char                                      m_EdArsenalGrenadeSP;                             		// 0x086C (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_lastSquadState;                                 		// 0x086D (0x0001) [0x0000000020000000]              ( CPF_Deprecated )
	unsigned char                                      m_kismetOverrideCommand;                          		// 0x086E (0x0001) [0x0000000020000000]              ( CPF_Deprecated )
	unsigned char                                      m_currentAvailableCommand;                        		// 0x086F (0x0001) [0x0000000020000000]              ( CPF_Deprecated )
	unsigned char                                      m_focusedCtxCommand;                              		// 0x0870 (0x0001) [0x0000000020000000]              ( CPF_Deprecated )
	unsigned char                                      m_lastContextCommandSet;                          		// 0x0871 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_edChapter;                                      		// 0x0872 (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned char                                      m_edContextCommand;                               		// 0x0873 (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UUISafeRegionPanel*                          m_pnlHUD;                                         		// 0x0874 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_plnHUD_Hide;                                    		// 0x0878 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_isDownButNotOut : 1;                            		// 0x087C (0x0004) [0x0000000020000000] [0x00000001] ( CPF_Deprecated )
	unsigned long                                      m_forceCommandRebuild : 1;                        		// 0x087C (0x0004) [0x0000000020000000] [0x00000002] ( CPF_Deprecated )
	unsigned long                                      m_lugoAlive : 1;                                  		// 0x087C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_showingPOI : 1;                                 		// 0x087C (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_forceHideEventTracker : 1;                      		// 0x087C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_isBlinking : 1;                                 		// 0x087C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_forceSquadCommandHUDAlwaysOn : 1;               		// 0x087C (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_hideDNBOWarnings : 1;                           		// 0x087C (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_tutorialActive : 1;                             		// 0x087C (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_HideGameplayUI : 1;                             		// 0x087C (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_markerRestrictedMode : 1;                       		// 0x087C (0x0004) [0x0000000000000000] [0x00000400] 
	struct FLinearColor                                m_squadDownStatus[ 0x4 ];                         		// 0x0880 (0x0040) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FLinearColor                                m_commandColor;                                   		// 0x08C0 (0x0010) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FLinearColor                                m_defaultColor;                                   		// 0x08D0 (0x0010) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FName                                       m_paramNameMainColor;                             		// 0x08E0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_paramNameSquadDown;                             		// 0x08E8 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_paramNameOpacity;                               		// 0x08F0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	TArray< struct FYSquadCmdBlinkFrame >              m_squadCmdBlinkFrames;                            		// 0x08F8 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	float                                              m_squadCmdBlinkTotalTime;                         		// 0x0904 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_squadCmdBlinkCooldown;                          		// 0x0908 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< unsigned char >                            m_excludeFromNofity;                              		// 0x090C (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	float                                              m_squadCmdBlinkTimer;                             		// 0x0918 (0x0004) [0x0000000000000000]              
	float                                              m_squadCmdBlinkCDTimer;                           		// 0x091C (0x0004) [0x0000000000000000]              
	struct FLinearColor                                m_currentBlinkColor;                              		// 0x0920 (0x0010) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_issueCommandSound;                              		// 0x0930 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	class UYSoundCueFMOD*                              m_newCommandSound;                                		// 0x0934 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	class UYSoundCueFMOD*                              m_cantIssueCommandSound;                          		// 0x0938 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	struct FS_MaterialInstanceConstantInfo             m_attackMarkingModeIcon;                          		// 0x093C (0x0094) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	class UUIPanel*                                    m_pnlFrag;                                        		// 0x09D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlStun;                                        		// 0x09D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSticky;                                      		// 0x09D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FLinearColor                                m_selectedColor;                                  		// 0x09DC (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_unselectedColor;                                		// 0x09EC (0x0010) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_chapterDisplayDuration;                         		// 0x09FC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_chapterDisplayFadeTime;                         		// 0x0A00 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_chapterDisplayTime;                             		// 0x0A04 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlChapterDisplay;                              		// 0x0A08 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblChapterName;                                 		// 0x0A0C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblChapterNumber;                               		// 0x0A10 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblEpilogue;                                    		// 0x0A14 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSquad;                                       		// 0x0A18 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSquadAction;                                 		// 0x0A1C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSquadActionTap;                              		// 0x0A20 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSquadButton;                                 		// 0x0A24 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSquadDescription;                            		// 0x0A28 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSquadPortraits;                              		// 0x0A2C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSquadCommandIndicator;                       		// 0x0A30 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_commandIcon;                                    		// 0x0A34 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_squadDNBOWarningPanel;                          		// 0x0A38 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_hideOnTutorialPanel;                            		// 0x0A3C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_secondaryModeIcons[ 0xD ];                      		// 0x0A40 (0x0034) [0x0000000000000002]              ( CPF_Const )
	struct FString                                     m_fireModeBurst;                                  		// 0x0A74 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_fireModeAuto;                                   		// 0x0A80 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	class UUIPanel*                                    m_pnlGameplayHide;                                		// 0x0A8C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYMarkerPanel*                               m_markerPanel;                                    		// 0x0A90 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2221 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	void ClearEventMessages ( );
	void AddRadioSpeakerEventMessage ( int numFound, int numTotal );
	void AddIntelEventMessage ( struct FString intelName, int numFound, int numTotal );
	void AddAchievementEventMessage ( struct FString AchievementName, int numFound, int numTotal );
	void AddObjectiveEventMessage ( struct FString Header, struct FString Objective, unsigned long completed );
	void AddPickupEventMessage ( struct FString Message, struct FString Icon, struct FString msg2 );
	void AddSquadEventMessage ( struct FString squadStatus );
	void AddEventMessage ( struct FString msg );
	class UUILabel* GetCoopLabel_Counter_numbers ( );
	class UUILabel* GetCoopLabel_Counter_title ( );
	class UUILabel* GetCoopLabel_Timer ( );
	class UUILabel* GetCoopLabel__Objective ( );
	class UUIPanel* GetCoopPanel__Hide ( );
	void InitializeCoopWidgets ( );
	bool HasFocusPOICommand ( );
	void HideCoopCounter ( );
	void ShowCoopCounter ( struct FString Message, int value_max, int value_current );
	void HideCoopTimer ( );
	void ShowCoopTimer ( int Value );
	void HideCoopObjective ( );
	void ShowCoopObjective ( struct FString Message, float Duration );
	void UpdateSquadPortrait ( int pwnDown );
	void SetArsenalWeapon ( unsigned char eWeapon );
	void SetCommandMessage ( struct FString sMessage );
	void SetGrenadeCount ( int iGrenadeCount );
	void SetCurrentChapter ( struct FString Title, struct FString chapterNumber, unsigned long isEpilogue );
	void UpdateCommandsNotify ( unsigned char CurrentCommand );
	void UpdateCommandsNotifyBlinkColor ( float DeltaTime );
};

UClass* UYUIScene_HUD_Life_SP::pClassPointer = NULL;

// Class SRGame.YUIScene_IngameCredits
// 0x0080 (0x07E0 - 0x0760)
class UYUIScene_IngameCredits : public UYUIScene_Hud
{
public:
	float                                              m_timeCounter;                                    		// 0x0760 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_displayTime;                                    		// 0x0764 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_panelFadeTime;                                  		// 0x0768 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_totalTime;                                      		// 0x076C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_fadeDirection;                                  		// 0x0770 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UUIScreenObject* >                   m_textPanels;                                     		// 0x0774 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_numberOfPanels;                                 		// 0x0780 (0x0004) [0x0000000000000000]              
	int                                                m_currentPanel;                                   		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FString >                           m_textBlocks;                                     		// 0x0788 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	TArray< struct FString >                           m_prologueTextBlocks;                             		// 0x0794 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_playerTextBlockPrefix;                          		// 0x07A0 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_playerTextBlockSuffix;                          		// 0x07AC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_playerTextBlock;                                		// 0x07B8 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	int                                                m_playerPanelIndex;                               		// 0x07C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_hasPlayerName : 1;                              		// 0x07C8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_isPrologueMode : 1;                             		// 0x07C8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bIsExternalUIOpen : 1;                          		// 0x07C8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	int                                                m_currentDisplayListIndex;                        		// 0x07CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_hidePanel;                                      		// 0x07D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_IngameCreditsDisplay >          m_displayData;                                    		// 0x07D4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2222 ];

		return pClassPointer;
	};

	int GetRandomPanel ( int lastPanel );
	void BuildDisplayList ( );
	void SetNewText ( unsigned long showPlayerName );
	void SwitchPanel ( );
	void UpdateFading ( float DeltaTime );
	void SetPrologue ( );
	void ExternalUIChange ( unsigned long bIsOpening );
	void RemoveExternalUIDelegates ( );
	void AddExternalUIDelegates ( );
	void PostInitialize ( );
	void InitWidgetRef ( );
};

UClass* UYUIScene_IngameCredits::pClassPointer = NULL;

// Class SRGame.YUIScene_MidGameMenu
// 0x005C (0x07BC - 0x0760)
class UYUIScene_MidGameMenu : public UYUIScene_Hud
{
public:
	class UUICalloutButtonPanel*                       m_pnlButtonBar;                                   		// 0x0760 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_MenuList;                                       		// 0x0764 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_SceneOptions;                                   		// 0x0768 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUIPanel*                                    m_objectivesHeaderPanel;                          		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_collectiblesPanel;                              		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_pnlMPModeInstructions;                          		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblModeInstructions;                            		// 0x0780 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblModeName;                                    		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_currentObjective;                               		// 0x0788 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_currentObjectiveItemID;                         		// 0x078C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_currentObjectiveCompleted : 1;                  		// 0x0790 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_slotsAvailable : 1;                             		// 0x0790 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      fixPauseOpeningHack : 1;                          		// 0x0790 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bIsPrologue : 1;                                		// 0x0790 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      stallForLeaderboardSubmission : 1;                		// 0x0790 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	class UUILabel*                                    m_titleLabel;                                     		// 0x0794 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_IntelLabel;                                     		// 0x0798 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_IntelText;                                      		// 0x079C (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_currentObjectiveText;                           		// 0x07A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_ObjectiveCompletedText;                         		// 0x07A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              timeToStall;                                      		// 0x07A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_coopMapImage;                                   		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_coopDiffImage;                                  		// 0x07B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_coopMapHeader;                                  		// 0x07B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_coopMapdescription;                             		// 0x07B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2223 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool IsKeyMappedToCommand ( struct FString Command, class AYPlayerController* playerCtrl, struct FName KeyName );
	void ResumeGame ( );
	bool OnReloadMessageBoxSelection ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	void OpenReloadConfirmationMessageBox ( );
	bool OnQuitMessageBoxSelection ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	void OpenQuitConfirmationMessageBox ( );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	class UUIScene* OpenSceneByName ( struct FString SceneToOpen, unsigned long bSkipAnimation, struct FScriptDelegate SceneDelegate, int ForcedPriority );
	void OnSelectItem ( int PlayerIndex );
	void OnMenu_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void OnMenu_ItemChosen ( class UYSimpleList* SourceList, int SelectedIndex, int PlayerIndex );
	bool OnBackClicked ( class UUIScreenObject* InButton, int InPlayerIndex );
	bool OnSelectClicked ( class UUIScreenObject* InButton, int InPlayerIndex );
	class UYDataProvider_Objectives* GetObjectiveDataProvider ( unsigned char objectiveID );
	bool SetObjective ( class UYDataProvider_Objectives* DP );
	void UpdateObjective ( );
	void InitMenuList ( );
	void UpdateMPModeInstructions ( );
	void SetupDelegate ( );
	void SetupButtonPanel ( );
	void InitWidgetRef ( );
	void InitWidget ( );
	void SceneDeactivated ( );
	void BeginSceneLostFocusAnimation ( );
	void ActivateCollectiblesInfo ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void SetPrologue ( );
	void UpdateCoopDescription ( );
	void UpdateCoopHeader ( );
	class UYUIDataProvider_MapInfo* GetMapProvider ( );
	void UpdateCoopDiffImage ( );
	void UpdateCoopMapImage ( );
	void InitCoopImagesAndLabels ( );
	void PostInitialize ( );
};

UClass* UYUIScene_MidGameMenu::pClassPointer = NULL;

// Class SRGame.YUIScene_Mortar
// 0x0028 (0x0788 - 0x0760)
class UYUIScene_Mortar : public UYUIScene_Hud
{
public:
	class UUIImage*                                    m_ReticleVScale;                                  		// 0x0760 (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_ReticleHScale;                                  		// 0x0764 (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_XHair;                                          		// 0x0768 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_lblReloading;                                   		// 0x076C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_ReticleVScaleMaterialInstance;                  		// 0x0770 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_ReticleHScaleMaterialInstance;                  		// 0x0774 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_XHairMaterialInstance;                          		// 0x0778 (0x0004) [0x0000000000000000]              
	float                                              m_countBlinkIntervall;                            		// 0x077C (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_deltaCountBlinkIntervall;                       		// 0x0780 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_reloading : 1;                                  		// 0x0784 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2224 ];

		return pClassPointer;
	};

	void SetReloadVisibility ( unsigned long IsVisible );
	void InitScene ( );
};

UClass* UYUIScene_Mortar::pClassPointer = NULL;

// Class SRGame.YUIScene_Scope
// 0x00F8 (0x0858 - 0x0760)
class UYUIScene_Scope : public UYUIScene_Hud
{
public:
	float                                              m_rotToDeg;                                       		// 0x0760 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UUIImage*                                    m_layer01;                                        		// 0x0764 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_layer02;                                        		// 0x0768 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_layer03;                                        		// 0x076C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_layer04;                                        		// 0x0770 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_zoomDisplay;                                    		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_SafeRegionPanel;                                		// 0x0778 (0x0004) [0x0000000000000000]              
	float                                              m_layer01Offset[ 0x2 ];                           		// 0x077C (0x0008) [0x0000000000000000]              
	float                                              m_layer02Offset[ 0x2 ];                           		// 0x0784 (0x0008) [0x0000000000000000]              
	float                                              m_layer03Offset[ 0x2 ];                           		// 0x078C (0x0008) [0x0000000000000000]              
	float                                              m_layer04Offset[ 0x2 ];                           		// 0x0794 (0x0008) [0x0000000000000000]              
	struct FVector                                     m_currentOffset[ 0x4 ];                           		// 0x079C (0x0030) [0x0000000000000000]              
	struct FVector                                     m_currentVelocity[ 0x4 ];                         		// 0x07CC (0x0030) [0x0000000000000000]              
	float                                              m_smoothing;                                      		// 0x07FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_layer01MaxOffset;                               		// 0x0800 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_layer02MaxOffset;                               		// 0x0804 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_layer03MaxOffset;                               		// 0x0808 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_layer04MaxOffset;                               		// 0x080C (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FVector2D                                   m_maxRotationVelocity;                            		// 0x0810 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_rotationRate;                                   		// 0x0818 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_rotationOffset;                                 		// 0x0820 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_newRotationOffset;                              		// 0x0828 (0x0008) [0x0000000000000000]              
	struct FRotator                                    m_lastControllerRotation;                         		// 0x0830 (0x000C) [0x0000000000000000]              
	struct FVector2D                                   m_rotationVelocity;                               		// 0x083C (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_rotationDelta;                                  		// 0x0844 (0x0008) [0x0000000000000000]              
	struct FRotator                                    m_layer04Rotation;                                		// 0x084C (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2225 ];

		return pClassPointer;
	};

	void ToggleScope ( unsigned long Enable );
	void InitScene ( );
};

UClass* UYUIScene_Scope::pClassPointer = NULL;

// Class SRGame.YUIScene_TacView
// 0x0034 (0x0794 - 0x0760)
class UYUIScene_TacView : public UYUIScene_Hud
{
public:
	class UUISafeRegionPanel*                          m_sceneBackground;                                		// 0x0760 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_numGridCells;                                   		// 0x0764 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_gridStart;                                      		// 0x076C (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_gridCellSize;                                   		// 0x0774 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_gridTextureSize;                                		// 0x077C (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_gridMaterialInst;                               		// 0x0784 (0x0004) [0x0000000000000000]              
	struct FName                                       m_tilingParamName;                                		// 0x0788 (0x0008) [0x0000000000000000]              
	unsigned long                                      m_useCellSize : 1;                                		// 0x0790 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2226 ];

		return pClassPointer;
	};

	void InitScene ( );
	void PostInitialize ( );
};

UClass* UYUIScene_TacView::pClassPointer = NULL;

// Class SRGame.YUIScene_UIMessage
// 0x004C (0x07AC - 0x0760)
class UYUIScene_UIMessage : public UYUIScene_Hud
{
public:
	struct FString                                     m_message;                                        		// 0x0760 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_headline;                                       		// 0x076C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_duration;                                       		// 0x0778 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_label;                                          		// 0x077C (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_labelShadow;                                    		// 0x0780 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_lblHeadline;                                    		// 0x0784 (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_background;                                     		// 0x0788 (0x0004) [0x0000000000000000]              
	class UUISafeRegionPanel*                          m_parent;                                         		// 0x078C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_overrideSceneLayout : 1;                        		// 0x0790 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_ImageLeft;                                      		// 0x0794 (0x0004) [0x0000000000000000]              
	float                                              m_ImageRight;                                     		// 0x0798 (0x0004) [0x0000000000000000]              
	float                                              m_textLeft;                                       		// 0x079C (0x0004) [0x0000000000000000]              
	float                                              m_textRight;                                      		// 0x07A0 (0x0004) [0x0000000000000000]              
	float                                              m_textUp;                                         		// 0x07A4 (0x0004) [0x0000000000000000]              
	float                                              m_textDown;                                       		// 0x07A8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2227 ];

		return pClassPointer;
	};

	void SetHUDTutorialMode ( unsigned long IsActive );
	bool CloseScene ( class UUIScene* SceneToClose, unsigned long bCloseChildScenes, unsigned long bForceCloseImmediately );
	void AutoCloseScene ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void CloseOtherUIMessageScene ( );
	void SetMessage ( struct FString msg, struct FString headline, float Duration );
};

UClass* UYUIScene_UIMessage::pClassPointer = NULL;

// Class SRGame.YUIScene_ButtonTutorial
// 0x006C (0x0818 - 0x07AC)
class UYUIScene_ButtonTutorial : public UYUIScene_UIMessage
{
public:
	struct FName                                       m_aliasMapDSName;                                 		// 0x07AC (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_keyBindDSName;                                  		// 0x07B4 (0x0008) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_inputScheme;                                    		// 0x07BC (0x0001) [0x0000000000000000]              
	unsigned char                                      m_platform;                                       		// 0x07BD (0x0001) [0x0000000000000000]              
	class UYUIDataStore_PCKeys*                        m_pcKeyDS;                                        		// 0x07C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_TutorialButtons                         m_inputPerPlatform[ 0x3 ];                        		// 0x07C4 (0x0048) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_waitForRelease : 1;                             		// 0x080C (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_waitForHold : 1;                                		// 0x080C (0x0004) [0x0000000000000003] [0x00000002] ( CPF_Edit | CPF_Const )
	unsigned long                                      m_swallowInput : 1;                               		// 0x080C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	int                                                m_numRepeats;                                     		// 0x0810 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_repeats;                                        		// 0x0814 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2228 ];

		return pClassPointer;
	};

	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void DoCloseScene ( );
	void DoOpenScene ( );
	bool CheckForPCBoundStartGameKey ( struct FString inputToCheck );
	bool ShouldClose ( struct FString inputToCheck );
};

UClass* UYUIScene_ButtonTutorial::pClassPointer = NULL;

// Class SRGame.YUIScene_Weapon
// 0x0088 (0x07E8 - 0x0760)
class UYUIScene_Weapon : public UYUIScene_Hud
{
public:
	class UUIImage*                                    m_backgroundPanel;                                		// 0x0760 (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_weaponIcon;                                     		// 0x0764 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_wpnIcon;                                        		// 0x0768 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_ammoCount;                                      		// 0x076C (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_clipsCount;                                     		// 0x0770 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_currentgrenadeCount;                            		// 0x0774 (0x0004) [0x0000000000000000]              
	struct FYS_GrenadeDisplay                          m_grenades[ 0x7 ];                                		// 0x0778 (0x0038) [0x0000000000000000]              
	class AYWeapon*                                    m_currentWeapon;                                  		// 0x07B0 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_currentGrenadeType;                             		// 0x07B4 (0x0001) [0x0000000000000000]              
	TArray< unsigned char >                            m_availableGrenadeTypes;                          		// 0x07B8 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	int                                                m_numGrenades;                                    		// 0x07C4 (0x0004) [0x0000000000000000]              
	int                                                m_numClips;                                       		// 0x07C8 (0x0004) [0x0000000000000000]              
	int                                                m_numBullets;                                     		// 0x07CC (0x0004) [0x0000000000000000]              
	float                                              m_countBlinkIntervall;                            		// 0x07D0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_deltaCountBlinkIntervall;                       		// 0x07D4 (0x0004) [0x0000000000000000]              
	float                                              m_grenadeIconActiveOffset;                        		// 0x07D8 (0x0004) [0x0000000000000000]              
	TArray< struct FTextureCoordinates >               m_grenadeIcons;                                   		// 0x07DC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2229 ];

		return pClassPointer;
	};

	void InitScene ( );
};

UClass* UYUIScene_Weapon::pClassPointer = NULL;

// Class SRGame.YUIScene_Mockup
// 0x0008 (0x074C - 0x0744)
class UYUIScene_Mockup : public UYUIScenes
{
public:
	class AYPlayerController*                          m_ctrl;                                           		// 0x0744 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_transMIC;                                       		// 0x0748 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2230 ];

		return pClassPointer;
	};

	void InitScene ( );
	void NotifyGameSessionEnded ( );
	void PostInitialize ( );
};

UClass* UYUIScene_Mockup::pClassPointer = NULL;

// Class SRGame.YUIScrollingTextPanel
// 0x001C (0x0498 - 0x047C)
class UYUIScrollingTextPanel : public UUIPanel
{
public:
	struct FPointer                                    VfTable_IUITickableObject;                        		// 0x047C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class UUILabel*                                    m_scrollingTextLabel;                             		// 0x0480 (0x0004) [0x0000000000000000]              
	float                                              m_offset;                                         		// 0x0484 (0x0004) [0x0000000000000000]              
	float                                              m_scrollSpeed;                                    		// 0x0488 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bIsMessageOfTheDayLavel : 1;                    		// 0x048C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class UOnlineNewsInterface*                        NewsInterface;                                    		// 0x0490 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x0494 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2231 ];

		return pClassPointer;
	};

	void RemovedFromParent ( class UUIScreenObject* WidgetOwner );
	void OnReadGameNewsCompleted ( unsigned long bWasSuccessful, unsigned char NewsType );
	void ReadNews ( );
	void PostInitialize ( );
};

UClass* UYUIScrollingTextPanel::pClassPointer = NULL;

// Class SRGame.YUIScrollLabel
// 0x0010 (0x04C0 - 0x04B0)
class UYUIScrollLabel : public UUILabel
{
public:
	struct FPointer                                    VfTable_IUITickableObject;                        		// 0x04B0 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	float                                              m_scrollSpeed;                                    		// 0x04B4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_ScrollCounter;                                  		// 0x04B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_fOffset;                                        		// 0x04BC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2232 ];

		return pClassPointer;
	};

	void RefreshStringComponent ( );
	bool HandleRefreshSubscriberValue ( class UUIObject* Sender, int BindingIndex );
	void PostInitialize ( );
};

UClass* UYUIScrollLabel::pClassPointer = NULL;

// Class SRGame.YActorFactorySceneCapture
// 0x0024 (0x0080 - 0x005C)
class UYActorFactorySceneCapture : public UActorFactory
{
public:
	int                                                m_resolutionX;                                    		// 0x005C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_resolutionY;                                    		// 0x0060 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_FOV;                                            		// 0x0064 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_enablePostProcess : 1;                          		// 0x0068 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_enableFog : 1;                                  		// 0x0068 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	struct FColor                                      m_clearColor;                                     		// 0x006C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_viewMode;                                       		// 0x0070 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_sceneLOD;                                       		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_frameRate;                                      		// 0x0078 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UPostProcessChain*                           m_postProcessChain;                               		// 0x007C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2233 ];

		return pClassPointer;
	};

};

UClass* UYActorFactorySceneCapture::pClassPointer = NULL;

// Class SRGame.YSeqAct_ActivateReplicatedEvent
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_ActivateReplicatedEvent : public USequenceAction
{
public:
	struct FName                                       EventName;                                        		// 0x00F4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bStatusIsOk : 1;                                  		// 0x00FC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2234 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ActivateReplicatedEvent::pClassPointer = NULL;

// Class SRGame.YSeqAct_AddStrings
// 0x0024 (0x0118 - 0x00F4)
class UYSeqAct_AddStrings : public USeqAct_SetSequenceVariable
{
public:
	struct FString                                     ValueA;                                           		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     ValueB;                                           		// 0x0100 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     StringResult;                                     		// 0x010C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2235 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_AddStrings::pClassPointer = NULL;

// Class SRGame.YSeqAct_AIFactory
// 0x0158 (0x024C - 0x00F4)
class UYSeqAct_AIFactory : public USequenceAction
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                     		// 0x00F4 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	float                                              m_AmmoDropMultiplier;                             		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FAISpawnInfo >                      SpawnSets;                                        		// 0x00FC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAITypeInfo >                       SpawnInfo;                                        		// 0x0108 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FAISpawnInfo >                      PresetSpawnSets;                                  		// 0x0114 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	TArray< class AActor* >                            SpawnPoints;                                      		// 0x0120 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      bAllSpawned : 1;                                  		// 0x012C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      bAllDead : 1;                                     		// 0x012C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      bFirstDead : 1;                                   		// 0x012C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      bFirstBotHit : 1;                                 		// 0x012C (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      bActivatedDeadLink : 1;                           		// 0x012C (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_aborted : 1;                                    		// 0x012C (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      bUseDamageForKillAll : 1;                         		// 0x012C (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	int                                                DeadCount;                                        		// 0x0130 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_dbnoCount;                                      		// 0x0134 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                ActivateDeadLinkCount;                            		// 0x0138 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       SquadName;                                        		// 0x013C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class AYAISquad*                                   m_squad;                                          		// 0x0144 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_squadDesc;                                      		// 0x0148 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                iNextSetToSpawn;                                  		// 0x0154 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_CharacterBoneAttachmentInfo             m_characterAttachmentsInfos[ 0x6 ];               		// 0x0158 (0x00D8) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_currentSpawnMesh;                               		// 0x0230 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_deadOutputsToFire;                              		// 0x0234 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_standardSpecialActionSetListPackageName;        		// 0x0238 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_RandomSpecialActionSetListInfo > m_randomSASLists;                                 		// 0x0240 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2236 ];

		return pClassPointer;
	};

	void VersionUpdated ( int OldVersion, int NewVersion );
	int GetObjClassVersion ( );
	class UYSpecialActionSetList* GetRandomSpecialActionSetList ( struct FString idString );
	bool CanSpawnAtLocation ( struct FVector ChkExtent, class AActor* SpawnPointActor, struct FVector* chkLocation );
};

UClass* UYSeqAct_AIFactory::pClassPointer = NULL;

// Class SRGame.YSeqAct_AutoTestInit
// 0x001C (0x0110 - 0x00F4)
class UYSeqAct_AutoTestInit : public USequenceAction
{
public:
	struct FString                                     m_initialDebugJumpPoint;                          		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bYAutoTestActive : 1;                           		// 0x0100 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FString                                     m_nextCheckPoint;                                 		// 0x0104 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2237 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
	void JumpToNextCheckpoint ( );
};

UClass* UYSeqAct_AutoTestInit::pClassPointer = NULL;

// Class SRGame.YSeqAct_AutoTestNext
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_AutoTestNext : public USequenceAction
{
public:
	struct FString                                     m_nextDebugJumpPoint;                             		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bYAutoTestActive : 1;                           		// 0x0100 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2238 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
	void RestartLevel ( );
};

UClass* UYSeqAct_AutoTestNext::pClassPointer = NULL;

// Class SRGame.YSeqAct_CamLookAt
// 0x0088 (0x017C - 0x00F4)
class UYSeqAct_CamLookAt : public USequenceAction
{
public:
	struct FYS_FocusPoint                              m_focusPoint;                                     		// 0x00F4 (0x0078) [0x0000000000080001]              ( CPF_Edit | CPF_Component )
	float                                              m_lookAtTime;                                     		// 0x016C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_updateControllerRot : 1;                        		// 0x0170 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_isLookingAt : 1;                                		// 0x0170 (0x0004) [0x0000000000000000] [0x00000002] 
	class AActor*                                      m_lookAtTarget;                                   		// 0x0174 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_startTime;                                      		// 0x0178 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2239 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_CamLookAt::pClassPointer = NULL;

// Class SRGame.YSeqAct_CastShadow
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_CastShadow : public USequenceAction
{
public:
	unsigned long                                      bEnableShadow : 1;                                		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2240 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_CastShadow::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheapShooter_CleanUpAllSpawned
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_CheapShooter_CleanUpAllSpawned : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2241 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_CheapShooter_CleanUpAllSpawned::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheapShooter_CustomAnim
// 0x0028 (0x011C - 0x00F4)
class UYSeqAct_CheapShooter_CustomAnim : public USequenceAction
{
public:
	class UAnimSet*                                    m_customAnim_AnimSet;                             		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_customAnim_Sequence;                            		// 0x00F8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_looping : 1;                                    		// 0x0100 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_useStartAndEndRotations : 1;                    		// 0x0100 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_animFinished : 1;                               		// 0x0100 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_blendToIdleWhenFinished : 1;                    		// 0x0100 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	float                                              m_blendInTime;                                    		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_blendOutTime;                                   		// 0x0108 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_startRotation;                                  		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_endRotation;                                    		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_animLength;                                     		// 0x0114 (0x0004) [0x0000000000000000]              
	class UObject*                                     m_cheapShooter;                                   		// 0x0118 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2242 ];

		return pClassPointer;
	};

	void CheapShooter_CustomAnimFinished ( );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_CheapShooter_CustomAnim::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheapShooter_KillWithSpecialAnim
// 0x0014 (0x0108 - 0x00F4)
class UYSeqAct_CheapShooter_KillWithSpecialAnim : public USequenceAction
{
public:
	class UAnimSet*                                    m_customAnim_AnimSet;                             		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_customAnim_Sequence;                            		// 0x00F8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_dropWeaponBeforeAnimation : 1;                  		// 0x0100 (0x0004) [0x0000000020000000] [0x00000001] ( CPF_Deprecated )
	unsigned long                                      m_animFinished : 1;                               		// 0x0100 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	class UObject*                                     m_cheapShooter;                                   		// 0x0104 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2243 ];

		return pClassPointer;
	};

	void CheapShooter_CustomAnimFinished ( );
};

UClass* UYSeqAct_CheapShooter_KillWithSpecialAnim::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheapShooter_MoveToSplineNode
// 0x000D (0x0101 - 0x00F4)
class UYSeqAct_CheapShooter_MoveToSplineNode : public USequenceAction
{
public:
	class UObject*                                     m_moveToSplineNode;                               		// 0x00F4 (0x0004) [0x0000000000000000]              
	class UObject*                                     m_cheapShooter;                                   		// 0x00F8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_nodeReached : 1;                                		// 0x00FC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      m_moveSpeed;                                      		// 0x0100 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2244 ];

		return pClassPointer;
	};

	void CheapShooter_ReachedNode ( );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_CheapShooter_MoveToSplineNode::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheapShooter_ShootAt
// 0x0020 (0x0114 - 0x00F4)
class UYSeqAct_CheapShooter_ShootAt : public USequenceAction
{
public:
	class UObject*                                     m_shootAt;                                        		// 0x00F4 (0x0004) [0x0000000000000000]              
	TArray< class UObject* >                           m_cheapshooters;                                  		// 0x00F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_aimingTimeBeforeShooting;                       		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_kismetInaccuracy;                               		// 0x0108 (0x0004) [0x0000000020000000]              ( CPF_Deprecated )
	float                                              m_accuracyMultiplier;                             		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_aimOnly : 1;                                    		// 0x0110 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_ignoreDifficultyTuning : 1;                     		// 0x0110 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_damageAll : 1;                                  		// 0x0110 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_noAimShootAhead : 1;                            		// 0x0110 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2245 ];

		return pClassPointer;
	};

	void CreateAccuracyList ( );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_CheapShooter_ShootAt::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheapShooter_Spawn
// 0x0058 (0x014C - 0x00F4)
class UYSeqAct_CheapShooter_Spawn : public USequenceAction
{
public:
	unsigned long                                      m_cleanedUp : 1;                                  		// 0x00F4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_isCheapShooterAlive : 1;                        		// 0x00F4 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_cheapShooterRecentlyKilled : 1;                 		// 0x00F4 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_triggerOutputEvent : 1;                         		// 0x00F4 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_dropWeaponOnceDead : 1;                         		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	class UObject*                                     m_spawnSplineActor;                               		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UObject*                                     m_replaceAI;                                      		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UObject*                                     m_linkedKismetObject;                             		// 0x0100 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYCheapShooter*                              m_cheapShooter;                                   		// 0x0104 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_CheapShooter_EnemyTypeData >    m_enemyTypeData;                                  		// 0x0108 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	class UClass*                                      m_weapon;                                         		// 0x0114 (0x0004) [0x0000000000000000]              
	class UYBT_ShootSet*                               m_shootSet;                                       		// 0x0118 (0x0004) [0x0000000000000000]              
	class USkeletalMesh*                               m_skeletalMesh;                                   		// 0x011C (0x0004) [0x0000000000000000]              
	class UPhysicsAsset*                               m_physicsAsset;                                   		// 0x0120 (0x0004) [0x0000000000000000]              
	class UAnimTree*                                   m_animtree;                                       		// 0x0124 (0x0004) [0x0000000000000000]              
	TArray< class UAnimSet* >                          m_animSets;                                       		// 0x0128 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_attackCommandGiveEvent;                         		// 0x0134 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_enemyType;                                      		// 0x0135 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_health;                                         		// 0x0138 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UAnimSet* >                          m_additionalAnimSets;                             		// 0x013C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UYBT_ShootSet*                               m_shootSetOverride;                               		// 0x0148 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2246 ];

		return pClassPointer;
	};

	float GetHealthValueFromPawn ( );
	class UClass* GetDefaultClassFromEnemyType ( );
	void CheapShooterGotKilled ( unsigned long _triggerOutputEvent );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_CheapShooter_Spawn::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheapShooter_TakeCover
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_CheapShooter_TakeCover : public USequenceAction
{
public:
	class UObject*                                     m_cheapShooter;                                   		// 0x00F4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_cheapshooterIsInCoverNow : 1;                   		// 0x00F8 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2247 ];

		return pClassPointer;
	};

	void IsNowReadyToShootOrMove ( );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_CheapShooter_TakeCover::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheckActorVisibility
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_CheckActorVisibility : public USequenceAction
{
public:
	unsigned long                                      bChecksVisibility : 1;                            		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bWasVisibleAtLastCheck : 1;                       		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      bIsFirstTest : 1;                                 		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2248 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_CheckActorVisibility::pClassPointer = NULL;

// Class SRGame.YSeqAct_CivilianDamageAllowed
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_CivilianDamageAllowed : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2249 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_CivilianDamageAllowed::pClassPointer = NULL;

// Class SRGame.YSeqAct_ComposeObjectList
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ComposeObjectList : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2250 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ComposeObjectList::pClassPointer = NULL;

// Class SRGame.YSeqAct_DummyWeaponFire
// 0x0070 (0x0174 - 0x0104)
class UYSeqAct_DummyWeaponFire : public USeqAct_Latent
{
public:
	int                                                m_shotsToFire;                                    		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_shootUntilStopped : 1;                          		// 0x0108 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_hideWeaponMesh : 1;                             		// 0x0108 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_stopped : 1;                                    		// 0x0108 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_finished : 1;                                   		// 0x0108 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_suppressMuzzleFlash : 1;                        		// 0x0108 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_suppressTracers : 1;                            		// 0x0108 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_suppressImpactFX : 1;                           		// 0x0108 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_suppressMuzzleAudio : 1;                        		// 0x0108 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_suppressDamage : 1;                             		// 0x0108 (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      m_firing : 1;                                     		// 0x0108 (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_alignOriginInsteadOfMuzzle : 1;                 		// 0x0108 (0x0004) [0x0000000000000001] [0x00000400] ( CPF_Edit )
	unsigned long                                      m_hardAttachMeshToSocket : 1;                     		// 0x0108 (0x0004) [0x0000000000000001] [0x00000800] ( CPF_Edit )
	float                                              m_inaccuracyDegrees;                              		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_weaponClass;                                    		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYWeaponDataDispatcher*                      m_dataDispatcher;                                 		// 0x0114 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	class AYWeapon*                                    m_spawnedWeapon;                                  		// 0x0118 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_remainingFireTime;                              		// 0x011C (0x0004) [0x0000000000000000]              
	int                                                m_shotsFired;                                     		// 0x0120 (0x0004) [0x0000000000000000]              
	struct FName                                       m_originSocketName;                               		// 0x0124 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_DummyFireObjectListParams               m_multipleTargetParams;                           		// 0x012C (0x0024) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_DummyFireObjectListParams               m_multipleOriginParams;                           		// 0x0150 (0x0024) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2251 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	struct FVector GetCurrentTargetLoc ( );
	void AlignWeaponMuzzleToActor ( class AActor* AlignTo, class AActor* AimAt );
	void SpawnDummyWeapon ( class AActor* OriginActor, class AActor* TargetActor );
};

UClass* UYSeqAct_DummyWeaponFire::pClassPointer = NULL;

// Class SRGame.YSeqAct_EnablePlayerDBNO
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_EnablePlayerDBNO : public USequenceAction
{
public:
	unsigned long                                      m_enableDBNO : 1;                                 		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2252 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_EnablePlayerDBNO::pClassPointer = NULL;

// Class SRGame.YSeqAct_EnableSkipInput
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_EnableSkipInput : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2253 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_EnableSkipInput::pClassPointer = NULL;

// Class SRGame.YSeqAct_EnableSkipMessage
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_EnableSkipMessage : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2254 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_EnableSkipMessage::pClassPointer = NULL;

// Class SRGame.YSeqAct_EnableSkipPending
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_EnableSkipPending : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2255 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_EnableSkipPending::pClassPointer = NULL;

// Class SRGame.YSeqAct_FadeMusicVolume
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_FadeMusicVolume : public USequenceAction
{
public:
	float                                              m_fadeTime;                                       		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_targetVolume;                                   		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2256 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_FadeMusicVolume::pClassPointer = NULL;

// Class SRGame.YSeqAct_FindActor
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_FindActor : public USequenceAction
{
public:
	struct FString                                     m_actorName;                                      		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2257 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_FindActor::pClassPointer = NULL;

// Class SRGame.YSeqAct_FullscreenMoviePlayer
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_FullscreenMoviePlayer : public USequenceAction
{
public:
	struct FString                                     m_Filename;                                       		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_WaitForMovie : 1;                               		// 0x0100 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_suppressEngineSoundsDuringPlayback : 1;         		// 0x0100 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_suppressMusicPlayback : 1;                      		// 0x0100 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2258 ];

		return pClassPointer;
	};

	bool IsValidUISequenceObject ( class UUIScreenObject* TargetObject );
};

UClass* UYSeqAct_FullscreenMoviePlayer::pClassPointer = NULL;

// Class SRGame.YSeqAct_GameCrowdSpawner
// 0x0004 (0x0160 - 0x015C)
class UYSeqAct_GameCrowdSpawner : public USeqAct_GameCrowdSpawner
{
public:
	unsigned long                                      bOnlyOneSpawnPerFrame : 1;                        		// 0x015C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bCivilianCrowdAgents : 1;                         		// 0x015C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bCrowdAgentsDamageDisabled : 1;                   		// 0x015C (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2259 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_GameCrowdSpawner::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetDemoBuildState
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_GetDemoBuildState : public USequenceAction
{
public:
	unsigned long                                      m_isPressDemoBuild : 1;                           		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_isIntelDemoBuild : 1;                           		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_isPressDemo_2Build : 1;                         		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_isPublicDemoBuild : 1;                          		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000008] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2260 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_GetDemoBuildState::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetFromList
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_GetFromList : public USequenceAction
{
public:
	unsigned long                                      WrapIndex : 1;                                    		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                Index;                                            		// 0x00F8 (0x0004) [0x0000000000000000]              
	class UObject*                                     Value;                                            		// 0x00FC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2261 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_GetFromList::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetGoreState
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_GetGoreState : public USequenceAction
{
public:
	unsigned long                                      m_civilianDamage : 1;                             		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_explodingHeads : 1;                             		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_toughExecutions : 1;                            		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_vaporizeEnemies : 1;                            		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000008] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2262 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_GetGoreState::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetObjectCount
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_GetObjectCount : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2263 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_GetObjectCount::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetPersistentDataBOOL
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_GetPersistentDataBOOL : public USequenceAction
{
public:
	struct FString                                     keySTR;                                           		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      Value : 1;                                        		// 0x0100 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2264 ];

		return pClassPointer;
	};

	bool IsValidUISequenceObject ( class UUIScreenObject* TargetObject );
};

UClass* UYSeqAct_GetPersistentDataBOOL::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetPersistentDataINT
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_GetPersistentDataINT : public USequenceAction
{
public:
	struct FString                                     keySTR;                                           		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                Value;                                            		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2265 ];

		return pClassPointer;
	};

	bool IsValidUISequenceObject ( class UUIScreenObject* TargetObject );
};

UClass* UYSeqAct_GetPersistentDataINT::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetSquadMemberByIdx
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_GetSquadMemberByIdx : public USequenceAction
{
public:
	int                                                m_index;                                          		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UObject*                                     m_squadMember;                                    		// 0x00F8 (0x0004) [0x0000000000000000]              
	class UObject*                                     m_squad;                                          		// 0x00FC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2266 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_GetSquadMemberByIdx::pClassPointer = NULL;

// Class SRGame.YSeqAct_Interp
// 0x0001 (0x01B9 - 0x01B8)
class UYSeqAct_Interp : public USeqAct_Interp
{
public:
	unsigned char                                      m_teamID;                                         		// 0x01B8 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2267 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_Interp::pClassPointer = NULL;

// Class SRGame.YSeqAct_LatentBase
// 0x0000 (0x0104 - 0x0104)
class UYSeqAct_LatentBase : public USeqAct_Latent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2268 ];

		return pClassPointer;
	};

	class AActor* GetObjectVarActor ( struct FString VarName );
	void OnInputImpulse ( int inputLinkIndex );
};

UClass* UYSeqAct_LatentBase::pClassPointer = NULL;

// Class SRGame.YSeqAct_IntelOp
// 0x0001 (0x0105 - 0x0104)
class UYSeqAct_IntelOp : public UYSeqAct_LatentBase
{
public:
	unsigned char                                      m_intelOpState;                                   		// 0x0104 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2269 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void OnFailed ( );
	void OnSucceeded ( );
	void OnStartFailed ( );
	void OnStarted ( );
	bool isStarted ( );
	void OnInputImpulse ( int inputLinkIndex );
};

UClass* UYSeqAct_IntelOp::pClassPointer = NULL;

// Class SRGame.YSeqAct_Latent
// 0x0001 (0x0105 - 0x0104)
class UYSeqAct_Latent : public UYSeqAct_LatentBase
{
public:
	unsigned char                                      m_latentActionState;                              		// 0x0104 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2270 ];

		return pClassPointer;
	};

	void OnFailed ( );
	void OnSucceeded ( );
	void OnStartFailed ( );
	void OnStarted ( );
	bool isStarted ( );
};

UClass* UYSeqAct_Latent::pClassPointer = NULL;

// Class SRGame.YSeqAct_CustomAnimationBase
// 0x0027 (0x012C - 0x0105)
class UYSeqAct_CustomAnimationBase : public UYSeqAct_Latent
{
public:
	struct FPointer                                    VfTable_IYICustomAnimationCallbackHandler;        		// 0x0108 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FName                                       m_animName;                                       		// 0x010C (0x0008) [0x0000000000000002]              ( CPF_Const )
	class UAnimSet*                                    m_animSet;                                        		// 0x0114 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UYCustomAnimationBase*                       m_customAnimation;                                		// 0x0118 (0x0004) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	TArray< struct FName >                             m_outputAnimNotifyNames;                          		// 0x011C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_aiDoNotReactToEnemyContact : 1;                 		// 0x0128 (0x0004) [0x0000000020000000] [0x00000001] ( CPF_Deprecated )
	unsigned long                                      m_aiAbortOnEnemySeenOrHeard : 1;                  		// 0x0128 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_aiAbortOnReactionToGrenadeOrStun : 1;           		// 0x0128 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_aiDoNotThrowGrenades : 1;                       		// 0x0128 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_aiPreviousAbortOnEnemySeenOrHeard : 1;          		// 0x0128 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_aiPreviousAbortOnReactionToGrenadeOrStun : 1;   		// 0x0128 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_aiPreviousGenericGrenadeUsage : 1;              		// 0x0128 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2271 ];

		return pClassPointer;
	};

	void StopAnimation ( );
	void OnEnded ( );
	void OnInitializeCustomAnimation ( );
	void OnStartFailedCustomAnimation ( );
	void OnFailedCustomAnimation ( );
	void OnSucceededCustomAnimation ( );
	void OnStartedCustomAnimation ( );
	void OnKismetAnimNotify ( class UYAnimNotify_Kismet* AnimNotify );
};

UClass* UYSeqAct_CustomAnimationBase::pClassPointer = NULL;

// Class SRGame.YSeqAct_CustomAnimation
// 0x0000 (0x012C - 0x012C)
class UYSeqAct_CustomAnimation : public UYSeqAct_CustomAnimationBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2272 ];

		return pClassPointer;
	};

	void OnEnded ( );
	void OnStarted ( );
	void StopAnimation ( );
	int GetObjClassVersion ( );
	class AActor* GetLookAtActor ( );
	class AActor* GetOrientToActor ( );
	class AActor* GetAlignToActor ( );
	void OnInputImpulse ( int inputLinkIndex );
};

UClass* UYSeqAct_CustomAnimation::pClassPointer = NULL;

// Class SRGame.YSeqAct_LevelStreaming
// 0x0000 (0x0118 - 0x0118)
class UYSeqAct_LevelStreaming : public USeqAct_LevelStreaming
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2273 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_LevelStreaming::pClassPointer = NULL;

// Class SRGame.YSeqAct_ModifyArsenal
// 0x0018 (0x010C - 0x00F4)
class UYSeqAct_ModifyArsenal : public USequenceAction
{
public:
	TArray< struct FYS_ModifyArsenal >                 m_weapons;                                        		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_weaponEnums;                                    		// 0x0100 (0x000C) [0x0000000020400000]              ( CPF_NeedCtorLink | CPF_Deprecated )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2274 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
	bool IsWeaponAllowed ( class AYGamePawn* Pawn, struct FYS_ModifyArsenal Weapon );
};

UClass* UYSeqAct_ModifyArsenal::pClassPointer = NULL;

// Class SRGame.YSeqAct_ModObjList
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_ModObjList : public USequenceAction
{
public:
	int                                                ListEntriesCount;                                 		// 0x00F4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_useLIFO : 1;                                    		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2275 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ModObjList::pClassPointer = NULL;

// Class SRGame.YSeqAct_MPSandstormStarter
// 0x0020 (0x0114 - 0x00F4)
class UYSeqAct_MPSandstormStarter : public USequenceAction
{
public:
	float                                              InitialDelay_Max;                                 		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              InitialDelay_Min;                                 		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              PauseDelay_Max;                                   		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              PauseDelay_Min;                                   		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      AutoFitSandstormsToGameLength : 1;                		// 0x0104 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bWaitToBeginSandstorm : 1;                      		// 0x0104 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	TArray< float >                                    Delays;                                           		// 0x0108 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2276 ];

		return pClassPointer;
	};

	void ActivateBeginSandstormNub ( );
	void Activated ( );
};

UClass* UYSeqAct_MPSandstormStarter::pClassPointer = NULL;

// Class SRGame.YSeqAct_MultiLevelStreaming
// 0x0000 (0x0118 - 0x0118)
class UYSeqAct_MultiLevelStreaming : public USeqAct_MultiLevelStreaming
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2277 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_MultiLevelStreaming::pClassPointer = NULL;

// Class SRGame.YSeqAct_NOP
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_NOP : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2278 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_NOP::pClassPointer = NULL;

// Class SRGame.YSeqAct_NotifyExplosion
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_NotifyExplosion : public USequenceAction
{
public:
	class UObject*                                     m_spawnLocationObject;                            		// 0x00F4 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_grenadeType;                                    		// 0x00F8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_timeLeft;                                       		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2279 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_NotifyExplosion::pClassPointer = NULL;

// Class SRGame.YSeqAct_ObjListIterator
// 0x0014 (0x0108 - 0x00F4)
class UYSeqAct_ObjListIterator : public USequenceAction
{
public:
	TArray< class UObject* >                           m_objList;                                        		// 0x00F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UObject*                                     m_nextObject;                                     		// 0x0100 (0x0004) [0x0000000000000000]              
	int                                                m_currentIndex;                                   		// 0x0104 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2280 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ObjListIterator::pClassPointer = NULL;

// Class SRGame.YSeqAct_OverrideDuckingSettings
// 0x0038 (0x012C - 0x00F4)
class UYSeqAct_OverrideDuckingSettings : public USequenceAction
{
public:
	struct FDuckingSettings                            m_settings;                                       		// 0x00F4 (0x0034) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_interpolationTime;                              		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2281 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_OverrideDuckingSettings::pClassPointer = NULL;

// Class SRGame.YSeqAct_OverrideGenericSitRep
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_OverrideGenericSitRep : public USequenceAction
{
public:
	int                                                m_voiceOverUID;                                   		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AYGamePawn*                                  m_speaker;                                        		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_allowFilters : 1;                               		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_playbackVolume;                                 		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2282 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_OverrideGenericSitRep::pClassPointer = NULL;

// Class SRGame.YSeqAct_OverrideListenerLocation
// 0x0018 (0x010C - 0x00F4)
class UYSeqAct_OverrideListenerLocation : public USequenceAction
{
public:
	class AActor*                                      m_listenerTarget;                                 		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_allowDoppler : 1;                               		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FListenerTransitionParams                   m_transitionParams;                               		// 0x00FC (0x0010) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2283 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_OverrideListenerLocation::pClassPointer = NULL;

// Class SRGame.YSeqAct_PlayCamShake
// 0x0034 (0x0128 - 0x00F4)
class UYSeqAct_PlayCamShake : public USequenceAction
{
public:
	TArray< class UCameraAnim* >                       m_cameraAnims;                                    		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UCameraAnimInst* >                   m_cameraAnimInstances;                            		// 0x0100 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_blendInTime;                                    		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_blendOutTime;                                   		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_rate;                                           		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_scale;                                          		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_looped : 1;                                     		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_randomStartTime : 1;                            		// 0x011C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_isPlaying : 1;                                  		// 0x011C (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_playTimeWhenLooping;                            		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_startTime;                                      		// 0x0124 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2284 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_PlayCamShake::pClassPointer = NULL;

// Class SRGame.YSeqAct_PlayMusic
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_PlayMusic : public USequenceAction
{
public:
	class UYMusicPart*                                 m_part;                                           		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeInTime;                                     		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeOutTime;                                    		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2285 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_PlayMusic::pClassPointer = NULL;

// Class SRGame.YSeqAct_PlaySound
// 0x0004 (0x0128 - 0x0124)
class UYSeqAct_PlaySound : public USeqAct_PlaySound
{
public:
	float                                              m_rangeMultiplier;                                		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2286 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_PlaySound::pClassPointer = NULL;

// Class SRGame.YSeqAct_RunSpecialAction
// 0x001C (0x0110 - 0x00F4)
class UYSeqAct_RunSpecialAction : public USequenceAction
{
public:
	class UYSpecialActionsDefinition*                  m_specialAction;                                  		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSpecialActionSet*                          m_specialActionSet;                               		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_priority;                                       		// 0x00FC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_suppressOtherSpecialActions : 1;                		// 0x0100 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FYS_SpecialActionData                       m_data;                                           		// 0x0104 (0x000C) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2287 ];

		return pClassPointer;
	};

	void ReportSuccess ( unsigned long Success );
};

UClass* UYSeqAct_RunSpecialAction::pClassPointer = NULL;

// Class SRGame.YSeqAct_RunSpecialActionByType
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_RunSpecialActionByType : public USequenceAction
{
public:
	unsigned char                                      m_type;                                           		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_priority;                                       		// 0x00F5 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_SpecialActionData                       m_data;                                           		// 0x00F8 (0x000C) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2288 ];

		return pClassPointer;
	};

	void ReportSuccess ( unsigned long Success );
};

UClass* UYSeqAct_RunSpecialActionByType::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetAdditionalSASetList
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetAdditionalSASetList : public USequenceAction
{
public:
	class UYSpecialActionSetList*                      m_specialActionSetList;                           		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2289 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetAdditionalSASetList::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetFMODParam
// 0x0024 (0x0128 - 0x0104)
class UYSeqAct_SetFMODParam : public USeqAct_Latent
{
public:
	TArray< struct FRunningInterpolation >             m_runningInterpolations;                          		// 0x0104 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_timeLeft;                                       		// 0x0110 (0x0004) [0x0000000000000000]              
	class USoundCue*                                   m_soundCue;                                       		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_paramName;                                      		// 0x0118 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_targetValue;                                    		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_interpStartValue;                               		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2290 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void InterpolateFMODParam ( class AActor* TargetActor, class USoundCue* Cue, struct FName ParamName, float TargetValue, float Duration );
};

UClass* UYSeqAct_SetFMODParam::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetLookAtTarget
// 0x0020 (0x0114 - 0x00F4)
class UYSeqAct_SetLookAtTarget : public USequenceAction
{
public:
	TArray< struct FName >                             m_skelControlNames;                               		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FName                                       m_targetBoneName;                                 		// 0x0100 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_targetOffset;                                   		// 0x0108 (0x000C) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2291 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetLookAtTarget::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetPawnInventory
// 0x003C (0x0130 - 0x00F4)
class UYSeqAct_SetPawnInventory : public USequenceAction
{
public:
	unsigned long                                      m_keepCurrentActiveWeapon : 1;                    		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_activeWeaponScndModeActivated : 1;              		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_activeWeaponHasScndMode : 1;                    		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bHideAmmocounter : 1;                           		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bHideAmmoReserveCounter : 1;                    		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_keepCurrentInactiveWeapon : 1;                  		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_inactiveWeaponScndModeActivated : 1;            		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_inactiveWeaponHasScndMode : 1;                  		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_keepOldGrenades : 1;                            		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned char                                      m_activeWeaponEnum;                               		// 0x00F8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_inactiveWeaponEnum;                             		// 0x00F9 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_activeWeaponClass;                              		// 0x00FC (0x0004) [0x0000000000000000]              
	int                                                m_activeWeaponAmmoInMagazine;                     		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_activeWeaponAmmoInReserve;                      		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_activeWeaponAmmoInMagazineScnd;                 		// 0x0108 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_activeWeaponAmmoInReserveScnd;                  		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_inactiveWeaponClass;                            		// 0x0110 (0x0004) [0x0000000000000000]              
	int                                                m_inactiveWeaponAmmoInMagazine;                   		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_inactiveWeaponAmmoInReserve;                    		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_inactiveWeaponAmmoInMagazineScnd;               		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_inactiveWeaponAmmoInReserveScnd;                		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FYS_GrenadeArsenal >                m_grenades;                                       		// 0x0124 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2292 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetPawnInventory::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetPersistentDataBOOL
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_SetPersistentDataBOOL : public USequenceAction
{
public:
	struct FString                                     keySTR;                                           		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      Value : 1;                                        		// 0x0100 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2293 ];

		return pClassPointer;
	};

	bool IsValidUISequenceObject ( class UUIScreenObject* TargetObject );
};

UClass* UYSeqAct_SetPersistentDataBOOL::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetPersistentDataINT
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_SetPersistentDataINT : public USequenceAction
{
public:
	struct FString                                     keySTR;                                           		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                Value;                                            		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2294 ];

		return pClassPointer;
	};

	bool IsValidUISequenceObject ( class UUIScreenObject* TargetObject );
};

UClass* UYSeqAct_SetPersistentDataINT::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetSoundVolume
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_SetSoundVolume : public USequenceAction
{
public:
	float                                              m_time;                                           		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USoundCue*                                   m_soundCue;                                       		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_targetVolume;                                   		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2295 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetSoundVolume::pClassPointer = NULL;

// Class SRGame.YSeqAct_ShowGameOver
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_ShowGameOver : public USequenceAction
{
public:
	struct FString                                     m_message;                                        		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2296 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void ApplyPlayerControllRestrictions ( class AYPlayerController* PC );
	void Activated ( );
};

UClass* UYSeqAct_ShowGameOver::pClassPointer = NULL;

// Class SRGame.YSeqAct_SimpleModifyProperty
// 0x0018 (0x010C - 0x00F4)
class UYSeqAct_SimpleModifyProperty : public USequenceAction
{
public:
	struct FString                                     PropertyName;                                     		// 0x00F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     PropertyValue;                                    		// 0x0100 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2297 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SimpleModifyProperty::pClassPointer = NULL;

// Class SRGame.YSeqAct_SpeakByUID
// 0x0034 (0x0138 - 0x0104)
class UYSeqAct_SpeakByUID : public USeqAct_Latent
{
public:
	class USoundCue*                                   PlaySound;                                        		// 0x0104 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_UID;                                            		// 0x0108 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              ExtraDelay;                                       		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_lookAtAddressee : 1;                            		// 0x0110 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_turnBodyTowardsAddressee : 1;                   		// 0x0110 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bStopped : 1;                                     		// 0x0110 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_allowFilters : 1;                               		// 0x0110 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_useDucking : 1;                                 		// 0x0110 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_groupIsDisabled : 1;                            		// 0x0110 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_suppressFinishedOutputs : 1;                    		// 0x0110 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	float                                              FadeOutTime;                                      		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_subtitlePriority;                               		// 0x0118 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_priority;                                       		// 0x0119 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class AYGamePawn*                                  m_speaker;                                        		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYRemoteSpeakerBase*                         m_remoteSpeaker;                                  		// 0x0120 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_startedSpeaking;                                		// 0x0124 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_playbackVolume;                                 		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     m_group;                                          		// 0x012C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2298 ];

		return pClassPointer;
	};

	void UpdateGroupVar ( );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SpeakByUID::pClassPointer = NULL;

// Class SRGame.YSeqAct_StopMusicPlayback
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_StopMusicPlayback : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2299 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_StopMusicPlayback::pClassPointer = NULL;

// Class SRGame.YSeqAct_StreamByURL
// 0x0004 (0x0108 - 0x0104)
class UYSeqAct_StreamByURL : public USeqAct_Latent
{
public:
	int                                                Stage;                                            		// 0x0104 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2300 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_StreamByURL::pClassPointer = NULL;

// Class SRGame.YSeqAct_TearOffActors
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_TearOffActors : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2301 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_TearOffActors::pClassPointer = NULL;

// Class SRGame.YSeqAct_TearOffMatinee
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_TearOffMatinee : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2302 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_TearOffMatinee::pClassPointer = NULL;

// Class SRGame.YSeqAct_Teleport
// 0x0004 (0x00FC - 0x00F8)
class UYSeqAct_Teleport : public USeqAct_Teleport
{
public:
	unsigned long                                      m_stopSpecialMoveOnPawn : 1;                      		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_stopCustomAnimationOnPawn : 1;                  		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_disableCrouch : 1;                              		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_disableCover : 1;                               		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_disableZoom : 1;                                		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_disableCautiousMode : 1;                        		// 0x00F8 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_abortCurrentSquadCommand : 1;                   		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_forceRefreshLightEnv : 1;                       		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_waitForAIToTriggerOutput : 1;                   		// 0x00F8 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2303 ];

		return pClassPointer;
	};

	void VersionUpdated ( int OldVersion, int NewVersion );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_Teleport::pClassPointer = NULL;

// Class SRGame.YSeqAct_TravelMap
// 0x0020 (0x0114 - 0x00F4)
class UYSeqAct_TravelMap : public USequenceAction
{
public:
	struct FString                                     MapName;                                          		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      m_mpMapID;                                        		// 0x0100 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     Parameters;                                       		// 0x0104 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bUseMPSectionTravel : 1;                        		// 0x0110 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2304 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void UpdateGameSettings ( class UOnlineSubsystem* OnlineSub );
	class UYUIDataProvider_MapInfo* GetMapProvider ( );
	bool IsValidUISequenceObject ( class UUIScreenObject* TargetObject );
};

UClass* UYSeqAct_TravelMap::pClassPointer = NULL;

// Class SRGame.YSeqAct_WaitForFullScreenMovieEnding
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_WaitForFullScreenMovieEnding : public USequenceAction
{
public:
	struct FString                                     m_Filename;                                       		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2305 ];

		return pClassPointer;
	};

	bool IsValidUISequenceObject ( class UUIScreenObject* TargetObject );
};

UClass* UYSeqAct_WaitForFullScreenMovieEnding::pClassPointer = NULL;

// Class SRGame.YSeqAct_WaitForLevelsVisible
// 0x0008 (0x0128 - 0x0120)
class UYSeqAct_WaitForLevelsVisible : public USeqAct_WaitForLevelsVisible
{
public:
	class AActor*                                      m_checkpoint;                                     		// 0x0120 (0x0004) [0x0000000000000000]              
	unsigned long                                      bStatusIsOk : 1;                                  		// 0x0124 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2306 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_WaitForLevelsVisible::pClassPointer = NULL;

// Class SRGame.YSeqAct_WaitForPlayers
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_WaitForPlayers : public USequenceAction
{
public:
	int                                                ConnectionCount;                                  		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UObject*                                     PlayerA;                                          		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UObject*                                     PlayerB;                                          		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2307 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_WaitForPlayers::pClassPointer = NULL;

// Class SRGame.YSeqCond_CompareObjectClass
// 0x0008 (0x00E4 - 0x00DC)
class UYSeqCond_CompareObjectClass : public USequenceCondition
{
public:
	class UClass*                                      m_objectClass;                                    		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_matchPawnOrCtrl : 1;                            		// 0x00E0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2308 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_CompareObjectClass::pClassPointer = NULL;

// Class SRGame.YSeqCond_CompareString
// 0x0018 (0x00F4 - 0x00DC)
class UYSeqCond_CompareString : public USequenceCondition
{
public:
	struct FString                                     ValueA;                                           		// 0x00DC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     ValueB;                                           		// 0x00E8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2309 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_CompareString::pClassPointer = NULL;

// Class SRGame.YSeqCond_FastRopeIsPrepared
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_FastRopeIsPrepared : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2310 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_FastRopeIsPrepared::pClassPointer = NULL;

// Class SRGame.YSeqCond_GetDifficulty
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_GetDifficulty : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2311 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_GetDifficulty::pClassPointer = NULL;

// Class SRGame.YSeqCond_GetTeam
// 0x0004 (0x00E0 - 0x00DC)
class UYSeqCond_GetTeam : public USequenceCondition
{
public:
	class UObject*                                     m_clientPlayer;                                   		// 0x00DC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2312 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_GetTeam::pClassPointer = NULL;

// Class SRGame.YSeqCond_IsAlive
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_IsAlive : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2313 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_IsAlive::pClassPointer = NULL;

// Class SRGame.YSeqCond_IsSquadUsingSquadCommand
// 0x0001 (0x00DD - 0x00DC)
class UYSeqCond_IsSquadUsingSquadCommand : public USequenceCondition
{
public:
	unsigned char                                      m_playerSquadCommandType;                         		// 0x00DC (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2314 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_IsSquadUsingSquadCommand::pClassPointer = NULL;

// Class SRGame.YSeqCond_LevelLoaded
// 0x0010 (0x00EC - 0x00DC)
class UYSeqCond_LevelLoaded : public USequenceCondition
{
public:
	TArray< struct FString >                           LevelNames;                                       		// 0x00DC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class AActor*                                      m_checkpoint;                                     		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2315 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_LevelLoaded::pClassPointer = NULL;

// Class SRGame.YSeqCond_PawnDeathCause
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_PawnDeathCause : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2316 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_PawnDeathCause::pClassPointer = NULL;

// Class SRGame.YSeqCond_PawnFacesDeathAnimVolume
// 0x0004 (0x00E0 - 0x00DC)
class UYSeqCond_PawnFacesDeathAnimVolume : public USequenceCondition
{
public:
	float                                              m_toleranceDegrees;                               		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2317 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_PawnFacesDeathAnimVolume::pClassPointer = NULL;

// Class SRGame.YSeqCond_PawnIsCrouched
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_PawnIsCrouched : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2318 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_PawnIsCrouched::pClassPointer = NULL;

// Class SRGame.YSeqCond_PawnIsDBNO
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_PawnIsDBNO : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2319 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_PawnIsDBNO::pClassPointer = NULL;

// Class SRGame.YSeqCond_PawnIsInCover
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_PawnIsInCover : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2320 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_PawnIsInCover::pClassPointer = NULL;

// Class SRGame.YSeqCond_PawnIsInSandStorm
// 0x0004 (0x00E0 - 0x00DC)
class UYSeqCond_PawnIsInSandStorm : public USequenceCondition
{
public:
	int                                                m_minSandstormLevel;                              		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2321 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_PawnIsInSandStorm::pClassPointer = NULL;

// Class SRGame.YSeqCond_Platform
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_Platform : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2322 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_Platform::pClassPointer = NULL;

// Class SRGame.YSeqCond_PlayerSquadInInfiltrate
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_PlayerSquadInInfiltrate : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2323 ];

		return pClassPointer;
	};

};

UClass* UYSeqCond_PlayerSquadInInfiltrate::pClassPointer = NULL;

// Class SRGame.YSeqEvent_Explosion
// 0x0004 (0x0114 - 0x0110)
class UYSeqEvent_Explosion : public USequenceEvent
{
public:
	unsigned long                                      m_reactToNotExplodingExplosives : 1;              		// 0x0110 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2324 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_Explosion::pClassPointer = NULL;

// Class SRGame.YSeqEvent_OnSpecialDeathTriggered
// 0x0010 (0x0120 - 0x0110)
class UYSeqEvent_OnSpecialDeathTriggered : public USequenceEvent
{
public:
	int                                                m_listLength;                                     		// 0x0110 (0x0004) [0x0000000000000000]              
	TArray< class APawn* >                             m_deadPawns;                                      		// 0x0114 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2325 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_OnSpecialDeathTriggered::pClassPointer = NULL;

// Class SRGame.YSeqEvent_SkipMatinee
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_SkipMatinee : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2326 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_SkipMatinee::pClassPointer = NULL;

// Class SRGame.YSeqEvent_SpecialMoveStopped
// 0x0001 (0x0111 - 0x0110)
class UYSeqEvent_SpecialMoveStopped : public USequenceEvent
{
public:
	unsigned char                                      m_associatedSpecialMove;                          		// 0x0110 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2327 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_SpecialMoveStopped::pClassPointer = NULL;

// Class SRGame.YSeqEvent_YDODamageModApplied
// 0x0010 (0x0120 - 0x0110)
class UYSeqEvent_YDODamageModApplied : public USequenceEvent
{
public:
	struct FName                                       subObjectName;                                    		// 0x0110 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       damageModName;                                    		// 0x0118 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2328 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_YDODamageModApplied::pClassPointer = NULL;

// Class SRGame.YSeqEvt_Interaction
// 0x0018 (0x0128 - 0x0110)
class UYSeqEvt_Interaction : public USequenceEvent
{
public:
	unsigned char                                      m_activationType;                                 		// 0x0110 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_activatedByTeam;                                		// 0x0111 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bCheckInteractFOV : 1;                            		// 0x0114 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              InteractFOV;                                      		// 0x0118 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FString                                     InteractAction;                                   		// 0x011C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2329 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	struct FString GetInteractionMessage ( );
	bool CanDoInteraction ( class AController* PC, class AActor* InOriginator );
};

UClass* UYSeqEvt_Interaction::pClassPointer = NULL;

// Class SRGame.YSeqEvt_InteractionHold
// 0x0008 (0x0130 - 0x0128)
class UYSeqEvt_InteractionHold : public UYSeqEvt_Interaction
{
public:
	float                                              m_fHoldTime;                                      		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_currenceSequenceIndex;                          		// 0x012C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2330 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqEvt_InteractionHold::pClassPointer = NULL;

// Class SRGame.YSeqEvt_MissionPoint
// 0x0010 (0x0120 - 0x0110)
class UYSeqEvt_MissionPoint : public USequenceEvent
{
public:
	unsigned char                                      MissionId;                                        		// 0x0110 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FLevelRecord >                      SubLevelsToLoad;                                  		// 0x0114 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2331 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_MissionPoint::pClassPointer = NULL;

// Class SRGame.YSeqEvt_PlayersSpawned
// 0x0010 (0x0120 - 0x0110)
class UYSeqEvt_PlayersSpawned : public USequenceEvent
{
public:
	int                                                m_listLength;                                     		// 0x0110 (0x0004) [0x0000000000000000]              
	TArray< class AController* >                       m_spawnedControllers;                             		// 0x0114 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2332 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_PlayersSpawned::pClassPointer = NULL;

// Class SRGame.YSeqEvt_ReplicatedEvent
// 0x000C (0x011C - 0x0110)
class UYSeqEvt_ReplicatedEvent : public USequenceEvent
{
public:
	struct FName                                       EventName;                                        		// 0x0110 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bStatusIsOk : 1;                                  		// 0x0118 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2333 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_ReplicatedEvent::pClassPointer = NULL;

// Class SRGame.YSeqVar_AliveCount
// 0x0039 (0x00D9 - 0x00A0)
class UYSeqVar_AliveCount : public USeqVar_Int
{
public:
	struct FYS_AliveCountSetting                       m_countSettings[ 0x7 ];                           		// 0x00A0 (0x0038) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_presetSelector;                                 		// 0x00D8 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2334 ];

		return pClassPointer;
	};

};

UClass* UYSeqVar_AliveCount::pClassPointer = NULL;

// Class SRGame.YSeqVar_EnemyCount
// 0x0000 (0x00A0 - 0x00A0)
class UYSeqVar_EnemyCount : public USeqVar_Int
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2335 ];

		return pClassPointer;
	};

};

UClass* UYSeqVar_EnemyCount::pClassPointer = NULL;

// Class SRGame.YSeqVar_Global
// 0x000C (0x00C4 - 0x00B8)
class UYSeqVar_Global : public USeqVar_Object
{
public:
	TArray< class UObject* >                           Objects;                                          		// 0x00B8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2336 ];

		return pClassPointer;
	};

	void FillObjectList ( );
	class UObject* GetObjectValue ( );
};

UClass* UYSeqVar_Global::pClassPointer = NULL;

// Class SRGame.YSeqVar_GlobalAIs
// 0x0020 (0x00E4 - 0x00C4)
class UYSeqVar_GlobalAIs : public UYSeqVar_Global
{
public:
	struct FYS_ObjectListAIs_Types                     m_types;                                          		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ObjectListAIs_Options                   m_options;                                        		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_classWalker;                                    		// 0x00CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_classAdams;                                     		// 0x00D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_classLugo;                                      		// 0x00D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_classRiggs;                                     		// 0x00D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_classCivilian;                                  		// 0x00DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_classEnemy;                                     		// 0x00E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2337 ];

		return pClassPointer;
	};

	void FillObjectList ( );
};

UClass* UYSeqVar_GlobalAIs::pClassPointer = NULL;

// Class SRGame.YSeqVar_GlobalCheapShooters
// 0x0000 (0x00C4 - 0x00C4)
class UYSeqVar_GlobalCheapShooters : public UYSeqVar_Global
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2338 ];

		return pClassPointer;
	};

	void FillObjectList ( );
};

UClass* UYSeqVar_GlobalCheapShooters::pClassPointer = NULL;

// Class SRGame.YSeqVar_NumTeamMembers
// 0x0008 (0x00A8 - 0x00A0)
class UYSeqVar_NumTeamMembers : public USeqVar_Int
{
public:
	unsigned char                                      m_eTeam;                                          		// 0x00A0 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_Not : 1;                                        		// 0x00A4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_dbno : 1;                                       		// 0x00A4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_dead : 1;                                       		// 0x00A4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2339 ];

		return pClassPointer;
	};

};

UClass* UYSeqVar_NumTeamMembers::pClassPointer = NULL;

// Class SRGame.YSeqVar_ObjectVolume
// 0x0020 (0x00D8 - 0x00B8)
class UYSeqVar_ObjectVolume : public USeqVar_Object
{
public:
	float                                              m_lastUpdateTime;                                 		// 0x00B8 (0x0004) [0x0000000000000000]              
	TArray< class UObject* >                           m_containedObjects;                               		// 0x00BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UClass* >                            m_includeClassList;                               		// 0x00C8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_collidingOnly : 1;                              		// 0x00D4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2340 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqVar_ObjectVolume::pClassPointer = NULL;

// Class SRGame.YSeqVar_PlayerCamera
// 0x0000 (0x00B8 - 0x00B8)
class UYSeqVar_PlayerCamera : public USeqVar_Object
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2341 ];

		return pClassPointer;
	};

};

UClass* UYSeqVar_PlayerCamera::pClassPointer = NULL;

// Class SRGame.YSeqVar_PlayerClass
// 0x0014 (0x00CC - 0x00B8)
class UYSeqVar_PlayerClass : public USeqVar_Object
{
public:
	unsigned char                                      m_squadMember;                                    		// 0x00B8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FName >                             m_classNames;                                     		// 0x00BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_showErrorWhenNotFound : 1;                      		// 0x00C8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2342 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqVar_PlayerClass::pClassPointer = NULL;

// Class SRGame.YSeqVar_PlayerSquad
// 0x0000 (0x00B8 - 0x00B8)
class UYSeqVar_PlayerSquad : public USeqVar_Object
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2343 ];

		return pClassPointer;
	};

};

UClass* UYSeqVar_PlayerSquad::pClassPointer = NULL;

// Class SRGame.YSeqVar_RemoteSpeaker_Generic
// 0x0000 (0x00B8 - 0x00B8)
class UYSeqVar_RemoteSpeaker_Generic : public USeqVar_Object
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2344 ];

		return pClassPointer;
	};

};

UClass* UYSeqVar_RemoteSpeaker_Generic::pClassPointer = NULL;

// Class SRGame.YSeqVar_RemoteSpeaker_Team
// 0x0001 (0x00B9 - 0x00B8)
class UYSeqVar_RemoteSpeaker_Team : public USeqVar_Object
{
public:
	unsigned char                                      m_teamID;                                         		// 0x00B8 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2345 ];

		return pClassPointer;
	};

};

UClass* UYSeqVar_RemoteSpeaker_Team::pClassPointer = NULL;

// Class SRGame.YSeqVar_TeamMembers
// 0x0001 (0x00C5 - 0x00C4)
class UYSeqVar_TeamMembers : public USeqVar_ObjectList
{
public:
	unsigned char                                      m_eTeam;                                          		// 0x00C4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2346 ];

		return pClassPointer;
	};

};

UClass* UYSeqVar_TeamMembers::pClassPointer = NULL;

// Class SRGame.YShyfflr
// 0x0044 (0x0080 - 0x003C)
class UYShyfflr : public UObject
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                     		// 0x003C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	TArray< struct FYS_ShyfflrEntry >                  m_shyfflrEntries;                                 		// 0x0040 (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )
	float                                              m_setListLifeTime;                                		// 0x004C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_shyfflrLoadPause;                               		// 0x0050 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned long                                      m_useShyfflr : 1;                                 		// 0x0054 (0x0004) [0x0000000000004002] [0x00000001] ( CPF_Const | CPF_Config )
	unsigned char                                      m_currentState;                                   		// 0x0058 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class UYSpecialActionSetList*                      m_currentSetList;                                 		// 0x005C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_timeSinceFinishedLoading;                       		// 0x0060 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_lastTickTime;                                   		// 0x0064 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< int >                                      m_unusedIndices;                                  		// 0x0068 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_currentLoadIndex;                               		// 0x0074 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FUObjectHandle                              m_previousVSBResourceHandle;                      		// 0x0078 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FUObjectHandle                              m_currentVSBResourceHandle;                       		// 0x007C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2347 ];

		return pClassPointer;
	};

	void UpdateShyfflrFromPawn ( class AYGamePawn* updatingPawn, float dt );
	void ConditionalInitShyfflr ( );
	class UYShyfflr* GetShyfflrDefaultInstance ( class UClass* shyfflrClass );
};

UClass* UYShyfflr::pClassPointer = NULL;

// Class SRGame.YSpecialAction
// 0x0008 (0x0044 - 0x003C)
class UYSpecialAction : public UObject
{
public:
	class USoundCue*                                   m_soundCue;                                       		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_uniqueIDToPlay;                                 		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2348 ];

		return pClassPointer;
	};

	bool PlayAnimInternal ( class AYGamePawn* Pawn );
	bool RunSpecialAction ( class AYGamePawn* Pawn, class UYSpecialActionsDefinition* sa_def, struct FScriptDelegate finishedCallback );
	class UYSpecialActionInstance* GetInstanceFromPawn ( class AYGamePawn* Pawn );
};

UClass* UYSpecialAction::pClassPointer = NULL;

// Class SRGame.YSA_SimpleAction
// 0x000C (0x0050 - 0x0044)
class UYSA_SimpleAction : public UYSpecialAction
{
public:
	struct FYS_SpecialActionAnimationDef               m_animation;                                      		// 0x0044 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_loopAnimation : 1;                              		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2349 ];

		return pClassPointer;
	};

	bool PlayAnimInternal ( class AYGamePawn* Pawn );
	class UYSpecialActionInstance* GetInstanceFromPawn ( class AYGamePawn* Pawn );
};

UClass* UYSA_SimpleAction::pClassPointer = NULL;

// Class SRGame.YSpecialActionEventFilter
// 0x0010 (0x004C - 0x003C)
class UYSpecialActionEventFilter : public UObject
{
public:
	unsigned long                                      m_enabled : 1;                                    		// 0x003C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_restrictToPawn : 1;                             		// 0x003C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned char                                      m_event;                                          		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_time;                                           		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_area;                                           		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2350 ];

		return pClassPointer;
	};

};

UClass* UYSpecialActionEventFilter::pClassPointer = NULL;

// Class SRGame.YSpecialActionEventFilterSet
// 0x0014 (0x0050 - 0x003C)
class UYSpecialActionEventFilterSet : public UObject
{
public:
	float                                              m_trackingTime;                                   		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UYSpecialActionEventFilter* >        m_filters;                                        		// 0x0040 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	struct FPointer                                    m_data;                                           		// 0x004C (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2351 ];

		return pClassPointer;
	};

	bool CheckEvent ( class AYGamePawn* Pawn, unsigned char Event, struct FYS_SpecialActionData* Data, unsigned char* mayPlay );
};

UClass* UYSpecialActionEventFilterSet::pClassPointer = NULL;

// Class SRGame.YSpecialActionInstance
// 0x001C (0x0058 - 0x003C)
class UYSpecialActionInstance : public UObject
{
public:
	class UYSpecialActionsDefinition*                  m_specialActionDef;                               		// 0x003C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_animFinished : 1;                               		// 0x0040 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_soundFinished : 1;                              		// 0x0040 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_pawnFinishedCalled : 1;                         		// 0x0040 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_delegateSet : 1;                                		// 0x0040 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              m_animFinishedTimeStamp;                          		// 0x0044 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             m_soundFinishedCallback;                          		// 0x0048 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class AYGamePawn*                                  m_pawn;                                           		// 0x0054 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2352 ];

		return pClassPointer;
	};

	bool IsAnimationFinishedSince ( float Time );
	bool isFinished ( );
	void AnimFinished ( );
	void SoundFinished ( );
	void OnAnimFromSpecialActionFinished ( );
	void OnSoundFromSpecialActionFinished ( );
	void StopSoundInternal ( );
	void StopAnimationInternal ( );
	void StopSpecialAction ( );
	bool RunSpecialAction ( class UYSpecialActionsDefinition* sa_def, struct FScriptDelegate finishedCallback );
	bool PlayAnimInternal ( );
	bool PlaySoundInternal ( );
	void SetPawn ( class AYGamePawn* Pawn );
	bool UsesDef ( class UYSpecialActionsDefinition* sa_def );
	bool InitInstance ( class UYSpecialActionsDefinition* sa_def );
};

UClass* UYSpecialActionInstance::pClassPointer = NULL;

// Class SRGame.YSAI_SimpleAction
// 0x0000 (0x0058 - 0x0058)
class UYSAI_SimpleAction : public UYSpecialActionInstance
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2353 ];

		return pClassPointer;
	};

	void StopAnimationInternal ( );
	bool InitInstance ( class UYSpecialActionsDefinition* sa_def );
};

UClass* UYSAI_SimpleAction::pClassPointer = NULL;

// Class SRGame.YSAI_SimpleRef
// 0x0000 (0x0058 - 0x0058)
class UYSAI_SimpleRef : public UYSpecialActionInstance
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2354 ];

		return pClassPointer;
	};

	void StopAnimationInternal ( );
	bool InitInstance ( class UYSpecialActionsDefinition* sa_def );
};

UClass* UYSAI_SimpleRef::pClassPointer = NULL;

// Class SRGame.YSpecialActionsDefinition
// 0x0014 (0x0050 - 0x003C)
class UYSpecialActionsDefinition : public UObject
{
public:
	TArray< class UYSpecialActionUseRestriction* >     m_useRestrictions;                                		// 0x003C (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	class UYSpecialAction*                             m_specialAction;                                  		// 0x0048 (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	unsigned long                                      m_usesVoice : 1;                                  		// 0x004C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2355 ];

		return pClassPointer;
	};

	void ReportActionUse ( class AYGamePawn* usingGamePawn );
	bool IsActionUsable ( class AYGamePawn* usingGamePawn );
};

UClass* UYSpecialActionsDefinition::pClassPointer = NULL;

// Class SRGame.YSpecialActionSet
// 0x0020 (0x005C - 0x003C)
class UYSpecialActionSet : public UObject
{
public:
	TArray< struct FYS_SpecialActionUseChance >        m_specialActions;                                 		// 0x003C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      m_type;                                           		// 0x0048 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_priority;                                       		// 0x0049 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< unsigned char >                            m_additionalTypes;                                		// 0x004C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_currentShuffleRound;                            		// 0x0058 (0x0004) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2356 ];

		return pClassPointer;
	};

	class UYSpecialActionsDefinition* GetSpecialActionInternal ( class AYGamePawn* usingPawn, class UYSpecialActionSet* addSet, int* numUsableActions );
	class UYSpecialActionsDefinition* GetSpecialAction ( class AYGamePawn* usingPawn, class UYSpecialActionSet* addSet );
};

UClass* UYSpecialActionSet::pClassPointer = NULL;

// Class SRGame.YSpecialActionSetList
// 0x000C (0x0048 - 0x003C)
class UYSpecialActionSetList : public UObject
{
public:
	TArray< class UYSpecialActionSet* >                m_specialActionSets;                              		// 0x003C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2357 ];

		return pClassPointer;
	};

};

UClass* UYSpecialActionSetList::pClassPointer = NULL;

// Class SRGame.YSASL_Brunell
// 0x0000 (0x0048 - 0x0048)
class UYSASL_Brunell : public UYSpecialActionSetList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2358 ];

		return pClassPointer;
	};

};

UClass* UYSASL_Brunell::pClassPointer = NULL;

// Class SRGame.YSASL_Civilian01
// 0x0000 (0x0048 - 0x0048)
class UYSASL_Civilian01 : public UYSpecialActionSetList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2359 ];

		return pClassPointer;
	};

};

UClass* UYSASL_Civilian01::pClassPointer = NULL;

// Class SRGame.YSASL_Enemy1
// 0x0000 (0x0048 - 0x0048)
class UYSASL_Enemy1 : public UYSpecialActionSetList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2360 ];

		return pClassPointer;
	};

};

UClass* UYSASL_Enemy1::pClassPointer = NULL;

// Class SRGame.YSASL_Enemy2
// 0x0000 (0x0048 - 0x0048)
class UYSASL_Enemy2 : public UYSpecialActionSetList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2361 ];

		return pClassPointer;
	};

};

UClass* UYSASL_Enemy2::pClassPointer = NULL;

// Class SRGame.YSASL_Enemy3
// 0x0000 (0x0048 - 0x0048)
class UYSASL_Enemy3 : public UYSpecialActionSetList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2362 ];

		return pClassPointer;
	};

};

UClass* UYSASL_Enemy3::pClassPointer = NULL;

// Class SRGame.YSASL_Enemy4
// 0x0000 (0x0048 - 0x0048)
class UYSASL_Enemy4 : public UYSpecialActionSetList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2363 ];

		return pClassPointer;
	};

};

UClass* UYSASL_Enemy4::pClassPointer = NULL;

// Class SRGame.YSASL_Martinez
// 0x0000 (0x0048 - 0x0048)
class UYSASL_Martinez : public UYSpecialActionSetList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2364 ];

		return pClassPointer;
	};

};

UClass* UYSASL_Martinez::pClassPointer = NULL;

// Class SRGame.YSASL_Saleh
// 0x0000 (0x0048 - 0x0048)
class UYSASL_Saleh : public UYSpecialActionSetList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2365 ];

		return pClassPointer;
	};

};

UClass* UYSASL_Saleh::pClassPointer = NULL;

// Class SRGame.YSpecialActionUseRestriction
// 0x0001 (0x003D - 0x003C)
class UYSpecialActionUseRestriction : public UObject
{
public:
	unsigned char                                      m_restrictionScope;                               		// 0x003C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2366 ];

		return pClassPointer;
	};

};

UClass* UYSpecialActionUseRestriction::pClassPointer = NULL;

// Class SRGame.YSAUR_AISolo
// 0x0007 (0x0044 - 0x003D)
class UYSAUR_AISolo : public UYSpecialActionUseRestriction
{
public:
	unsigned long                                      m_alone : 1;                                      		// 0x0040 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2367 ];

		return pClassPointer;
	};

	bool IsSpecialActionUsable ( class UYSpecialActionsDefinition* sa_def, class AYGamePawn* usingObject );
};

UClass* UYSAUR_AISolo::pClassPointer = NULL;

// Class SRGame.YSAUR_FriendFoe
// 0x000C (0x0049 - 0x003D)
class UYSAUR_FriendFoe : public UYSpecialActionUseRestriction
{
public:
	int                                                m_minMembers;                                     		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxRadius;                                      		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_team;                                           		// 0x0048 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2368 ];

		return pClassPointer;
	};

};

UClass* UYSAUR_FriendFoe::pClassPointer = NULL;

// Class SRGame.YSAUR_HumanControlled
// 0x0007 (0x0044 - 0x003D)
class UYSAUR_HumanControlled : public UYSpecialActionUseRestriction
{
public:
	unsigned long                                      m_humanControlled : 1;                            		// 0x0040 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2369 ];

		return pClassPointer;
	};

};

UClass* UYSAUR_HumanControlled::pClassPointer = NULL;

// Class SRGame.YSAUR_IsInCombat
// 0x0007 (0x0044 - 0x003D)
class UYSAUR_IsInCombat : public UYSpecialActionUseRestriction
{
public:
	unsigned long                                      m_isInCombat : 1;                                 		// 0x0040 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2370 ];

		return pClassPointer;
	};

};

UClass* UYSAUR_IsInCombat::pClassPointer = NULL;

// Class SRGame.YSAUR_IsRunning
// 0x0007 (0x0044 - 0x003D)
class UYSAUR_IsRunning : public UYSpecialActionUseRestriction
{
public:
	unsigned long                                      m_running : 1;                                    		// 0x0040 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2371 ];

		return pClassPointer;
	};

	bool IsSpecialActionUsable ( class UYSpecialActionsDefinition* sa_def, class AYGamePawn* usingObject );
};

UClass* UYSAUR_IsRunning::pClassPointer = NULL;

// Class SRGame.YSAUR_MaxUseCount
// 0x0017 (0x0054 - 0x003D)
class UYSAUR_MaxUseCount : public UYSpecialActionUseRestriction
{
public:
	int                                                m_maxUseCount;                                    		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_timeFrame;                                      		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FYS_MUCUseReport >                  m_globalUseReports;                               		// 0x0048 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2372 ];

		return pClassPointer;
	};

};

UClass* UYSAUR_MaxUseCount::pClassPointer = NULL;

// Class SRGame.YSAUR_MinPause
// 0x000B (0x0048 - 0x003D)
class UYSAUR_MinPause : public UYSpecialActionUseRestriction
{
public:
	float                                              m_pauseTime;                                      		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lastGlobalUseTime;                              		// 0x0044 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2373 ];

		return pClassPointer;
	};

};

UClass* UYSAUR_MinPause::pClassPointer = NULL;

// Class SRGame.YSAUR_PawnStance
// 0x0009 (0x0046 - 0x003D)
class UYSAUR_PawnStance : public UYSpecialActionUseRestriction
{
public:
	int                                                m_classAlignHelper;                               		// 0x0040 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_inCover;                                        		// 0x0044 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_crouched;                                       		// 0x0045 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2374 ];

		return pClassPointer;
	};

};

UClass* UYSAUR_PawnStance::pClassPointer = NULL;

// Class SRGame.YSAUR_SkippedUsage
// 0x000B (0x0048 - 0x003D)
class UYSAUR_SkippedUsage : public UYSpecialActionUseRestriction
{
public:
	int                                                m_triesBeforeUsableAgain;                         		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_tries;                                          		// 0x0044 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2375 ];

		return pClassPointer;
	};

};

UClass* UYSAUR_SkippedUsage::pClassPointer = NULL;

// Class SRGame.YSAUR_TeamMembership
// 0x0007 (0x0044 - 0x003D)
class UYSAUR_TeamMembership : public UYSpecialActionUseRestriction
{
public:
	unsigned long                                      m_playerTeam : 1;                                 		// 0x0040 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_enemyTeam : 1;                                  		// 0x0040 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_civilianTeam : 1;                               		// 0x0040 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_neutralTeam : 1;                                		// 0x0040 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2376 ];

		return pClassPointer;
	};

};

UClass* UYSAUR_TeamMembership::pClassPointer = NULL;

// Class SRGame.YSpecialActionUseRestrictionArray
// 0x000C (0x0048 - 0x003C)
class UYSpecialActionUseRestrictionArray : public UObject
{
public:
	TArray< class UYSpecialActionUseRestriction* >     m_useRestrictions;                                		// 0x003C (0x000C) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2377 ];

		return pClassPointer;
	};

};

UClass* UYSpecialActionUseRestrictionArray::pClassPointer = NULL;

// Class SRGame.YSpecialActionUseRestrictionOD
// 0x0004 (0x0040 - 0x003C)
class UYSpecialActionUseRestrictionOD : public UObject
{
public:
	class UYSpecialActionUseRestriction*               m_useRestriction;                                 		// 0x003C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2378 ];

		return pClassPointer;
	};

	bool MayBeRemoved ( float CurrentTimeStamp );
};

UClass* UYSpecialActionUseRestrictionOD::pClassPointer = NULL;

// Class SRGame.YSAUR_MaxUseCountOD
// 0x000C (0x004C - 0x0040)
class UYSAUR_MaxUseCountOD : public UYSpecialActionUseRestrictionOD
{
public:
	TArray< struct FYS_ODMUCUseReport >                m_reports;                                        		// 0x0040 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2379 ];

		return pClassPointer;
	};

	bool MayBeRemoved ( float CurrentTimeStamp );
};

UClass* UYSAUR_MaxUseCountOD::pClassPointer = NULL;

// Class SRGame.YSAUR_MinPauseOD
// 0x0004 (0x0044 - 0x0040)
class UYSAUR_MinPauseOD : public UYSpecialActionUseRestrictionOD
{
public:
	float                                              m_useTime;                                        		// 0x0040 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2380 ];

		return pClassPointer;
	};

	bool MayBeRemoved ( float CurrentTimeStamp );
};

UClass* UYSAUR_MinPauseOD::pClassPointer = NULL;

// Class SRGame.YSAUR_SkippedUsageOD
// 0x0004 (0x0044 - 0x0040)
class UYSAUR_SkippedUsageOD : public UYSpecialActionUseRestrictionOD
{
public:
	int                                                m_tries;                                          		// 0x0040 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2381 ];

		return pClassPointer;
	};

	bool MayBeRemoved ( float CurrentTimeStamp );
};

UClass* UYSAUR_SkippedUsageOD::pClassPointer = NULL;

// Class SRGame.YCollisionEffectDefinition
// 0x0004 (0x0040 - 0x003C)
class UYCollisionEffectDefinition : public UObject
{
public:
	class UYCollisionEffectDesc*                       m_CollisionEffect;                                		// 0x003C (0x0004) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2382 ];

		return pClassPointer;
	};

};

UClass* UYCollisionEffectDefinition::pClassPointer = NULL;

// Class SRGame.YCollisionEffectDesc
// 0x0024 (0x0060 - 0x003C)
class UYCollisionEffectDesc : public UObject
{
public:
	float                                              m_maxLifetime;                                    		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_tearDownTime;                                   		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_autoDetectLifetime : 1;                         		// 0x0044 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_reflectHitDirection : 1;                        		// 0x0044 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_goWithRayDir : 1;                               		// 0x0044 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	float                                              m_minReflectionQuantum;                           		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxReflectionQuantum;                           		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_reflectDirVariationAngle;                       		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_randomRotateAngle;                              		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_effectDefType;                                  		// 0x0058 (0x0001) [0x0000000000000000]              
	int                                                m_clusterLevel;                                   		// 0x005C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2383 ];

		return pClassPointer;
	};

};

UClass* UYCollisionEffectDesc::pClassPointer = NULL;

// Class SRGame.YCollisionEffect_Debug
// 0x0000 (0x0060 - 0x0060)
class UYCollisionEffect_Debug : public UYCollisionEffectDesc
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2384 ];

		return pClassPointer;
	};

};

UClass* UYCollisionEffect_Debug::pClassPointer = NULL;

// Class SRGame.YCollisionEffect_Decal
// 0x002C (0x008C - 0x0060)
class UYCollisionEffect_Decal : public UYCollisionEffectDesc
{
public:
	TArray< struct FYS_DecalType >                     m_decalTypes;                                     		// 0x0060 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FVector                                     m_minSize;                                        		// 0x006C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_maxSize;                                        		// 0x0078 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minRotation;                                    		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxRotation;                                    		// 0x0088 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2385 ];

		return pClassPointer;
	};

};

UClass* UYCollisionEffect_Decal::pClassPointer = NULL;

// Class SRGame.YCollisionEffect_Particles
// 0x0018 (0x0078 - 0x0060)
class UYCollisionEffect_Particles : public UYCollisionEffectDesc
{
public:
	class UParticleSystem*                             m_particleSystem;                                 		// 0x0060 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FYS_ParticleType >                  m_particleSystems;                                		// 0x0064 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_offsetLoc : 1;                                  		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_attachedToBone : 1;                             		// 0x0070 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      OcclusionRadius : 1;                              		// 0x0070 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	float                                              OcclusionTime;                                    		// 0x0074 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2386 ];

		return pClassPointer;
	};

};

UClass* UYCollisionEffect_Particles::pClassPointer = NULL;

// Class SRGame.YCollisionEffect_Sound
// 0x000C (0x006C - 0x0060)
class UYCollisionEffect_Sound : public UYCollisionEffectDesc
{
public:
	class USoundCue*                                   m_soundCue;                                       		// 0x0060 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_velocity;                                       		// 0x0064 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_fixedOffset;                                    		// 0x0068 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2387 ];

		return pClassPointer;
	};

};

UClass* UYCollisionEffect_Sound::pClassPointer = NULL;

// Class SRGame.YCollisionEffectMgr
// 0x0010 (0x004C - 0x003C)
class UYCollisionEffectMgr : public UObject
{
public:
	unsigned long                                      m_enabled : 1;                                    		// 0x003C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_maxImpactSpawnDistParticles;                    		// 0x0040 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_maxImpactSpawnDistDecals;                       		// 0x0044 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_maxImpactSpawnDistSounds;                       		// 0x0048 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2388 ];

		return pClassPointer;
	};

	bool HandleWeaponImpact ( class UClass* DamageType, struct FVector HitLocation, struct FVector HitNormal, struct FVector RayDir, class UPhysicalMaterial* hitMaterial, class UPrimitiveComponent* HitComponent, struct FName BoneName, int minClusterLevel, unsigned long forceEffects );
};

UClass* UYCollisionEffectMgr::pClassPointer = NULL;

// Class SRGame.YFootstepEffectDefinition
// 0x000C (0x0048 - 0x003C)
class UYFootstepEffectDefinition : public UObject
{
public:
	TArray< struct FYS_PawnFootstepEffectDefinition >  m_footStepEffects;                                		// 0x003C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2389 ];

		return pClassPointer;
	};

};

UClass* UYFootstepEffectDefinition::pClassPointer = NULL;

// Class SRGame.YPhysicalMaterialProperty
// 0x0029 (0x0065 - 0x003C)
class UYPhysicalMaterialProperty : public UPhysicalMaterialPropertyBase
{
public:
	TArray< struct FYS_MaterialEffectDefinition >      m_materialEffects;                                		// 0x003C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_WeaponEffectDefinition >        m_weaponEffects;                                  		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_hasBeenResavedWithNewImpactTypes : 1;           		// 0x0054 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_initialized : 1;                                		// 0x0054 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bFeetSink : 1;                                  		// 0x0054 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_allowBloodPool : 1;                             		// 0x0054 (0x0004) [0x0000000000000000] [0x00000008] 
	class UYFootstepEffectDefinition*                  m_footStepEffectsDef;                             		// 0x0058 (0x0004) [0x0000000000000000]              
	float                                              m_directOcclusion;                                		// 0x005C (0x0004) [0x0000000000000000]              
	float                                              m_reverbOcclusion;                                		// 0x0060 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_physMaterialType;                               		// 0x0064 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2390 ];

		return pClassPointer;
	};

	struct FYS_PawnFootstepEffectDefinition GetFootStepEffectDefinition ( class UClass* PawnClass );
};

UClass* UYPhysicalMaterialProperty::pClassPointer = NULL;

// Class SRGame.YCameraFXEmitter
// 0x0018 (0x021C - 0x0204)
class AYCameraFXEmitter : public AEmitter
{
public:
	class UParticleSystem*                             m_particleSystem;                                 		// 0x0204 (0x0004) [0x0000000000000000]              
	float                                              m_distFromCamera;                                 		// 0x0208 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class AYCamera*                                    m_cam;                                            		// 0x020C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bAllowMultipleInstances : 1;                    		// 0x0210 (0x0004) [0x0000000000000002] [0x00000001] ( CPF_Const )
	float                                              m_xoffset;                                        		// 0x0214 (0x0004) [0x0000000000000000]              
	float                                              m_yoffset;                                        		// 0x0218 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2391 ];

		return pClassPointer;
	};

	void NotifyRetriggered ( );
	void UpdateLocation ( float CamFOVDeg, struct FVector* CamLoc, struct FRotator* CamRot );
	void SetParticleOffset ( float X, float Y );
	void SetParticleRotation ( float Rot );
	void RegisterCamera ( class AYCamera* inCam );
	void Destroyed ( );
	void ActivateEffect ( );
	void PostBeginPlay ( );
};

UClass* AYCameraFXEmitter::pClassPointer = NULL;

// Class SRGame.YCapturePointVolume
// 0x0040 (0x0274 - 0x0234)
class AYCapturePointVolume : public AVolume
{
public:
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x0234 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	float                                              m_pointsPerSecond;                                		// 0x0238 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bActivateFirst : 1;                             		// 0x023C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bEnabled : 1;                                   		// 0x023C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bWasCapturing : 1;                              		// 0x023C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bToggleCaptureSound : 1;                        		// 0x023C (0x0004) [0x0000000000002020] [0x00000008] ( CPF_Net | CPF_Transient )
	class UMaterialInstance*                           m_ShimmerMaterial;                                		// 0x0240 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_FlareObjects;                                   		// 0x0244 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UClass*                                      m_tacIconClass;                                   		// 0x0250 (0x0004) [0x0000000000000000]              
	class UYMarkerBase*                                m_tacIcon;                                        		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              m_fMultiCaptureMultiplier;                        		// 0x0258 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_scoringTeamIndex;                               		// 0x025C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_brokenForTeamNum;                               		// 0x0260 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UAudioComponent*                             m_captureSoundPlayer;                             		// 0x0264 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              m_notificationVoiceTimer;                         		// 0x0268 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_konradScoringVoiceId;                           		// 0x026C (0x0004) [0x0000000000000000]              
	int                                                m_specopsScoringVoiceId;                          		// 0x0270 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2392 ];

		return pClassPointer;
	};

	void OnNotifyRepairVoice ( );
	void UpdateRepairVoice ( );
	void OnNotifySound ( );
	void StopCapturingSound ( );
	void StartCapturingSound ( );
	void SendChangeStateEvent ( );
	void SetFlaresHidden ( unsigned long bHideFlares );
	void SetCapturable ( unsigned long bEnabled );
	void ClientUpdateTouchingPlayers ( float DeltaTime );
	void Tick ( float DeltaTime );
	void UpdateScore ( float DeltaTime );
	void PostBeginPlay ( );
	void SetScoringTeamIndex ( int Index );
	void UpdateBrokeForTeam ( );
	void ScoreUpdated ( class APlayerReplicationInfo* Player );
	void ReplicatedEvent ( struct FName VarName );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	void OnDetected ( unsigned long detected );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	void UpdateIconParameters ( );
	bool IsEnabledForTacView ( );
	void OnToggle ( class USeqAct_Toggle* seqAct );
	struct FBoxSphereBounds GetBounds ( );
};

UClass* AYCapturePointVolume::pClassPointer = NULL;

// Class SRGame.YCharacterCustomizer
// 0x0050 (0x008C - 0x003C)
class UYCharacterCustomizer : public UObject
{
public:
	int                                                m_standardMaterialIndex;                          		// 0x003C (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< struct FYS_CharacterVisDefinition >        m_characterVars;                                  		// 0x0040 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class UClass*                                      m_randomizerStateManagingClass;                   		// 0x004C (0x0004) [0x0000000000000000]              
	TArray< class UClass* >                            m_shyfflrClasses;                                 		// 0x0050 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_usedShyfflrClasses;                             		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_AnimSet >                       m_animSets;                                       		// 0x0068 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FYS_AnimSet >                       m_pistolSpecificAdditionalAnimSets;               		// 0x0074 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FYS_AimingSet >                     m_aimingSets;                                     		// 0x0080 (0x000C) [0x0000000000402002]              ( CPF_Const | CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2393 ];

		return pClassPointer;
	};

	int GetNextShyfflrClass ( );
	int GetNextMaterialIndex ( int meshIdx );
	int GetNextCharacterVarIndex ( );
};

UClass* UYCharacterCustomizer::pClassPointer = NULL;

// Class SRGame.YCheckpoint
// 0x019C (0x01D8 - 0x003C)
class UYCheckpoint : public UObject
{
public:
	int                                                SlotIndex;                                        		// 0x003C (0x0004) [0x0000000000000000]              
	struct FString                                     BaseLevelName;                                    		// 0x0040 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_chapter;                                        		// 0x004C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_mission;                                        		// 0x004D (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentObjective;                               		// 0x004E (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentDifficultyLevel;                         		// 0x004F (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentLowestDifficultyLevel;                   		// 0x0050 (0x0001) [0x0000000000000000]              
	float                                              m_timePlayed;                                     		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                m_currentObjectiveItem;                           		// 0x0058 (0x0004) [0x0000000000000000]              
	int                                                m_currentObjectiveComplete;                       		// 0x005C (0x0004) [0x0000000000000000]              
	struct FString                                     m_checkpointName;                                 		// 0x0060 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FCheckpointTime                             SaveTime;                                         		// 0x006C (0x0010) [0x0000000000000000]              
	struct FYS_SquadSpatialData                        m_spatialData;                                    		// 0x007C (0x0078) [0x0000000000000000]              
	TArray< struct FLevelRecord >                      LevelRecords;                                     		// 0x00F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FActorRecord >                      ActorRecords;                                     		// 0x0100 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned char >                            KismetData;                                       		// 0x010C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UClass* >                            ActorClassesToRecord;                             		// 0x0118 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< class UClass* >                            ActorClassesToDestroy;                            		// 0x0124 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< class UClass* >                            ActorClassesNotToDestroy;                         		// 0x0130 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	struct FString                                     DisplayName;                                      		// 0x013C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_grenadeArray;                                   		// 0x0148 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_grenadeCount;                                   		// 0x0154 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x0160 (0x003C) UNKNOWN PROPERTY: MapProperty SRGame.YCheckpoint.m_persistentDataINT
	unsigned char                                      UnknownData01[ 0x3C ];                            		// 0x019C (0x003C) UNKNOWN PROPERTY: MapProperty SRGame.YCheckpoint.m_persistentDataBOOL

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2394 ];

		return pClassPointer;
	};

	void HideSavingContentWarning ( );
	void ShowSavingContentWarning ( float MinDisplayTime );
	void SaveCurrentInventory ( );
	struct FString GetChapterName ( );
	void PostSaveCheckpoint ( );
	void PreSaveCheckpoint ( );
	void PostLoadCheckpoint ( );
	void CancelEffects ( );
	void PreLoadCheckpoint ( );
	void CancelCurrentPlayerSquadTrigger ( );
	void PreLoadCheckpointLevels ( );
	bool CheckpointIsNewer ( class UYCheckpoint* OtherCheckpoint );
	bool CheckpointTimeIsNewer ( struct FCheckpointTime* inCheckpointTime, struct FCheckpointTime* OtherCheckpointTime );
	bool CheckpointIsEmpty ( );
};

UClass* UYCheckpoint::pClassPointer = NULL;

// Class SRGame.YCinematicVehicle
// 0x0018 (0x024C - 0x0234)
class AYCinematicVehicle : public ASkeletalMeshActor
{
public:
	TArray< struct FYS_CinematicWheelInfo >            m_wheels;                                         		// 0x0234 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              MinDistFactorForUpdate;                           		// 0x0240 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                FireCount;                                        		// 0x0244 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                DieCount;                                         		// 0x0248 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2395 ];

		return pClassPointer;
	};

	void OnCauseDamage ( class USeqAct_ModifyHealth* Action );
	void OnToggle ( class USeqAct_Toggle* Action );
	void PostBeginPlay ( );
	void PostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYCinematicVehicle::pClassPointer = NULL;

// Class SRGame.YComStation
// 0x0034 (0x022C - 0x01F8)
class AYComStation : public AActor
{
public:
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x01F8 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	int                                                m_bActiveTeam;                                    		// 0x01FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bInUse : 1;                                     		// 0x0200 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bFirstTaken : 1;                                		// 0x0200 (0x0004) [0x0000000000000000] [0x00000002] 
	class USkeletalMeshComponent*                      m_ComStationMeshComponent;                        		// 0x0204 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x0208 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )
	class UMaterialInstance*                           m_ShimmerMaterial;                                		// 0x020C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_tacIconClass;                                   		// 0x0210 (0x0004) [0x0000000000000000]              
	class UYMarkerBase*                                m_tacIcon;                                        		// 0x0214 (0x0004) [0x0000000000000000]              
	int                                                m_ActivatingTeam;                                 		// 0x0218 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_comStationID;                                   		// 0x021C (0x0004) [0x0000000000000000]              
	float                                              m_fActivationTime;                                		// 0x0220 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fDeactivationTime;                              		// 0x0224 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPointsPerSecond;                               		// 0x0228 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2396 ];

		return pClassPointer;
	};

	void ActivateComEvent ( );
	void ActivateStation ( int TeamNum, class APawn* InteractionInstigator );
	void DeactivateStation ( class APawn* InteractionInstigator );
	void PostBeginPlay ( );
	void Reset ( );
	void ServerSetInUse ( unsigned long bInUse, int activeTeam );
	float GetDeactivationTime ( );
	float GetActivationTime ( int teamToActivate );
	void ReplicatedEvent ( struct FName VarName );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	void OnDetected ( unsigned long detected );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	void UpdateIconParameters ( );
	bool IsEnabledForTacView ( );
	void OnToggle ( class USeqAct_Toggle* seqAct );
	struct FBoxSphereBounds GetBounds ( );
};

UClass* AYComStation::pClassPointer = NULL;

// Class SRGame.YDeliveryDefendingBase
// 0x0018 (0x024C - 0x0234)
class AYDeliveryDefendingBase : public AVolume
{
public:
	class UMaterialInstance*                           m_ShimmerMaterial;                                		// 0x0234 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_FlareObjects;                                   		// 0x0238 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      m_team;                                           		// 0x0244 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bInUse : 1;                                     		// 0x0248 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2397 ];

		return pClassPointer;
	};

	void Reset ( );
	void PostBeginPlay ( );
	void SetShimmerColor ( );
};

UClass* AYDeliveryDefendingBase::pClassPointer = NULL;

// Class SRGame.YDestroyPoint
// 0x00E0 (0x02D8 - 0x01F8)
class AYDestroyPoint : public AActor
{
public:
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x01F8 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class USkeletalMeshComponent*                      m_StationMeshComponent;                           		// 0x01FC (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x0200 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )
	unsigned char                                      m_team;                                           		// 0x0204 (0x0001) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	unsigned long                                      m_bBlockScoring : 1;                              		// 0x0208 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bRepairable : 1;                                		// 0x0208 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bDestroyed : 1;                                 		// 0x0208 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	float                                              m_fDestroyedRespawnDelayInc;                      		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTimeForAutoRepair;                             		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fDestroyScore;                                  		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fDestructTime;                                  		// 0x0218 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRepairTime;                                    		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_bInUse;                                         		// 0x0220 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UMaterialInstance*                           m_ShimmerMaterial;                                		// 0x0224 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                m_allyStationColorStart;                          		// 0x0228 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_allyStationColorEnd;                            		// 0x0238 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationColorStart;                         		// 0x0248 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationColorEnd;                           		// 0x0258 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_allyStationArrowColor;                          		// 0x0268 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationArrowColor;                         		// 0x0278 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_allyStationColorText;                           		// 0x0288 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationColorText;                          		// 0x0298 (0x0010) [0x0000000000004000]              ( CPF_Config )
	class UAudioComponent*                             m_ambientSoundPlayer;                             		// 0x02A8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_interationSoundPlayer;                          		// 0x02AC (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UYSoundCueFMOD*                              m_sabotageSound;                                  		// 0x02B0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_repairSound;                                    		// 0x02B4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_tacIconClass;                                   		// 0x02B8 (0x0004) [0x0000000000000000]              
	class UYMarkerBase*                                m_tacIcon;                                        		// 0x02BC (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_destroyInteractionSound;                        		// 0x02C0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_repairInteractionSound;                         		// 0x02C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_stationEnabledSound;                            		// 0x02C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_konradDestroyingVoiceId;                        		// 0x02CC (0x0004) [0x0000000000000000]              
	int                                                m_specopsDestroyingVoiceId;                       		// 0x02D0 (0x0004) [0x0000000000000000]              
	float                                              m_notificationVoiceTimer;                         		// 0x02D4 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2398 ];

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void OnNotifySound ( );
	void SetInUse ( int bInUse );
	void UpdateInteractionSound ( unsigned long bWasInUse );
	void ReplicatedEvent ( struct FName VarName );
	void Reset ( );
	void SetShimmerColor ( unsigned long Repaired );
	void Repaired ( );
	void SetIsDestroyed ( );
	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	void OnDetected ( unsigned long detected );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	void UpdateIconParameters ( );
	bool IsEnabledForTacView ( );
	void OnToggle ( class USeqAct_Toggle* seqAct );
	struct FBoxSphereBounds GetBounds ( );
};

UClass* AYDestroyPoint::pClassPointer = NULL;

// Class SRGame.YDifficultyProvider
// 0x000C (0x0048 - 0x003C)
class UYDifficultyProvider : public UObject
{
public:
	class UYDifficultyProvider*                        m_instance;                                       		// 0x003C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_currentDifficultyLevel;                         		// 0x0040 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentLowestDifficultyLevel;                   		// 0x0041 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_pendingDifficultyLevel;                         		// 0x0042 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_hasPendingDifficultyLevel : 1;                  		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_allowChangeByCheckpoint : 1;                    		// 0x0044 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2399 ];

		return pClassPointer;
	};

	void ResetLowestDifficulty ( );
	bool HasPendingDifficultyLevel ( );
	void ApplyPendingDifficultyLevel ( );
	void SetPendingDifficultyLevel ( unsigned char DiffLevel );
	void SetDifficultyLevel ( unsigned char DiffLevel, unsigned long byCheckpoint );
	void SetDifficultyFromCheckpoint ( unsigned char DiffLevel, unsigned char LowestDiffLevel );
	class UYDifficultyProvider* GetInstance ( );
};

UClass* UYDifficultyProvider::pClassPointer = NULL;

// Class SRGame.YDifficultySetting
// 0x0098 (0x00D4 - 0x003C)
class UYDifficultySetting : public UObject
{
public:
	struct FString                                     m_name;                                           		// 0x003C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_description;                                    		// 0x0048 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	float                                              m_playerBulletAttractionRadius;                   		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_playerBulletAttractionWeight;                   		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_playerDamage;                                   		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_playerHealth;                                   		// 0x0060 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_squadDamage;                                    		// 0x0064 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_squadHealth;                                    		// 0x0068 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_enemyDamage;                                    		// 0x006C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_enemyHealth;                                    		// 0x0070 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_aIProfileBasicEnemy;                            		// 0x0074 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_aIProfileEnemy1;                                		// 0x0080 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_aIProfileEnemy2;                                		// 0x008C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_aIProfileEnemy3;                                		// 0x0098 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_aIProfileEnemy4;                                		// 0x00A4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_aIProfileEnemy5;                                		// 0x00B0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_aIProfileEnemy6;                                		// 0x00BC (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_aIProfileEnemy7;                                		// 0x00C8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2400 ];

		return pClassPointer;
	};

};

UClass* UYDifficultySetting::pClassPointer = NULL;

// Class SRGame.YGameEngine
// 0x0264 (0x0914 - 0x06B0)
class UYGameEngine : public UGameEngine
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                     		// 0x06B0 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FYS_CheckpointData                          m_checkpointData;                                 		// 0x06B4 (0x0090) [0x0000000000000000]              
	unsigned char                                      m_currentSaveSlot;                                		// 0x0744 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_inviteState;                                    		// 0x0745 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_numberOfReloadsBecausePlayerDiedAmmo;           		// 0x0748 (0x0004) [0x0000000000000000]              
	int                                                m_numberOfReloadsBecausePlayerDiedDifficulty;     		// 0x074C (0x0004) [0x0000000000000000]              
	class UYCheckpoint*                                m_verifyCheckpoint;                               		// 0x0750 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_CheckpointIODummy                       m_checkpointIO;                                   		// 0x0754 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                CurrentUserID;                                    		// 0x0758 (0x0004) [0x0000000000000000]              
	int                                                CurrentDeviceID;                                  		// 0x075C (0x0004) [0x0000000000000000]              
	int                                                TempDeviceID;                                     		// 0x0760 (0x0004) [0x0000000000000000]              
	unsigned long                                      bHasSelectedValidStorageDevice : 1;               		// 0x0764 (0x0004) [0x0000000000002002] [0x00000001] ( CPF_Const | CPF_Transient )
	unsigned long                                      bStorageDeviceRemoved : 1;                        		// 0x0764 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_ignoreLoginChange : 1;                          		// 0x0764 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_travellingToMenu : 1;                           		// 0x0764 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_travelingBackToOnlineMenuRequiresCleanUp : 1;   		// 0x0764 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      bCheckpointLoadInProgress : 1;                    		// 0x0764 (0x0004) [0x0000000000002002] [0x00000020] ( CPF_Const | CPF_Transient )
	unsigned long                                      m_hasConnectedGamepadPC : 1;                      		// 0x0764 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_drawVersionInfo : 1;                            		// 0x0764 (0x0004) [0x0000000000044000] [0x00000080] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      m_showPausedIcon : 1;                             		// 0x0764 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_gameInFocus : 1;                                		// 0x0764 (0x0004) [0x0000000000002000] [0x00000200] ( CPF_Transient )
	unsigned long                                      m_showRotatorIcon : 1;                            		// 0x0764 (0x0004) [0x0000000000002000] [0x00000400] ( CPF_Transient )
	unsigned long                                      bSkipMessageEnabled : 1;                          		// 0x0764 (0x0004) [0x0000000000002000] [0x00000800] ( CPF_Transient )
	unsigned long                                      bSkipInputEnabled : 1;                            		// 0x0764 (0x0004) [0x0000000000002000] [0x00001000] ( CPF_Transient )
	unsigned long                                      bSkipMessagePending : 1;                          		// 0x0764 (0x0004) [0x0000000000002000] [0x00002000] ( CPF_Transient )
	unsigned long                                      bMidGameMenuOpened : 1;                           		// 0x0764 (0x0004) [0x0000000000002000] [0x00004000] ( CPF_Transient )
	unsigned long                                      bHasDisplayedSaveWarningMessage : 1;              		// 0x0764 (0x0004) [0x0000000000002000] [0x00008000] ( CPF_Transient )
	unsigned long                                      bIsDrawingBinkMoveIcons : 1;                      		// 0x0764 (0x0004) [0x0000000000002000] [0x00010000] ( CPF_Transient )
	unsigned long                                      m_bIsCampaignMap : 1;                             		// 0x0764 (0x0004) [0x0000000000002000] [0x00020000] ( CPF_Transient )
	unsigned long                                      m_playingDashboardMusic : 1;                      		// 0x0764 (0x0004) [0x0000000000002000] [0x00040000] ( CPF_Transient )
	unsigned long                                      m_isDemoBuild : 1;                                		// 0x0764 (0x0004) [0x0000000000004000] [0x00080000] ( CPF_Config )
	unsigned long                                      m_isPressDemoBuild : 1;                           		// 0x0764 (0x0004) [0x0000000000004000] [0x00100000] ( CPF_Config )
	unsigned long                                      m_isPressDemo_2Build : 1;                         		// 0x0764 (0x0004) [0x0000000000004000] [0x00200000] ( CPF_Config )
	unsigned long                                      m_isPublicDemoBuild : 1;                          		// 0x0764 (0x0004) [0x0000000000004000] [0x00400000] ( CPF_Config )
	unsigned long                                      m_showMissingUIDWarningsInShippingBuild : 1;      		// 0x0764 (0x0004) [0x0000000000004000] [0x00800000] ( CPF_Config )
	unsigned long                                      m_isOriginalAudioForced : 1;                      		// 0x0764 (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      m_forceControllerDisconnectMessagePS3 : 1;        		// 0x0764 (0x0004) [0x0000000000002000] [0x02000000] ( CPF_Transient )
	class UYBoneData*                                  m_boneData;                                       		// 0x0768 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_timeSinceLastCtrlCheck;                         		// 0x076C (0x0004) [0x0000000000000000]              
	int                                                m_controller[ 0x4 ];                              		// 0x0770 (0x0010) [0x0000000000000000]              
	TArray< struct FYExodusScoreInfo >                 m_exodusScores;                                   		// 0x0780 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UYOOMHandler*                                m_oomHandler;                                     		// 0x078C (0x0004) [0x0000000000000000]              
	int                                                m_skipMessageGapSize;                             		// 0x0790 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_skipSequenceMessageButton;                      		// 0x0794 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_skipSequenceMessageButtonAlt;                   		// 0x07A0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_skipSequenceMessageText;                        		// 0x07AC (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_skipSequenceMessageTextPC;                      		// 0x07B8 (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_loadingMessageText;                             		// 0x07C4 (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FVector2D                                   m_loadSaveIconSize;                               		// 0x07D0 (0x0008) [0x0000000000004000]              ( CPF_Config )
	struct FVector2D                                   m_loadSaveIconPadding;                            		// 0x07D8 (0x0008) [0x0000000000004000]              ( CPF_Config )
	class UMaterialInterface*                          m_loadIconMat;                                    		// 0x07E0 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_saveIconMat;                                    		// 0x07E4 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          m_pauseIconMat;                                   		// 0x07E8 (0x0004) [0x0000000000000000]              
	struct FYS_PositionCache                           m_posCache[ 0x4 ];                                		// 0x07EC (0x00E0) [0x0000000000100000]              
	struct FThreadSafeCounter                          m_saveInProgress;                                 		// 0x08CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FThreadSafeCounter                          m_lastSavingTimeStamp;                            		// 0x08D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FString >                           m_fadeToWhiteMovies;                              		// 0x08D4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_pendingTicksBeforeStopMovie;                    		// 0x08E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_numMissingUIDScreenWarnings;                    		// 0x08E4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_missinUIDWarningDisplayDuration;                		// 0x08E8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_lastMissingUIDEntryTimeStamp;                   		// 0x08EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< int >                                      m_missingUIDs;                                    		// 0x08F0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FString >                           m_foundLocDataLanguages;                          		// 0x08FC (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class UYProfileWriter*                             m_profileWriter;                                  		// 0x0908 (0x0004) [0x0000000000000000]              
	int                                                m_realPS3ControllerIndex;                         		// 0x090C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_disconnectedPS3ControllerIndex;                 		// 0x0910 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2401 ];

		return pClassPointer;
	};

	bool IsAtTitleScreen ( );
	bool UpdatePreorderInstallChangedDLC ( );
	bool UpdatePreorderInstall ( struct FScriptDelegate SelectionCallback );
	bool PreorderMessageAccepted ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void ShowCorruptedMessage ( );
	bool OnDeviceSelectedValidation ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void ShowDeviceSelectedValidationMessageBox ( );
	void ShowNoDeviceSelectedMessageBox ( );
	void ShowInvalidDLCVersionMessageBox ( );
	void ClearCashedIconValues ( );
	bool GamepadConnected ( );
	bool CheckForCorruptedSaveDevice ( );
	bool IsPressDemoBuild ( );
	bool IsDemoBuild ( );
	bool IsFullShippingBuild ( );
	void IncreaseDeathCounterInternal ( unsigned long Ammo, unsigned long Difficulty );
	void ResetDeathCounterInternal ( unsigned long Ammo, unsigned long Difficulty );
	void SetMidGameMenuOpened ( unsigned long Enable );
	struct FString GetBuildTime ( );
	struct FString GetChangeList ( );
	bool AreAllStreamingManagerRequestsFinished ( );
	void CatchOOM ( );
	struct FString GetMainMemoryUsageMB ( );
	struct FString GetDefaultLocalMap ( );
	void OnControllerDetached ( int controllerIdx );
	void OnControllerAttached ( int controllerIdx );
	void InitializeOnlineDelegates ( );
	void InitBoneData ( );
	void OnUserChanged ( );
	void OnStorageDeviceRemoved ( );
	void OnStorageDeviceChanged ( );
	void OnLoginChanged ( unsigned char LocalUserNum );
	bool AreStorageWritesAllowed ( unsigned long bIgnoreDeviceStatus, int RequiredSize );
	bool IsCurrentDeviceValid ( int SizeNeeded );
	void InitCheckpointSystem ( unsigned long forceVerify );
	struct FCheckpointEnumerationResult VerifyCheckpointData ( );
	bool HasStorageDeviceBeenRemoved ( );
	int GetCurrentDeviceID ( );
	void SetCurrentDeviceID ( int NewDeviceID );
	int GetCurrentUserID ( );
	void SetCurrentUserID ( int NewUserID );
	class AWorldInfo* GetWorldInfo ( );
};

UClass* UYGameEngine::pClassPointer = NULL;

// Class SRGame.YGameInfo
// 0x01CC (0x0558 - 0x038C)
class AYGameInfo : public AGameInfo
{
public:
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x038C (0x003C) UNKNOWN PROPERTY: MapProperty SRGame.YGameInfo.m_PersitentDataINT
	unsigned char                                      UnknownData01[ 0x3C ];                            		// 0x03C8 (0x003C) UNKNOWN PROPERTY: MapProperty SRGame.YGameInfo.m_PersitentDataBOOL
	unsigned long                                      m_allowFriendlyFire : 1;                          		// 0x0404 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_allowFriendlyFire4Player : 1;                   		// 0x0404 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_gameHasTeamLeaders : 1;                         		// 0x0404 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_bDisplayLeaderStatusInName : 1;                 		// 0x0404 (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	unsigned long                                      m_waitingPlayersGoSpectateView : 1;               		// 0x0404 (0x0004) [0x0000000000004001] [0x00000010] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_enableTacticalView : 1;                         		// 0x0404 (0x0004) [0x0000000000004000] [0x00000020] ( CPF_Config )
	unsigned long                                      m_autoRespawn : 1;                                		// 0x0404 (0x0004) [0x0000000000004001] [0x00000040] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_showClock : 1;                                  		// 0x0404 (0x0004) [0x0000000000004001] [0x00000080] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_bDelaySpawning : 1;                             		// 0x0404 (0x0004) [0x0000000000004000] [0x00000100] ( CPF_Config )
	unsigned long                                      m_bAllowAiStuckResponse : 1;                      		// 0x0404 (0x0004) [0x0000000000004000] [0x00000200] ( CPF_Config )
	unsigned long                                      bForceRespawn : 1;                                		// 0x0404 (0x0004) [0x0000000000044000] [0x00000400] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bTempForceRespawn : 1;                            		// 0x0404 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      bWaitForNetPlayers : 1;                           		// 0x0404 (0x0004) [0x0000000000044000] [0x00001000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bQuickStart : 1;                                  		// 0x0404 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      bSkipPlaySound : 1;                               		// 0x0404 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      bMustJoinBeforeStart : 1;                         		// 0x0404 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      bDemoMode : 1;                                    		// 0x0404 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      bConsoleServer : 1;                               		// 0x0404 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      bAllowKeyboardAndMouse : 1;                       		// 0x0404 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      bMidGameHasMap : 1;                               		// 0x0404 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      bForceMidGameMenuAtStart : 1;                     		// 0x0404 (0x0004) [0x0000000000004000] [0x00100000] ( CPF_Config )
	unsigned long                                      m_punishInnocentKills : 1;                        		// 0x0404 (0x0004) [0x0000000000004000] [0x00200000] ( CPF_Config )
	unsigned long                                      m_lastKillWasInCombat : 1;                        		// 0x0404 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      m_inCombatSituation : 1;                          		// 0x0404 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_blockShyfflrUpdates : 1;                        		// 0x0404 (0x0004) [0x0000000000002000] [0x01000000] ( CPF_Transient )
	class UYDamageManager*                             m_damageManager;                                  		// 0x0408 (0x0004) [0x0000000000000000]              
	TArray< class UYDamageEvaluationParams* >          m_predefinedDamageParams;                         		// 0x040C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             m_predefinedDamageParamNames;                     		// 0x0418 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AYFogVolumeSandDensityInfo* >        m_fogSandVolumes;                                 		// 0x0424 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AYFogVolumeSandDensityInfo* >        m_fogStaticSandVolumes;                           		// 0x0430 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_TeamInfoDesc >                  m_teamDesc;                                       		// 0x043C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AYTeamInfo* >                        m_teams;                                          		// 0x0448 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UClass*                                      m_dbnoRuleClass;                                  		// 0x0454 (0x0004) [0x0000000000000000]              
	class UYDBNORule*                                  m_dbnoRule;                                       		// 0x0458 (0x0004) [0x0000000000000000]              
	float                                              m_respawnDelay;                                   		// 0x045C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UYSpecialActionSuppressor*                   m_specialActionSuppressor;                        		// 0x0460 (0x0004) [0x0000000000000000]              
	TArray< class AController* >                       m_controllersSpawnPending;                        		// 0x0464 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class UClass*                                      m_arsenalManagerClass;                            		// 0x0470 (0x0004) [0x0000000000000000]              
	TArray< class AYPlayerStart* >                     m_playerStarts;                                   		// 0x0474 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     Acronym;                                          		// 0x0480 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     Description;                                      		// 0x048C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	int                                                MinNetPlayers;                                    		// 0x0498 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	int                                                DesiredPlayerCount;                               		// 0x049C (0x0004) [0x0000000000000000]              
	float                                              SpawnProtectionTime;                              		// 0x04A0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                DefaultMaxLives;                                  		// 0x04A4 (0x0004) [0x0000000000000000]              
	int                                                LateEntryLives;                                   		// 0x04A8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class ANavigationPoint*                            LastPlayerStartSpot;                              		// 0x04AC (0x0004) [0x0000000000000000]              
	class ANavigationPoint*                            LastStartSpot;                                    		// 0x04B0 (0x0004) [0x0000000000000000]              
	float                                              EndTime;                                          		// 0x04B4 (0x0004) [0x0000000000000000]              
	int                                                EndMessageWait;                                   		// 0x04B8 (0x0004) [0x0000000000000000]              
	class AActor*                                      EndGameFocus;                                     		// 0x04BC (0x0004) [0x0000000000000000]              
	class UClass*                                      VictoryMessageClass;                              		// 0x04C0 (0x0004) [0x0000000000000000]              
	class UClass*                                      StartupMessageClass;                              		// 0x04C4 (0x0004) [0x0000000000000000]              
	class UClass*                                      GameplayAnnouncementMessageClass;                 		// 0x04C8 (0x0004) [0x0000000000000000]              
	TArray< struct FString >                           MapPrefixes;                                      		// 0x04CC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UClass*                                      ConsolePlayerControllerClass;                     		// 0x04D8 (0x0004) [0x0000000000000000]              
	int                                                SinglePlayerMissionID;                            		// 0x04DC (0x0004) [0x0000000000000000]              
	struct FString                                     DemoPrefix;                                       		// 0x04E0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UYUIScenes*                                  MidGameMenuTemplate;                              		// 0x04EC (0x0004) [0x0000000000000000]              
	struct FString                                     EndOfMatchRulesTemplateStr_Scoring;               		// 0x04F0 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     EndOfMatchRulesTemplateStr_Time;                  		// 0x04FC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	class USpeechRecognition*                          SpeechRecognitionData;                            		// 0x0508 (0x0004) [0x0000000000000000]              
	struct FName                                       MidgameScorePanelTag;                             		// 0x050C (0x0008) [0x0000000000000000]              
	float                                              m_innocentDamageLockTime;                         		// 0x0514 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_innocentKillLockTime;                           		// 0x0518 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_innocenMortarLockTime;                          		// 0x051C (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_numInnocentKills;                               		// 0x0520 (0x0004) [0x0000000000000000]              
	int                                                m_numInnocentDamage;                              		// 0x0524 (0x0004) [0x0000000000000000]              
	float                                              m_lastInnocentDamageTime;                         		// 0x0528 (0x0004) [0x0000000000000000]              
	float                                              m_lastInnocentKillTime;                           		// 0x052C (0x0004) [0x0000000000000000]              
	float                                              m_lastInnocentMortarTime;                         		// 0x0530 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_crosshairIndicatorClass;                        		// 0x0534 (0x0004) [0x0000000000000000]              
	class USkeletalMesh*                               m_overrideSpawnMesh;                              		// 0x0538 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_modeSpecificAssets;                             		// 0x053C (0x0004) [0x0000000000000000]              
	int                                                m_maxAllowedDeadRagDollPawnsConfig;               		// 0x0540 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	int                                                m_maxAllowedDeadRagDollPawnsCurrent;              		// 0x0544 (0x0004) [0x0000000000000000]              
	float                                              m_ragdollDestructionDistanceThreshold;            		// 0x0548 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_minTimeBeforeDeadBeforeDestroyed;               		// 0x054C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_sessionTimestamp;                               		// 0x0550 (0x0004) [0x0000000000000000]              
	int                                                m_maxDynamicDecals;                               		// 0x0554 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2402 ];

		return pClassPointer;
	};

	void UpdateGameplayMuteList ( class APlayerController* PC );
	void ManageDeadPawns ( );
	void GetMenuType ( );
	void SandstormStopped ( );
	void StopSandstorm ( );
	void SandstormStarted ( );
	void StartSandstorm ( );
	void InitSandstorm ( );
	void RecalculateSkillRating ( );
	void UpdateMuteList ( class AYPlayerController_MPBase* Other );
	void UpdatePlayersMuteLists ( );
	void NotifyOutOfAmmoAllWeapons ( class AController* YPC );
	void NotifyLowOnAmmo ( class AController* YPC, unsigned char WeaponId );
	void NotifyOutOfAmmo ( class AController* YPC, unsigned char WeaponId );
	bool MatchIsInProgress ( );
	bool JustStarted ( float MaxElapsedTime );
	void logdifficulty ( );
	void testdifficulty ( int Level );
	void ShowSquads ( );
	bool AllowCheats ( class APlayerController* P );
	bool GetTravelType ( );
	void ContinueSeamlessTravel ( );
	void HandleSeamlessTravelPlayer ( class AController** C );
	struct FString GetBeaconText ( );
	struct FString GetNextMap ( );
	struct FString GetEndOfMatchRules ( int InGoalScore, int InTimeLimit );
	void BroadcastDeathMessage ( class AController* Killer, class AController* Other, class UClass* DamageType );
	bool SkipPlaySound ( );
	void SortPlayerScores ( TArray< struct FOnlinePlayerScore >* PlayerScores );
	void CallKismetDeathEvents ( class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, unsigned long onlyDBNO );
	void Killed ( class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType );
	void Downed ( class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType );
	void ScoreRevive ( class AYPlayerReplicationInfo* Reviver, class AYPlayerReplicationInfo* Revived );
	void ScoreTakeDown ( class AController* Killer, class AController* Other );
	void YScoreKill ( class AController* Killer, class AController* Killed, class APawn* KilledPawn, class UClass* DamageType );
	void ScoreKill ( class AController* Killer, class AController* Other );
	void OverrideEndOfMatchRulesTemplateStrings ( struct FString Scoring, struct FString Time );
	void ProcessSpeechRecognition ( class AYPlayerController* Speaker, TArray< struct FSpeechRecognizedWord >* Words );
	void StartMatch ( );
	void SendPreStartMatch ( );
	void KillBot ( class AYAIController* B, unsigned long bDestroyController );
	void KillBots ( );
	void InitializeBot ( class AYAIBaseController* Bot );
	float RatePlayerStart ( class APlayerStart* P, unsigned char Team, class AController* Player );
	class APlayerStart* ChoosePlayerStart ( class AController* Player, unsigned char InTeam );
	class ANavigationPoint* FindPlayerStart ( class AController* Player, unsigned char InTeam, struct FString IncomingName );
	bool IsAWinner ( class APlayerController* C );
	float SpawnWait ( class AAIController* B );
	bool WantFastSpawnFor ( class AAIController* B );
	bool ShouldRespawn ( class APickupFactory* Other );
	bool ForceRespawn ( );
	void ResetInnocentKills ( );
	void PunishInnocentKills ( unsigned char npcCategory, unsigned long Kill, unsigned long combat, class UClass* DamageType, class AController* Killer, class AController* Victim );
	void CheckForInnocentKills ( class AController* Killer, class AController* Victim, class UClass* DamageType, unsigned long Kill );
	void ReduceDamage ( class APawn* injured, class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, class AActor* DamageCauser, int* Damage, struct FVector* Momentum );
	int LevelRecommendedPlayers ( );
	bool GetSinglePlayerResult ( );
	void BecomeLeader ( class AYPlayerController* C );
	class AYPlayerReplicationInfo* FindTeamLeader ( int TeamIdx );
	void BroadcastWelcomeMessage ( class APlayerReplicationInfo* PRI, class AYTeamInfo* NewTeam );
	void YBroadcastLocalizedTeam ( class AActor* Sender, class UClass* Message, class ATeamInfo* SendTeam, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject, struct FName SquadName );
	void SetPartyMemberTeam ( class APlayerController* PC, class AYTeamInfo* NewTeam );
	void SetTeam ( class AController* Other, class AYTeamInfo* NewTeam );
	bool AllowBecomeActivePlayer ( class APlayerController* P );
	bool BecomeSpectator ( class APlayerController* P );
	class AYCameraActor* GetPrevSpectatorPoint ( class AYCameraActor* CurrPoint );
	class AYCameraActor* GetNextSpectatorPoint ( class AYCameraActor* CurrPoint );
	class AYCameraActor* GetFirstSpectatorPoint ( );
	void SetPlayerDefaults ( class APawn* PlayerPawn );
	void SetPlayerChar ( struct FString Type );
	void SetPlayerClass ( class AController* Other, int N );
	void GameEnding ( );
	void OnGameShutdown ( );
	void PostCommitMapChange ( );
	void OnChapterChanged ( );
	bool GetStartingArsenalForPlayer ( class AYGamePawn* pwn, unsigned long testOnly, class UClass** wpToAdd, int* startAmmo, int* StartMag );
	void RestartFromCheckpoint ( class AController* PC );
	void AddPlayerToSpawnEvent ( class AController* aPlayer );
	void PlayerRestartComplete ( class AController* aPlayer );
	void NotifyCompletedDelayedPlayerStart ( );
	void DelayedPlayerStart ( );
	void BaseRestartPlayer ( class AController* NewPlayer );
	void RestartPlayer ( class AController* aPlayer );
	void RestartGame ( );
	void Reset ( );
	void Tick ( float DeltaTime );
	void ChangeName ( class AController* Other, struct FString S, unsigned long bNameChange );
	bool AtCapacity ( unsigned long bSpectator );
	void Logout ( class AController* Exiting );
	void WriteOnlinePlayerScores ( );
	void UpdateGameSettingsCounts ( );
	void UpdateGameSettings ( );
	void PostLogin ( class APlayerController* NewPlayer );
	class APlayerController* Login ( struct FString Portal, struct FString Options, struct FUniqueNetId UniqueId, struct FString* ErrorMessage );
	void PostBeginPlay ( );
	void PreBeginPlay ( );
	void DestroyStormInfo ( );
	void CreateStormInfo ( );
	void EnableDamageManagerDebug ( unsigned long Enable );
	void CreateDamageParams ( );
	void CreateDamageManager ( );
	bool IsMultiplayer ( );
	class UClass* SetGameType ( struct FString MapName, struct FString Options, struct FString Portal );
	void InitGameReplicationInfo ( );
	void EditDBNORule ( );
	void SwitchDBNORule ( struct FString rule );
	void InitDBNORules ( );
	void InitGame ( struct FString Options, struct FString* ErrorMessage );
	void SetGameSpeed ( float T );
	void NotifyKilled ( class AController* Killer, class AController* Killed, class APawn* KilledPawn, class UClass* DamageType );
	int GetHumanPlayerCount ( );
	unsigned char GetNeutralTeamIndex ( );
	unsigned char GetPlayerTeamIndex ( );
	int GetForcedTeam ( class AController* Other, int Team );
	bool ChangeTeam ( class AController* Other, int N, unsigned long bNewTeam );
	unsigned char PickTeam ( unsigned char Num, class AController* C );
	void InitializeTeams ( );
	void OnMatineeStartPlaying ( class UInterpData* InterpData );
	bool IsInCombatMode ( );
	void SetGameCombatMode ( unsigned long combat );
	class AYGameReplicationInfo* GetGRI ( );
	void ClearPersistentDataBOOL ( );
	bool GetPersistentDataBOOL ( struct FString keySTR );
	void SetPersistenDataBOOL ( struct FString keySTR, unsigned long Data );
	void ClearPersistentDataINT ( );
	int GetPersistentDataINT ( struct FString keySTR );
	void SetPersistenDataINT ( struct FString keySTR, int Data );
};

UClass* AYGameInfo::pClassPointer = NULL;

// Class SRGame.YGameInfo_MP
// 0x05D4 (0x0B2C - 0x0558)
class AYGameInfo_MP : public AYGameInfo
{
public:
	unsigned long                                      m_bDBNOSpectateEnabled : 1;                       		// 0x0558 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_tieGameEndsRound : 1;                           		// 0x0558 (0x0004) [0x0000000000004001] [0x00000002] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_deathBasedTeamScore : 1;                        		// 0x0558 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_bGameEnding : 1;                                		// 0x0558 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_bEnableXPSystem : 1;                            		// 0x0558 (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	unsigned long                                      m_bForceXPSystemEnabled : 1;                      		// 0x0558 (0x0004) [0x0000000000044000] [0x00000020] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bFirstBlood : 1;                                  		// 0x0558 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bConsiderPlayTimeForMatchEndBaseXP : 1;         		// 0x0558 (0x0004) [0x0000000000004000] [0x00000080] ( CPF_Config )
	unsigned long                                      bAutoNumBots : 1;                                 		// 0x0558 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      bPlayersVsBots : 1;                               		// 0x0558 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bUseSquadRespawnForSpecops : 1;                 		// 0x0558 (0x0004) [0x0000000000004000] [0x00000400] ( CPF_Config )
	unsigned long                                      m_bUseSquadRespawnForKonrad : 1;                  		// 0x0558 (0x0004) [0x0000000000004000] [0x00000800] ( CPF_Config )
	unsigned long                                      m_bForceRespawnForPlayersInDeathState : 1;        		// 0x0558 (0x0004) [0x0000000000004000] [0x00001000] ( CPF_Config )
	unsigned long                                      m_bSpecopsSeeEnemyOnRespawn : 1;                  		// 0x0558 (0x0004) [0x0000000000004000] [0x00002000] ( CPF_Config )
	unsigned long                                      m_bKonradSeeEnemyOnRespawn : 1;                   		// 0x0558 (0x0004) [0x0000000000004000] [0x00004000] ( CPF_Config )
	unsigned long                                      bPlayersMustBeReady : 1;                          		// 0x0558 (0x0004) [0x0000000000004000] [0x00008000] ( CPF_Config )
	unsigned long                                      m_bWaitForTextureStreaming : 1;                   		// 0x0558 (0x0004) [0x0000000000004000] [0x00010000] ( CPF_Config )
	unsigned long                                      bPlayersBalanceTeams : 1;                         		// 0x0558 (0x0004) [0x0000000000004000] [0x00020000] ( CPF_Config )
	unsigned long                                      m_ReplaceDroppingKonrad : 1;                      		// 0x0558 (0x0004) [0x0000000000004000] [0x00040000] ( CPF_Config )
	unsigned long                                      m_ReplaceDroppingSpecops : 1;                     		// 0x0558 (0x0004) [0x0000000000004000] [0x00080000] ( CPF_Config )
	unsigned long                                      m_AllowSpecopsHotSwap : 1;                        		// 0x0558 (0x0004) [0x0000000000004000] [0x00100000] ( CPF_Config )
	unsigned long                                      m_bEndGameOnEmptyTeam : 1;                        		// 0x0558 (0x0004) [0x0000000000004000] [0x00200000] ( CPF_Config )
	unsigned long                                      m_bAutoOpenCharacterSelectionMenu : 1;            		// 0x0558 (0x0004) [0x0000000000004000] [0x00400000] ( CPF_Config )
	unsigned long                                      bScoreTeamKills : 1;                              		// 0x0558 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      bSpawnInTeamArea : 1;                             		// 0x0558 (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      bTeamScoreRounds : 1;                             		// 0x0558 (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      bOverTimeBroadcast : 1;                           		// 0x0558 (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      m_bUseFixedTeamColors : 1;                        		// 0x0558 (0x0004) [0x0000000000004000] [0x08000000] ( CPF_Config )
	unsigned long                                      m_bUseFixedTeamColorsForCrosshair : 1;            		// 0x0558 (0x0004) [0x0000000000004000] [0x10000000] ( CPF_Config )
	unsigned long                                      m_bUseFixedTeamColorsForNames : 1;                		// 0x0558 (0x0004) [0x0000000000004000] [0x20000000] ( CPF_Config )
	unsigned long                                      m_useNeutralColorsForNames : 1;                   		// 0x0558 (0x0004) [0x0000000000004000] [0x40000000] ( CPF_Config )
	unsigned long                                      m_bHasMinNetPlayers : 1;                          		// 0x0558 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned char                                      m_currentStartMachSequence;                       		// 0x055C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_bForceSeeLifeBarOfTargetedPawn[ 0x2 ];          		// 0x055D (0x0002) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_StartupStage;                                   		// 0x055F (0x0001) [0x0000000000000000]              
	unsigned char                                      m_MultiplayerModeId;                              		// 0x0560 (0x0001) [0x0000000000000002]              ( CPF_Const )
	struct FYS_XPModifier                              m_xpPerFirstBloodKill;                            		// 0x0564 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerGhostKill;                                 		// 0x0578 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerHawkeyeKill;                               		// 0x058C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerAvengedKill;                               		// 0x05A0 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerEnemyPlayerKill;                           		// 0x05B4 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerEnemyBotKill;                              		// 0x05C8 (0x0014) [0x0000000000004000]              ( CPF_Config )
	int                                                m_xpPerSuccessiveKill;                            		// 0x05DC (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_numKillMsg;                                     		// 0x05E0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_noXpDueToFriendlyFire;                          		// 0x05E4 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerTeamKill;                                  		// 0x05F8 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerSpawnKill;                                 		// 0x060C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerAssist;                                    		// 0x0620 (0x0014) [0x0000000000004000]              ( CPF_Config )
	float                                              m_damagePercentageForAssist;                      		// 0x0634 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerExecution;                                 		// 0x0638 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerHeal;                                      		// 0x064C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerHealed;                                    		// 0x0660 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerChallenge;                                 		// 0x0674 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerHeadShotKill;                              		// 0x0688 (0x0014) [0x0000000000004000]              ( CPF_Config )
	int                                                m_deathStreakThreshold;                           		// 0x069C (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerRecovery;                                  		// 0x06A0 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerLooter;                                    		// 0x06B4 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerARealGoGetter;                             		// 0x06C8 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerDoubleKill;                                		// 0x06DC (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerTripleKill;                                		// 0x06F0 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerMultikill;                                 		// 0x0704 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerDetonator;                                 		// 0x0718 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerHelpingHand;                               		// 0x072C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerExecutioner;                               		// 0x0740 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerAvenged;                                   		// 0x0754 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerMadBomber;                                 		// 0x0768 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerBombSquad;                                 		// 0x077C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerGungHo;                                    		// 0x0790 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerSandAvalancheKill;                         		// 0x07A4 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPer10killsnodeath;                            		// 0x07B8 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerVaultKills;                                		// 0x07CC (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerYachtFind;                                 		// 0x07E0 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPromotionEvent;                               		// 0x07F4 (0x0014) [0x0000000000004000]              ( CPF_Config )
	float                                              m_TimeForAvengeKill;                              		// 0x0808 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerZiplineGrenadeKills;                       		// 0x080C (0x0014) [0x0000000000004000]              ( CPF_Config )
	float                                              m_TeammateSaveTime;                               		// 0x0820 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerTeammateSave;                              		// 0x0824 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerDisarmingTeammateMine;                     		// 0x0838 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerDisarmingSelfMine;                         		// 0x084C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerDisarmingC4;                               		// 0x0860 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerOccupyingForce;                            		// 0x0874 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpForBeyondCallDuty;                            		// 0x0888 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpForLastLineOfDefense;                         		// 0x089C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpForBehindEnemyLines;                          		// 0x08B0 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerOnTheBall;                                 		// 0x08C4 (0x0014) [0x0000000000004000]              ( CPF_Config )
	float                                              m_OnTheBallDisarmTime;                            		// 0x08D8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPPerVictory;                           		// 0x08DC (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPPerDefeat;                            		// 0x08F8 (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPPerDraw;                              		// 0x0914 (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromTeamScore;                        		// 0x0930 (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromPlayerPos;                        		// 0x094C (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromKills;                            		// 0x0968 (0x001C) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fXPModifier;                                    		// 0x0984 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPlayerStartMaxReuseTime;                       		// 0x0988 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPlayerStartMaxHorizontalDist[ 0x25 ];          		// 0x098C (0x0094) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPlayerStartMaxVerticalDist;                    		// 0x0A20 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPlayerStartTimingWeight;                       		// 0x0A24 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPlayerStartDistanceToTeammateWeight;           		// 0x0A28 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPlayerStartDistanceToEnemyWeight;              		// 0x0A2C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPlayerStartSeenByEnemyWeight;                  		// 0x0A30 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPlayerStartRandomWeight;                       		// 0x0A34 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FYS_KismetXPModifier >              m_kismetXPModifiers;                              		// 0x0A38 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	float                                              m_fXPRatioWhenDisconnected;                       		// 0x0A44 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_unrespondingClientDisconnectionTimeout;         		// 0x0A48 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< class AYCameraActor* >                     m_spectatorPoints;                                		// 0x0A4C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UYSeqEvt_SpawningPlayerSetArsenal*           m_setArsenalKismetEvent;                          		// 0x0A58 (0x0004) [0x0000000000000000]              
	int                                                m_setArsenalEventIteratorIndex;                   		// 0x0A5C (0x0004) [0x0000000000000000]              
	class AController*                                 m_controllerWhoRequestedAPawnLast;                		// 0x0A60 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_defaultPawnClasses[ 0x2 ];                      		// 0x0A64 (0x0008) [0x0000000000000000]              
	float                                              m_deathDuration;                                  		// 0x0A6C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_spectateKillerDuration;                         		// 0x0A70 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FActiveBotInfo >                    ActiveBots;                                       		// 0x0A74 (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	class UClass*                                      BotClass;                                         		// 0x0A80 (0x0004) [0x0000000000000000]              
	struct FName                                       m_overridenCharacterListName;                     		// 0x0A84 (0x0008) [0x0000000000000000]              
	float                                              m_squadRespawnTimer;                              		// 0x0A8C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_respawnSecurityTimer;                           		// 0x0A90 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_amountToIncreaseRespawnTimer;                   		// 0x0A94 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_numKillsUntilBoot;                              		// 0x0A98 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                NumRounds;                                        		// 0x0A9C (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                ResetTimeDelay;                                   		// 0x0AA0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_processEndMatchDelay;                           		// 0x0AA4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              EndTimeDelay;                                     		// 0x0AA8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                NetWait;                                          		// 0x0AAC (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                RestartWait;                                      		// 0x0AB0 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	int                                                m_WarmupTime;                                     		// 0x0AB4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_StartUpCountDown;                               		// 0x0AB8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                CurrentRound;                                     		// 0x0ABC (0x0004) [0x0000000000000000]              
	TArray< class APlayerController* >                 PendingTeamSwitchRequests;                        		// 0x0AC0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UClass* >                            m_StatsGlobal;                                    		// 0x0ACC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_weaponIconDisplayDistance;                      		// 0x0AD8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FYS_WeaponClassRefData >            m_weaponClassRefData;                             		// 0x0ADC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UYStatsObject*                               StatsObject;                                      		// 0x0AE8 (0x0004) [0x0000000000000000]              
	int                                                m_maxGrenadeCountForTeam[ 0x2 ];                  		// 0x0AEC (0x0008) [0x0000000000004000]              ( CPF_Config )
	int                                                m_startGrenadeCountForTeam[ 0x2 ];                		// 0x0AF4 (0x0008) [0x0000000000004000]              ( CPF_Config )
	int                                                m_minHealthForArmorHitFeedback;                   		// 0x0AFC (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UClass*                                      m_fremenPickupActorClass;                         		// 0x0B00 (0x0004) [0x0000000000000000]              
	int                                                m_deathIdCounter;                                 		// 0x0B04 (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            m_CompletedChallenges;                            		// 0x0B08 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AYPlayerController_MP* >             m_controllersToSpawn;                             		// 0x0B14 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __PerPlayerXPModifier__Delegate;                  		// 0x0B20 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2403 ];

		return pClassPointer;
	};

	void SetExpectedPlayerCount ( int Cnt );
	void SandstormStopped ( );
	void StartSandstorm ( );
	void BeginPendingSandstorm ( float PauseTime );
	void HandleFriendlyFireKill ( class AController* Killer, class AController* Victim );
	bool CyclingCamera ( class AYPlayerController_MP* YPRI_MP );
	int CountRemainingTeammatesHavePawn ( class AController* Player );
	void KismetScoreTeam ( int TeamIdx, int scoreAmount, unsigned long bIsEndOfRoundBonus );
	void GameEnding ( );
	void NotifyOutOfAmmo ( class AController* YPC, unsigned char WeaponId );
	void GenericPlayerInitialization ( class AController* C );
	void StartHumans ( );
	void BeginStartMatchSequence ( );
	void GotoNextSequence ( );
	void DisableIdleKick ( );
	void SetTimeLimitTimer ( int Seconds );
	void TurnOffAllPlayers ( unsigned long bRoundEnded );
	void StandbyCheatDetected ( unsigned char StandbyType );
	bool DominatingVictory ( );
	bool IsAWinner ( class APlayerController* C );
	bool IsWinningTeam ( class ATeamInfo* T );
	void PlayEndOfMatchMessage ( );
	void PlayEndOfRoundMessage ( );
	void ShowScoreboardOnClient ( class AYPlayerController_MP* PC );
	void PlayersPlayStartupMessage ( int StartUpStage );
	void ChangeStartupStage ( int NewStartupStage );
	void BroadcastDeathMessage ( class AController* Killer, class AController* Other, class UClass* DamageType );
	int GetEarnedXPByScore ( int StartTime, float Score, struct FYS_EarnedXPFunc* Func );
	int GetRoundEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI );
	int GetMatchEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI, int baseXP );
	void GiveXPToTeam ( int TeamIndex, struct FYS_XPModifier xp, struct FScriptDelegate modifierFunc );
	void GiveXPToPlayer ( class AController* Scorer, struct FYS_XPModifier xp, struct FScriptDelegate modifierFunc );
	int CalcStaticXPMod ( class AYPlayerReplicationInfo_MP* PRI, int baseXP );
	void GiveXP ( class AController* Scorer, struct FYS_XPModifier xp, struct FScriptDelegate modifierFunc );
	void ScoreRevive ( class AYPlayerReplicationInfo* Reviver, class AYPlayerReplicationInfo* Revived );
	void ScoreTakeDown ( class AController* Killer, class AController* Other );
	void Killed ( class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType );
	void Downed ( class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType );
	void LogMedicReviveEvent ( class APawn** MedicPawn, class APawn** TargetPawn );
	void LogMedicAdrenalineEvent ( class APawn** MedicPawn, class APawn** TargetPawn );
	void LogSupplyDropEvent ( struct FString OfficerName, struct FVector OfficerLocation, float ThrownTime, struct FVector* OrderLocation );
	void LogOrderGivenEvent ( struct FString OfficerName, struct FVector OfficerLocation, float ThrownTime, struct FVector* OrderLocation );
	void LogSandbombEvent ( int I );
	void LogAvalancheEvent ( class AYVitalPoint* VP, class APawn** Pawn );
	void LogVPDestroyedEvent ( class AYVitalPoint* VP, unsigned long IsHVT, class APawn** Pawn );
	void LogCOMDeactivationEvent ( class APawn** Pawn, struct FVector* COMLocation );
	void LogCOMActivationEvent ( class APawn** Pawn, struct FVector* COMLocation );
	void LogLootDroppedEvent ( int LootValue, unsigned long IsDeposit, class APawn** Pawn );
	void LogLootPickUpEvent ( int LootValue, unsigned long IsStolen, class APawn** Pawn );
	void LogSandStormEvent ( float Time, unsigned long bStarting );
	void LogZipLineEvent ( class AController* Zipper );
	void LogVaultEvent ( class AController* Vaulter );
	void LogCoverEvent ( class AController* Coveree, unsigned long bEntering );
	void LogPickupEvent ( class AController* Picker, class AYPickupActor* PickupObject );
	void LogAssistEvent ( class AController* Killer, class APawn* KilledPawn );
	void LogDeathEvent ( unsigned long bDBNO, class AController* KilledPlayer, class AController* Killer, class UClass* DamageType, int DeathId );
	void NotifyPlayerControllerDestruction ( class AYPlayerController_MP* C );
	void YScoreKill ( class AController* Killer, class AController* Killed, class APawn* KilledPawn, class UClass* DamageType );
	void ScoreKill ( class AController* Killer, class AController* Other );
	void FriendlyFireMessage ( class AController* teamKiller );
	void SetEndGameFocus ( class APlayerReplicationInfo* Winner );
	bool CheckEndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void EndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void KickIdler ( class APlayerController* PC );
	void PrepareForFriendKillerKick ( class APlayerController* PC );
	void PrepareForIdleKick ( class APlayerController* PC );
	void KickFriendKiller ( class APlayerController* PC );
	void GiveRoundEndXP ( class APlayerReplicationInfo* Winner );
	bool HasEnoughPlayersToGiveRoundEndXP ( );
	bool ProcessRoundEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void IncrementRoundScore ( class APlayerReplicationInfo* Winner );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void LogOutcome ( class APlayerReplicationInfo* PRI, class APlayerReplicationInfo* Winner );
	bool CheckMaxLives ( class APlayerReplicationInfo* Scorer );
	void CheckScoreBeforeMatchBegin ( );
	bool CheckScore ( class APlayerReplicationInfo* Scorer );
	void NotifyKilled ( class AController* Killer, class AController* Killed, class APawn* KilledPawn, class UClass* DamageType );
	void ChangeName ( class AController* Other, struct FString S, unsigned long bNameChange );
	void InitializeBot ( class AYAIBaseController* Bot );
	void InitializeBotTeam ( class AYAIMPBot* Bot, unsigned long bUseDesiredTeamIndex, int iDesiredTeamIndex );
	class AYAIMPBot* SpawnBot ( struct FString BotName, unsigned long bUseTeamIndex, int TeamIndex );
	void AddInitialBots ( );
	void KillOthers ( );
	bool TooManyAis ( class AController* botToRemove );
	class AYAIMPBot* AddBot ( struct FString BotName, unsigned long bUseTeamIndex, int TeamIndex );
	class AYAIMPBot* AddNamedBot ( struct FString BotName, unsigned long bUseTeamIndex, int TeamIndex );
	int ComputeAverageHumanPlayersRank ( unsigned char eForTeam );
	float RatePlayerStart ( class APlayerStart* PlayerStart, unsigned char Team, class AController* Player );
	class APlayerStart* ChoosePlayerStart ( class AController* Player, unsigned char InTeam );
	void EndOnlineGame ( );
	void StartMatch ( );
	void StartStatSession ( );
	bool NeedAiPlayer ( );
	void KismetTick ( );
	void KismetTimer ( );
	class AYPlayerReplicationInfo* FindTeamLeader ( int TeamIdx );
	bool CanSpectate ( class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget );
	bool CanToggleSpectateMode ( class APlayerController* P );
	class AYCameraActor* GetPrevSpectatorPoint ( class AYCameraActor* CurrPoint );
	class AYCameraActor* GetNextSpectatorPoint ( class AYCameraActor* CurrPoint );
	class AYCameraActor* GetFirstSpectatorPoint ( );
	void AcquireSpectatorPoints ( );
	void Reset ( );
	bool GetStartingArsenalForPlayer ( class AYGamePawn* pwn, unsigned long testOnly, class UClass** wpToAdd, int* startAmmo, int* StartMag );
	void StorePawnRequestingController ( class AController* C );
	class USkeletalMesh* GetOverridePawnMesh ( class AController* NewPlayer );
	class APawn* SpawnDefaultPawnFor ( class AController* NewPlayer, class ANavigationPoint* StartSpot );
	void SetPlayerClass ( class AController* Other, int N );
	class UClass* GetDefaultPlayerClass ( class AController* C );
	void DelayedPlayerStart ( );
	void LoadCompletedCallback ( class AYPlayerController_MP* C );
	void SpawnAllControllersIfReady ( );
	void PlayerRestartComplete ( class AController* aPlayer );
	void RestartPlayer ( class AController* aPlayer );
	void PostBeginPlay ( );
	void UnregisterPlayer ( class APlayerController* PC );
	void Logout ( class AController* Exiting );
	void CheckForClientDisconnects ( );
	void HandlePostLogin ( class APlayerController* NewPlayer );
	void HandleSeamlessTravelPlayer ( class AController** C );
	void PostLogin ( class APlayerController* NewPlayer );
	unsigned char ValidateTeam ( class AController* C );
	class APlayerController* Login ( struct FString Portal, struct FString Options, struct FUniqueNetId UniqueId, struct FString* ErrorMessage );
	void ConditionalStartMatchSequenceRestart ( );
	void CancelLobbyCountDown ( );
	void StartLobbyCountDown ( );
	void EndLobbyCountDown ( );
	void RemoveUnresponsiveClients ( );
	void ForceControllerToBeReady ( class AYPlayerController_MPBase* PC );
	void SetUnresponsiveClientTimer ( );
	bool HasMinNetPlayers ( );
	bool ArePlayersReady ( );
	void DisablePlayersMustBeReady ( );
	void EnablePlayersMustBeReady ( );
	bool HavePlayersLoadedCurrentWorld ( );
	bool HasEnoughNetPlayers ( );
	void ChangeRespawnSecurityTimer ( float _to );
	void SquadRespawn ( );
	bool IsControllerCanRespawn ( class AController* C );
	void ChangeSquadRespawnTimer ( float _to );
	bool IsSquadRespawnTimerEnabled ( );
	void InitGameReplicationInfo ( );
	void GetSeamlessTravelActorList ( unsigned long bToEntry, TArray< class AActor* >* ActorList );
	void PostSeamlessTravel ( );
	void ProcessServerTravel ( struct FString URL, unsigned long bAbsolute );
	void OverridePRI ( class APlayerController* PC, class APlayerReplicationInfo* OldPRI );
	void PreBeginPlay ( );
	void InitGame ( struct FString Options, struct FString* ErrorMessage );
	void UpdateGameOnlineStatus ( unsigned long checkLastManStanding );
	void SetTeam ( class AController* Other, class AYTeamInfo* NewTeam );
	void ApplyChangeTeam ( class AController* C, int NewTeamNum );
	bool ChangeTeam ( class AController* C, int DesiredTeamNum, unsigned long bPickNewTeam );
	class APlayerController* PlayerFindMatchingChangeTeamRequest ( class APlayerController* PC, int DesiredTeamNum );
	void PlayerClearPendingTeamSwitch ( class APlayerController* PC );
	void PlayerRequestPendingTeamSwitch ( class APlayerController* PC );
	unsigned char PickTeam ( unsigned char DesiredTeamNum, class AController* C );
	void SetupMatchmakingManagerForCommandLineRun ( );
	void UpdateMuteList ( class AYPlayerController_MPBase* Other );
	int GetBotCountInTeam ( unsigned char TeamNum );
	bool IsBot ( class AController* Other );
	bool IsCivilian ( class AController* Other );
	bool isPlayer ( class AController* Other );
	int PerPlayerXPModifier ( class AYPlayerReplicationInfo_MP* PRI, int baseXP );
	void ResetPlayerConnections ( );
	struct FString PS3GetLocalIPAddress ( );
};

UClass* AYGameInfo_MP::pClassPointer = NULL;

// Class SRGame.YGameInfo_CP
// 0x0160 (0x0C8C - 0x0B2C)
class AYGameInfo_CP : public AYGameInfo_MP
{
public:
	float                                              m_spawnDelayIncrPerDeath;                         		// 0x0B2C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_SpawnDelayCap;                                  		// 0x0B30 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_specOpsHealthMultiplier;                        		// 0x0B34 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_refillAttemptsOnNewSection : 1;                 		// 0x0B38 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_addRemainingAttemptsOnNewSection : 1;           		// 0x0B38 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_bPlayerCanSeeEnemyName : 1;                     		// 0x0B38 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_bEndGameIfNoAliveHumanSpecopsLeft : 1;          		// 0x0B38 (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	unsigned long                                      m_bAllowSpecopsSideAi : 1;                        		// 0x0B38 (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	unsigned long                                      m_bAllowCPSquadCommands : 1;                      		// 0x0B38 (0x0004) [0x0000000000004000] [0x00000020] ( CPF_Config )
	float                                              m_lastDeathSequenceTime;                          		// 0x0B3C (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_lastDeathSequenceMessage;                       		// 0x0B40 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FYS_XPModifier                              m_xpPerSpecopsDamage;                             		// 0x0B4C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerEliteClassUnlock[ 0x5 ];                   		// 0x0B60 (0x0064) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerBossClassUnlock;                           		// 0x0BC4 (0x0014) [0x0000000000004000]              ( CPF_Config )
	int                                                m_specopsDamageStep;                              		// 0x0BD8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_xpPerSpecopsSuccessiveInjury;                   		// 0x0BDC (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_numInjuryMsg;                                   		// 0x0BE0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerSpecopsTakeDown;                           		// 0x0BE4 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromSpecopsKnockedOuts;               		// 0x0BF8 (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromSpecopsDamage;                    		// 0x0C14 (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromSpecopsTakeDowns;                 		// 0x0C30 (0x001C) [0x0000000000004000]              ( CPF_Config )
	class UClass*                                      CrossPlayerMessageClass;                          		// 0x0C4C (0x0004) [0x0000000000000000]              
	class UYMusicPart*                                 m_specopsLooseMusicPart;                          		// 0x0C50 (0x0004) [0x0000000000000000]              
	int                                                DesiredBotCount;                                  		// 0x0C54 (0x0004) [0x0000000000000000]              
	int                                                m_iDefaultKonradAisRank;                          		// 0x0C58 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_iDefaultSpecopsAisRank;                         		// 0x0C5C (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< int >                                      m_BotsDifficultyToRankMap;                        		// 0x0C60 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	int                                                m_botRank;                                        		// 0x0C6C (0x0004) [0x0000000000000000]              
	float                                              m_CurrentBotsAccuracyModifier[ 0x2 ];             		// 0x0C70 (0x0008) [0x0000000000000000]              
	float                                              m_CurrentBotsDamageModifier[ 0x2 ];               		// 0x0C78 (0x0008) [0x0000000000000000]              
	TArray< class AYTacticalMarker* >                  m_objectiveMarkers;                               		// 0x0C80 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2404 ];

		return pClassPointer;
	};

	void IncrementRoundScore ( class APlayerReplicationInfo* Winner );
	void KismetScoreTeamSurvivalBonus ( int TeamIdx, int maxScoreIncrease, int perDownDecrease );
	void KismetScoreTeam ( int TeamIdx, int scoreAmount, unsigned long bIsEndOfRoundBonus );
	void ActivateReadyForEndChoreoKismet ( );
	void EndingChoreoEnded ( );
	bool CheckMaxLives ( class APlayerReplicationInfo* Scorer );
	void CheckScoreBeforeMatchBegin ( );
	bool CheckEndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	bool ProcessRoundEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void NotifyCompletedDelayedPlayerStart ( );
	void RestartPlayer ( class AController* aPlayer );
	bool NeedAiPlayer ( );
	bool TooManyAis ( class AController* aiToRemove );
	void StartBots ( );
	void KillThisBot ( );
	void AddBots ( int Num );
	void DumpBotRanks ( unsigned char eForTeam );
	void SetBotRank ( unsigned char eForTeam, int iRank );
	void PlayEndOfMatchMessage ( );
	void PlayEndOfRoundMessage ( );
	int GetRoundEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI );
	void ScoreRevive ( class AYPlayerReplicationInfo* Reviver, class AYPlayerReplicationInfo* Revived );
	void ScoreTakeDown ( class AController* Killer, class AController* Other );
	void ScoreKill ( class AController* Killer, class AController* Other );
	void Damaged ( class AController* attacker, class AController* Other, int Damage, class UClass* DamageType );
	float SpawnWait ( class AAIController* C );
	void KillUnnecessaryAI ( );
	void PlayerRestartComplete ( class AController* aPlayer );
	class APlayerController* Login ( struct FString Portal, struct FString Options, struct FUniqueNetId UniqueId, struct FString* ErrorMessage );
	void GameEnding ( );
	void InitGame ( struct FString Options, struct FString* ErrorMessage );
	void PreBeginPlay ( );
	void SkipChoreo ( );
	void UpdateObjectiveMarkers ( );
	void RemoveObjectiveMarkers ( TArray< class AYTacticalMarker* > markers );
	void AddObjectiveMarkers ( TArray< class AYTacticalMarker* > markers );
	void StartSection ( );
	void CPStartSection ( );
	void UpdateBotsSkillModifiers ( );
	void NotifyStrategyManager ( unsigned char eNotif, class AActor* ActorOfNote );
	void ShutdownStrategyManager ( );
	void InitStrategyManager ( class UObject* configObject );
};

UClass* AYGameInfo_CP::pClassPointer = NULL;

// Class SRGame.YGameInfo_DM
// 0x000C (0x0B38 - 0x0B2C)
class AYGameInfo_DM : public AYGameInfo_MP
{
public:
	class APlayerReplicationInfo*                      ScoreLeader;                                      		// 0x0B2C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class APlayerReplicationInfo*                      OldScoreLeader;                                   		// 0x0B30 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      bAnnouncedFiveKills : 1;                          		// 0x0B34 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2405 ];

		return pClassPointer;
	};

	void PlayEndOfMatchMessage ( );
	bool IsAWinner ( class APlayerController* C );
	void UpdateMuteList ( class AYPlayerController_MPBase* Other );
	void GiveRoundEndXP ( class APlayerReplicationInfo* Winner );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void LogOutcome ( class APlayerReplicationInfo* PRI, class APlayerReplicationInfo* Winner );
	void Logout ( class AController* Exiting );
	bool CheckEndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void AnnounceFiveKills ( );
	void AnnounceYourLead ( );
	void AnnounceLostLead ( );
	void AnnounceLeader ( class APlayerReplicationInfo* Scorer );
	bool CheckScore ( class APlayerReplicationInfo* Scorer );
	void HandleSeamlessTravelPlayer ( class AController** C );
	void OverridePRI ( class APlayerController* PC, class APlayerReplicationInfo* OldPRI );
};

UClass* AYGameInfo_DM::pClassPointer = NULL;

// Class SRGame.YGameInfo_Coop
// 0x0040 (0x0B78 - 0x0B38)
class AYGameInfo_Coop : public AYGameInfo_DM
{
public:
	class AYGamePawn*                                  CoopPawnA;                                        		// 0x0B38 (0x0004) [0x0000000000000000]              
	class AYGamePawn*                                  CoopPawnB;                                        		// 0x0B3C (0x0004) [0x0000000000000000]              
	class AYGamePawn*                                  CoopPawnC;                                        		// 0x0B40 (0x0004) [0x0000000000000000]              
	class USkeletalMesh*                               CoopMeshA;                                        		// 0x0B44 (0x0004) [0x0000000000000000]              
	class USkeletalMesh*                               CoopMeshB;                                        		// 0x0B48 (0x0004) [0x0000000000000000]              
	class USkeletalMesh*                               CoopMeshC;                                        		// 0x0B4C (0x0004) [0x0000000000000000]              
	class UClass*                                      CoopDecoyClass;                                   		// 0x0B50 (0x0004) [0x0000000000000000]              
	struct FName                                       m_endGameMessageBledOut;                          		// 0x0B54 (0x0008) [0x0000000000000000]              
	struct FName                                       m_endGameMessageAllSquadDBNO;                     		// 0x0B5C (0x0008) [0x0000000000000000]              
	struct FName                                       m_endGameMessageHostQuit;                         		// 0x0B64 (0x0008) [0x0000000000000000]              
	TArray< class UObject* >                           m_SPcontentRefs;                                  		// 0x0B6C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2406 ];

		return pClassPointer;
	};

	void ShowScoreboardOnClient ( class AYPlayerController_MP* PC );
	void ReturnToLobby ( );
	void RestartPlayer ( class AController* aPlayer );
	void GiveRoundEndXP ( class APlayerReplicationInfo* Winner );
	void GiveXP ( class AController* Scorer, struct FYS_XPModifier xp, struct FScriptDelegate modifierFunc );
	bool AllowPausing ( class APlayerController* PC );
	void LogDeathEvent ( unsigned long bDBNO, class AController* KilledPlayer, class AController* Killer, class UClass* DamageType, int DeathId );
	void EndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	class ANavigationPoint* FindPlayerStart ( class AController* Player, unsigned char InTeam, struct FString IncomingName );
	bool IsSquadPoitionOpen ( unsigned char SquadPosition );
	bool SpawnAIControllerForSquadmatePawn ( class APawn* PawnToControl, unsigned char SquadPosition );
	void Killed ( class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType );
	void InitCoopSquadMember ( class AYPlayerController_Coop* PC, unsigned char RequestedSquadMember );
	void LoadCompletedCallback ( class AYPlayerController_MP* C );
	void SpawnDecoyControllerForSquadmate ( unsigned char CoopPlayerTag );
	class APawn* SpawnDefaultPawnFor ( class AController* NewPlayer, class ANavigationPoint* StartSpot );
	class APlayerController* SpawnPlayerController ( struct FVector SpawnLocation, struct FRotator SpawnRotation );
	bool ChangeTeam ( class AController* Other, int N, unsigned long bNewTeam );
	void PreLogin ( struct FString Options, struct FString Address, struct FString* ErrorMessage );
	bool CheckEndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void PreBeginPlay ( );
};

UClass* AYGameInfo_Coop::pClassPointer = NULL;

// Class SRGame.YGameInfo_Horde
// 0x0000 (0x0B2C - 0x0B2C)
class AYGameInfo_Horde : public AYGameInfo_MP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2407 ];

		return pClassPointer;
	};

	bool CheckAllPlayersDead ( class APlayerReplicationInfo* Scorer );
	bool CheckScore ( class APlayerReplicationInfo* Scorer );
	void PlayerRestartComplete ( class AController* C );
	void EnableMelee ( class AYPawn_Multiplayer* Pawn );
	void EnableOnTacView ( class AYGamePawn* Pawn );
	int GetBotCountInTeam ( unsigned char TeamNum );
	bool ChangeTeam ( class AController* Other, int DesiredTeamNum, unsigned long bPickNewTeam );
	bool CanJoinPlayableTeamMP ( unsigned char TeamNum, class AController* C, unsigned long bBalanceTeams, class UYGameSettingsMultiplayer* GameSettings );
	bool CanSwitchToPlayableTeamMP ( unsigned char DesiredTeamNum, class AController* C, unsigned long bBalanceTeams, class UYGameSettingsMultiplayer* GameSettings, int MinPlayerInTeam );
	void InitializeBot ( class AYAIBaseController* Bot );
};

UClass* AYGameInfo_Horde::pClassPointer = NULL;

// Class SRGame.YGameInfo_RP
// 0x0058 (0x0B84 - 0x0B2C)
class AYGameInfo_RP : public AYGameInfo_MP
{
public:
	struct FYS_XPModifier                              m_xpPerHold;                                      		// 0x0B2C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerOwned;                                     		// 0x0B40 (0x0014) [0x0000000000004000]              ( CPF_Config )
	int                                                m_holdTimeInterval;                               		// 0x0B54 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromHold;                             		// 0x0B58 (0x001C) [0x0000000000004000]              ( CPF_Config )
	int                                                m_capturePointChangeTimer;                        		// 0x0B74 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_capturePointChangeWarning;                      		// 0x0B78 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_capturePointChangeWarningDone : 1;              		// 0x0B7C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_announce10Points : 1;                           		// 0x0B7C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	float                                              m_capturePointChangeStartTime;                    		// 0x0B80 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2408 ];

		return pClassPointer;
	};

	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void Announce10PointsRemain ( );
	bool CheckScore ( class APlayerReplicationInfo* Scorer );
	void ScoreOwned ( class AYPlayerController_MP* PC );
	int GetRoundEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI );
};

UClass* AYGameInfo_RP::pClassPointer = NULL;

// Class SRGame.YGameInfo_SDM
// 0x0060 (0x0B8C - 0x0B2C)
class AYGameInfo_SDM : public AYGameInfo_MP
{
public:
	struct FYS_XPModifier                              m_xpPerAnnihilation;                              		// 0x0B2C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromAnnihilations;                    		// 0x0B40 (0x001C) [0x0000000000004000]              ( CPF_Config )
	int                                                m_killingWholeEnemyTeamExtraScore;                		// 0x0B5C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_InstantRespawnTime;                             		// 0x0B60 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_respawnScoreEnhancer;                           		// 0x0B64 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_instantRespawnTeam;                             		// 0x0B68 (0x0004) [0x0000000000000000]              
	int                                                m_choosenSquadStart[ 0x2 ];                       		// 0x0B6C (0x0008) [0x0000000000000000]              
	float                                              m_TeamRespawnTime[ 0x2 ];                         		// 0x0B74 (0x0008) [0x0000000000000000]              
	float                                              m_defaultRespawnTime;                             		// 0x0B7C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_RADReActivateTime;                              		// 0x0B80 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_respawnTimerOnElimination;                      		// 0x0B84 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UClass*                                      AnnihilationMessageClass;                         		// 0x0B88 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2409 ];

		return pClassPointer;
	};

	class APlayerStart* ChoosePlayerStart ( class AController* Player, unsigned char InTeam );
	int GetRoundEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void YScoreKill ( class AController* Killer, class AController* Killed, class APawn* KilledPawn, class UClass* DamageType );
	void ReActivateRAD ( );
	void SpecopsRespawnTimerReset ( );
	void SpecopsRespawn ( );
	void KonradRespawnTimerReset ( );
	void KonradRespawn ( );
	void DisableInstantRespawn ( );
	void SquadRespawn ( );
	void ScoreKill ( class AController* Killer, class AController* Other );
	bool IsTeamAnnihilated ( int TeamID );
	void DelayedPlayerStart ( );
	void ActivateRAD ( );
	void StartMatch ( );
};

UClass* AYGameInfo_SDM::pClassPointer = NULL;

// Class SRGame.YGameInfo_SP
// 0x0078 (0x05D0 - 0x0558)
class AYGameInfo_SP : public AYGameInfo
{
public:
	class UYGameSettingsCampaign*                      CampaignGameSettings;                             		// 0x0558 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_killingSquadMemberEndsGame : 1;                 		// 0x055C (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_immortalSquadMates : 1;                         		// 0x055C (0x0004) [0x0000000000004001] [0x00000002] ( CPF_Edit | CPF_Config )
	unsigned long                                      m_allowContextualSlomo : 1;                       		// 0x055C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_ignoreContextualVoiceSlomo : 1;                 		// 0x055C (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      bLogGameplayEvents : 1;                           		// 0x055C (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	struct FString                                     m_gameOverReasons[ 0x3 ];                         		// 0x0560 (0x0024) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_gameOverMessage;                                		// 0x0584 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_currentChapter;                                 		// 0x0590 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentMission;                                 		// 0x0591 (0x0001) [0x0000000000000000]              
	float                                              m_currentGlobalVoicePitchFactor;                  		// 0x0594 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_ContextualSlomoTriggerData >    m_contextualSlomoDataEntries;                     		// 0x0598 (0x000C) [0x0000000000404001]              ( CPF_Edit | CPF_Config | CPF_NeedCtorLink )
	int                                                m_currentSlomoPriority;                           		// 0x05A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     GameplayEventsWriterClassName;                    		// 0x05A8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	class UYGameplayEventsWriter*                      GameplayEventsWriter;                             		// 0x05B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UObject* >                           m_SPcontentRefs;                                  		// 0x05B8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnCreateOnlineGameComplete__Delegate;           		// 0x05C4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2410 ];

		return pClassPointer;
	};

	void UpdateGameSettings ( );
	bool SetCurrentMission ( unsigned char mission );
	unsigned char GetCurrentChapter ( );
	unsigned char GetCurrentMission ( );
	bool CheckEndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	bool CheckScore ( class APlayerReplicationInfo* Scorer );
	void ReduceDamage ( class APawn* injured, class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, class AActor* DamageCauser, int* Damage, struct FVector* Momentum );
	void AutoFadeInAfterFadeToWhite ( );
	void ReselectStorageDevice ( );
	void ForceCheckpointSave ( );
	void FadeInAfterFadeToWhite ( );
	void CheckpointLoadComplete ( unsigned long Success, unsigned long fadeToWhite, unsigned long isCampaignMap );
	void CheckGameOver ( class AController* KilledPlayer );
	void Downed ( class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType );
	void Killed ( class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType );
	void NotifyOutOfAmmoAllWeapons ( class AController* YPC );
	void NotifyLowOnAmmo ( class AController* YPC, unsigned char WeaponId );
	void NotifyOutOfAmmo ( class AController* YPC, unsigned char WeaponId );
	bool NeverUnpause ( );
	void StartMatch ( );
	void StartHumans ( );
	void StartBots ( );
	bool PreventDeath ( class APawn* KilledPawn, class AController* Killer, class UClass* DamageType, struct FVector HitLocation );
	void BroadcastDeathMessage ( class AController* Killer, class AController* Other, class UClass* DamageType );
	bool CanSpectate ( class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget );
	int GetNumPlayerControllersActive ( );
	class UClass* SuggestPawnClassFor ( class AYPlayerController* Player );
	class APawn* SpawnDefaultPawnFor ( class AController* NewPlayer, class ANavigationPoint* StartSpot );
	class UClass* GetDefaultPlayerClass ( class AController* C );
	void OnGameShutdown ( );
	void RestartPlayer ( class AController* NewPlayer );
	void Reset ( );
	bool CreateCampaign ( int ControllerIndex, class UYGameSettingsCampaign* CampaignSettings, struct FScriptDelegate CreateOnlineGameComplete );
	void OnCreateOnlineGameComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void Logout ( class AController* Exiting );
	void PostLogin ( class APlayerController* NewPlayer );
	void InitGame ( struct FString Options, struct FString* ErrorMessage );
	int GetForcedTeam ( class AController* Other, int Team );
	bool IsGameStatTrackinInProgress ( );
	void EndGameStatTracking ( );
	void InitGameStatTracking ( );
	bool IsLoggingAllowed ( );
};

UClass* AYGameInfo_SP::pClassPointer = NULL;

// Class SRGame.YGameInfo_FMP
// 0x0000 (0x05D0 - 0x05D0)
class AYGameInfo_FMP : public AYGameInfo_SP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2411 ];

		return pClassPointer;
	};

};

UClass* AYGameInfo_FMP::pClassPointer = NULL;

// Class SRGame.YGameInfo_Menu
// 0x0011 (0x05E1 - 0x05D0)
class AYGameInfo_Menu : public AYGameInfo_SP
{
public:
	class UOnlineChallengeInterface*                   m_OnlineChallengeInterface;                       		// 0x05D0 (0x0008) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x05D4 (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	int                                                m_ControllerIndex;                                		// 0x05D8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bQuickMatch : 1;                                		// 0x05DC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIsLanMatch : 1;                                		// 0x05DC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bOpenUISceneWhenReady : 1;                      		// 0x05DC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_prologueStarted : 1;                            		// 0x05DC (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_runPrologue : 1;                                		// 0x05DC (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	unsigned char                                      m_exodusMode;                                     		// 0x05E0 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2412 ];

		return pClassPointer;
	};

	class UClass* SuggestPawnClassFor ( class AYPlayerController* Player );
	void OnPrologueStarted ( );
	void UpdateMuteList ( class AYPlayerController_MPBase* Other );
	unsigned char PickTeam ( unsigned char DesiredTeamNum, class AController* C );
	void HandlePostLogin ( class APlayerController* NewPlayer );
	void HandleSeamlessTravelPlayer ( class AController** C );
	void SetPlayerDefaults ( class APawn* PlayerPawn );
	void PostLogin ( class APlayerController* NewPlayer );
	void PreBeginPlay ( );
	void ProcessServerTravel ( struct FString URL, unsigned long bAbsolute );
	void InitGame ( struct FString Options, struct FString* ErrorMessage );
	class ULocalPlayer* GetPlayerOwner ( int PlayerIndex );
	void InitMatchmakingManager ( );
	void ContinueParty ( int ControllerIndex, unsigned long bQuickMatch, unsigned long bIsLanMatch, unsigned char exodusMode, unsigned long bOpenUISceneWhenReady );
	void CreateParty ( int ControllerIndex, unsigned long bQuickMatch, unsigned long bIsLanMatch, unsigned char exodusMode, unsigned long bOpenUISceneWhenReady );
	bool InitializePartySettings ( int ControllerIndex, class UYGameSettingsMultiplayer* PartySettings, unsigned long bIsLanMatch, unsigned char exodusMode );
	class UYProfileSettings* GetProfile ( int ControllerId );
};

UClass* AYGameInfo_Menu::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo
// 0x0324 (0x0570 - 0x024C)
class AYGameReplicationInfo : public AGameReplicationInfo
{
public:
	int                                                MinNetPlayers;                                    		// 0x024C (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      bWarmupRound : 1;                                 		// 0x0250 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      bStoryMode : 1;                                   		// 0x0250 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      bConsoleServer : 1;                               		// 0x0250 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      bAllowKeyboardAndMouse : 1;                       		// 0x0250 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      bAnnouncementsDisabled : 1;                       		// 0x0250 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      bShowMenuOnDeath : 1;                             		// 0x0250 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      bIsCoop : 1;                                      		// 0x0250 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      m_gameHasTeamLeaders : 1;                         		// 0x0250 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      m_showClock : 1;                                  		// 0x0250 (0x0004) [0x0000000000000020] [0x00000100] ( CPF_Net )
	unsigned long                                      m_gameRestart : 1;                                		// 0x0250 (0x0004) [0x0000000000000020] [0x00000200] ( CPF_Net )
	unsigned long                                      m_inCombatSituation : 1;                          		// 0x0250 (0x0004) [0x0000000000000020] [0x00000400] ( CPF_Net )
	unsigned long                                      m_inStealthMode : 1;                              		// 0x0250 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bDisplayTimerOnHud : 1;                         		// 0x0250 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_isFrontend : 1;                                 		// 0x0250 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_isIngameShell : 1;                              		// 0x0250 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_currentObjectiveComplete : 1;                   		// 0x0250 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bShowObjectiveTitle : 1;                        		// 0x0250 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_allowFriendlyFire : 1;                          		// 0x0250 (0x0004) [0x0000000000000020] [0x00020000] ( CPF_Net )
	int                                                SinglePlayerMissionID;                            		// 0x0254 (0x0004) [0x0000000000000000]              
	class UYCollisionEffectMgr*                        m_collisionEffectMgr;                             		// 0x0258 (0x0004) [0x0000000000000000]              
	int                                                MapVoteTimeRemaining;                             		// 0x025C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UYUIScene_MidGameMenu*                       CurrentMidGameMenu;                               		// 0x0260 (0x0004) [0x0000000000000000]              
	float                                              m_respawnDelay;                                   		// 0x0264 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_numRounds;                                      		// 0x0268 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_currentRound;                                   		// 0x026C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_NumCurrentRound;                                		// 0x0270 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_mpTimerValue;                                   		// 0x0274 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UYUIScene_KeyboardInputDialog*               CurrentKeyboardInputDialog;                       		// 0x0278 (0x0004) [0x0000000000000000]              
	class UYUIScene_KeyboardInputDialog*               KeyboardInputDialogTemplate;                      		// 0x027C (0x0004) [0x0000000000000000]              
	class AYObjectPool*                                m_YOP;                                            		// 0x0280 (0x0004) [0x0000000000000000]              
	struct FYS_DeathAnimationIndices                   m_daIndices;                                      		// 0x0284 (0x0030) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_HitReactionAnimationIndices             m_hraIndicesSmall;                                		// 0x02B4 (0x0024) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_HitReactionAnimationIndices             m_hraIndicesBig;                                  		// 0x02D8 (0x0024) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_PlayedIdleAnimations                    m_unusedIdleAnims[ 0x33 ];                        		// 0x02FC (0x0264) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_ddeaFront;                                      		// 0x0560 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_ddeaBack;                                       		// 0x0561 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_currentObjective;                               		// 0x0562 (0x0001) [0x0000000000000000]              
	class AYRemoteSpeaker_Generic*                     m_genericRemoteSpeaker;                           		// 0x0564 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UClass*                                      TimerMessageClass;                                		// 0x0568 (0x0004) [0x0000000000000000]              
	int                                                m_currentObjectiveItem;                           		// 0x056C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2413 ];

		return pClassPointer;
	};

	void OnKeyboardInputDeactivated ( class UUIScene* Scene );
	void ShowKeyboardInputDialog ( struct FScriptDelegate KeyboardInputDone, int LocalUserNum, struct FString TitleText, struct FString DescriptionText, unsigned long bIsPassword, unsigned long bShouldValidate, struct FString DefaultText, int MaxResultLength );
	void SetCurrentObjective ( unsigned char myObjective, int objectiveItem, unsigned long complete, unsigned long showObjectiveTitle );
	void GetCurrentObjectiveInfo ( unsigned char* currentObjective, int* currentObjectiveItem, int* currentObjectiveComplete );
	int GetNumPlayers ( );
	void ReplicatedDataBinding ( struct FName VarName );
	void ReplicatedEvent ( struct FName VarName );
	void Reset ( );
	void PostBeginPlay ( );
	void CreateObjectPool ( );
	void EndGame ( );
	bool ShouldShowDBNOIndicator ( );
	bool CanChangeTeam ( );
	float GetRespawnDelay ( class AController* C );
	void MidGameMenuClosed ( );
	void HideMidGameMenu ( class AYPlayerController* instigatorPC );
	class UYUIScene_MidGameMenu* ShowMidGameMenu ( class AYPlayerController* instigatorPC, struct FName TabTag, unsigned long bEnableInput );
	unsigned char GetCurrentMenuType ( );
	void CreateKynapseTeam ( class AYTeamInfo* Info );
	void ReconnectExistingSquads ( );
	void RecreateMissingKynapseTeams ( );
	void SetTeam ( int Idx, class ATeamInfo* TeamInfo );
	bool IsMultiPlayerNetworkGame ( );
	bool IsSinglePlayerGame ( );
	bool IsMultiplayerGame ( );
	bool IsDeathMatchGame ( );
	void Timer ( );
	void PlayLastMinuteWarning ( );
	bool IsCoopMultiplayerGame ( );
	void DestroyCollisionEffectMgr ( );
	void InitializeCollisionEffectMgr ( );
};

UClass* AYGameReplicationInfo::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_MPBase
// 0x0138 (0x06A8 - 0x0570)
class AYGameReplicationInfo_MPBase : public AYGameReplicationInfo
{
public:
	unsigned char                                      m_MatchmakingState;                               		// 0x0570 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_LobbyState;                                     		// 0x0571 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_MatchTypeId;                                    		// 0x0572 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_MultiplayerModeId;                              		// 0x0573 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_mapId;                                          		// 0x0574 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_FactionId;                                      		// 0x0575 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_AIDifficultyId;                                 		// 0x0576 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_MapChoicesId[ 0x2 ];                            		// 0x0577 (0x0002) [0x0000000000000020]              ( CPF_Net )
	int                                                m_PlaylistId;                                     		// 0x057C (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FYS_RuleSettings                            m_Rules;                                          		// 0x0580 (0x0040) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       m_PlaylistEntryChoices[ 0x2 ];                    		// 0x05C0 (0x0010) [0x0000000000000020]              ( CPF_Net )
	int                                                m_VoteCounts[ 0x2 ];                              		// 0x05D0 (0x0008) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nLobbyTimeOut;                                  		// 0x05D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nLobbyRemainingTime;                            		// 0x05DC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nVoteTimeOut;                                   		// 0x05E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nVoteRemainingTime;                             		// 0x05E4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nStartUpTimeOut;                                		// 0x05E8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nStartUpRemainingTime;                          		// 0x05EC (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bHandlePostTravelOnLoadUI : 1;                  		// 0x05F0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bShouldResetLobby : 1;                          		// 0x05F0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_coopSettingHasBeenSet : 1;                      		// 0x05F0 (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                m_TimerBackup;                                    		// 0x05F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_LastPlayerCount;                                		// 0x05F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_coopDifficultyIndex;                            		// 0x05FC (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __OnLobbyTimeOut__Delegate;                       		// 0x0600 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnVoteTimeOut__Delegate;                        		// 0x060C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnStartUpTimeOut__Delegate;                     		// 0x0618 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnPlaylistIdUpdated__Delegate;                  		// 0x0624 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnMatchTypeUpdated__Delegate;                   		// 0x0630 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnMultiplayerModeUpdated__Delegate;             		// 0x063C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnMultiplayerMapUpdated__Delegate;              		// 0x0648 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnMultiplayerFactionUpdated__Delegate;          		// 0x0654 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnMultiplayerAIDifficultyUpdated__Delegate;     		// 0x0660 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnRuleSettingsUpdated__Delegate;                		// 0x066C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnLobbyStateUpdated__Delegate;                  		// 0x0678 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnLobbyCountDownEnd__Delegate;                  		// 0x0684 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnVoteUpdated__Delegate;                        		// 0x0690 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnVoteEnd__Delegate;                            		// 0x069C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2414 ];

		return pClassPointer;
	};

	void WritePerkUseTimes ( );
	int GetPlayerRankInTeam ( class APlayerReplicationInfo* PRI );
	int CalculateAveragePlayersXP ( );
	bool IsExperienceSystemEnabled ( );
	void Timer ( );
	int GetStartUpRemainingTime ( );
	void ClearStartUpCountDown ( );
	void EndStartUpCountDown ( );
	void StartStartUpCountDown ( int StartUpTimeOut, struct FScriptDelegate StartUpTimeOutDelegate );
	int GetLobbyRemainingTime ( );
	void ClearLobbyCountDown ( );
	void EndLobbyCountDown ( );
	void StartLobbyCountDown ( int LobbyTimeOut, struct FScriptDelegate LobbyTimeOutDelegate );
	int GetVoteRemainingTime ( );
	void ClearVoteCountDown ( );
	void EndVoteCountDown ( );
	void StartVoteCountDown ( int VoteTimeOut, struct FScriptDelegate VoteTimeOutDelegate );
	bool IsDeathmatch ( );
	bool IsCrossplayer ( );
	void PostBeginPlay ( );
	bool CheckMajorityVote ( );
	void NotifyVoteChange ( );
	void CancelLobbyMapVote ( );
	void RequestLobbyMapVoteEnd ( );
	void RequestLobbyMapVoteBegin ( class UYGameSettingsMultiplayer* GameSettings, int RandomMapDrawCountMax, int VoteTimeOut, struct FScriptDelegate VoteEndDelegate );
	void SetLobbyVoteCount ( int* VoteCounts );
	int GetLobbyVoteCount ( int ChoiceIndex );
	unsigned char GetLobbyVoteMap ( int ChoiceIndex );
	class UYUIDataProvider_PlaylistEntry* GetLobbyVotePlaylistEntry ( int ChoiceIndex );
	void CancelLobbyCountDown ( );
	void RequestLobbyCountDownEnd ( );
	void RequestLobbyCountDownBegin ( int LobbyTimeOut, struct FScriptDelegate LobbyCountDownEndDelegate );
	unsigned char GetLobbyState ( );
	void SetLobbyState ( unsigned char NewState );
	unsigned char GetMatchmakingState ( );
	void SetMatchmakingState ( unsigned char NewState );
	struct FYS_RuleSettings GetRules ( );
	unsigned char GetAIDifficultyId ( );
	unsigned char GetFactionId ( );
	int GetCooperativeMapId ( );
	unsigned char GetMapId ( );
	int GetPlaylistId ( );
	bool IsExodusMode ( );
	unsigned char GetMultiplayerModeId ( );
	unsigned char GetMatchTypeId ( );
	void SetRules ( struct FYS_RuleSettings MPRules );
	void SetAIDifficultyId ( unsigned char MPDifficultyId );
	void SetFactionId ( unsigned char MPFactionId );
	int GetCoopDifficulty ( );
	void ServerReplicateCoopDifficulty ( int NewDifficulty );
	void SetCoopDifficulty ( int NewDifficulty );
	void SetMapId ( unsigned char MPMapId );
	void SetMultiplayerModeId ( unsigned char MPModeId );
	void SetMatchTypeId ( unsigned char MPMatchTypeId );
	void SetPlaylistId ( int PlaylistId );
	void UpdateFromOnlineGameSettings ( class UYGameSettingsMultiplayer* GameSettings );
	void ReplicatedEvent ( struct FName VarName );
	void UpdateOnlineSlotCount ( );
	void ClearVoteUpdatedDelegate ( );
	void SetVoteUpdatedDelegate ( struct FScriptDelegate UpdateVoteDelegate );
	void ClearLobbyStateUpdatedDelegate ( );
	void SetLobbyStateUpdatedDelegate ( struct FScriptDelegate UpdateLobbyStateDelegate );
	void ClearRuleSettingsUpdatedDelegate ( );
	void SetRuleSettingsUpdatedDelegate ( struct FScriptDelegate UpdateRuleSettingsDelegate );
	void ClearMultiplayerFactionUpdatedDelegate ( );
	void SetMultiplayerFactionUpdatedDelegate ( struct FScriptDelegate UpdateMultiplayerFactionDelegate );
	void ClearMultiplayerMapUpdatedDelegate ( );
	void SetMultiplayerMapUpdatedDelegate ( struct FScriptDelegate UpdateMultiplayerMapDelegate );
	void ClearMultiplayerModeUpdatedDelegate ( );
	void SetMultiplayerModeUpdatedDelegate ( struct FScriptDelegate UpdateMultiplayerModeDelegate );
	void ClearMatchTypeUpdatedDelegate ( );
	void SetMatchTypeUpdatedDelegate ( struct FScriptDelegate UpdateMatchTypeDelegate );
	void ClearPlaylistIdUpdatedDelegate ( );
	void SetPlaylistIdUpdatedDelegate ( struct FScriptDelegate UpdatePlaylistIdDelegate );
	void ClearScoreData ( );
	void OnVoteEnd ( );
	void OnVoteUpdated ( unsigned long bUpdateMapChoice );
	void OnLobbyCountDownEnd ( );
	void OnLobbyStateUpdated ( );
	void OnRuleSettingsUpdated ( );
	void OnMultiplayerAIDifficultyUpdated ( );
	void OnMultiplayerFactionUpdated ( );
	void OnMultiplayerMapUpdated ( );
	void OnMultiplayerModeUpdated ( );
	void OnMatchTypeUpdated ( );
	void OnPlaylistIdUpdated ( );
	void OnStartUpTimeOut ( );
	void OnVoteTimeOut ( );
	void OnLobbyTimeOut ( );
};

UClass* AYGameReplicationInfo_MPBase::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_MP
// 0x00E4 (0x078C - 0x06A8)
class AYGameReplicationInfo_MP : public AYGameReplicationInfo_MPBase
{
public:
	TArray< struct FYS_RankInfo >                      m_ranks;                                          		// 0x06A8 (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	int                                                m_numPrestigeLevels;                              		// 0x06B4 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      m_bMatchEnded : 1;                                		// 0x06B8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bAutoOpenCharacterSelectionMenu : 1;            		// 0x06B8 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bOnelifeBossChallenge : 1;                      		// 0x06B8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bPlayGameAnnounceVoice : 1;                     		// 0x06B8 (0x0004) [0x0000000000000000] [0x00000008] 
	class UYTracerPoolData*                            m_tracerPoolData;                                 		// 0x06BC (0x0004) [0x0000000000000000]              
	int                                                m_magicNumber;                                    		// 0x06C0 (0x0004) [0x0000000000000000]              
	struct FName                                       m_overridenCharacterListName;                     		// 0x06C4 (0x0008) [0x0000000000000020]              ( CPF_Net )
	int                                                m_timeBeforeSquadRespawn;                         		// 0x06CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_timeBeforeSpecopsRespawn;                       		// 0x06D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_timeBeforeKonradRespawn;                        		// 0x06D4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_respawnSecurityTimer;                           		// 0x06D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYRemoteSpeaker_Team*                        m_SpecopsRemoteSpeaker;                           		// 0x06DC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYRemoteSpeaker_Team*                        m_KonradRemoteSpeaker;                            		// 0x06E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FPointer                                    m_characterSelectionManager;                      		// 0x06E4 (0x0004) [0x0000000000001000]              ( CPF_Native )
	class ATeamInfo*                                   m_currentWinningTeam;                             		// 0x06E8 (0x0004) [0x0000000000000000]              
	TArray< class UYFMODResource_VSB* >                m_gameSoundWaveBanks;                             		// 0x06EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_konradLostLeadVoiceId;                          		// 0x06F8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_konradTookLeadVoiceId;                          		// 0x06FC (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_specopsLostLeadVoiceId;                         		// 0x0700 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_specopsTookLeadVoiceId;                         		// 0x0704 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_konradLastMinuteLeadVoiceId;                    		// 0x0708 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_konradLastMinuteLosingVoiceId;                  		// 0x070C (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_specopsLastMinuteLeadVoiceId;                   		// 0x0710 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_specopsLastMinuteLosingVoiceId;                 		// 0x0714 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_konradGameStartVoice;                           		// 0x0718 (0x0004) [0x0000000000000000]              
	int                                                m_konradGameDescVoice;                            		// 0x071C (0x0004) [0x0000000000000000]              
	int                                                m_specopsGameStartVoice;                          		// 0x0720 (0x0004) [0x0000000000000000]              
	int                                                m_specopsGameDescVoice;                           		// 0x0724 (0x0004) [0x0000000000000000]              
	class UYMusicPart*                                 m_lastMinuteMusicPart;                            		// 0x0728 (0x0004) [0x0000000000000000]              
	float                                              m_MaxDistFromObjectives;                          		// 0x072C (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_SpecAdvantage;                                  		// 0x0730 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UYSoundCueFMOD*                              m_normalHitIndicatorSound;                        		// 0x0734 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_nearDeathHitIndicatorSound;                     		// 0x0738 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_armorHitIndicatorSound;                         		// 0x073C (0x0004) [0x0000000000000000]              
	float                                              m_hitFeebackNormalThreshold;                      		// 0x0740 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_hitFeebackNearDeathThreshold;                   		// 0x0744 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UYSoundCueFMOD*                              m_capturingSound;                                 		// 0x0748 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_ChallengeDefinition >           m_eliteChallenges;                                		// 0x074C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_eliteChallengeResetIndex;                       		// 0x0758 (0x0004) [0x0000000000000000]              
	struct FYS_ChallengeDefinition                     m_bossChallenge;                                  		// 0x075C (0x0014) [0x0000000000000000]              
	TArray< class AYProj_MPOfficerBeacon* >            m_officerBeacons;                                 		// 0x0770 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AYProj_MPOfficerSupply* >            m_officerSupplies;                                		// 0x077C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                ReplicatedElapsedTime;                            		// 0x0788 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2415 ];

		return pClassPointer;
	};

	class UYUIDataProvider_MapInfo* GetCurrentMapInfo ( );
	void IgnoreLocalControllerInput ( );
	void ResetLocalControllerInputState ( );
	void ForceSaveAndUpdateExperienceInProfile ( );
	void UpdateExperienceInProfile ( );
	void EndGame ( );
	void PlayTeamSpecificVoice ( unsigned char TeamNum, int konradVoice, int specopsVoice, float Delay );
	void OnMultiplayerMapUpdatedDelegate ( );
	void OnMultiplayerModeUpdatedDelegate ( );
	void OnPlaylistIdUpdatedDelegate ( );
	bool ArePerksAllowed ( );
	void PostBeginPlay ( );
	bool OnSameTeam ( class AActor* A, class AActor* B );
	void Reset ( );
	bool ShouldShowDBNOIndicator ( );
	bool IsDrawGame ( );
	bool IsWinner ( class AYPlayerReplicationInfo_MP* PRI );
	class APlayerReplicationInfo* GetBestPlayerByTeam ( unsigned char TeamID, unsigned long bPreferAlive, unsigned long bAllowTie );
	class APlayerReplicationInfo* GetWinnerFromTimeUp ( );
	class APlayerReplicationInfo* GetBestPlayer ( unsigned long bPreferAlive, unsigned long bAllowTie );
	bool IsTied ( class APlayerReplicationInfo* P1, class APlayerReplicationInfo* P2, unsigned long bPlayersInOrder );
	bool InOrder ( class APlayerReplicationInfo* P1, class APlayerReplicationInfo* P2 );
	void SortPRIArray ( );
	void Timer ( );
	void PlayLastMinuteWarning ( );
	bool ShouldPlayLastMinuteWarning ( );
	bool NotifyTeamLeadChange ( );
	void CreateObjectPool ( );
	void NotifyPCListCharacterChange ( );
	void SetOverridenCharacterListName ( struct FName listName );
	void ReceivedGameClass ( );
	void ReplicatedEvent ( struct FName VarName );
	void UpdateAdvantage ( );
	bool CheckForBalance ( class AYPlayerController_MP* PC );
	void UpdateModeScores ( class AYVitalPoint* vital );
	void SetupModeArray ( class AYVitalPoint* vital );
	void GetNextRank ( int* iRankLevel );
	int GetRankLevelFromXP ( int xp );
	bool IsNotLastRank ( int iRankLevel );
	bool IsLastRank ( int iRankLevel );
	int GetMaxRank ( );
	int GetRankXPThreshold ( int iRankLevel );
	bool ShowCharacterManagerDebugInfo ( class AYHUD* HUD );
	bool IsPlayerNearObjective ( class AYPlayerReplicationInfo_MP* PRIMP );
	void PlayGameModeStartVoice ( );
	void PlayGameModeDescVoice ( );
	int GetALocalTeamNum ( );
	void SwapSpawns ( );
	void ResetMode ( );
	void ManageDeadPawns_Coop ( );
	bool IsCharacterListOverriden ( );
	int GetBossCharacterCount ( );
	int GetCharacterClassRestrictionCount ( unsigned char TeamID, int iCharacter );
	int GetMajorPerkLevel ( unsigned char TeamID, int iCharacter );
	struct FYS_EquipmentClass GetEquipmentClass ( unsigned char TeamID, int iCharacter, class AYPlayerController_MP* PC );
	struct FYS_CharacterEquipmentList GetCharacter ( unsigned char TeamID, int iCharacter, class AYPlayerController_MP* PC );
	struct FYS_CharacterMeshList GetCharacterMeshList ( unsigned char TeamID, int iCharacter, class AYPlayerController_MP* PC );
	int GetNbCharacterInList ( unsigned char TeamID );
	void CreateCharacterSelectionManager ( );
	void InitializeCharacterSelectionManager ( );
};

UClass* AYGameReplicationInfo_MP::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_Buried
// 0x0034 (0x07C0 - 0x078C)
class AYGameReplicationInfo_Buried : public AYGameReplicationInfo_MP
{
public:
	class AYVitalPoint*                                m_vitalPoints[ 0xA ];                             		// 0x078C (0x0028) [0x0000000000001020]              ( CPF_Net | CPF_Native )
	class AYVitalPoint*                                m_TrumpVitalPoints[ 0x2 ];                        		// 0x07B4 (0x0008) [0x0000000000001020]              ( CPF_Net | CPF_Native )
	int                                                vpOwnerTeam;                                      		// 0x07BC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2416 ];

		return pClassPointer;
	};

	void UpdateModeScores ( class AYVitalPoint* vital );
	void SetupModeArray ( class AYVitalPoint* vital );
	bool InOrder ( class APlayerReplicationInfo* P1, class APlayerReplicationInfo* P2 );
	class APlayerReplicationInfo* AquireWinningTeam ( );
	void AnnounceHVTVisible ( );
	void CheckForTrumpDestroyable ( int Team );
	bool IsPlayerNearObjective ( class AYPlayerReplicationInfo_MP* PRIMP );
	void ServerVitalPointDestroyed ( class AYVitalPoint* vital );
	bool ShouldGameEnd ( );
	bool IsShowingAvalancheMovie ( );
	class APlayerReplicationInfo* AquireWinner ( );
};

UClass* AYGameReplicationInfo_Buried::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_CA
// 0x0050 (0x07DC - 0x078C)
class AYGameReplicationInfo_CA : public AYGameReplicationInfo_MP
{
public:
	class AYChopperDestroyBase*                        m_destructionBases[ 0x5 ];                        		// 0x078C (0x0014) [0x0000000000000020]              ( CPF_Net )
	class AYComStation*                                m_comStations[ 0xD ];                             		// 0x07A0 (0x0034) [0x0000000000000020]              ( CPF_Net )
	class AYChopperCallBase*                           m_radioBase;                                      		// 0x07D4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_attackingTeam;                                  		// 0x07D8 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2417 ];

		return pClassPointer;
	};

	void UpdateModeScores ( class AYVitalPoint* vital );
	void SetupModeArray ( class AYVitalPoint* vital );
	bool InOrder ( class APlayerReplicationInfo* P1, class APlayerReplicationInfo* P2 );
	class APlayerReplicationInfo* AquireWinner ( );
	bool IsPlayerNearObjective ( class AYPlayerReplicationInfo_MP* PRIMP );
	class APlayerReplicationInfo* GetWinnerFromTimeUp ( );
	void ResetMode ( );
};

UClass* AYGameReplicationInfo_CA::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_CP
// 0x001C (0x07A8 - 0x078C)
class AYGameReplicationInfo_CP : public AYGameReplicationInfo_MP
{
public:
	unsigned long                                      m_bIsChoreoPlaying : 1;                           		// 0x078C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	struct FString                                     m_currentObjectiveMessage[ 0x2 ];                 		// 0x0790 (0x0018) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2418 ];

		return pClassPointer;
	};

	void UpdateChoreoStatus ( );
	void SetChoreoStatus ( unsigned long bNewChoreoStatus );
	bool IsChoreoPlaying ( );
	void IncrementVictoryStreak ( );
	int GetPlayerRankInTeam ( class APlayerReplicationInfo* PRI );
	bool ShouldPlayLastMinuteWarning ( );
	bool NotifyTeamLeadChange ( );
	bool ShouldShowDBNOIndicator ( );
	bool InOrder ( class APlayerReplicationInfo* P1, class APlayerReplicationInfo* P2 );
	void SetObjectiveMessageForTeam ( unsigned char TeamID, struct FString Message );
	void ClearObjectiveMessage ( );
	void NotifyStrategyManagerCharacterListSet ( );
	void ReplicatedEvent ( struct FName VarName );
	void BackupScore ( );
};

UClass* AYGameReplicationInfo_CP::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_Delivery
// 0x0090 (0x081C - 0x078C)
class AYGameReplicationInfo_Delivery : public AYGameReplicationInfo_MP
{
public:
	class AYDeliveryDefendingBase*                     m_bases[ 0xA ];                                   		// 0x078C (0x0028) [0x0000000000000020]              ( CPF_Net )
	class AYPlayerController_Delivery*                 m_specInstigatorController;                       		// 0x07B4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYPlayerController_Delivery*                 m_konInstigatorController;                        		// 0x07B8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYDeliveryPackage*                           m_specExplodingPackage;                           		// 0x07BC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYDeliveryPackage*                           m_konExplodingPackage;                            		// 0x07C0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYDeliveryPackage*                           m_specDroppedPackage;                             		// 0x07C4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYDeliveryPackage*                           m_konDroppedPackage;                              		// 0x07C8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYDeliveryPackage*                           m_specStartingPackage;                            		// 0x07CC (0x0004) [0x0000000000000000]              
	class AYDeliveryPackage*                           m_konStartingPackage;                             		// 0x07D0 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_specBombStart;                                  		// 0x07D4 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FRotator                                    m_specBombRotation;                               		// 0x07E0 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_konBombStart;                                   		// 0x07EC (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FRotator                                    m_konBombRotation;                                		// 0x07F8 (0x000C) [0x0000000000000000]              
	float                                              m_specArmTime;                                    		// 0x0804 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_konArmTime;                                     		// 0x0808 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_detonateTime;                                   		// 0x080C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_enemyNearPackage[ 0x2 ];                        		// 0x0810 (0x0008) [0x0000000000000020]              ( CPF_Net )
	int                                                m_attackersTeam;                                  		// 0x0818 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2419 ];

		return pClassPointer;
	};

	class AYDeliveryPackage* GetExplodingPackage ( );
	class APlayerReplicationInfo* AquireWinner ( );
	class APlayerReplicationInfo* GetWinnerFromTimeUp ( );
	bool IsPlayerNearObjective ( class AYPlayerReplicationInfo_MP* PRIMP );
	void ResetMode ( );
	void PostBeginPlay ( );
};

UClass* AYGameReplicationInfo_Delivery::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_DM
// 0x0004 (0x0790 - 0x078C)
class AYGameReplicationInfo_DM : public AYGameReplicationInfo_MP
{
public:
	class APlayerReplicationInfo*                      m_leaderPRI;                                      		// 0x078C (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2420 ];

		return pClassPointer;
	};

	void SortPRIArray ( );
	bool IsWinner ( class AYPlayerReplicationInfo_MP* PRI );
	bool OnSameTeam ( class AActor* A, class AActor* B );
};

UClass* AYGameReplicationInfo_DM::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_HD
// 0x000C (0x0798 - 0x078C)
class AYGameReplicationInfo_HD : public AYGameReplicationInfo_MP
{
public:
	class AYDestroyPoint*                              m_destroyPoints[ 0x2 ];                           		// 0x078C (0x0008) [0x0000000000000020]              ( CPF_Net )
	class AYCapturePointVolume*                        m_capturePointVolume;                             		// 0x0794 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2421 ];

		return pClassPointer;
	};

	void PlayStationRepairVoice ( int destroyPointTeam, int PlayerTeam );
	void PlayStationSabotageVoice ( int destroyPointTeam, int PlayerTeam );
	bool InOrder ( class APlayerReplicationInfo* P1, class APlayerReplicationInfo* P2 );
	bool IsPlayerNearObjective ( class AYPlayerReplicationInfo_MP* PRIMP );
};

UClass* AYGameReplicationInfo_HD::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_Offline
// 0x0034 (0x07C0 - 0x078C)
class AYGameReplicationInfo_Offline : public AYGameReplicationInfo_MP
{
public:
	class AYComStation*                                m_comStations[ 0xD ];                             		// 0x078C (0x0034) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2422 ];

		return pClassPointer;
	};

	void PlayStationRepairVoice ( int PlayerTeam );
	void PlayStationSabotageVoice ( int PlayerTeam );
	bool InOrder ( class APlayerReplicationInfo* P1, class APlayerReplicationInfo* P2 );
	class APlayerReplicationInfo* AquireWinner ( );
	bool IsPlayerNearObjective ( class AYPlayerReplicationInfo_MP* PRIMP );
	void Tick ( float DeltaTime );
};

UClass* AYGameReplicationInfo_Offline::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_RP
// 0x0018 (0x07A4 - 0x078C)
class AYGameReplicationInfo_RP : public AYGameReplicationInfo_MP
{
public:
	TArray< class AYCapturePointVolume* >              m_capturePointVolumeArray;                        		// 0x078C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_currentCapturePoint;                            		// 0x0798 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_numCapturePointsSpawned;                        		// 0x079C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_timeBeforeChangeCapturePoint;                   		// 0x07A0 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2423 ];

		return pClassPointer;
	};

	void EnableRandomCapturePoint ( );
	void ActivateFirstCapturePoint ( );
	void DeactivateAllCapturePoints ( );
	bool InOrder ( class APlayerReplicationInfo* P1, class APlayerReplicationInfo* P2 );
	void ResetMode ( );
};

UClass* AYGameReplicationInfo_RP::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_SDM
// 0x0020 (0x07AC - 0x078C)
class AYGameReplicationInfo_SDM : public AYGameReplicationInfo_MP
{
public:
	class AYRADStation*                                m_radDevices[ 0x8 ];                              		// 0x078C (0x0020) [0x0000000000001020]              ( CPF_Net | CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2424 ];

		return pClassPointer;
	};

	void ActivateRAD ( );
};

UClass* AYGameReplicationInfo_SDM::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_SW
// 0x0018 (0x07A4 - 0x078C)
class AYGameReplicationInfo_SW : public AYGameReplicationInfo_MP
{
public:
	class AYGoldTreasurePointVolume*                   m_capturePointVolumes[ 0x2 ];                     		// 0x078C (0x0008) [0x0000000000000020]              ( CPF_Net )
	TArray< class AYGoldDepot* >                       m_goldDepots;                                     		// 0x0794 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_secondsTilBank;                                 		// 0x07A0 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2425 ];

		return pClassPointer;
	};

	bool InOrder ( class APlayerReplicationInfo* P1, class APlayerReplicationInfo* P2 );
	bool ConditionalUpdateScores ( );
	class APlayerReplicationInfo* AquireTimeLimitWinner ( );
	class APlayerReplicationInfo* AquireWinner ( );
	void BankGold ( );
	bool IsPlayerNearObjective ( class AYPlayerReplicationInfo_MP* PRIMP );
};

UClass* AYGameReplicationInfo_SW::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_TDM
// 0x0000 (0x078C - 0x078C)
class AYGameReplicationInfo_TDM : public AYGameReplicationInfo_MP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2426 ];

		return pClassPointer;
	};

};

UClass* AYGameReplicationInfo_TDM::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_TE
// 0x0018 (0x07A4 - 0x078C)
class AYGameReplicationInfo_TE : public AYGameReplicationInfo_MP
{
public:
	int                                                m_numSpecops;                                     		// 0x078C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_numKonrad;                                      		// 0x0790 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_1v1BlipFlash : 1;                               		// 0x0794 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	float                                              m_timeBetweenBlipFlashes;                         		// 0x0798 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_timeBetweenBlipFlashesOneMinute;                		// 0x079C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_timeBetweenBlipFlashesTenSeconds;               		// 0x07A0 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2427 ];

		return pClassPointer;
	};

	void Stop1v1Blips ( );
	void Update1v1Blips ( );
	void StartMatch ( );
	bool NotifyTeamLeadChange ( );
};

UClass* AYGameReplicationInfo_TE::pClassPointer = NULL;

// Class SRGame.YGoldTreasurePointVolume
// 0x00D0 (0x02C8 - 0x01F8)
class AYGoldTreasurePointVolume : public AActor
{
public:
	class UMaterialInstance*                           m_ShimmerMaterial;                                		// 0x01F8 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_FlareObjects;                                   		// 0x01FC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_fDepositTime;                                   		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_DepositedGold;                                  		// 0x020C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fBankedGold;                                    		// 0x0210 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_team;                                           		// 0x0214 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	unsigned long                                      m_bHasGold : 1;                                   		// 0x0218 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FLinearColor                                m_allyStationColorStart;                          		// 0x021C (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_allyStationColorEnd;                            		// 0x022C (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationColorStart;                         		// 0x023C (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationColorEnd;                           		// 0x024C (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_allyStationArrowColor;                          		// 0x025C (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationArrowColor;                         		// 0x026C (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_allyStationColorText;                           		// 0x027C (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationColorText;                          		// 0x028C (0x0010) [0x0000000000004000]              ( CPF_Config )
	class UAudioComponent*                             m_ambientSoundPlayer;                             		// 0x029C (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_interationSoundPlayer;                          		// 0x02A0 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UYSoundCueFMOD*                              m_stealSound;                                     		// 0x02A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_depositSound;                                   		// 0x02A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_depositInteractionSound;                        		// 0x02AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYSoundCueFMOD*                              m_stealInteractionSound;                          		// 0x02B0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_konradStealingVoiceId;                          		// 0x02B4 (0x0004) [0x0000000000000000]              
	int                                                m_specopsStealingVoiceId;                         		// 0x02B8 (0x0004) [0x0000000000000000]              
	int                                                m_konradDepositingVoiceId;                        		// 0x02BC (0x0004) [0x0000000000000000]              
	int                                                m_specopsDepositingVoiceId;                       		// 0x02C0 (0x0004) [0x0000000000000000]              
	float                                              m_notificationVoiceTimer;                         		// 0x02C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2428 ];

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void SetShimmerColor ( );
	void BankGold ( );
	void CheckDepositedGold ( );
};

UClass* AYGoldTreasurePointVolume::pClassPointer = NULL;

// Class SRGame.YMapInfo
// 0x0064 (0x00A0 - 0x003C)
class UYMapInfo : public UMapInfo
{
public:
	unsigned long                                      m_isMainIndexLevel : 1;                           		// 0x003C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_isIndexLevel : 1;                               		// 0x003C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_isPathLevel : 1;                                		// 0x003C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_isStartLevel : 1;                               		// 0x003C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_pathWasRebuilt : 1;                             		// 0x003C (0x0004) [0x0000000000000000] [0x00000010] 
	TArray< struct FName >                             m_pathLevels;                                     		// 0x0040 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FName                                       m_indexLevel;                                     		// 0x004C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_mainIndexLevel;                                 		// 0x0054 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	TArray< int >                                      m_graphIDs;                                       		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_TimeOrDegrees                           m_localTime;                                      		// 0x0068 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_TimeOrDegrees                           m_localLongitude;                                 		// 0x0074 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_TimeOrDegrees                           m_localLatitude;                                  		// 0x0080 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_northernDirection;                              		// 0x008C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_elevationAboveSeaLevel;                         		// 0x0094 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_humidity;                                       		// 0x0098 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_temperature;                                    		// 0x009C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2429 ];

		return pClassPointer;
	};

};

UClass* UYMapInfo::pClassPointer = NULL;

// Class SRGame.YMatchmakingManager
// 0x006C (0x00A8 - 0x003C)
class UYMatchmakingManager : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                          		// 0x003C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	unsigned char                                      m_PreviousState;                                  		// 0x0040 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_MatchmakingState;                               		// 0x0041 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_PendingMatchmakingState;                        		// 0x0042 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bApplyStateOnNextTick : 1;                      		// 0x0044 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bUseQuickmatch : 1;                             		// 0x0044 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bStartSystemLinkMatch : 1;                      		// 0x0044 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bOpenUISceneWhenReady : 1;                      		// 0x0044 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_bQuitMatchmakingOnFinish : 1;                   		// 0x0044 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_bEndListeningOnQuit : 1;                        		// 0x0044 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_bValidPartySkillData : 1;                       		// 0x0044 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_bInAsyncWork : 1;                               		// 0x0044 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_bWasHost : 1;                                   		// 0x0044 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	int                                                m_numberOfQoSQueryFailuresDuringMatchMaking;      		// 0x0048 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UOnlineSubsystemCommonImpl*                  m_OnlineSubCommon;                                		// 0x004C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYMatchmakingHostComponent*                  m_HostCmpnt;                                      		// 0x0050 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYMatchmakingHostInviteComponent*            m_HostInviteCmpnt;                                		// 0x0054 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYMatchmakingPartyComponent*                 m_PartyCmpnt;                                     		// 0x0058 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYMatchmakingSearchComponent*                m_SearchCmpnt;                                    		// 0x005C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYMatchmakingJoinComponent*                  m_JoinCmpnt;                                      		// 0x0060 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYMatchmakingJoinInviteComponent*            m_JoinInviteCmpnt;                                		// 0x0064 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_OwnerControllerIndex;                           		// 0x0068 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYLeaderboardMultiplayerSkill*               m_MultiplayerSkillLeaderboard;                    		// 0x006C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYGameSearchMultiplayer*                     m_MultiplayerMatchSearch;                         		// 0x0070 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYGameSearchQM*                              m_QuickMatchSearch;                               		// 0x0074 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_PlayerFullName;                                 		// 0x0078 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUIMessageBoxBase*                           m_MatchmakingProgressMessageBox;                  		// 0x0084 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_MatchmakingMessageBoxName;                      		// 0x0088 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FScriptDelegate >                   CleanupFinishedDelegates;                         		// 0x0090 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnCleanupFinished__Delegate;                    		// 0x009C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2430 ];

		return pClassPointer;
	};

	void JoinSpecificSession ( struct FOnlineGameSearchResult SessionToJoin );
	void JoinSystemLinkSession ( struct FOnlineGameSearchResult SessionToJoin );
	void ConnectToPartyBeacon ( class AYPlayerController* PC, unsigned long bCanJoinOppositTeam );
	unsigned char PickTeam ( unsigned char DesiredTeamNum, class AController* C );
	void HostInviteUnregisterPlayer ( struct FUniqueNetId PlayerID );
	void HostUnregisterPlayer ( struct FUniqueNetId PlayerID );
	bool HostRegisterPlayer ( struct FUniqueNetId PlayerID, int TeamIndex, unsigned long bWasFromInvite );
	void ClientFinishRegisterPlayer ( unsigned long bWasFromInvite );
	void ClientStartRegisterPlayer ( unsigned long bWasFromInvite );
	void UpdateGameOnlineStatus ( unsigned long checkLastManStanding );
	void ClientUpdatePlayerTeam ( struct FUniqueNetId PlayerID, int NewTeamIndex );
	void HostUpdatePlayerTeam ( struct FUniqueNetId PlayerID, int OldTeamIndex, int NewTeamIndex );
	void UpdatePartyTeamNum ( int TeamNum );
	void UpdateTeamListSkillDataFromLeaderboard ( class UYLeaderboardMultiplayerSkill* SkillLeaderboard, TArray< struct FPlayerReservation >* TeamList );
	void UpdateTeamListSkillData ( TArray< struct FPlayerReservation >* TeamList );
	int AddRegisteredPlayersToTeamList ( int TeamNum, int MaxAddedPlayerCount, TArray< struct FPlayerReservation >* TeamList );
	int GetPartyPlayerCount ( );
	class AYPlayerController_MPBase* GetOwnerController ( );
	class AYPlayerController_MPBase* GetPlayerController ( int ControllerIndex );
	class ULocalPlayer* GetPlayerOwner ( int PlayerIndex );
	bool IsStartingSystemLinkMatch ( );
	bool IsJoinInviteComponentJoiningFriendSession ( );
	bool IsJoinComponentBeaconValid ( );
	bool IsHostComponentBeaconValid ( );
	void ProcessTravelToSession ( unsigned long bHostingMatch, unsigned long bDontProcessTravel );
	void FinishProcessHostMatch ( struct FName SessionName, unsigned long bWasSuccessful );
	void ProcessHostMatch ( );
	void ProcessJoinBestMatchingSession ( );
	void ProcessFindBestMatchingSession ( );
	void ProcessFindMatchingSessions ( );
	bool CheckMatchMakingFailedDueToConnectionError ( );
	void ContinueOnlineServiceReachableWhileMatchMaking ( );
	void OnOnlineServiceReachableCompleteWhileMatchmaking ( unsigned long bWasSuccessful, float timeLeftUntilNextQuery );
	void StartOnlineServiceReachableRequest ( );
	void OnStartOnlinePartyComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	bool StartPartyMatching ( );
	void OnReadPartySkillComplete ( unsigned long bWasSuccessful );
	void ReadPartySkillData ( );
	void OnReadyForMatchmaking ( );
	void ProcessHostCancelPartyMatchmaking ( unsigned char PreviousState );
	void ProcessCancelPartyMatchmaking ( unsigned char PreviousState );
	bool MatchmakingCancelButtonPressed ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void ShowMatchmakingProgressMessage ( unsigned long bCloseMessageBox );
	void ProcessMatchmakingStateChange ( unsigned char NewState, unsigned long bDontProcessTravel );
	bool IsTravellingToSession ( );
	bool HasJoinedMatchSession ( );
	bool IsWaitingForSessionInfo ( );
	bool IsMatchMaking ( );
	bool IsReadyForMatchmaking ( );
	bool IsInitializingMatchmaking ( );
	bool IsReadyForInitialization ( );
	void QuitMatchmaking ( unsigned long bSkipQuitMatchmakingOnFinishIfPartyLeader );
	void ProcessQuitMatchmaking ( );
	void FinishReadyForMatchmaking ( );
	void OnEndOnlinePartyComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void OnDestroyOnlineGameComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void EndPartySession ( );
	void OnEndOnlineGameComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void OnStartOnlineGameComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void ResetTier2 ( );
	void EndMatchmaking ( );
	bool IsInAsyncWork ( );
	void StartSystemLinkMatch ( );
	void StartOnlineMatch ( );
	void StartMatchMaking ( int ControllerIndex, unsigned char MultiplayerGameType );
	void EndListening ( );
	bool StartListening ( struct FString URL );
	bool InitializePartyHostInviteConnection ( int HostControllerIndex, struct FName PartySessionName );
	void ClearDelegates ( );
	void ClearCleanupFinishedDelegate ( struct FScriptDelegate CleanupFinishedDelegate );
	void AddCleanupFinishedDelegate ( struct FScriptDelegate CleanupFinishedDelegate );
	void OnCleanupOnlineSubsystemComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void CleanupOnlineSubsystem ( );
	void Reset ( );
	void CancelMatchMakingAndQuitToMainMenuDelayed ( );
	void Tick ( float DeltaTime );
	void ApplyStateOnNextTick ( unsigned char MState );
	void InitGameReplicationInfoFromPartySettings ( class AYGameReplicationInfo_MPBase* GRI, class UYGameSettingsParty* GameSettings );
	void InitMatchmakingForJoinInvite ( int ControllerIndex );
	void InitMatchmaking ( class AYGameInfo* CurrentGameInfo, int ControllerIndex, class UYGameSettingsParty* PartyGameSettings, unsigned long bQuickMatch, unsigned long bOpenUISceneWhenReady );
	void ContinueMatchmaking ( class AYGameInfo* CurrentGameInfo, int ControllerIndex, class UYGameSettingsParty* PartyGameSettings, unsigned long bQuickMatch, unsigned long bOpenUISceneWhenReady );
	void PostTravel ( class AYGameInfo* CurrentGameInfo );
	void PreTravel ( );
	void ResetMatchmakingState ( class AYGameInfo* CurrentGameInfo );
	void Init ( class UOnlineSubsystem* CurrentOnlineSub );
	void HandleClientDirectJoining ( );
	void SetupForCommandLineRun ( class AYGameInfo_MP* YGI );
	void OnCleanupFinished ( );
};

UClass* UYMatchmakingManager::pClassPointer = NULL;

// Class SRGame.YOPEmitter
// 0x000C (0x0210 - 0x0204)
class AYOPEmitter : public AEmitter
{
public:
	struct FName                                       m_turnOffFnc;                                     		// 0x0204 (0x0008) [0x0000000000000000]              
	class UParticleSystem*                             m_particleSystem;                                 		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2431 ];

		return pClassPointer;
	};

	void OnSystemFinished__Delegate ( );
	void HideBecauseFinished ( class UParticleSystemComponent* FinishedComponent );
	void TurnOff ( );
	void InitEmitter ( struct FVector StartLoc, struct FVector endLoc, struct FRotator Rot );
};

UClass* AYOPEmitter::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo
// 0x0104 (0x03B8 - 0x02B4)
class AYPlayerReplicationInfo : public APlayerReplicationInfo
{
public:
	class AYPlayerReplicationInfo*                     LastKillerPRI;                                    		// 0x02B4 (0x0004) [0x0000000000000000]              
	int                                                m_teamNumForTravel;                               		// 0x02B8 (0x0004) [0x0000000000000000]              
	int                                                m_successiveKills;                                		// 0x02BC (0x0004) [0x0000000000000000]              
	float                                              m_lastKillTime;                                   		// 0x02C0 (0x0004) [0x0000000000000000]              
	float                                              m_successiveKillTime;                             		// 0x02C4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_currentKillStreak;                              		// 0x02C8 (0x0004) [0x0000000000000000]              
	int                                                m_longestKillStreak;                              		// 0x02CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_bloodThirstStreak;                              		// 0x02D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      bIsLeader : 1;                                    		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      bSquadLeader : 1;                                 		// 0x02D4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_isDownButNotOut : 1;                            		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_canSelfRevive : 1;                              		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      m_canTeamRevive : 1;                              		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      m_canBeExecutedInDBNO : 1;                        		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned long                                      m_canBeDamagedInDBNO : 1;                         		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      m_canSuicideInDBNO : 1;                           		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      m_isBleedingOut : 1;                              		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000100] ( CPF_Net )
	unsigned long                                      m_perkLevel2Cheat : 1;                            		// 0x02D4 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bSeeEnemyOnTacticalVision : 1;                  		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000400] ( CPF_Net )
	unsigned long                                      m_bSeeMeOnTacticalVision : 1;                     		// 0x02D4 (0x0004) [0x0000000000000020] [0x00000800] ( CPF_Net )
	unsigned long                                      m_bHost : 1;                                      		// 0x02D4 (0x0004) [0x0000000000000020] [0x00001000] ( CPF_Net )
	unsigned long                                      m_bHasSwitchTeamPendingRequest : 1;               		// 0x02D4 (0x0004) [0x0000000040000020] [0x00002000] ( CPF_Net | CPF_EditInlineNotify )
	struct FName                                       SquadName;                                        		// 0x02D8 (0x0008) [0x0000000040000020]              ( CPF_Net | CPF_EditInlineNotify )
	class UClass*                                      PawnClass;                                        		// 0x02E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                PreferredSRIndex;                                 		// 0x02E4 (0x0004) [0x0000000000000000]              
	int                                                PreferredEFIndex;                                 		// 0x02E8 (0x0004) [0x0000000000000000]              
	float                                              m_bleedoutDuration;                               		// 0x02EC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_bleedOutTimeStamp;                              		// 0x02F0 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_majorPerkType;                                  		// 0x02F4 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_MajorPerkLevel;                                 		// 0x02F5 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_minorPerkTypes[ 0x3 ];                          		// 0x02F6 (0x0003) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_minorPerkLevels[ 0x3 ];                         		// 0x02F9 (0x0003) [0x0000000000000020]              ( CPF_Net )
	float                                              m_totalFlameTime;                                 		// 0x02FC (0x0004) [0x0000000000000000]              
	float                                              m_totalFlameDmgTime;                              		// 0x0300 (0x0004) [0x0000000000000000]              
	int                                                m_takeDowns;                                      		// 0x0304 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_knockedOuts;                                    		// 0x0308 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_revives;                                        		// 0x030C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_totalDamageDoneInLastLife;                      		// 0x0310 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_totalDamageTakenInLastLife;                     		// 0x0314 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_totalDamageDoneInThisLife;                      		// 0x0318 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_totalDamageTakenInThisLife;                     		// 0x031C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_totalDamageDone;                                		// 0x0320 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_totalDamageTaken;                               		// 0x0324 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_totalFriendlyDamageDone;                        		// 0x0328 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_personalStatsReplicationDelaySP;                		// 0x032C (0x0004) [0x0000000000000000]              
	int                                                m_hitsSP;                                         		// 0x0330 (0x0004) [0x0000000000000000]              
	int                                                m_shotsSP;                                        		// 0x0334 (0x0004) [0x0000000000000000]              
	struct FString                                     EmptyColumn;                                      		// 0x0338 (0x000C) [0x0000000040400000]              ( CPF_NeedCtorLink | CPF_EditInlineNotify )
	float                                              m_horizontalRotationSensitivityValues[ 0xB ];     		// 0x0344 (0x002C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_verticalRotationSensitivityValues[ 0xB ];       		// 0x0370 (0x002C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_horizontalRotationSensitivity;                  		// 0x039C (0x0004) [0x0000000000000000]              
	float                                              m_verticalRotationSensitivity;                    		// 0x03A0 (0x0004) [0x0000000000000000]              
	float                                              m_horizontalRotationSensitivityMouse;             		// 0x03A4 (0x0004) [0x0000000000000000]              
	float                                              m_verticalRotationSensitivityMouse;               		// 0x03A8 (0x0004) [0x0000000000000000]              
	int                                                m_SelectedTitle;                                  		// 0x03AC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_SelectedBadge;                                  		// 0x03B0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_UIDResendTimeStamp;                             		// 0x03B4 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2432 ];

		return pClassPointer;
	};

	void DelayedInitTravelToGameSession ( );
	void YRegisterPlayerWithSession ( unsigned long allowTravelToGameSession );
	void RegisterPlayerWithSession ( );
	void UpdateRotationSensitivity ( class UYProfileSettings* Profile );
	void SetRotationSensitivity ( int SettingId, int Sensitivity );
	void ServerSetSelectedBadge ( int selectedBadge );
	void SetSelectedBadge ( int selectedBadge );
	void ServerSetSelectedTitle ( int selectedTitle );
	void SetSelectedTitle ( int selectedTitle );
	void SetSquadName ( struct FName NewSquadName );
	struct FName GetSquadName ( );
	void ClearPendingSwitchTeam ( );
	void RequestPendingSwitchTeam ( );
	bool HasSwitchTeamRequestPending ( );
	void SetHost ( );
	bool IsInvalidName ( );
	void ClientInitialize ( class AController* C );
	void DisplayDebug ( class AHUD* H, float* YL, float* YPos );
	bool AttemptMidGameMenu ( );
	void ShowMidGameMenu ( unsigned long bInitial );
	unsigned char GetTeamNum ( );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
	void ResetPRIToInitialState ( );
	void Reset ( );
	void SetLeader ( unsigned long lead );
	void BroadcastLeaderStatusChange ( int Switch );
	void RefreshLobbyScene ( );
	bool ShouldBroadCastWelcomeMessage ( unsigned long bExiting );
	void OnPerksChanged ( class AYGamePawn* pwn );
	unsigned char GetPerkLevel ( unsigned char perk_type );
	bool HasPerkOfType ( unsigned char perk_type );
	void ClientUpdatePersonalStats ( int hits, int shots );
	void UpdateClientPersonalStats ( );
	void IncrementShots ( );
	void ResetHitStreak ( );
	void IncrementHitStreak ( );
	void IncrementHits ( float PercentRaysHit );
	void IncrementDeaths ( int Amt );
	void ResetBloodThirst ( );
	void IncrementKills ( unsigned long bEnemyKill );
	void InitLongestKillStreak ( );
	void IncrementDamageTaken ( int Damage );
	void IncrementDamageDone ( int Damage, unsigned long bFriendlyFire );
	void SetPlayerTeam ( class ATeamInfo* NewTeam );
	void ReplicatedDataBinding ( struct FName VarName );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYPlayerReplicationInfo::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_MPBase
// 0x0118 (0x04D0 - 0x03B8)
class AYPlayerReplicationInfo_MPBase : public AYPlayerReplicationInfo
{
public:
	struct FYS_ExperienceData                          m_experienceData;                                 		// 0x03B8 (0x00FC) [0x0000000000000020]              ( CPF_Net )
	int                                                m_rankLevel;                                      		// 0x04B4 (0x0004) [0x0000000040000000]              ( CPF_EditInlineNotify )
	int                                                m_playerCurrentRankLevel;                         		// 0x04B8 (0x0004) [0x0000000040000000]              ( CPF_EditInlineNotify )
	struct FXPInfo                                     m_XpInfo;                                         		// 0x04BC (0x000C) [0x0000000000000020]              ( CPF_Net )
	int                                                m_MapVoteIndex;                                   		// 0x04C8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_HasVoted : 1;                                   		// 0x04CC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bHeadsetPresent : 1;                            		// 0x04CC (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bIsInSeamlessTravel : 1;                        		// 0x04CC (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2433 ];

		return pClassPointer;
	};

	bool HasVoted ( );
	void SetVoteIndex ( int Index );
	int GetVoteIndex ( );
	void NotifyLocalPlayerExperienceChange ( );
	void OnXpInfoReplication ( );
	void ResetBonusMatchXP ( );
	void ResetCollectedXPFromChallenges ( );
	void ResetCollectedXP ( );
	void AddBonusMatchXP ( int iBonusMatchXP );
	void AddCollectedXPFromChallenges ( int iCollectedXPFromChallenges );
	void AddCollectedXP ( int iCollectedXP );
	int GetBonusMatchXP ( );
	int GetCollectedXPFromChallenges ( );
	int GetCollectedXP ( );
	int GetPlayerPrestigeLevel ( );
	int GetPlayerXP ( );
	int GetPlayerRankLevel ( );
	bool IsExperienceSystemInitialized ( );
	void UpdateCurrentRankLevelDatabinding ( );
	void UpdateRankLevelDatabindings ( );
	void ServerSendExperienceData ( struct FYS_ExperienceData experienceData );
	void ClientSendExperienceData ( );
	void OnExperienceDataChanged ( );
	void UnregisterPlayerFromSession ( );
	void Reset ( );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
	void SetPlayerTeam ( class ATeamInfo* NewTeam );
	void ReplicatedEvent ( struct FName VarName );
	void ClientInitialize ( class AController* C );
	void ServerSetHeadsetPresence ( unsigned long bPresent );
	bool ShouldBroadCastWelcomeMessage ( unsigned long bExiting );
	void SeamlessTravelTo ( class APlayerReplicationInfo* NewPRI );
};

UClass* AYPlayerReplicationInfo_MPBase::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_MP
// 0x012C (0x05FC - 0x04D0)
class AYPlayerReplicationInfo_MP : public AYPlayerReplicationInfo_MPBase
{
public:
	int                                                m_hits;                                           		// 0x04D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_hitsAsOpponentTeam;                             		// 0x04D4 (0x0004) [0x0000000000000000]              
	int                                                m_Shots;                                          		// 0x04D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_shotsAsOpponentTeam;                            		// 0x04DC (0x0004) [0x0000000000000000]              
	int                                                m_currentHitStreak;                               		// 0x04E0 (0x0004) [0x0000000000000000]              
	int                                                m_biggestHitStreak;                               		// 0x04E4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_deathStreak;                                    		// 0x04E8 (0x0004) [0x0000000000000000]              
	int                                                m_lastDamageAmount;                               		// 0x04EC (0x0004) [0x0000000000000000]              
	int                                                m_collectedXP;                                    		// 0x04F0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_Annihilations;                                  		// 0x04F4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bWasArming : 1;                                 		// 0x04F8 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bWasDisarming : 1;                              		// 0x04F8 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bIsInBeacon : 1;                                		// 0x04F8 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_bIsInSupply : 1;                                		// 0x04F8 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      m_bFriendlyCrosshair : 1;                         		// 0x04F8 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      m_bIsElite : 1;                                   		// 0x04F8 (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned long                                      m_bIsBoss : 1;                                    		// 0x04F8 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bKilledDev : 1;                                 		// 0x04F8 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      m_bHasRun : 1;                                    		// 0x04F8 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bHasCrouched : 1;                               		// 0x04F8 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bHasUsedCover : 1;                              		// 0x04F8 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bHasUsedOnlyMelee : 1;                          		// 0x04F8 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bHasAttacked : 1;                               		// 0x04F8 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bHasUsedPerkOrArmor : 1;                        		// 0x04F8 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bHad2HeavyWeaponsEquipped : 1;                  		// 0x04F8 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bSeeEnemyDBNO : 1;                              		// 0x04F8 (0x0004) [0x0000000000000020] [0x00008000] ( CPF_Net )
	unsigned long                                      m_bLastGrenadeFromZipline : 1;                    		// 0x04F8 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_bCallingForHelp : 1;                            		// 0x04F8 (0x0004) [0x0000000000000020] [0x00020000] ( CPF_Net )
	unsigned long                                      m_bMeshesSetUp : 1;                               		// 0x04F8 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_bForceVisibleToOtherTeamHUD : 1;                		// 0x04F8 (0x0004) [0x0000000000000020] [0x00080000] ( CPF_Net )
	unsigned long                                      m_useRandomEnemyTeamName : 1;                     		// 0x04F8 (0x0004) [0x0000000000000020] [0x00100000] ( CPF_Net )
	int                                                m_executions;                                     		// 0x04FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_heals;                                          		// 0x0500 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYProj_MPOfficerBeacon*                      m_pBeacon;                                        		// 0x0504 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYProj_MPOfficerSupply*                      m_pSupply;                                        		// 0x0508 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_lastEquipmentChangeTime;                        		// 0x050C (0x0004) [0x0000000000000000]              
	float                                              m_lastWeaponChangeTime;                           		// 0x0510 (0x0004) [0x0000000000000000]              
	TArray< struct FWeaponAccuracyInfo >               WeaponAccuracies;                                 		// 0x0514 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_CharacterEquipmentList                  m_EquipmentChoose;                                		// 0x0520 (0x0050) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_MatchRank;                                      		// 0x0570 (0x0004) [0x0000000040000000]              ( CPF_EditInlineNotify )
	int                                                m_SpecOpsCharacterChosen;                         		// 0x0574 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_KonradCharacterChosen;                          		// 0x0578 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_myWeaponEnum;                                   		// 0x057C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_eliteLevelCurrentlyUnlocked;                    		// 0x0580 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_eliteLevelPreviouslyUnlocked;                   		// 0x0584 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_previousDamageOnBossSelection;                  		// 0x0588 (0x0004) [0x0000000000000000]              
	int                                                m_explosiveMultikillCount;                        		// 0x058C (0x0004) [0x0000000000000000]              
	int                                                m_bossIndexChoose;                                		// 0x0590 (0x0004) [0x0000000000000000]              
	int                                                m_armorValue;                                     		// 0x0594 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_GlobalVictoryStreak;                            		// 0x0598 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_TeamVictoryStreak;                              		// 0x059C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_numFriendlyKills;                               		// 0x05A0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_friendlyKillRespawnPenalty;                     		// 0x05A4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_tacIconOffset;                                  		// 0x05A8 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FYS_CharacterMeshList                       m_CharacterMeshList;                              		// 0x05B4 (0x0018) [0x0000000000000020]              ( CPF_Net )
	struct FYS_CharacterMeshAssetList                  m_CharacterMeshAssets;                            		// 0x05CC (0x0014) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_NumberOfPendingPackageLoads;                    		// 0x05E0 (0x0004) [0x0000000000000000]              
	class UYMPMeshLookupTable*                         m_MeshLookupTable;                                		// 0x05E4 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_ReplicatedWeapons[ 0x3 ];                       		// 0x05E8 (0x0003) [0x0000000000000020]              ( CPF_Net )
	struct FString                                     m_RandomEnemyTeamName;                            		// 0x05EC (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	float                                              m_fXPModifier;                                    		// 0x05F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2434 ];

		return pClassPointer;
	};

	void SettingHasRun ( unsigned long hasRun );
	void SettingMeleeOnly ( unsigned long onlyMelee );
	bool IsForcedVisibleToOtherTeamHUD ( );
	void ForceVisibleToOtherTeamHUD ( unsigned long isforced );
	int GetFriendlyKills ( );
	void SetFriendlyKills ( int Num );
	void ClientUpdatePlayerTeam ( );
	void IncrementVictoryStreak ( );
	void ResetVictoryStreak ( );
	bool IsDrawGame ( );
	bool IsWinner ( );
	void RetrieveVictoryStreakStats ( );
	void NotifyLocalPlayerTeamReceived ( );
	void SetPlayerTeam ( class ATeamInfo* NewTeam );
	void Reset ( );
	int GetMatchRank ( );
	void SetMatchRank ( int Rank );
	void OnWeaponChange ( class AYWeapon* PrevWeapon, class AYWeapon* NextWeapon );
	void ServerSetWeaponEnum ( int val );
	void ClientUpdatePersonalStats ( int hits, int shots );
	void ClientUpdateWeaponStats ( unsigned char Weapon, int hits, int shots );
	void UpdateClientPersonalStats ( );
	void ClientSetEndGameClientStats ( );
	void SetEndGameClientStats ( );
	void ResetHitStreak ( );
	void IncrementHitStreak ( );
	void IncrementShots ( );
	void IncrementHits ( float PercentRaysHit );
	void IncrementDeaths ( int Amt );
	void MCPIncrementHeadShots ( );
	void MCPIncrementShots ( );
	void MCPIncrementHits ( float PercentRaysHit );
	class UClass* GetOverridePawnClass ( );
	bool AreAllMandatoryCharactersSelected ( );
	int GetClassSelectionCount ( int ClassIndex, unsigned char TeamID );
	bool IsClassAvailable ( int ClassIndex, unsigned long bCountMeIn );
	bool IsMajorPerkUnlocked ( unsigned char perk, int iLevel );
	bool IsPerkUnlocked ( unsigned char perk, int iLevel );
	void PostBeginPlay ( );
	void OnEquipmentChange ( );
	void SetSelectedEquipment ( struct FYS_CharacterEquipmentList equipment );
	struct FYS_CharacterEquipmentList GetSelectedEquipment ( );
	void ResetChallenges ( );
	bool IsBoss ( );
	bool IsElite ( );
	bool IsBossUnlocked ( );
	int GetUnlockedEliteLevel ( );
	void GetBossChallengeProgression ( int* bossProgress, int* bossTarget );
	void GetEliteChallengeProgression ( int* eliteProgress, int* eliteTarget, int* currentEliteLevel );
	int GetSelectedCharacter ( );
	unsigned char GetCharacterType ( );
	void InternalSetSelectedCharacter ( int characterIndex );
	void UpdateCharacterSelectionMenu ( );
	void ClientInitialize ( class AController* C );
	bool ExplosiveMultikillOver ( );
	void OnExplosiveKill ( );
	void SetSelectedCharacter ( int characterIndex );
	void IncrementXP ( int Amount );
	void ServerSetKilledDev ( unsigned long bKilledDev );
	void SetKilledDev ( );
	bool AreMeshesLoaded ( );
	bool AreMeshesLoading ( );
	bool NeedToLoadMeshes ( );
	void SetUpCharacterMeshes ( struct FYS_CharacterMeshList* in_MeshList );
	void ServerEndSetUpCharacterMeshes ( struct FYS_CharacterMeshList in_MeshList );
	void ClientStartSetUpCharacterMeshes ( );
	void ClientLoadCompletedCallback ( class AYPlayerController_MP* C );
	void ClientEndSetUpCharacterMeshes ( struct FYS_CharacterMeshList in_MeshList );
	void ServerStartSetUpCharacterMeshes ( struct FYS_CharacterMeshList in_MeshList );
	void ClearMeshAssets ( );
	void ServerSelectRandomEnemyTeamName ( );
	void ServerSetUseRandomEnemyTeamName ( unsigned long bUseRandom );
	void ServerSetSeeEnemyDBNO ( unsigned long bSeeEnemyDBNO );
	void ServerSetXPModifier ( float xpModifier );
	class AYGamePawn* GetPawn ( );
	void SetGrenadeFromZipline ( unsigned long fromZip );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYPlayerReplicationInfo_MP::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_CP
// 0x0008 (0x0604 - 0x05FC)
class AYPlayerReplicationInfo_CP : public AYPlayerReplicationInfo_MP
{
public:
	unsigned long                                      m_bWantToSkipChoreo : 1;                          		// 0x05FC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	int                                                m_successiveInjuries;                             		// 0x0600 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2435 ];

		return pClassPointer;
	};

	void CopyProtertiesForHotSwap ( class AYPlayerReplicationInfo_CP* PRI );
	bool IsMajorPerkUnlocked ( unsigned char perk, int iLevel );
	void ResetPRIToInitialState ( );
	void Reset ( );
};

UClass* AYPlayerReplicationInfo_CP::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_Delivery
// 0x0008 (0x0604 - 0x05FC)
class AYPlayerReplicationInfo_Delivery : public AYPlayerReplicationInfo_MP
{
public:
	unsigned long                                      m_bHasPackage : 1;                                		// 0x05FC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	class AYDeliveryPackage*                           m_currentDP;                                      		// 0x0600 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2436 ];

		return pClassPointer;
	};

	void Reset ( );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
};

UClass* AYPlayerReplicationInfo_Delivery::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_HD
// 0x0010 (0x060C - 0x05FC)
class AYPlayerReplicationInfo_HD : public AYPlayerReplicationInfo_MP
{
public:
	float                                              m_holdStat;                                       		// 0x05FC (0x0004) [0x0000000040000020]              ( CPF_Net | CPF_EditInlineNotify )
	int                                                m_destroyStat;                                    		// 0x0600 (0x0004) [0x0000000040000020]              ( CPF_Net | CPF_EditInlineNotify )
	int                                                m_repairStat;                                     		// 0x0604 (0x0004) [0x0000000040000020]              ( CPF_Net | CPF_EditInlineNotify )
	unsigned long                                      m_capturePointReached : 1;                        		// 0x0608 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2437 ];

		return pClassPointer;
	};

	void Reset ( );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
	void IncrementHoldStat ( float holdStat );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYPlayerReplicationInfo_HD::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_RP
// 0x0010 (0x060C - 0x05FC)
class AYPlayerReplicationInfo_RP : public AYPlayerReplicationInfo_MP
{
public:
	float                                              m_holdStat;                                       		// 0x05FC (0x0004) [0x0000000040000020]              ( CPF_Net | CPF_EditInlineNotify )
	unsigned long                                      m_beyondCall : 1;                                 		// 0x0600 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	float                                              m_currentRPHoldStat;                              		// 0x0604 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_capturePointsReached;                           		// 0x0608 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2438 ];

		return pClassPointer;
	};

	void Reset ( );
	void IncrementHoldStat ( float holdStat );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
	void Tick ( float DeltaTime );
};

UClass* AYPlayerReplicationInfo_RP::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_SW
// 0x0024 (0x0620 - 0x05FC)
class AYPlayerReplicationInfo_SW : public AYPlayerReplicationInfo_MP
{
public:
	int                                                m_CurrentGold;                                    		// 0x05FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_DepositedGold;                                  		// 0x0600 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_numStolenPieces;                                		// 0x0604 (0x0004) [0x0000000000000000]              
	int                                                m_StolenGold;                                     		// 0x0608 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_GoldFull;                                       		// 0x060C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fRunSpeedMultiplier;                            		// 0x0610 (0x0004) [0x0000000000000000]              
	TArray< int >                                      m_CurrentGoldPickupSizes;                         		// 0x0614 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2439 ];

		return pClassPointer;
	};

	void Reset ( );
	void OnPickupGold ( );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
};

UClass* AYPlayerReplicationInfo_SW::pClassPointer = NULL;

// Class SRGame.YRADStation
// 0x0014 (0x020C - 0x01F8)
class AYRADStation : public AActor
{
public:
	class USkeletalMeshComponent*                      m_ComStationMeshComponent;                        		// 0x01F8 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x01FC (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )
	class UMaterialInstance*                           m_ShimmerMaterial;                                		// 0x0200 (0x0004) [0x0000000000000000]              
	int                                                m_ActiveTeam;                                     		// 0x0204 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bActivated : 1;                                 		// 0x0208 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2440 ];

		return pClassPointer;
	};

	void PlayLoopAnim ( );
	void DeactivateRADSpawnPoints ( int Team );
	void ActivateTeamSpawnPoints ( int Team );
	void DeactivateSpawnEvent ( );
	void ActivateRADSpawnPoints ( int Team );
	void DeactivateTeamSpawnPoints ( int Team );
	void ActivateSpawnEvent ( int Team );
	void ActivateComEvent ( );
	void DeactivateSpawn ( );
	void ActivateSpawn ( int Team );
	void ActivateStation ( );
	void DeactivateStation ( );
	void PostBeginPlay ( );
	void Reset ( );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYRADStation::pClassPointer = NULL;

// Class SRGame.YScoreboardPlayerInfo
// 0x0058 (0x0094 - 0x003C)
class UYScoreboardPlayerInfo : public UObject
{
public:
	int                                                playerRank;                                       		// 0x003C (0x0004) [0x0000000000000000]              
	int                                                playerPrestige;                                   		// 0x0040 (0x0004) [0x0000000000000000]              
	int                                                playerKills;                                      		// 0x0044 (0x0004) [0x0000000000000000]              
	int                                                playerDeaths;                                     		// 0x0048 (0x0004) [0x0000000000000000]              
	int                                                playerCollectedEXP;                               		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                playerBonusEXP;                                   		// 0x0050 (0x0004) [0x0000000000000000]              
	int                                                playerChallengeEXP;                               		// 0x0054 (0x0004) [0x0000000000000000]              
	int                                                playerModeExtraData1;                             		// 0x0058 (0x0004) [0x0000000000000000]              
	int                                                playerModeExtraData2;                             		// 0x005C (0x0004) [0x0000000000000000]              
	int                                                playerModeExtraData3;                             		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                PlayerTeam;                                       		// 0x0064 (0x0004) [0x0000000000000000]              
	struct FString                                     PlayerName;                                       		// 0x0068 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FUniqueNetId                                UniqueId;                                         		// 0x0074 (0x0008) [0x0000000000000000]              
	TArray< struct FYS_PerkTimePair >                  m_UsedPerks;                                      		// 0x007C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned char >                            m_CompletedChallenges;                            		// 0x0088 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2441 ];

		return pClassPointer;
	};

	void CopyProperties ( class AYGameReplicationInfo_MP* GRIMP, class AYPlayerReplicationInfo* PRI );
	class UYScoreboardPlayerInfo* CreateInfo ( );
};

UClass* UYScoreboardPlayerInfo::pClassPointer = NULL;

// Class SRGame.YStorm
// 0x002C (0x0224 - 0x01F8)
class AYStorm : public AReplicationInfo
{
public:
	float                                              m_minDuration;                                    		// 0x01F8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maxDuration;                                    		// 0x01FC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minPauseTime;                                   		// 0x0200 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maxPauseTime;                                   		// 0x0204 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minInitialPauseTime;                            		// 0x0208 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maxInitialPauseTime;                            		// 0x020C (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned char                                      m_galeForce;                                      		// 0x0210 (0x0001) [0x0000000000000020]              ( CPF_Net )
	class UAnimSet*                                    m_animSet;                                        		// 0x0214 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UObject* >                           m_requestors;                                     		// 0x0218 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2442 ];

		return pClassPointer;
	};

	float GetInitialPauseTime ( );
	float GetPauseTime ( );
	float GetDuration ( );
	class AYStorm* GetStormActor ( );
};

UClass* AYStorm::pClassPointer = NULL;

// Class SRGame.YTeamInfo
// 0x002F (0x0243 - 0x0214)
class AYTeamInfo : public ATeamInfo
{
public:
	TArray< class AController* >                       m_teamMembers;                                    		// 0x0214 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AYPlayerReplicationInfo*                     m_teamLeader;                                     		// 0x0220 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYGamePawn*                                  m_teamLeaderPawn;                                 		// 0x0224 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class AYAISquad* >                         m_squads;                                         		// 0x0228 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_bonusScore;                                     		// 0x0234 (0x0004) [0x0000000040000020]              ( CPF_Net | CPF_EditInlineNotify )
	int                                                m_roundScore;                                     		// 0x0238 (0x0004) [0x0000000040000020]              ( CPF_Net | CPF_EditInlineNotify )
	unsigned char                                      m_standing[ 0x7 ];                                		// 0x023C (0x0007) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2443 ];

		return pClassPointer;
	};

	void ReconnectExistingSquads ( );
	bool HasValidLeader ( );
	void SetLeader ( class AYPlayerReplicationInfo* Leader );
	void NotifyRespawned ( class AYPlayerController* PC );
	void NotifyKilled ( class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn );
	class AYAISquad* JoinSquadFormation ( struct FName SquadName, class AController* NewMember, unsigned long bLeader, class UClass* SquadClass );
	void DestroySquad ( class AYAISquad* squad );
	class AYAISquad* ConditionalCreateSquad ( struct FName SquadName, class UClass* SquadClass );
	class AYAISquad* GetSquadByName ( struct FName SquadName );
	void Reset ( );
	void Destroyed ( );
	int CountAis ( );
	void RemoveFromTeam ( class AController* Other );
	bool AddToTeam ( class AController* Other );
	void ReplicatedEvent ( struct FName VarName );
	void Tick ( float DeltaTime );
};

UClass* AYTeamInfo::pClassPointer = NULL;

// Class SRGame.YVitalPoint
// 0x0104 (0x02FC - 0x01F8)
class AYVitalPoint : public AActor
{
public:
	struct FPointer                                    VfTable_IYITacticalMarkable;                      		// 0x01F8 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	class UStaticMeshComponent*                        m_HealthBar;                                      		// 0x01FC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x0200 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )
	class UMaterialInstance*                           m_HealthMaterial;                                 		// 0x0204 (0x0004) [0x0000000000000000]              
	TArray< class AActor* >                            m_ShootableObjects;                               		// 0x0208 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UMaterialInstance* >                 m_ShimmerMat;                                     		// 0x0214 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UClass*                                      m_tacIconClass;                                   		// 0x0220 (0x0004) [0x0000000000000000]              
	class UYMarkerBase*                                m_tacIcon;                                        		// 0x0224 (0x0004) [0x0000000000000000]              
	class AYPlayerReplicationInfo_MP*                  m_Destroyer;                                      		// 0x0228 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_team;                                           		// 0x022C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_hudIndex;                                       		// 0x022D (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bCanBeRepaired : 1;                             		// 0x0230 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bTrump : 1;                                     		// 0x0230 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bDestroyable : 1;                               		// 0x0230 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      m_bDestroyed : 1;                                 		// 0x0230 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      m_bInUse : 1;                                     		// 0x0230 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      m_bRecentlyTookDamage : 1;                        		// 0x0230 (0x0004) [0x0000000000000000] [0x00000020] 
	float                                              m_fMaxHealth;                                     		// 0x0234 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	float                                              m_fCurrentHealth;                                 		// 0x0238 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	float                                              m_fLastHealth;                                    		// 0x023C (0x0004) [0x0000000000000000]              
	int                                                m_sparkComponent;                                 		// 0x0240 (0x0004) [0x0000000000000000]              
	int                                                m_recentDamageDuration;                           		// 0x0244 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBuriedAvalancheHealth;                         		// 0x0248 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fAvalancheHealth;                               		// 0x024C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fTrumpHealth;                                   		// 0x0250 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fExplosiveDamage;                               		// 0x0254 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fRepairingTime;                                 		// 0x0258 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_iHealthPerRepair;                               		// 0x025C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fRepairXPTime;                                  		// 0x0260 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_damageMessageDelay;                             		// 0x0264 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_lastTimeDamageMessageWasSent;                   		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              m_fInvQuarterHealth;                              		// 0x026C (0x0004) [0x0000000000000000]              
	struct FName                                       m_movieFilename;                                  		// 0x0270 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_allyStationColorStart;                          		// 0x0278 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_allyStationColorEnd;                            		// 0x0288 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationColorStart;                         		// 0x0298 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationColorEnd;                           		// 0x02A8 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_allyStationArrowColor;                          		// 0x02B8 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationArrowColor;                         		// 0x02C8 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_allyStationColorText;                           		// 0x02D8 (0x0010) [0x0000000000004000]              ( CPF_Config )
	struct FLinearColor                                m_enemyStationColorText;                          		// 0x02E8 (0x0010) [0x0000000000004000]              ( CPF_Config )
	class UYSoundCueFMOD*                              m_RepairEndSound;                                 		// 0x02F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2444 ];

		return pClassPointer;
	};

	unsigned char GetContextCommandFor ( class AYPlayerController* PC );
	void GetCurrentIconPosition ( struct FVector* lastKnownPos, struct FVector* lastKnownFloorPos );
	void GetDescriptionForTacView ( int LOD, struct FString Distance, struct FString* descTop, struct FString* descBottom );
	void OnDetected ( unsigned long detected );
	bool HasFixedPosition ( );
	bool AlwaysUpdatePositionForTacView ( );
	void UpdateIconParameters ( );
	bool IsEnabledForTacView ( );
	void OnToggle ( class USeqAct_Toggle* seqAct );
	void UpdateHealthScores ( );
	void PostBeginPlay ( );
	void SetupShootableObjects ( );
	void SetInUse ( unsigned long bInUse );
	void SetDestroyable ( unsigned long bDestroyable );
	bool IsDead ( );
	int GetSparkComponent ( );
	void SetShimmerColor ( );
	void TakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void StopRecentDamageFlag ( );
	void OnDestroyed ( class AYPlayerReplicationInfo_MP* PRI );
	void Repaired ( float repairRate );
	void Reset ( );
	void SetHealthMaterials ( );
	void ReplicatedEvent ( struct FName VarName );
	void Tick ( float DeltaTime );
	void RotateHealthBar ( float DeltaTime );
	struct FBoxSphereBounds GetBounds ( );
};

UClass* AYVitalPoint::pClassPointer = NULL;

// Class SRGame.YChopperCallBase
// 0x0028 (0x0324 - 0x02FC)
class AYChopperCallBase : public AYVitalPoint
{
public:
	unsigned long                                      m_ChopperActive : 1;                              		// 0x02FC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_CanCallChopper : 1;                             		// 0x02FC (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	int                                                m_targetedBase;                                   		// 0x0300 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AController*                                 m_AttackingController;                            		// 0x0304 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AYChopperDestroyBase*                        m_destructionBases[ 0x5 ];                        		// 0x0308 (0x0014) [0x0000000000000020]              ( CPF_Net )
	float                                              m_ChopperCooldown;                                		// 0x031C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_TimeToCallChopper;                              		// 0x0320 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2445 ];

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void CheckForCanCallChopper ( );
	bool CooldownOver ( );
	bool CanCallChopper ( );
	void OnChopperCalled ( class AController* YPC );
	void OnChopperDestroyed ( class AYPlayerReplicationInfo_CA* PRICA );
	void ChopperReset ( );
	float GetChopperCooldownRemaining ( );
	bool IsCooldownActive ( );
};

UClass* AYChopperCallBase::pClassPointer = NULL;

// Class SRGame.YChopperDestroyBase
// 0x000C (0x0308 - 0x02FC)
class AYChopperDestroyBase : public AYVitalPoint
{
public:
	unsigned long                                      m_MarkedForAttack : 1;                            		// 0x02FC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	float                                              m_TimeToMark;                                     		// 0x0300 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_baseID;                                         		// 0x0304 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2446 ];

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void Reset ( );
	void TakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void OnDestroyed ( class AYPlayerReplicationInfo_MP* PRI );
};

UClass* AYChopperDestroyBase::pClassPointer = NULL;

// Class SRGame.DrawFMODSoundRadiusComponent
// 0x0000 (0x0214 - 0x0214)
class UDrawFMODSoundRadiusComponent : public UDrawSphereComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2447 ];

		return pClassPointer;
	};

};

UClass* UDrawFMODSoundRadiusComponent::pClassPointer = NULL;

// Class SRGame.YAmbientSound
// 0x0010 (0x0214 - 0x0204)
class AYAmbientSound : public AAmbientSound
{
public:
	unsigned long                                      bCurrentlyPlaying : 1;                            		// 0x0204 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_supportsScaling : 1;                            		// 0x0204 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_cachedMaxRange;                                 		// 0x0208 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_audibilityChangeThreshold;                      		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_distanceScaleStepsize;                          		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2448 ];

		return pClassPointer;
	};

	void StopPlayback ( );
	void StartPlayback ( );
	void PostBeginPlay ( );
};

UClass* AYAmbientSound::pClassPointer = NULL;

// Class SRGame.YBattleChatterAmbientActor
// 0x005D (0x0259 - 0x01FC)
class AYBattleChatterAmbientActor : public AKeypoint
{
public:
	TArray< class UYFMODResource_VSB* >                m_vsbResources;                                   		// 0x01FC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FVector2D                                   m_playbackTimeInterval;                           		// 0x0208 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_maxNumSimultaneousPlaybacks;                    		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_rangeScale;                                     		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_volumeRandomizerInterval;                       		// 0x0218 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_playbackPositionRandomizerRadius;               		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_playBattleChatter : 1;                          		// 0x0224 (0x0004) [0x0000000000000021] [0x00000001] ( CPF_Edit | CPF_Net )
	struct FName                                       m_speakerNameOverride;                            		// 0x0228 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	TArray< int >                                      m_availableUIDs;                                  		// 0x0230 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< int >                                      m_playedUIDs;                                     		// 0x023C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_nextPlaybackTime;                               		// 0x0248 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UAudioComponent* >                   m_audioComponents;                                		// 0x024C (0x000C) [0x0000000004482008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_NeedCtorLink | CPF_EditInline )
	unsigned char                                      m_subtitlePriority;                               		// 0x0258 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2449 ];

		return pClassPointer;
	};

	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYBattleChatterAmbientActor::pClassPointer = NULL;

// Class SRGame.UIComp_DrawTeamString
// 0x0024 (0x0198 - 0x0174)
class UUIComp_DrawTeamString : public UUIComp_DrawString
{
public:
	unsigned char                                      m_TeamIDDisplay;                                  		// 0x0174 (0x0001) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FUIStyleReference                           StringStyle2;                                     		// 0x0178 (0x0020) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2450 ];

		return pClassPointer;
	};

	void SetTeamID ( unsigned char NewTeam );
};

UClass* UUIComp_DrawTeamString::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_Ranks
// 0x00AC (0x0128 - 0x007C)
class UYUIDataProvider_Ranks : public UUIResourceDataProvider
{
public:
	struct FString                                     m_sFriendlyName;                                  		// 0x007C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_sMaterialInstance;                              		// 0x0088 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FS_MaterialInstanceConstantInfo             m_MatInfoIcon;                                    		// 0x0094 (0x0094) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2451 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_Ranks::pClassPointer = NULL;

// Class SRGame.YUIListPlayer
// 0x0014 (0x0820 - 0x080C)
class UYUIListPlayer : public UUIList
{
public:
	class UYUIListPlayer*                              m_LinkedPlayerList;                               		// 0x080C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bTop : 1;                                       		// 0x0810 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bPreventFocusWhenOneOrLessItem : 1;             		// 0x0810 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	struct FScriptDelegate                             __OnMuteSelection__Delegate;                      		// 0x0814 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2452 ];

		return pClassPointer;
	};

	struct FString GetPlayerName ( int nDx, int ElementIndex );
	struct FString GetSelectedPlayerName ( );
	void PostInitialize ( );
	void OnMuteSelection ( class UUIList* Sender, int PlayerIndex );
};

UClass* UYUIListPlayer::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd
// 0x0030 (0x0774 - 0x0744)
class UYUIFrontEnd : public UYUIScenes
{
public:
	class UUILabel*                                    m_MenuTitle;                                      		// 0x0744 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_LocMenuTitle;                                   		// 0x0748 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_allowAttractMovie : 1;                          		// 0x0754 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bCloseLoadingMovie : 1;                         		// 0x0754 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bCloseLoadingMovieAllowed : 1;                  		// 0x0754 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_inputLockedFromKismet : 1;                      		// 0x0754 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_contentLoading : 1;                             		// 0x0754 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_wantsToAllowLiveVoicePacketResendAndClearing : 1;		// 0x0754 (0x0004) [0x0000000000000002] [0x00000020] ( CPF_Const )
	unsigned long                                      m_overlayWasJustClosed : 1;                       		// 0x0754 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_ignoreNextEscInput : 1;                         		// 0x0754 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_isWaitingForOnlineServiceReachableToComplete : 1;		// 0x0754 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_removeSkipToCompetitiveOnlineMenuURLOptionAfterOnlineServiceReachableComplete : 1;		// 0x0754 (0x0004) [0x0000000000000000] [0x00000200] 
	class USkeletalMeshComponent*                      m_HeadSkelMeshCmp;                                		// 0x0758 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UYMPMeshLookupTable*                         m_MeshLookupTable;                                		// 0x075C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      MenuTransitionEventClass;                         		// 0x0760 (0x0004) [0x0000000000000000]              
	class UClass*                                      IntelMenuTransitionEventClass;                    		// 0x0764 (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __OnYUIFrontEndTick__Delegate;                    		// 0x0768 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2453 ];

		return pClassPointer;
	};

	struct FString GetLocalizedString ( unsigned char stringType );
	void CurrentStorageDeviceChanged ( );
	struct FString GetRequiredDLCSimpleName ( );
	bool QuitToMainMenu ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void NotifyUserAboutRemovedDLC ( );
	void NotifyStorageDeviceChanged ( );
	void RefreshAllStrings ( );
	bool QuitValidate ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void OpenQuitQuestion ( );
	bool HasConnectedGamepad ( );
	class UClass* GetPreviewWeaponMesh ( int TeamID, int iNumCharacter );
	bool Set3DPrimaryWeaponMesh ( class UClass* WeaponClass );
	bool Set3DCharacterMeshes ( struct FYS_CharacterMeshList* in_MeshList );
	bool Set3DCharacterMesh ( struct FString meshName );
	void PackageDoneLoading ( struct FString PackageName );
	void OnInitializationComplete ( unsigned long bSuccess );
	void OnInitializationServiceReachableComplete ( unsigned long bWasSuccessful, float timeLeftUntilNextQuery );
	bool CancelButtonPressed ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void DoOnlineInitCheck ( );
	void OnSelectOnlineLoginUIComplete ( unsigned long Success );
	struct FString GetPerkPreviewMesh ( unsigned char PerkNum );
	void SetItemEquipmentType ( class UUILabel* Label, class UYUIDataProvider_Equipment* Provider, struct FName ProviderTag );
	void SetItemEquipmentName ( class UUILabel* Label, class UYUIDataProvider_Equipment* Provider );
	void SetPerkIcon ( class UUIImage* Image, int MatPosition );
	void SetKitImage ( class UUIImage* Image, struct FKit_Data kitItem, unsigned char TeamID, int Level );
	void SetItemImage ( class UUIImage* Image, class UYUIDataProvider_Equipment* Provider, unsigned char TeamID, int Level );
	void SetMainControllerId ( int ControllerId );
	int GetMainControllerId ( );
	void CheckSkipMenuOnSceneActivationDelegate ( class UUIScene* ActivatedScene, unsigned long bInitialActivation );
	void EnableCheckSkipMenuOnSceneActivation ( );
	void CheckSkipMenu ( int ControllerId );
	void CloseLoadingMovie ( );
	void SceneActivated ( unsigned long bInitialActivation );
	class UUIScene* OpenSceneByName ( struct FString SceneToOpen, unsigned long bSkipAnimation, struct FScriptDelegate SceneDelegate );
	void TriggerIntelMenuTransitionEvent ( unsigned char EventReason, int collectiblesID, class UClass* SequenceClass );
	void TriggerMenuTransitionEvent ( int Idx, class UClass* SequenceClass );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnSelectItem ( int PlayerIndex );
	bool OnSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void SetContentLoading ( unsigned long contentLoading );
	void SetKismetInputLocked ( unsigned long inputIsLocked );
	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	bool HandleEscInput ( struct FInputEventParameters* EventParms );
	void CloseWidget ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void PostInitialize ( );
	void WarnAboutParentalChatRestriction ( int ControllerId );
	bool CheckLoginAndError ( int ControllerId, unsigned long bMustBeLoggedInOnline, struct FString AlternateTitle, struct FString AlternateMessage );
	bool CheckOnlinePrivilegeAndErrorStatic ( int ControllerId );
	bool CheckOnlinePrivilegeAndError ( int ControllerId, struct FString AlternateTitle, struct FString AlternateMessage );
	bool CheckLinkConnectionAndError ( struct FString AlternateTitle, struct FString AlternateMessage );
	bool ShowLoginUI ( unsigned char LocalUserNum, unsigned long bOnlineOnly );
	unsigned char GetPlayerProfileAccessState ( int ControllerId );
	bool IsWritingPlayerProfile ( int ControllerId );
	bool IsReadingPlayerProfile ( int ControllerId );
	class UYProfileSettings* GetProfile ( );
	void InitMaterialInstanceConstantOnImage ( class UUIImage* Image );
	class AYPlayerController* GetPlayerControllerFromControllerId ( int ControllerId );
	class AYPlayerController* GetPlayerController ( int PlayerIndex );
	struct FString GetNextRankName ( unsigned char TeamID, int iPrestige, int iRankLevel );
	struct FString GetRankName ( unsigned char TeamID, int iRankLevel );
	bool HasSkipToCoopSystemLinkMenuURLOption ( );
	void RemoveSkipToCoopSystemLinkMenuURLOption ( );
	void AddSkipToCoopSystemLinkMenuOptionToURL ( struct FString* URL );
	bool HasSkipToCoopOnlineMenuURLOption ( );
	void RemoveSkipToCoopOnlineMenuURLOption ( );
	void AddSkipToCoopOnlineMenuOptionToURL ( struct FString* URL );
	bool HasSkipToCompetitiveSystemLinkMenuURLOption ( );
	void RemoveSkipToCompetitiveSystemLinkMenuURLOption ( );
	void AddSkipToCompetitiveSystemLinkMenuOptionToURL ( struct FString* URL );
	bool HasSkipToCompetitiveOnlineMenuURLOption ( );
	void RemoveSkipToCompetitiveOnlineMenuURLOption ( );
	void AddSkipToCompetitiveOnlineMenuOptionToURL ( struct FString* URL );
	bool HasSkipToMultiplayerMenuURLOption ( );
	void RemoveSkipToMultiplayerMenuURLOption ( );
	void AddSkipToMultiplayerMenuOptionToURL ( struct FString* URL );
	void ResetAllMenuURLOptions ( );
	void OnYUIFrontEndTick ( float DeltaTime );
	void InitRankIcons ( int TeamID, class UUIImage* pRankIcon, class UUIImage* pNextRankIcon, struct FYS_ExperienceData* Data );
	class UYUIDataProvider_Ranks* GetRankProvider ( unsigned char TeamID, int iPrestige, int iRankLevel );
	struct FName GetRankProviderName ( unsigned char TeamID, int iPrestige, int iRankLevel );
	void SetRankIcon ( class UUIImage* Image, unsigned char TeamID, int iPrestige, int iRankLevel );
	void SetRankIconMat ( class UMaterialInstanceConstant* MatInst, unsigned char TeamID, int iPrestige, int iRankLevel );
	bool IsGameInFocus ( );
	class AActor* GetNamedKismetObjectActor ( struct FName actorName );
	class ASkeletalMeshActor* Get3DWeaponMeshActor ( );
	class ASkeletalMeshActor* Get3DCharacterMeshActor ( );
	void RemoveURLOption ( struct FString Option );
};

UClass* UYUIFrontEnd::pClassPointer = NULL;

// Class SRGame.YUI_FrontEnd_Credits
// 0x0060 (0x07D4 - 0x0774)
class UYUI_FrontEnd_Credits : public UYUIFrontEnd
{
public:
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_scrollSpeed;                                    		// 0x0778 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned long                                      m_bStopAllAudio : 1;                              		// 0x077C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_initialized : 1;                                		// 0x077C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bIsOpenedFromMenu : 1;                          		// 0x077C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bIsWalkerAlive : 1;                             		// 0x077C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_AdjustableScrollSpeed : 1;                      		// 0x077C (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	float                                              m_scrollSpeedFactor;                              		// 0x0780 (0x0004) [0x0000000000000000]              
	float                                              m_scrollSpeedModifier;                            		// 0x0784 (0x0004) [0x0000000000000000]              
	class UUISafeRegionPanel*                          m_SafeRegionPanel;                                		// 0x0788 (0x0004) [0x0000000000000000]              
	float                                              m_SafeRegionTop;                                  		// 0x078C (0x0004) [0x0000000000000000]              
	float                                              m_SafeRegionBottom;                               		// 0x0790 (0x0004) [0x0000000000000000]              
	float                                              m_SafeRegionLeft;                                 		// 0x0794 (0x0004) [0x0000000000000000]              
	TArray< struct FString >                           TextSets;                                         		// 0x0798 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_creditsLines;                                   		// 0x07A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_linesPerBlock;                                  		// 0x07B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    ScrollingTextLabels[ 0x3 ];                       		// 0x07B4 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              ListOffsets[ 0x3 ];                               		// 0x07C0 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_CurrentTextSet;                                 		// 0x07CC (0x0004) [0x0000000000000000]              
	int                                                m_textOnScreenOffset;                             		// 0x07D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2454 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	void ModifyScrollSpeed ( float ScrollSpeedModifier );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool IsPS3UseCircleToAccept ( );
	void TriggerCreditsNearEnd ( );
	void HandleCloseCredits ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void SetOpenFromMenuStatus ( );
	void OnSelectItem ( int PlayerIndex );
	void SceneActivated ( unsigned long bInitialActivation );
	bool IsDataFound ( struct FString TestMe );
	bool NextLine ( struct FString* OutCurrentLine, int* CurrentLineNumber );
	void GetLocalizedStrings ( );
	void InitWidget ( );
};

UClass* UYUI_FrontEnd_Credits::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_BasicMenu
// 0x0028 (0x079C - 0x0774)
class UYUIFrontEnd_BasicMenu : public UYUIFrontEnd
{
public:
	class UYUIMenuList*                                m_MenuList;                                       		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlMenu;                                        		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bHasEnoughXBoxLivePartyMembers : 1;             		// 0x0780 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bShowLoginUIOnLoginErrorMsgClose : 1;           		// 0x0780 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bShowLoginUIOnlineOnly : 1;                     		// 0x0780 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	struct FString                                     m_SceneOptions;                                   		// 0x0784 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SearchSceneClass;                               		// 0x0790 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2455 ];

		return pClassPointer;
	};

	class UYUIDataProvider_MapInfo* FindCoopMap ( int MapListIndex, unsigned char MapId );
	struct FString GetCoopDifficultyIconStringFromIndex ( int DiffIndex );
	bool IsSelectedItemEnabled ( class UYUIMenuList* menuList );
	bool OnSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnOverridePlatformChanged ( );
	bool OnInvitePartyClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool HasAPartyChat ( );
	void ReloadCharacterInfo ( );
	void InitCharacterIDBlock ( class UYProfileSettings* Profile, class UYUIDataStore_Equipment* EquipmentDataStore );
	void InitCharacterDescriptionWidget ( );
	void SetupUnlockPanel ( struct FYSUnlockPanel panelData, class UYUIDataStore_Equipment* EquipmentDataStore, struct FYS_ExperienceData xpData, int TeamID );
	class UUIPanel* InitUnlockPanel ( struct FName panelName, struct FYSUnlockPanel* panelData );
	void SetupPanel ( struct FYSCommonXPPanel panelData, struct FYS_ExperienceData xpData, unsigned char Team, int lvlAddition );
	class UUIPanel* InitXPPanel ( struct FName panelName, struct FYSCommonXPPanel* panelData );
	bool OnLoginError_Confirm ( class UUIMessageBoxBase* MessageBox, struct FName SelectedItem, int PlayerIndex );
	void ShowLoginUIOnLoginErrorMsgClose ( unsigned long bOnlineOnly );
	void OnMenu_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void SetVisibility ( unsigned long bIsVisible );
	void OpenSearchScene ( int ControllerIndex );
	void OpenCustomMatchScene ( int ControllerIndex, unsigned long bIsLanMatch, unsigned char exodusMode, unsigned long bStartParty );
	void StartQuickmatch ( int ControllerIndex );
	void BeginSceneLostFocusAnimation ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void OpenOptionMenu ( );
	bool OnOptionsClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void InitWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_BasicMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_IntelCollectibles
// 0x0128 (0x08C4 - 0x079C)
class UYUIFrontEnd_IntelCollectibles : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_detailsSceneTemplate;                           		// 0x079C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_detailsSceneMenuTemplate;                       		// 0x07A8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UYUIFrontEnd_IntelCollectibleDetailsMenu*    m_detailsScene;                                   		// 0x07B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UYDataProvider_IntelCollectibles* >  m_providers;                                      		// 0x07B8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_numTotalCollectibles;                           		// 0x07C4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_numTotalRadioSpeakers;                          		// 0x07C8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_RadioSpeakerPerChapter                  m_speakersPerChapter[ 0x14 ];                     		// 0x07CC (0x00F0) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	unsigned long                                      m_selectionLocked : 1;                            		// 0x08BC (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_currentSelectedIntel;                           		// 0x08C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2456 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnDetailsSceneClosed ( class UUIScene* DeactivatedScene );
	void OnDetailsSceneOpened ( class UUIScene* ActivatedScene, unsigned long bInitialActivation );
	void HideDetails ( );
	class USurface* ResolveImageFromMarkup ( struct FString markup );
	void ShowDetails ( class UYDataProvider_IntelCollectibles* Provider );
	bool GetIntelCollectiblesForCurrentMissionProgress ( TArray< class UYDataProvider_IntelCollectibles* >* providers );
	void OnSelectItem ( int PlayerIndex );
	class UYDataProvider_IntelCollectibles* GetIntelProviderForCurrentSelection ( unsigned long ignoreUnlocked, unsigned long useProviderIndexInsteadOfListIndex );
	void OnIntelList_ItemChosen ( class UYSimpleList* SourceList, int SelectedIndex, int PlayerIndex );
	void OnIntelList_SelectionChanged ( class UYSimpleList* SourceList, int NewSelectedIndex );
	void UpdateDetails ( );
	void GetIntelCollectibeUnlockInfo ( class UYProfileSettings* Profile, TArray< class UYDataProvider_IntelCollectibles* >* providers );
	void OnIntelList_OptionsRegenerated ( class UUIObject* Sender );
	void SceneDeactivated ( );
	void TriggerUnlockedItemsInKismet ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitWidget ( );
	void SetSelectionLocked ( unsigned long isLocked );
	void InitCharacterDescriptionWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_IntelCollectibles::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_LobbyBase
// 0x0054 (0x07F0 - 0x079C)
class UYUIFrontEnd_LobbyBase : public UYUIFrontEnd_BasicMenu
{
public:
	class UUIImage*                                    m_imgSelectedMap;                                 		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSettingsInfo;                                		// 0x07A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSelectionDescription;                        		// 0x07A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblModeSettingValue;                            		// 0x07A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMapSettingValue;                             		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIObjectList*                              m_RulesListValue;                                 		// 0x07B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYGameReplicationInfo_MPBase*                m_GRI;                                            		// 0x07B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bInitGRIDelegatesOnActivation : 1;              		// 0x07B8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bRulesInitialized : 1;                          		// 0x07B8 (0x0004) [0x0000000000000000] [0x00000002] 
	class UYUIDataStore_MenuItems*                     m_MenuItemDataStore;                              		// 0x07BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FUIStyleReference                           LocalPlayerStyle;                                 		// 0x07C0 (0x0020) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_loadMeshTableDelay;                             		// 0x07E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_checkIfSessionIsStillValidTimer;                		// 0x07E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_checkIfSessionIsStillValidName;                 		// 0x07E8 (0x0008) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2457 ];

		return pClassPointer;
	};

	void CleanupOnlineSubsystem ( );
	void OnPlayerList_SubmitSelection ( class UUIList* Sender, int PlayerIndex );
	void Refresh ( );
	void UpdateRuleSettingsDelegate ( );
	struct FYS_RuleSettings GetRules ( );
	void UpdateMultiplayerMapDelegate ( );
	void UpdateMapLabels ( class UYUIDataProvider_MapInfo* MapInfo );
	struct FString AddPrefix ( struct FString baseName, struct FString Prefix, unsigned long isHardcore );
	void UpdateMultiplayerModeDelegate ( );
	void SceneDeactivated ( );
	void SceneActivated ( unsigned long bInitialActivation );
	bool SceneHasPlaceHolderCharacter ( );
	void SetCharacterHidden ( unsigned long hide );
	void LoadCharacterMeshData ( );
	void ClearGRIDelegates ( );
	void InitGRIDelegates ( );
	bool CanUserCommunicateWith ( int userID, struct FUniqueNetId Uid );
	bool CanCommunicate ( struct FUniqueNetId Uid );
	void InitLobbyMenu ( );
	bool TestIfSessionIsStillValidConnectionLost ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	void TestIfSessionIsStillValidFinished ( struct FName SessionName, unsigned long sessionIsValid );
	bool SessionCheckAllowed ( );
	void TestIfSessionIsStillValid ( );
	void OnTick ( float DeltaTime );
	class AYPlayerReplicationInfo_MPBase* ResolvePlayerName ( struct FString PlayerName, int indexSkip );
	void InitWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_LobbyBase::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_CustomMatch
// 0x00E8 (0x08D8 - 0x07F0)
class UYUIFrontEnd_CustomMatch : public UYUIFrontEnd_LobbyBase
{
public:
	struct FString                                     LockIcon;                                         		// 0x07F0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FName                                       m_MenuItemsDataStore;                             		// 0x07FC (0x0008) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	unsigned char                                      m_MenuState;                                      		// 0x0804 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_MatchType;                                      		// 0x0805 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_PlaylistType;                                   		// 0x0806 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_OldMPModeId;                                    		// 0x0807 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_OldMPMapId;                                     		// 0x0808 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_OldMPDifficultyId;                              		// 0x0809 (0x0001) [0x0000000000000000]              
	class UUIPanel*                                    m_pnlSubMenu;                                     		// 0x080C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlMatchInfo;                                   		// 0x0810 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_SubMenuList;                                    		// 0x0814 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIObjectList*                              m_RulesList;                                      		// 0x0818 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_SubMenuButtonBarCallout;                        		// 0x081C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlFilterDescription;                           		// 0x0820 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgFilterPreview;                               		// 0x0824 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFilterDescription;                           		// 0x0828 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgFactionModeIcon;                             		// 0x082C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMapIcon;                                     		// 0x0830 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMatchTypeValue;                              		// 0x0834 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblModeValue;                                   		// 0x0838 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblModeTitle;                                   		// 0x083C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMapValue;                                    		// 0x0840 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFactionValue;                                		// 0x0844 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMapTitle;                                    		// 0x0848 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_MainMenuBtSelect;                               		// 0x084C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_MainMenuBtBack;                                 		// 0x0850 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSquadPlayer;                                 		// 0x0854 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_SlotAvailableMessage;                           		// 0x0858 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SquadFullMessage;                               		// 0x0864 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      m_bIsInSubMenu : 1;                               		// 0x0870 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bRulesChanged : 1;                              		// 0x0870 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bRulesInputOverride : 1;                        		// 0x0870 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bAbsorbNextInput : 1;                           		// 0x0870 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_bCheckUnlock : 1;                               		// 0x0870 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_subMenuWasOpened : 1;                           		// 0x0870 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_b3DSceneInitialized : 1;                        		// 0x0870 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	class UYGameSettingsMultiplayer*                   m_CurrentGameSettings;                            		// 0x0874 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_iPlayerLocalIndex;                              		// 0x0878 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_ScrollMarker;                                   		// 0x087C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_RuleSettings                            m_OldRules;                                       		// 0x0880 (0x0040) [0x0000000000000000]              
	int                                                m_SpoilsDefaultScoreLimit;                        		// 0x08C0 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_SpoilsScoreLimitAddition;                       		// 0x08C4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UUIImage*                                    m_LockedBar;                                      		// 0x08C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_LockedText;                                     		// 0x08CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_DescriptionText;                                		// 0x08D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIScrollbar*                                m_ScrollBar;                                      		// 0x08D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2458 ];

		return pClassPointer;
	};

	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	bool Init3DScene ( );
	void PackageDoneLoading ( struct FString PackageName );
	void OnOverridePlatformChanged ( );
	void UpdateNbPlayer ( );
	void OnPartyMembersChanged ( );
	void RestoreSettings ( );
	void BackupSettings ( );
	struct FUIStyleReference ShouldCutomizeStyle ( class UUIList* Sender, unsigned char ElementState, int ElementIndex );
	void SetLocalPlayerIndex ( int iLocalPlayerIndex );
	struct FYS_RuleSettings GetRules ( );
	void SceneDeactivated ( );
	void SetVisibility ( unsigned long bIsVisible );
	void UpdateVoiceChatSetting ( );
	void SceneActivated ( unsigned long bInitialActivation );
	struct FYS_RuleSettings GetSelectedRulesFromMenu ( );
	class UYUIResourceDataProvider* GetSelectedItemInfoFromSubMenu ( );
	void SelectRules ( struct FYS_RuleSettings MPRules );
	void SelectDifficulty ( unsigned char MPDifficultyId );
	void SelectFaction ( unsigned char MPFactionId );
	void SelectMap ( unsigned char MPMapId );
	void PickNewTeamsForPlayers ( );
	void PickNewTeamsForPlayersBalance ( class AYGameInfo* GI, unsigned char targetTeam, TArray< class APlayerController* > SourceList, TArray< class APlayerController* > targetList );
	void SelectGameMode ( unsigned char MPModeId );
	void SelectMatchType ( unsigned char MPMatchTypeId );
	void SelectRandomMapFromPlaylist ( int MPPlaylistId );
	void SelectPlaylist ( int MPPlaylistId );
	void Play ( );
	void CloseSubMenu ( );
	void OpenFilterSettingsInSubMenu ( struct FString DataStoreBindingName );
	void OpenPlaylistsInSubMenu ( struct FString DataStoreBindingName );
	void OpenRulesInSubMenu ( struct FString DataStoreBindingName );
	void OpenSubMenu ( );
	bool OnLeaveMessageBoxSelection ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	bool OnCancelMessageBoxSelection ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	bool OnInvitePartyClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnInviteFriendsClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void WantCancelModification ( );
	void WantLeaveMenu ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void CloseMenu ( );
	bool SubMenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void SetSubMenuSelectedItem ( int PlayerIndex );
	void OnSubMenuSelectItem ( int PlayerIndex );
	void SelectNextItem ( int PlayerIndex );
	void UpdateVoiceChatSettingInProfile ( unsigned long SaveProfile );
	void OnMainMenuSelectItem ( int PlayerIndex );
	struct FString GetItemDataStoreBindingFromTag ( struct FName ItemTag );
	void OnSelectItem ( int PlayerIndex );
	void OnSubMenuSelectionChange ( class UYSimpleList* SourceList, int Item );
	void InitPlaylist ( unsigned long bFirstTime );
	void UpdateFilterDescription ( );
	void UpdateMultiplayerFactionDelegate ( );
	void UpdateMultiplayerMapDelegate ( );
	void UpdateMultiplayerModeDelegate ( );
	void UpdateMapLabels ( class UYUIDataProvider_MapInfo* MapInfo );
	void UpdateMatchTypeDelegate ( );
	void ClearGRIDelegates ( );
	void InitGRIDelegates ( );
	void InitMatchSettingsMenu ( );
	void OnTick ( float DeltaTime );
	void InitWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_CustomMatch::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Lobby
// 0x013C (0x092C - 0x07F0)
class UYUIFrontEnd_Lobby : public UYUIFrontEnd_LobbyBase
{
public:
	unsigned long                                      m_bHasVoted : 1;                                  		// 0x07F0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bIsReady : 1;                                   		// 0x07F0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bForceSwitchTeamVisible : 1;                    		// 0x07F0 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bLocalPlayerIndexIsInitilized : 1;              		// 0x07F0 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_bHostIsQuitting : 1;                            		// 0x07F0 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_bIsLanMatch : 1;                                		// 0x07F0 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_bEnableInviteButtons : 1;                       		// 0x07F0 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_bHighlightIsSet : 1;                            		// 0x07F0 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_bIsCoopMatch : 1;                               		// 0x07F0 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_pnlSettingsButtonBar;                           		// 0x07F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_pnlSecondButtonBar;                             		// 0x07F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSettingsBarBG;                               		// 0x07FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlMapVote;                                     		// 0x0800 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMapChoiceLeft;                               		// 0x0804 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMapChoiceLeftName;                           		// 0x0808 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMapChoiceLeftVoteCount;                      		// 0x080C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblModeChoiceLeftName;                          		// 0x0810 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_pnlMapChoiceLeftButtonBar;                      		// 0x0814 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgMapChoiceRight;                              		// 0x0818 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMapChoiceRightName;                          		// 0x081C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMapChoiceRightVoteCount;                     		// 0x0820 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblModeChoiceRightName;                         		// 0x0824 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_pnlMapChoiceRightButtonBar;                     		// 0x0828 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_BtReady;                                        		// 0x082C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_BtLeave;                                        		// 0x0830 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_BtSwitchTeam;                                   		// 0x0834 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_BtCharacterSettings;                            		// 0x0838 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_btInviteFriends;                                		// 0x083C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_btInviteParty;                                  		// 0x0840 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_btGamerCard;                                    		// 0x0844 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIListPlayer*                              m_SpecopsList;                                    		// 0x0848 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIListPlayer*                              m_KonradList;                                     		// 0x084C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIListPlayer*                              m_PlayerList;                                     		// 0x0850 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIListPlayer*                              m_CurrentList;                                    		// 0x0854 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_CharacterSettingsSceneClass;                    		// 0x0858 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUIScene*                                    m_CharacterSettingsScene;                         		// 0x0864 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_ChangeSettingsSceneClass;                       		// 0x0868 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUIScene*                                    m_ChangeSettingsScene;                            		// 0x0874 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSpecops;                                     		// 0x0878 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FPartyPlayerData >                  m_playerDataS;                                    		// 0x087C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUIPanel*                                    m_pnlKonrads;                                     		// 0x0888 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FPartyPlayerData >                  m_playerDataK;                                    		// 0x088C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUIPanel*                                    m_pnlPlayers;                                     		// 0x0898 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FPartyPlayerData >                  m_playerDataP;                                    		// 0x089C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_nPlayersPerFaction;                             		// 0x08A8 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class UUILabel*                                    m_lblTimeLeft;                                    		// 0x08AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKonradLabel;                                 		// 0x08B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSpecopsLabel;                                		// 0x08B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgTimer;                                       		// 0x08B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_VoteTimeLeftMessage;                            		// 0x08BC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_LobbyTimeLeftMessage;                           		// 0x08C8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_WaitingForPlayersMessage;                       		// 0x08D4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_WaitingForHostMessage;                          		// 0x08E0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_MatchStartingMessage;                           		// 0x08EC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUIPanel*                                    m_pnlTeamMode;                                    		// 0x08F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSO;                                          		// 0x08FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlK;                                           		// 0x0900 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlRules;                                       		// 0x0904 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRoundsRemainingValue;                        		// 0x0908 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblDifficultyValue;                             		// 0x090C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_LocalPlayerIndex;                               		// 0x0910 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_LocalPlayerIndexSpecops;                        		// 0x0914 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_LocalPlayerIndexKonrad;                         		// 0x0918 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_TimerForHostQuitting;                           		// 0x091C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIOptionList*                              m_voiceChatSwitcher;                              		// 0x0920 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_currentVOIPSetting;                             		// 0x0924 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_VOIPLabel;                                      		// 0x0928 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2459 ];

		return pClassPointer;
	};

	class AYPlayerReplicationInfo_MPBase* GetSelectedPRI ( );
	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	void OnOverridePlatformChanged ( );
	struct FUIStyleReference ShouldCutomizeStyle ( class UUIList* Sender, unsigned char ElementState, int ElementIndex );
	void SetLocalPlayerIndex ( class UUIList* Sender, int iIndex );
	void UpdateFactionIcon ( struct FPartyPlayerData PlayerData, unsigned char TeamID, struct FString PlayerName );
	void UpdatePlayerTeamIcon ( class UYUIListPlayer* ListPlayer, struct FPartyPlayerData PlayerData, unsigned char TeamID, struct FString PlayerName );
	void UpdatePlayerTeamRow ( class UUITexture* TextureRow, unsigned char TeamID, unsigned long bIsLocalPlayer );
	void ListValueChange ( class UUIObject* Sender, int PlayerIndex );
	int GetTotalScore ( unsigned char TeamID );
	void SceneDeactivated ( );
	void UpdateVOIPSettingInProfile ( unsigned long bShouldSave );
	void OnVoiceChatChanged ( class UUIObject* Sender, int PlayerIndex );
	bool ShouldShowSwitcher ( class AYGameReplicationInfo_MPBase* GRIMP );
	bool ShouldShowVoiceChatSwitcher ( );
	int GetCurrentVoiceChatSetting ( );
	void SceneActivated ( unsigned long bInitialActivation );
	bool VoteForMap ( int PlayerIndex, int MapIndex );
	void UpdateMapLabels ( class UYUIDataProvider_MapInfo* MapInfo );
	bool OnChooseRightMapClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnChooseLeftMapClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OpenChangeSettingsMenu ( int PlayerIndex );
	bool OnChangeSettingsClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OpenCharacterSettingsMenu ( int PlayerIndex );
	bool OnCharacterSettingsClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool RequestSwitchTeam ( int PlayerIndex );
	bool OnSwitchTeamClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void DisplayHostQuittingMessage ( );
	bool OnLeaveMessageBoxSelection ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	void CheckForHostQuitting ( );
	void CloseLoadingMovie ( );
	bool OnLeaveClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool ConfirmPlayerReady ( int PlayerIndex );
	bool OnReadyClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	int FindIndexFromReadyButton ( class UUIScreenObject* EventObject, TArray< struct FPartyPlayerData > PlayerData );
	bool OnClicked_ReadyButton ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnGamerCardClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void UpdatePlayerData ( class UYUIListPlayer* BoundList, TArray< struct FPartyPlayerData >* PlayerData );
	int GetNumberOfRepeatedNamesToThisPoint ( class UYUIListPlayer* BoundList, int Index );
	struct FString GetPlayerNameForIndex ( int PlayerIndex, class UYUIListPlayer* BoundList );
	void RefreshMapAndDifficulty ( );
	void Refresh ( );
	void UpdateTimeLeftLabel ( );
	void ShowTimerImage ( unsigned long shouldShow );
	bool IsModeReadyToStartGame ( );
	void UpdateReadyButtonVisiblity ( );
	void UpdateAIDifficultyDelegate ( );
	bool TestIfSessionIsStillValidConnectionLost ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	void OnTick ( float DeltaTime );
	void UpdateCharacterSettingsButtonVisibility ( );
	void UpdateSwitchTeamButtonAlias ( );
	void UpdateReadyButtonAlias ( );
	bool CanPlayerBeginMatch ( );
	void ForceSwitchTeamButtonVisible ( );
	void UpdateSwitchTeamButtonVisibility ( );
	void UpdateChangeSettingsButtonBarVisibility ( );
	void ClearPlayersListDelegate ( );
	void UpdatePlayersListsDelegate ( );
	void UpdatePlayersListsVisibility ( );
	void UpdateReadyPanelVisibility ( class UUIPanel* Parent );
	void UpdateVoteInfoDelegate ( unsigned long bUpdateMapChoice );
	struct FString GetModeName ( unsigned char ModeId );
	void GetMapInfo ( unsigned char MapId, struct FString* MapName, struct FString* imageName );
	void UpdateLobbyStateDelegate ( );
	void UpdateMultiplayerModeDelegate ( );
	void UpdateMatchTypeDelegate ( );
	void ClearGRIDelegates ( );
	void InitGRIDelegates ( );
	void InitLobbyMenu ( );
	bool OnInvitePartyClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnInviteFriendsClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void UpdateListSelectionCallbacks ( unsigned long Enable );
	void UpdateButtonCallbacks ( unsigned long Enable );
	void DisableLobbyFunctionality ( );
	void InitWidget ( );
	void UpdateChatIcon ( int ListIndex, TArray< struct FPartyPlayerData >* List );
	void OnPlayerTalkingStateChange ( struct FUniqueNetId Player, unsigned long bIsTalking );
	int GetPartyPlayerData ( struct FUniqueNetId Uid, TArray< struct FPartyPlayerData >* List );
	void ApplyMutingByRemote ( struct FUniqueNetId mutingPlayerUID, unsigned long muted );
	void TellRemoteAboutBeingMuted ( struct FUniqueNetId mutedUID, unsigned long muted );
	void ToggleMuteOnPlayer ( int Index, TArray< struct FPartyPlayerData >* List );
	void OnPlayerList_OnMuteSelection ( int PlayerIndex, class UUIList** Sender );
	void InitPlayerData ( int PlayerCount, struct FString FactionSuffix, TArray< struct FPartyPlayerData >* PlayerData );
	void HideUnusedPlayerSlots ( );
	void UpdateLanMatchFlag ( );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_Lobby::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_OnlineMPMenu
// 0x007C (0x086C - 0x07F0)
class UYUIFrontEnd_OnlineMPMenu : public UYUIFrontEnd_LobbyBase
{
public:
	class UUICalloutButton*                            m_MainMenuBtSelect;                               		// 0x07F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_CurrentList;                                    		// 0x07F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_SquadPlayerList;                                		// 0x07F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_SquadPlayerNum;                                 		// 0x07FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScrollingTextPanel*                      m_MessageOfTheDay;                                		// 0x0800 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bMenuIsDirty : 1;                               		// 0x0804 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_b3DSceneInitialized : 1;                        		// 0x0804 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	int                                                m_TickCount;                                      		// 0x0808 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                MenuListIndex;                                    		// 0x080C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_SceneHeadquarters;                              		// 0x0810 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_exodusProgressionToUnlockVersus;                		// 0x081C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlJoinedPlayers;                               		// 0x0820 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSquadPlayer;                                 		// 0x0824 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UUIImage* >                          m_Headsets;                                       		// 0x0828 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UUIImage* >                          m_Speakers;                                       		// 0x0834 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< float >                                    m_LastChatTimes;                                  		// 0x0840 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SlotAvailableMessage;                           		// 0x084C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SquadFullMessage;                               		// 0x0858 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned char                                      m_MenuState;                                      		// 0x0864 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_iPlayerLocalIndex;                              		// 0x0868 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2460 ];

		return pClassPointer;
	};

	void UpdateSquadInfo ( );
	struct FUIStyleReference ShouldCutomizeStyle ( class UUIList* Sender, unsigned char ElementState, int ElementIndex );
	void SetLocalPlayerIndex ( int iLocalPlayerIndex );
	void SceneDeactivated ( );
	void SceneActivated ( unsigned long bInitialActivation );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	void HandleSquadSelection ( );
	void OnSquad_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	bool OnLeaveMessageBoxSelection ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	bool OnCancelMessageBoxSelection ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	void UpdateNbPlayer ( );
	bool TestIfSessionIsStillValidConnectionLost ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	void OnTick ( float DeltaTime );
	int GetPlayerListIndex ( struct FUniqueNetId Uid );
	void OnPlayerTalkingStateChange ( struct FUniqueNetId Player, unsigned long bIsTalking );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	void SendAllPlayersToCustomMatchScreen ( );
	bool OnConfirmingOutofGameDLCStore ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void PackageDoneLoading ( struct FString PackageName );
	bool Init3DScene ( );
	void UpdateRuleSettingsDelegate ( );
	void UpdateMultiplayerMapDelegate ( );
	void UpdateMultiplayerModeDelegate ( );
	void InitOnlineMPMenu ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_OnlineMPMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Multiplayer
// 0x0014 (0x07B0 - 0x079C)
class UYUIFrontEnd_Multiplayer : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneSystemLink;                                		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      m_b3DSceneInitialized : 1;                        		// 0x07A8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	class UYUIScrollingTextPanel*                      m_MessageOfTheDay;                                		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2461 ];

		return pClassPointer;
	};

	void ReselectSystemLinkMenu ( );
	void SelectSystemLink ( int ControllerId );
	void OnLoginUIChange ( unsigned long bIsOpening );
	void SelectOnline ( int ControllerId );
	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	void PackageDoneLoading ( struct FString PackageName );
	bool Init3DScene ( );
	void SceneDeactivated ( );
	void SceneActivated ( unsigned long bInitialActivation );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void CheckSkipMenu ( int ControllerId );
	void TickScene ( float DeltaTime );
	void InitWidget ( );
};

UClass* UYUIFrontEnd_Multiplayer::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Career
// 0x0064 (0x07D8 - 0x0774)
class UYUIFrontEnd_Career : public UYUIFrontEnd
{
public:
	struct FYS_CareerWidgetRef                         m_Career[ 0x2 ];                                  		// 0x0774 (0x0060) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_ButtonBar;                                      		// 0x07D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2462 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool OnStatisticsClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void InitMajorPerk ( class UYUIDataProvider_MajorPerks* MajorPerk, unsigned char TeamID, int iPerkLevel );
	void InitCareerWidget ( unsigned char TeamID, struct FYS_ExperienceData* Data );
	void InitWidget ( );
	void InitCareerWidgetRef ( int TeamIndex, class UUIPanel* careerPanel );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_Career::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_CharacterCreation
// 0x001C (0x0790 - 0x0774)
class UYUIFrontEnd_CharacterCreation : public UYUIFrontEnd
{
public:
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_sPreviewBaseSpecops;                            		// 0x0778 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_sPreviewBaseKonrad;                             		// 0x0784 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2463 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_CharacterCreation::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_CharacterCreationInventory
// 0x00CC (0x085C - 0x0790)
class UYUIFrontEnd_CharacterCreationInventory : public UYUIFrontEnd_CharacterCreation
{
public:
	class UUIImage*                                    m_imgCharacterPreview;                            		// 0x0790 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUISafeRegionPanel*                          m_pnlSafeRegion;                                  		// 0x0794 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIW_CharacterEquipmentSelect*              m_wCharacEquipSelect;                             		// 0x0798 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabelButton*                              m_butAccept;                                      		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabelButton*                              m_butClassSelection;                              		// 0x07A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIW_SelectEquipment*                       m_wEquipChoose[ 0x7 ];                            		// 0x07A4 (0x001C) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblName;                                        		// 0x07C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_iCharacterIndex;                                		// 0x07C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_teamID;                                         		// 0x07C8 (0x0001) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )
	unsigned char                                      m_CurrentWidgetVisible;                           		// 0x07C9 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_ActiveEquipment;                                		// 0x07CA (0x0001) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )
	struct FYS_EquipmentClass                          m_EquipmentSelected;                              		// 0x07CC (0x001C) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_CharacterMeshList                       m_MeshListSelected;                               		// 0x07E8 (0x0018) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_sCharacterName;                                 		// 0x0800 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_sCharacterRenameTitle;                          		// 0x080C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_sCharacterRenameDesc;                           		// 0x0818 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	int                                                m_nCharacterNameMaxLen;                           		// 0x0824 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class UUIPanel*                                    m_pnlKonradsFactionBG;                            		// 0x0828 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSpecopsFactionBG;                            		// 0x082C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlLeftShade;                                   		// 0x0830 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlRightShade;                                  		// 0x0834 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTimeLeft;                                    		// 0x0838 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgTimer;                                       		// 0x083C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_SceneClassSelection;                            		// 0x0840 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UMaterialInstance*                           m_SelectionMaterial;                              		// 0x084C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fSelectionImageOffsetX;                         		// 0x0850 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceTimeVarying*                m_SelectionMaterialInstance;                      		// 0x0854 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bSelectorInFocusMode : 1;                       		// 0x0858 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2464 ];

		return pClassPointer;
	};

	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void UpdateFactionBackground ( );
	void ActiveEquipmentChangeInEditor ( );
	struct FString GetPerkPreview ( unsigned char PerkNum );
	void UpdatePrimaryWeaponPreview ( );
	void UpdateFactionPerkPreview ( );
	void ForceSecondaryWeapon ( );
	bool NeedForceSecondaryWeapon ( );
	void ForcePrimaryWeapon ( );
	bool NeedForcePrimaryWeapon ( );
	void ChangeEquipment ( unsigned char NewEquipmentSlot, class UClass* cNewEquipment );
	class UClass* GetCurrentEquipmentClass ( unsigned char NewEquipmentSlot );
	void EqSelectLoseFocus ( );
	void OnAcceptPress ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnClassSelectionClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnAcceptClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnKeyboardInputComplete ( unsigned long bWasSuccessful );
	void OnSaveProfileCompleted ( );
	bool CharacterIsDifferent ( struct FString sNameCharacter1, struct FString sNameCharacter2, struct FYS_EquipmentClass* EquipmentClass1, struct FYS_EquipmentClass* EquipmentClass2 );
	void ValidateEquipment ( int InPlayerIndex );
	void Rename ( int ControllerId );
	void Cancel ( int ControllerId );
	void Validate ( int ControllerId );
	bool ClassHasModification ( );
	void StopEquipementSelection ( );
	void CloseWidgetSelectionEquipement ( );
	void FocusNextWidgetEquipement ( );
	void FocusWidgetEquipementSelection ( unsigned char EqSlot );
	void OpenWidgetEquipementSelection ( unsigned char EqSlot );
	bool ResetCancelCharacterModification_Confirm ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void WantCancelCharacterModification ( );
	bool OnCharacterResetClicked ( class UUIScreenObject* InButton, int InPlayerIndex );
	bool OnChangeNameClicked ( class UUIScreenObject* InButton, int InPlayerIndex );
	bool OnSelectClicked ( class UUIScreenObject* InButton, int InPlayerIndex );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool HaveAccessToSecondPrimaryWeapon ( );
	bool HaveAccessToHeavyWeapon ( );
	struct FYS_EquipmentClass GetEquipment ( );
	void InitCharacterName ( );
	void InitWidgetSelection ( );
	void InitCharacterEquipment ( );
	void SetCharacterIndex ( unsigned char TeamID, int iCharacter );
	void CloseWidget ( );
	void TickScene ( float DeltaTime );
	void InitWidgetWithDatas ( );
	void InitWidgetDelegate ( );
	void InitForEditor ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void SceneDeactivated ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void PostInitialize ( );
	void ActiveSelector ( );
	void UnactiveSelector ( );
	void RestartAnimSelector ( );
};

UClass* UYUIFrontEnd_CharacterCreationInventory::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_CharacterRespawnSelection
// 0x07E8 (0x0F5C - 0x0774)
class UYUIFrontEnd_CharacterRespawnSelection : public UYUIFrontEnd
{
public:
	class UUIPanel*                                    m_SafeRegionPanel;                                		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_iSelectedCharacter;                             		// 0x077C (0x0004) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )
	int                                                m_iOldSelectedCharacter;                          		// 0x0780 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_CharacterWidget                         m_character[ 0x5 ];                               		// 0x0784 (0x01A4) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_CharacterWidgetName                     m_characterWidgetName[ 0x5 ];                     		// 0x0928 (0x0348) [0x0000000000002000]              ( CPF_Transient )
	class UTexture*                                    m_specopsPerkTextures[ 0x7 ];                     		// 0x0C70 (0x001C) [0x0000000000002000]              ( CPF_Transient )
	class UTexture*                                    m_konradPerkTextures[ 0x7 ];                      		// 0x0C8C (0x001C) [0x0000000000002000]              ( CPF_Transient )
	class UYUIFrontEnd_CharacterCreationInventory*     m_characterCreation;                              		// 0x0CA8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bSpawnButtonActive : 1;                         		// 0x0CAC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bOpenedFromMidGameMenu : 1;                     		// 0x0CAC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSwitchingFactions : 1;                         		// 0x0CAC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned char                                      m_teamID;                                         		// 0x0CB0 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_CharacterCount;                                 		// 0x0CB1 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_CharacterSelected;                              		// 0x0CB2 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     m_sPreviewBaseSpecops;                            		// 0x0CB4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_sPreviewBaseKonrad;                             		// 0x0CC0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUILabel*                                    m_lblSelected;                                    		// 0x0CCC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlFocused;                                     		// 0x0CD0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTimer;                                       		// 0x0CD4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTimerText;                                   		// 0x0CD8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTitle;                                       		// 0x0CDC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlCPKonradUnlock;                              		// 0x0CE0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgUnlockedPerkLevel0;                          		// 0x0CE4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgUnlockedPerkLevel1;                          		// 0x0CE8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgUnlockedPerkLevel2;                          		// 0x0CEC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgUnlockedExplosive0;                          		// 0x0CF0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgUnlockedExplosive1;                          		// 0x0CF4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgUnlockedExplosive2;                          		// 0x0CF8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgUnlockedHealthNoBonus;                       		// 0x0CFC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgUnlockedHealthBonus;                         		// 0x0D00 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FLinearColor                                m_PerkIconSelectedColor;                          		// 0x0D04 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_PerkIconUnselectedColor;                        		// 0x0D14 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_WeaponIconSelectedColor;                        		// 0x0D24 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_WeaponIconUnselectedColor;                      		// 0x0D34 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPerkIconSelectedOpacity;                       		// 0x0D44 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPerkIconUnselectedOpacity;                     		// 0x0D48 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fWeaponIconSelectedOpacity;                     		// 0x0D4C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fWeaponIconUnselectedOpacity;                   		// 0x0D50 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ClassRespawn                            m_CharacterPreviewEdSpecops[ 0x5 ];               		// 0x0D54 (0x00F0) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FYS_ClassRespawn                            m_CharacterPreviewEdKonrad[ 0x5 ];                		// 0x0E44 (0x00F0) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     m_timeBeforeSpawnMessage;                         		// 0x0F34 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_spawningMessage;                                		// 0x0F40 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_midGameClassChangeMessage;                      		// 0x0F4C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	int                                                m_TickWaitToSwitchFactions;                       		// 0x0F58 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2465 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	void CloseMenu ( );
	void Cancel ( int ControllerId );
	void OnSelectItem ( int PlayerIndex );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnCharacterProcessKey ( struct FSubscribedInputEventParameters* EventParms );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void OnPlayerCanSpawn ( );
	void OnMatchStart ( );
	void Spawn ( );
	void Validate ( int ControllerId );
	void OnServerValidateCharacterChange ( int selectedCharacter );
	void ValidateSelection ( int ControllerId );
	bool OnCharacterClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnCharacterPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnCharacterDoubleClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnSpawnClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void ShowCharacterSelectButton ( );
	void HideChangeFactionButton ( );
	bool OnFactionChangeClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnCharacterSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnCloseClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	struct FString GetPerkName ( unsigned char PerkNum );
	struct FString GetWeaponName ( unsigned char WpNum );
	void SetCharacterWidgetStruct ( int iCharacter, struct FYS_CharacterWidget CharacterWidget );
	struct FYS_CharacterWidget GetCharacterWidgetStruct ( int iCharacter );
	void InitWidgetCharacterRef ( int iCharacter );
	void SetSpawnButtonVisibility ( unsigned long bVisibility );
	void InitAllMaterialInstanceConstant ( );
	void TickScene ( float DeltaTime );
	void InitWidget ( );
	void InitWidgetRef ( );
	void InitSelectedCharacter ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void PostInitialize ( );
	void UpdateSelection ( );
	void SelectCharacter ( int iCharacterIndex );
	void SelectNextCharacter ( );
	void SelectPreviousCharacter ( );
	void UpdateCharacters ( );
	void InitFactionImages ( );
};

UClass* UYUIFrontEnd_CharacterRespawnSelection::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_ClassSelection
// 0x0224 (0x0998 - 0x0774)
class UYUIFrontEnd_ClassSelection : public UYUIFrontEnd
{
public:
	class AYPlayerController*                          m_YPC;                                            		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYProfileSettings*                           m_Profile;                                        		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_ExperienceData                          m_XPData;                                         		// 0x077C (0x00FC) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_NumPerks;                                       		// 0x0878 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_teamID;                                         		// 0x087C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_CurrentPanelEnum;                               		// 0x087D (0x0001) [0x0000000000000000]              
	unsigned char                                      m_PreviewState;                                   		// 0x087E (0x0001) [0x0000000000000000]              
	int                                                m_iCharacterIndex;                                		// 0x0880 (0x0004) [0x0000000000000000]              
	class UYUICharacterCustomPanel*                    m_CustomPanels[ 0x7 ];                            		// 0x0884 (0x001C) [0x0000000000000000]              
	class UUIButton*                                   m_btnRotate;                                      		// 0x08A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnRotateRight;                                 		// 0x08A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnRotateLeft;                                  		// 0x08A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_loadoutName;                                    		// 0x08AC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUILabel*                                    m_lblLoadoutSelect;                               		// 0x08B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_FactionChangeButton;                            		// 0x08BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIFrontEnd_CharacterCreationInventory*     parentCharacterCreationInventory;                 		// 0x08C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_CharacterMeshList                       m_CharacterMeshList;                              		// 0x08C4 (0x0018) [0x0000000000000000]              
	struct FYS_EquipmentClass                          m_ProfileClassEquipment[ 0x5 ];                   		// 0x08DC (0x008C) [0x0000000000000000]              
	unsigned long                                      m_ShouldSave : 1;                                 		// 0x0968 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      TimerOn : 1;                                      		// 0x0968 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	int                                                m_packagesLoaded;                                 		// 0x096C (0x0004) [0x0000000000000000]              
	float                                              m_deltaTime;                                      		// 0x0970 (0x0004) [0x0000000000000000]              
	class ASkeletalMeshActor*                          PreviewActor;                                     		// 0x0974 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_characterRenameTitle;                           		// 0x0978 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_characterRenameDesc;                            		// 0x0984 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	class UUICalloutButtonPanel*                       m_CalloutButtonPanel;                             		// 0x0990 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                TickTimer;                                        		// 0x0994 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2466 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	void SetCharacterIndex ( unsigned char TeamID, int iCharacter );
	void PostBeginPlay ( );
	class UUIButton* GetLoadoutButton ( int Index );
	void RotateActorRight ( class UUIScreenObject* EventObject, int PlayerIndex );
	void RotateActorLeft ( class UUIScreenObject* EventObject, int PlayerIndex );
	void RotateActorNone ( class UUIScreenObject* EventObject, int PlayerIndex );
	void PanelTick ( float fTickTime );
	void OnBackPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnChangeFactionClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void OnKeyboardInputComplete ( unsigned long bWasSuccessful );
	void OnChangeCharacterName ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnActionPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void SetFaction ( unsigned char TeamID );
	void TrySave ( );
	void ChangeFaction ( );
	void SetupEquipmentInfo ( );
	void ActivatePanel ( unsigned char panel );
	void SelectLoadout ( int Selection );
	void UpdateRotateButtons ( );
	void SceneDeactivated ( );
	void TickScene ( float DeltaTime );
	void InitWidget ( );
	void InitWidgetRef ( );
	void PostInitialize ( );
	unsigned char GetOverridePlatform ( );
	void PackageDoneLoading ( struct FString PackageName );
	void SetHandMaterialOnHandle ( int MaterialIndex, struct FName* AssetHandle );
	void SetMaterialOnHandle ( int MaterialIndex, struct FName* AssetHandle );
};

UClass* UYUIFrontEnd_ClassSelection::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard
// 0x0084 (0x07F8 - 0x0774)
class UYUIFrontEnd_Leaderboard : public UYUIFrontEnd
{
public:
	class UYDataStore_OnlineStats*                     StatsDataStore;                                   		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UOnlineStatsInterface*                       StatsInterface;                                   		// 0x0778 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x077C (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	class UUILabel*                                    RefreshingLabel;                                  		// 0x0780 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    TitleLabel;                                       		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    FactionLabel;                                     		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScoreboardPanel_KillsLeaderboard*        StatsList;                                        		// 0x078C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                CurrentPlayerIndex;                               		// 0x0790 (0x0004) [0x0000000000000000]              
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0794 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_FriendsButton;                                  		// 0x0798 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButton*                            m_TopOfList;                                      		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_leaderboardDSTag;                               		// 0x07A0 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_RankMatInst;                                    		// 0x07A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FUIStyleReference                           LocalPlayerStyle;                                 		// 0x07AC (0x0020) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bNavUp : 1;                                     		// 0x07CC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bRefreshing : 1;                                		// 0x07CC (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bShouldProcessDelay : 1;                        		// 0x07CC (0x0004) [0x0000000000000000] [0x00000004] 
	TArray< class UYUIResourceDataProvider* >          m_LeaderBoardCategoryProviders;                   		// 0x07D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_CurrentListIndex;                               		// 0x07DC (0x0004) [0x0000000000000000]              
	int                                                m_StartListIndex;                                 		// 0x07E0 (0x0004) [0x0000000000000000]              
	class UUILabelButton*                              m_btnCategories;                                  		// 0x07E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnPrevCat;                                     		// 0x07E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnNextCat;                                     		// 0x07EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fCatDelay;                                      		// 0x07F0 (0x0004) [0x0000000000000000]              
	float                                              RefreshBoardTimeout;                              		// 0x07F4 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2467 ];

		return pClassPointer;
	};

	bool OnButtonBar_Category ( class UUIScreenObject* InButton, int PlayerIndex );
	bool ListOnProcessInputKey ( struct FInputEventParameters* EventParms );
	void ProcessCategoryChange ( );
	void Tick ( float DeltaTime );
	void StartCategoryChange ( );
	void OnNextCatButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnPrevCatButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void DisplayCategoryList ( );
	void OnCategoryButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	int GetCategoryListIndex ( struct FName categoryTag );
	void GetLeaderboardsCategoryList ( TArray< class UYUIResourceDataProvider* >* LeaderBoardProviders );
	void OnOverridePlatformChanged ( );
	struct FUIStyleReference ShouldCutomizeStyle ( class UUIList* Sender, unsigned char ElementState, int ElementIndex );
	void OnStatsReadComplete ( unsigned long bWasSuccessful );
	bool FailedStatsRead ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void RefreshAttemptTimeout ( );
	void InvalidLoginStatus ( );
	bool CheckIsLoggedIn ( );
	void RefreshStats ( );
	void EnableButtonBar ( unsigned long bEnable );
	void OnSelectGamerTag ( class UUIList* Sender, int PlayerIndex );
	bool OnButtonBar_PageDown ( class UUIScreenObject* InButton, int PlayerIndex );
	bool OnButtonBar_PageUp ( class UUIScreenObject* InButton, int PlayerIndex );
	bool OnButtonBar_Friends ( class UUIScreenObject* InButton, int PlayerIndex );
	bool OnButtonBar_TopOfList ( class UUIScreenObject* InButton, int PlayerIndex );
	bool OnButtonBar_GamerCard ( class UUIScreenObject* InButton, int PlayerIndex );
	bool OnButtonBar_Back ( class UUIScreenObject* InButton, int PlayerIndex );
	void UpdateFactionLabel ( );
	void OnTopOfList ( );
	void OnFriends ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnBack ( );
	void OnRankListChanged ( );
	bool CloseScene ( class UUIScene* SceneToClose, unsigned long bCloseChildScenes, unsigned long bForceCloseImmediately );
	void OnNavBeyondBoundaries ( class UUIList* Sender, unsigned long bUp );
	void OnOpen ( struct FName SelectedItemTag );
	void PostInitialize ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitWidgetRef ( );
	void UpdateList ( );
};

UClass* UYUIFrontEnd_Leaderboard::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_TitleScreen
// 0x00B0 (0x0824 - 0x0774)
class UYUIFrontEnd_TitleScreen : public UYUIFrontEnd
{
public:
	struct FString                                     MainMenuScene;                                    		// 0x0774 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     SafeZoneScene;                                    		// 0x0780 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     BrightnessScene;                                  		// 0x078C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     SaveWarningScene;                                 		// 0x0798 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     ReadProfileScene;                                 		// 0x07A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bDemoMode : 1;                                  		// 0x07B0 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_bBrightnessShown : 1;                           		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_waitingForLoginChange : 1;                      		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_profileSettingHasBeenRead : 1;                  		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_readProfileWasSuccessfull : 1;                  		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_messageBoxhasBeenShown : 1;                     		// 0x07B0 (0x0004) [0x0000000000000000] [0x00000020] 
	struct FString                                     m_DemoLevel;                                      		// 0x07B4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FName                                       m_ReadingProfileMessageBoxName;                   		// 0x07C0 (0x0008) [0x0000000000000000]              
	struct FString                                     m_ReadingProfileMessageBoxTitle;                  		// 0x07C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_ReadingProfileMessage;                          		// 0x07D4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       m_NotLoggedInWarningMessageBoxName;               		// 0x07E0 (0x0008) [0x0000000000000000]              
	struct FString                                     m_NotLoggedInWarningMessageBoxTitle;              		// 0x07E8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_NotLoggedInWarningMessage;                      		// 0x07F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       m_NotLoggedInWarningBackButtonName;               		// 0x0800 (0x0008) [0x0000000000000000]              
	struct FName                                       m_NotLoggedInWarningAcceptButtonName;             		// 0x0808 (0x0008) [0x0000000000000000]              
	class UUIImage*                                    m_contentLoadingImage;                            		// 0x0810 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_hidePanel;                                      		// 0x0814 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_pressStartMessage;                              		// 0x0818 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScene_TimedUIScene*                      m_saveWarningScene;                               		// 0x081C (0x0004) [0x0000000000000000]              
	class UYUIScene_TimedUIMessge*                     m_readingProfileMessageScene;                     		// 0x0820 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2468 ];

		return pClassPointer;
	};

	void TickScene ( float DeltaTime );
	void OnOverridePlatformChanged ( );
	bool OnNotLoggedInSelect ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void StartNotLoggedIn ( int ControllerId );
	void OnLoginFailed ( unsigned char LocalUserNum, unsigned char ErrorCode );
	void OnLoginChange ( unsigned char LocalUserNum );
	void OnLoginUIChange ( unsigned long bIsOpening );
	void OnProfileSaveFinish ( );
	bool ProfileNeedSave ( unsigned char LocalUserNum );
	void TriggerReadProfileSettingsComplete ( unsigned char LocalUserNum, unsigned long bWasSuccessful );
	void OnReadProfileSettingsComplete ( unsigned char LocalUserNum, unsigned long bWasSuccessful );
	void ReadProfileSceneShown ( );
	void OpenReadingProfileUIScene ( );
	void StartLoggedIn ( int ControllerId );
	void SelectMainMenu ( int ControllerId );
	void SetLoggedInPlayerNum ( int ControllerId );
	bool OnConfirmingMissingSteamMessage ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	bool IsUsingSteamSubSystem ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool OpenBrightness ( class UYProfileSettings* Profile );
	void SafeZoneClosed ( );
	bool OpenSafeZone ( class UYProfileSettings* Profile );
	void CheckForPendingProfileSaveCheck ( );
	bool OpenSaveWarning ( );
	bool PreorderMessageAcceptedTitleScreen ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void OpenMainMenuDelayed ( );
	void OpenMainMenu ( );
	void LaunchDemoLevel ( );
	bool IsPlayerOnTitleScreenForFirstTime ( );
	void CheckSkipMenu ( int ControllerId );
	int GetNumLoggedInPlayers ( );
	void CleanupOnlineDelegates ( );
	void SceneDeactivated ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void PostInitialize ( );
	void InitWidget ( );
};

UClass* UYUIFrontEnd_TitleScreen::pClassPointer = NULL;

// Class SRGame.YUIScene_MatchEndXP
// 0x006C (0x07E0 - 0x0774)
class UYUIScene_MatchEndXP : public UYUIFrontEnd
{
public:
	class UUIImage*                                    m_imgBackground[ 0x2 ];                           		// 0x0774 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCollectedXP;                                 		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblBonusMatchXP;                                		// 0x0780 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblEarnedXP;                                    		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCurrentRank;                                 		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblNextRankText;                                		// 0x078C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblNextRank;                                    		// 0x0790 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRequiredXPText;                              		// 0x0794 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRequiredXP;                                  		// 0x0798 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCurrentRank;                                 		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgNextRank;                                    		// 0x07A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIProgressBar*                              m_barProgress;                                    		// 0x07A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_ButtonBar;                                      		// 0x07A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_InitialXP;                                      		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_TargetXP;                                       		// 0x07B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_InitialRankLevel;                               		// 0x07B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_InitialPrestigeLevel;                           		// 0x07B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_CurrentRankLevel;                               		// 0x07BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_TargetRankLevel;                                		// 0x07C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_WaitDelay;                                      		// 0x07C4 (0x0004) [0x0000000000002003]              ( CPF_Edit | CPF_Const | CPF_Transient )
	float                                              m_XPDuration;                                     		// 0x07C8 (0x0004) [0x0000000000002003]              ( CPF_Edit | CPF_Const | CPF_Transient )
	float                                              m_AnimStartTime;                                  		// 0x07CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_AnimEndTime;                                    		// 0x07D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScene_Scoreboard*                        m_ScoreboardTemplate;                             		// 0x07D4 (0x0004) [0x0000000000000000]              
	class UUIScene*                                    m_rewardsScene;                                   		// 0x07D8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsTeamValid : 1;                               		// 0x07DC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2469 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnCloseClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void StopProgressBarAnimation ( );
	void StartProgressBarAnimation ( int InitialXP, int TargetXP );
	void InitWidgetWith ( unsigned char TeamID, int iPrestige, int rankLevel, int xp );
	void SetXPInfos ( unsigned char TeamID, class AYPlayerReplicationInfo_MPBase* PRI );
	void SetPlayerTeam ( unsigned char TeamID );
	void InitWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIScene_MatchEndXP::pClassPointer = NULL;

// Class SRGame.YUISceneFEOptions_Base
// 0x0040 (0x07B4 - 0x0774)
class UYUISceneFEOptions_Base : public UYUIFrontEnd
{
public:
	TArray< class UUIObject* >                         m_SwitcherListRef;                                		// 0x0774 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< int >                                      m_SwitcherListValues;                             		// 0x0780 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_LastSelected;                                   		// 0x078C (0x0004) [0x0000000000000000]              
	class UUIPanel*                                    m_SwitcherListPanel;                              		// 0x0790 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_SettingsAreDirty : 1;                           		// 0x0794 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bResettedDefaults : 1;                          		// 0x0794 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	class UYProfileSettings*                           m_MyProfile;                                      		// 0x0798 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIObjectFilter*                            m_ObjectFilter;                                   		// 0x07A0 (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	float                                              m_SwitcherListCellSize;                           		// 0x07A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_itemHeight;                                     		// 0x07A8 (0x0004) [0x0000000000000000]              
	int                                                m_itemPadding;                                    		// 0x07AC (0x0004) [0x0000000000000000]              
	float                                              m_resScaling;                                     		// 0x07B0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2470 ];

		return pClassPointer;
	};

	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSettingValueChanged ( class UUIObject* Sender, int PlayerIndex );
	void OptionsSelectionChange ( class UYSimpleList* SourceList, int NewSelectedIndex );
	void OnOverridePlatformChanged ( );
	void SetDefaultSwitcherValue ( class UYUIOptionList* CurrentSwitcher );
	bool SetToDefaults ( );
	bool SetDefaultsResponse ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	bool OnSetDefaultsClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnSelectItem ( int PlayerIndex );
	void UpdatePlayerController ( int ProfileSettingId, int CurrentValue );
	void UpdateProfileStatsAndSave ( );
	bool ApplyChanges ( );
	void FocusFirstElement ( );
	float GetMouseWidgetY ( class UUIScreenObject* Widget );
	int GetMouseOverSelected ( );
	void SelectNewItem ( int Selection );
	void TickScene ( float DeltaTime );
	void RepositionSwitcherList ( );
	void HandleResolutionChanged ( struct FVector2D* OldViewportsize, struct FVector2D* NewViewportSize );
	void SwitcherAlignmentChanged ( );
	void InitSwitcherListPanelReference ( );
	void HandleValuechanged ( class UUIObject* Sender, int PlayerIndex );
	void InitWidget ( );
	void UpdateSwitcherValue ( class UYUIOptionList* CurrentSwitcher );
	void UpdateListValues ( );
	int FindIndexOfCurrentlySelected ( );
	void RemoveHiddenSwitchers ( );
	void CheckForCoopAndRemoveSubtitles ( );
	void SceneActivated ( unsigned long bInitialActivation );
	bool MayUseEnglishAudioLanguageSettings ( );
	void PostInitialize ( );
};

UClass* UYUISceneFEOptions_Base::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_OptionsGfx
// 0x0054 (0x0808 - 0x07B4)
class UYUIFrontEnd_OptionsGfx : public UYUISceneFEOptions_Base
{
public:
	struct FString                                     m_SceneBrightness;                                		// 0x07B4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneTimedMessageBox;                           		// 0x07C0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUTUIDataStore_StringList*                   m_stringListDataStore;                            		// 0x07CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIOptionList*                              m_QualitySwitcher;                                		// 0x07D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIOptionList*                              m_resolutionSwitcher;                             		// 0x07D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIOptionList*                              m_msaaSwitcher;                                   		// 0x07D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIOptionList*                              m_texDetailsSwitcher;                             		// 0x07DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIOptionList*                              m_shadowDetailsSwitcher;                          		// 0x07E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIOptionList*                              m_fullscreenSwitcher;                             		// 0x07E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIOptionList*                              m_vSyncSwitcher;                                  		// 0x07E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIOptionList*                              m_AOSwitcher;                                     		// 0x07EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabelButton*                              m_BrightnessButton;                               		// 0x07F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_ResolutionDirty : 1;                            		// 0x07F4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_fullscreenDirty : 1;                            		// 0x07F4 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	int                                                PreviousResolutionIndex;                          		// 0x07F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                PreviousFullscreenSetting;                        		// 0x07FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_fullscreenEnabled;                              		// 0x0800 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_lastValidCompatSetting;                         		// 0x0804 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2471 ];

		return pClassPointer;
	};

	void OnBrightnessPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool SetToDefaults ( );
	void UpdateProfileStatsAndSave ( );
	void SubmitQualityLevel ( );
	void SubmitAmbientOcclusion ( );
	void SubmitShadowDetails ( );
	void SubmitTexDetails ( );
	void SubmitFullscreen ( int NewFullscreenIndex );
	void SubmitVSync ( );
	void SubmitMSAALevel ( );
	void SubmitResolution ( int NewResIndex );
	void ResolutionBoxResponse ( struct FString MessageBoxResponse );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void SubQualitySettingChanged ( class UUIObject* Sender, int PlayerIndex );
	void QualityLevelChanged ( class UUIObject* Sender, int PlayerIndex );
	void FullscreenChanged ( class UUIObject* Sender, int PlayerIndex );
	void ResolutionChanged ( class UUIObject* Sender, int PlayerIndex );
	void UpdateCompatSettingSwitcher ( );
	void UpdateListValues ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitWidgetReferences ( );
	void RefreshSettings ( int compatLevel );
	void InitWidget ( );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_OptionsGfx::pClassPointer = NULL;

// Class SRGame.YUIScene_Scoreboard
// 0x0068 (0x07AC - 0x0744)
class UYUIScene_Scoreboard : public UYUIScenes
{
public:
	class UUILabel*                                    m_lblTimeLeft;                                    		// 0x0744 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblXP;                                          		// 0x0748 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRank;                                        		// 0x074C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRequiredXP;                                  		// 0x0750 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_MenuTitle;                                      		// 0x0754 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRevengeRound;                                		// 0x0758 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblGameMode;                                    		// 0x075C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScoreboardPanel*                         m_pnlScoreboard;                                  		// 0x0760 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblScoreSpecops;                                		// 0x0764 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblScoreKonrad;                                 		// 0x0768 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgKonrad;                                      		// 0x076C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSpecop;                                      		// 0x0770 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgChaos;                                       		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnXPEvent;                                     		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnChallenges;                                  		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnGamerCard;                                   		// 0x0780 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnCloseA;                                      		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_pnlButtonBar;                                   		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_LocMenuTitle;                                   		// 0x078C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_sLocRevegeRound;                                		// 0x0798 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       m_CloseSceneKey;                                  		// 0x07A4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2472 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	void CloseScoreboard ( );
	void Cancel ( int ControllerId );
	bool OnCloseInGame ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnCloseEndGame ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnShowGamerCard ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnSelectItem ( int PlayerIndex );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void OnTick ( float DeltaTime );
	void InitRevenge ( );
	void InitWidget ( );
	void PostInitialize ( );
};

UClass* UYUIScene_Scoreboard::pClassPointer = NULL;

// Class SRGame.YUIScene_TimedUIScene
// 0x0014 (0x0758 - 0x0744)
class UYUIScene_TimedUIScene : public UYUIScenes
{
public:
	float                                              m_TotalDisplayTime;                               		// 0x0744 (0x0004) [0x0000000000000000]              
	float                                              m_DisplayTimeLeft;                                		// 0x0748 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             __OnTimedSceneClosed__Delegate;                   		// 0x074C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2473 ];

		return pClassPointer;
	};

	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void TimeIsUp ( );
	void SetDisplayTime ( float Time );
	void TickScene ( float DeltaTime );
	void SceneActivated ( unsigned long bInitialActivation );
	void OnTimedSceneClosed ( );
};

UClass* UYUIScene_TimedUIScene::pClassPointer = NULL;

// Class SRGame.YDisablePathVolume
// 0x0004 (0x0238 - 0x0234)
class AYDisablePathVolume : public AVolume
{
public:
	unsigned long                                      m_disablePathes : 1;                              		// 0x0234 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2474 ];

		return pClassPointer;
	};

	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYDisablePathVolume::pClassPointer = NULL;

// Class SRGame.YPathVolume
// 0x0010 (0x0244 - 0x0234)
class AYPathVolume : public AVolume
{
public:
	unsigned long                                      m_include : 1;                                    		// 0x0234 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class UObject*                                     m_dataTag;                                        		// 0x0238 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_localPitch;                                     		// 0x023C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_localGraphAccuracy;                             		// 0x0240 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2475 ];

		return pClassPointer;
	};

};

UClass* AYPathVolume::pClassPointer = NULL;

// Class SRGame.YSeqVar_CombatPos
// 0x000C (0x00C4 - 0x00B8)
class UYSeqVar_CombatPos : public USeqVar_Object
{
public:
	unsigned char                                      m_slotType;                                       		// 0x00B8 (0x0001) [0x0000000000000000]              
	int                                                m_slotIdx;                                        		// 0x00BC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_useStack : 1;                                   		// 0x00C0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2476 ];

		return pClassPointer;
	};

};

UClass* UYSeqVar_CombatPos::pClassPointer = NULL;

// Class SRGame.YLeaderboardMultiplayerSkill
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardMultiplayerSkill : public UOnlineStatsRead
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2477 ];

		return pClassPointer;
	};

	void FillPlayerResevation ( struct FUniqueNetId PlayerID, struct FPlayerReservation* PlayerRes );
	int GetSkillForPlayer ( struct FUniqueNetId PlayerID );
	void CopySkillDataToSearch ( class UOnlineGameSearch* Search );
};

UClass* UYLeaderboardMultiplayerSkill::pClassPointer = NULL;

// Class SRGame.YActorFactory_YFogVolumeSandBoxDensityInfo
// 0x0000 (0x0064 - 0x0064)
class UYActorFactory_YFogVolumeSandBoxDensityInfo : public UActorFactoryFogVolumeConstantDensityInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2478 ];

		return pClassPointer;
	};

};

UClass* UYActorFactory_YFogVolumeSandBoxDensityInfo::pClassPointer = NULL;

// Class SRGame.YActorFactory_YFogVolumeSandSphereDensityInfo
// 0x0000 (0x0064 - 0x0064)
class UYActorFactory_YFogVolumeSandSphereDensityInfo : public UActorFactoryFogVolumeSphericalDensityInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2479 ];

		return pClassPointer;
	};

};

UClass* UYActorFactory_YFogVolumeSandSphereDensityInfo::pClassPointer = NULL;

// Class SRGame.YFogVolumeSandDensityInfo
// 0x0044 (0x0248 - 0x0204)
class AYFogVolumeSandDensityInfo : public AFogVolumeDensityInfo
{
public:
	float                                              m_maxDensityTime;                                 		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDensity;                                     		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxSizeTime1;                                   		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxSizeTime2;                                   		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeOutStartTime;                               		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeOutTime;                                    		// 0x0218 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bStaticVolume : 1;                              		// 0x021C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bExcludeVolume : 1;                             		// 0x021C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bTriggerAIAnimation : 1;                        		// 0x021C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bShowSizePreview : 1;                           		// 0x021C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_isSecond : 1;                                   		// 0x021C (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              m_maxTriggerRadius;                               		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_denityTriggerAnimThreshold;                     		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_initLocation;                                   		// 0x0228 (0x000C) [0x0000000000000000]              
	unsigned char                                      m_fadeState;                                      		// 0x0234 (0x0001) [0x0000000000000000]              
	float                                              m_typeScale;                                      		// 0x0238 (0x0004) [0x0000000000000000]              
	float                                              m_runTime;                                        		// 0x023C (0x0004) [0x0000000000000000]              
	class AYFogVolumeSandDensityInfo*                  m_secondFogVolume;                                		// 0x0240 (0x0004) [0x0000000000000000]              
	class UDrawLightRadiusComponent*                   m_maxTriggerPreviewSphereRadius;                  		// 0x0244 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2480 ];

		return pClassPointer;
	};

	void ShowStatic ( float typeScale );
	void show ( struct FVector pos, float typeScale );
};

UClass* AYFogVolumeSandDensityInfo::pClassPointer = NULL;

// Class SRGame.YFogVolumeSandBoxDensityInfo
// 0x0068 (0x02B0 - 0x0248)
class AYFogVolumeSandBoxDensityInfo : public AYFogVolumeSandDensityInfo
{
public:
	struct FVector                                     m_maxSize1;                                       		// 0x0248 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_maxSize2;                                       		// 0x0254 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	class UDrawBoxComponent*                           m_maxSize1PreviewBoxRadius;                       		// 0x0260 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UDrawBoxComponent*                           m_maxSize2PreviewBoxRadius;                       		// 0x0264 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UDrawBoxComponent*                           m_previewBox;                                     		// 0x0268 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x026C (0x0004) MISSED OFFSET
	struct FMatrix                                     m_initScaleMatrix;                                		// 0x0270 (0x0040) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2481 ];

		return pClassPointer;
	};

};

UClass* AYFogVolumeSandBoxDensityInfo::pClassPointer = NULL;

// Class SRGame.YFogVolumeSandSphereDensityInfo
// 0x001C (0x0264 - 0x0248)
class AYFogVolumeSandSphereDensityInfo : public AYFogVolumeSandDensityInfo
{
public:
	float                                              m_maxSize1;                                       		// 0x0248 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxSize2;                                       		// 0x024C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_initSphereRadius;                               		// 0x0250 (0x0004) [0x0000000000000000]              
	float                                              m_baseSphereRadius;                               		// 0x0254 (0x0004) [0x0000000000000000]              
	class UDrawLightRadiusComponent*                   m_maxSize1PreviewSphereRadius;                    		// 0x0258 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UDrawLightRadiusComponent*                   m_maxSize2PreviewSphereRadius;                    		// 0x025C (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UDrawLightRadiusComponent*                   m_previewSphereRadius;                            		// 0x0260 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2482 ];

		return pClassPointer;
	};

};

UClass* AYFogVolumeSandSphereDensityInfo::pClassPointer = NULL;

// Class SRGame.YMPFogVolumeConstantDensityComponent
// 0x0008 (0x00A0 - 0x0098)
class UYMPFogVolumeConstantDensityComponent : public UFogVolumeConstantDensityComponent
{
public:
	float                                              m_fremenDensityModifier;                          		// 0x0098 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bLocalPawnCanSeeInSandstorms : 1;               		// 0x009C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2483 ];

		return pClassPointer;
	};

};

UClass* UYMPFogVolumeConstantDensityComponent::pClassPointer = NULL;

// Class SRGame.UTDataStore_GameSearchBase
// 0x0004 (0x00AC - 0x00A8)
class UUTDataStore_GameSearchBase : public UUIDataStore_OnlineGameSearch
{
public:
	class UUTUIDataProvider_ServerDetails*             ServerDetailsProvider;                            		// 0x00A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2484 ];

		return pClassPointer;
	};

	bool HasExistingSearchResults ( );
	bool HasOutstandingQueries ( unsigned long bRestrictCheckToSelf );
	void OnSearchComplete ( unsigned long bWasSuccessful );
	bool SubmitGameSearch ( unsigned char ControllerIndex, unsigned long bInvalidateExistingSearchResults );
	void Init ( );
	bool GetEnabledMutators ( TArray< int >* MutatorIndices );
};

UClass* UUTDataStore_GameSearchBase::pClassPointer = NULL;

// Class SRGame.UTGameInteraction
// 0x0004 (0x01B0 - 0x01AC)
class UUTGameInteraction : public UUIInteraction
{
public:
	int                                                BlockUIInputSemaphore;                            		// 0x01AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2485 ];

		return pClassPointer;
	};

	void NotifyGameSessionEnded ( );
	void BlockUIInput ( unsigned long bBlock );
	void ClearUIInputBlocks ( );
	bool ShouldProcessUIInput ( );
};

UClass* UUTGameInteraction::pClassPointer = NULL;

// Class SRGame.UTUIDataProvider_SearchResult
// 0x002C (0x00BC - 0x0090)
class UUTUIDataProvider_SearchResult : public UUIDataProvider_Settings
{
public:
	struct FName                                       PlayerRatioTag;                                   		// 0x0090 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       GameModeFriendlyNameTag;                          		// 0x0098 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       ServerFlagsTag;                                   		// 0x00A0 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       MapNameTag;                                       		// 0x00A8 (0x0008) [0x0000000000000002]              ( CPF_Const )
	struct FString                                     IconFontPathName;                                 		// 0x00B0 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2486 ];

		return pClassPointer;
	};

};

UClass* UUTUIDataProvider_SearchResult::pClassPointer = NULL;

// Class SRGame.UTUIDataProvider_SimpleElementProvider
// 0x0004 (0x005C - 0x0058)
class UUTUIDataProvider_SimpleElementProvider : public UUIDataProvider
{
public:
	struct FPointer                                    VfTable_IUIListElementCellProvider;               		// 0x0058 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2487 ];

		return pClassPointer;
	};

	int GetElementCount ( );
};

UClass* UUTUIDataProvider_SimpleElementProvider::pClassPointer = NULL;

// Class SRGame.UTUIDataProvider_ServerDetails
// 0x0004 (0x0060 - 0x005C)
class UUTUIDataProvider_ServerDetails : public UUTUIDataProvider_SimpleElementProvider
{
public:
	int                                                SearchResultsRow;                                 		// 0x005C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2488 ];

		return pClassPointer;
	};

	int GetElementCount ( );
	class UUIDataProvider_Settings* GetSearchResultsProvider ( );
};

UClass* UUTUIDataProvider_ServerDetails::pClassPointer = NULL;

// Class SRGame.UTUIDataProvider_StringArray
// 0x000C (0x0068 - 0x005C)
class UUTUIDataProvider_StringArray : public UUTUIDataProvider_SimpleElementProvider
{
public:
	TArray< struct FString >                           Strings;                                          		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2489 ];

		return pClassPointer;
	};

	int GetElementCount ( );
};

UClass* UUTUIDataProvider_StringArray::pClassPointer = NULL;

// Class SRGame.UTUIDataStore_StringAliasMap
// 0x0004 (0x00C8 - 0x00C4)
class UUTUIDataStore_StringAliasMap : public UUIDataStore_StringAliasMap
{
public:
	int                                                FakePlatform;                                     		// 0x00C4 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2490 ];

		return pClassPointer;
	};

	int GetStringWithFieldName ( struct FString FieldName, struct FString* MappedString );
};

UClass* UUTUIDataStore_StringAliasMap::pClassPointer = NULL;

// Class SRGame.UTUIDataStore_StringList
// 0x0014 (0x008C - 0x0078)
class UUTUIDataStore_StringList : public UUIDataStore_StringBase
{
public:
	struct FPointer                                    VfTable_IUIListElementProvider;                   		// 0x0078 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_IUIListElementCellProvider;               		// 0x007C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	TArray< struct FEStringListData >                  StringData;                                       		// 0x0080 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 2491 ];

		return pClassPointer;
	};

	int Num ( struct FName FieldName );
	void SetValue ( struct FName FieldName, int NewValueIndex );
	int SetCurrentValueIndex ( struct FName FieldName, int NewValueIndex );
	int GetCurrentValueIndex ( struct FName FieldName );
	bool GetCurrentValue ( struct FName FieldName, struct FString* out_Value );
	TArray< struct FString > GetList ( struct FName FieldName );
	struct FString GetStr ( struct FName FieldName, int StrIndex );
	int FindStr ( struct FName FieldName, struct FString SearchString );
	void Empty ( struct FName FieldName, unsigned long bBatchOp );
	void RemoveStrByIndex ( struct FName FieldName, int Index, int Count, unsigned long bBatchOp );
	void RemoveStr ( struct FName FieldName, struct FString StringToRemove, unsigned long bBatchOp );
	void InsertStr ( struct FName FieldName, struct FString NewString, int InsertIndex, unsigned long bBatchOp );
	void AddStr ( struct FName FieldName, struct FString NewString, unsigned long bBatchOp );
	int GetFieldIndex ( struct FName FieldName );
	void Registered ( class ULocalPlayer* PlayerOwner );
};

UClass* UUTUIDataStore_StringList::pClassPointer = NULL;

// Class SRGame.AIFactoryEnums
// 0x0000 (0x003C - 0x003C)
class UAIFactoryEnums : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 38974 ];

		return pClassPointer;
	};

};

UClass* UAIFactoryEnums::pClassPointer = NULL;

// Class SRGame.YGameInfo_Elimination
// 0x0010 (0x0B3C - 0x0B2C)
class AYGameInfo_Elimination : public AYGameInfo_MP
{
public:
	int                                                konradLastManVoiceId;                             		// 0x0B2C (0x0004) [0x0000000000000000]              
	int                                                specopsLastManVoiceId;                            		// 0x0B30 (0x0004) [0x0000000000000000]              
	int                                                m_remainingKonrad;                                		// 0x0B34 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_remainingSpecops;                               		// 0x0B38 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39790 ];

		return pClassPointer;
	};

	bool ProcessRoundEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	bool HasEnoughNetPlayers ( );
	void Killed ( class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, class UClass* DamageType );
	void PlayTwoEnemiesLeft ( class AController* KilledPlayer );
	void PlayThreeEnemiesLeft ( class AController* KilledPlayer );
	void PlayFourEnemiesLeft ( class AController* KilledPlayer );
	void PlayLastManVoice ( class AController* KilledPlayer );
	int CountRemainingLivingTeammates ( class AController* KilledPlayer );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
};

UClass* AYGameInfo_Elimination::pClassPointer = NULL;

// Class SRGame.YGameInfo_HD
// 0x0094 (0x0BC0 - 0x0B2C)
class AYGameInfo_HD : public AYGameInfo_MP
{
public:
	struct FYS_XPModifier                              m_xpPerHold;                                      		// 0x0B2C (0x0014) [0x0000000000004000]              ( CPF_Config )
	int                                                m_holdTimeInterval;                               		// 0x0B40 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerSabotage;                                  		// 0x0B44 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerRepair;                                    		// 0x0B58 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromHold;                             		// 0x0B6C (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromSabotages;                        		// 0x0B88 (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromRepairs;                          		// 0x0BA4 (0x001C) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39791 ];

		return pClassPointer;
	};

	void AnnounceComStationRepair ( int TeamNum );
	void AnnounceComStationSabotage ( int TeamNum );
	void ScoreRepair ( class AYPlayerController_HD* PC, class AYDestroyPoint* DP );
	void ScoreSabotage ( class AYPlayerController_HD* PC, class AYDestroyPoint* DP );
	int GetRoundEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
};

UClass* AYGameInfo_HD::pClassPointer = NULL;

// Class SRGame.YGameInfo_TDM
// 0x0000 (0x0B2C - 0x0B2C)
class AYGameInfo_TDM : public AYGameInfo_MP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39792 ];

		return pClassPointer;
	};

	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
};

UClass* AYGameInfo_TDM::pClassPointer = NULL;

// Class SRGame.YGameInfo_Buried
// 0x0060 (0x0B8C - 0x0B2C)
class AYGameInfo_Buried : public AYGameInfo_MP
{
public:
	struct FYS_XPModifier                              m_xpPerVitalPointAssist;                          		// 0x0B2C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerRepair;                                    		// 0x0B40 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromSabotages;                        		// 0x0B54 (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromRepairs;                          		// 0x0B70 (0x001C) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39793 ];

		return pClassPointer;
	};

	void PlayAvalancheMovie ( struct FName movieFileName );
	void ScoreDestructionAssist ( class AYPlayerController_Buried* PC );
	void ScoreDestruction ( class AYPlayerController_Buried* PC );
	void ScoreRepair ( class AYPlayerController_Buried* PC );
	int GetRoundEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	bool CheckEndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void EndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	bool CheckScore ( class APlayerReplicationInfo* Scorer );
	void ClientVitalPointAttacked ( int destroyPointTeam );
};

UClass* AYGameInfo_Buried::pClassPointer = NULL;

// Class SRGame.YGameInfo_CA
// 0x0068 (0x0B94 - 0x0B2C)
class AYGameInfo_CA : public AYGameInfo_MP
{
public:
	struct FYS_XPModifier                              m_xpPerChopperDestruction;                        		// 0x0B2C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerChopperDestructionAssist;                  		// 0x0B40 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerChopperCall;                               		// 0x0B54 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerBaseDestruction;                           		// 0x0B68 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerBaseMarked;                                		// 0x0B7C (0x0014) [0x0000000000004000]              ( CPF_Config )
	int                                                m_comStationsNeeded;                              		// 0x0B90 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39794 ];

		return pClassPointer;
	};

	void OnChopperCalled ( class AController* YPC, int attackThisBase );
	void AnnounceTeam1OwnsAll ( );
	void AnnounceTeam0OwnsAll ( );
	void AnnounceCOMStationAcquired ( int TeamNum );
	void ScoreActivate ( class AYPlayerController_CA* PC );
	void AnnounceCOMStationCaptured ( int TeamNum );
	void ScoreDeactivate ( class AYPlayerController_CA* PC );
	void ScoreBaseMarked ( class AYPlayerController_CA* PC );
	void ScoreBaseDestruction ( class AYPlayerController_CA* PC );
	void ScoreChopperCall ( class AYPlayerController_CA* PC );
	void ScoreChopperDestructionAssist ( class AYPlayerController_CA* PC );
	void ScoreChopperDestruction ( class AYPlayerController_CA* PC );
	int GetRoundEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI );
	bool CheckScore ( class APlayerReplicationInfo* Scorer );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void SwapSides ( );
};

UClass* AYGameInfo_CA::pClassPointer = NULL;

// Class SRGame.YGameInfo_Offline
// 0x0064 (0x0B90 - 0x0B2C)
class AYGameInfo_Offline : public AYGameInfo_MP
{
public:
	struct FYS_XPModifier                              m_xpPerDeactivation;                              		// 0x0B2C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerActivation;                                		// 0x0B40 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromDeactivations;                    		// 0x0B54 (0x001C) [0x0000000000004000]              ( CPF_Config )
	struct FYS_EarnedXPFunc                            m_matchEndXPFromActivations;                      		// 0x0B70 (0x001C) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bFirstRound : 1;                                		// 0x0B8C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bFirstActivation : 1;                           		// 0x0B8C (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39795 ];

		return pClassPointer;
	};

	void CheckForEndRound ( class APlayerReplicationInfo* Scorer );
	void AnnounceTeam1OwnsAll ( );
	void AnnounceTeam0OwnsAll ( );
	void AnnounceCOMStationAcquired ( int TeamNum );
	void ScoreActivate ( class AYPlayerController_Offline* PC );
	void AnnounceCOMStationCaptured ( int TeamNum );
	void ScoreDeactivate ( class AYPlayerController_Offline* PC );
	int GetRoundEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void SwapSides ( );
	bool CheckScore ( class APlayerReplicationInfo* Scorer );
};

UClass* AYGameInfo_Offline::pClassPointer = NULL;

// Class SRGame.YGameInfo_Delivery
// 0x0000 (0x0B2C - 0x0B2C)
class AYGameInfo_Delivery : public AYGameInfo_MP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39796 ];

		return pClassPointer;
	};

	int GetRoundEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void SwapSides ( );
	bool ProcessRoundEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void EndGameByTimeOut ( );
	void EndGameByExplosion ( );
	int GetAttackingTeam ( class AYPlayerController_MP* PC );
	void Tick ( float DeltaTime );
	void PostBeginPlay ( );
};

UClass* AYGameInfo_Delivery::pClassPointer = NULL;

// Class SRGame.YGameInfo_SW
// 0x0054 (0x0B80 - 0x0B2C)
class AYGameInfo_SW : public AYGameInfo_MP
{
public:
	struct FYS_XPModifier                              m_xpPerDeposit;                                   		// 0x0B2C (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerSteal;                                     		// 0x0B40 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerStolenDeposit;                             		// 0x0B54 (0x0014) [0x0000000000004000]              ( CPF_Config )
	struct FYS_XPModifier                              m_xpPerLootCarrierKill;                           		// 0x0B68 (0x0014) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fTimeBeforeBanking;                             		// 0x0B7C (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39797 ];

		return pClassPointer;
	};

	void YScoreKill ( class AController* Killer, class AController* Killed, class APawn* KilledPawn, class UClass* DamageType );
	void ScoreDepositStolenLoot ( class AYPlayerController_SW* PC, int depositAmount );
	void AnnounceBankedLoot ( int teamThatBanked );
	void ScoreDeposit ( class AYPlayerController_SW* PC, int depositAmount );
	void AnnounceStolenLoot ( int teamThatStole );
	void ScoreSteal ( class AYPlayerController_SW* PC, int stealamount );
	int GetRoundEndBonusXP ( class AYPlayerReplicationInfo_MP* PRI );
	void EndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void BankGold ( );
	void StartMatch ( );
	void ProcessGameEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void Tick ( float DeltaTime );
	bool CheckEndGameByGold ( );
};

UClass* AYGameInfo_SW::pClassPointer = NULL;

// Class SRGame.YUICharacterCustomPanel
// 0x0074 (0x00B0 - 0x003C)
class UYUICharacterCustomPanel : public UObject
{
public:
	struct FString                                     LockIcon;                                         		// 0x003C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     CurrentIcon;                                      		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UYUIFrontEnd_ClassSelection*                 m_owner;                                          		// 0x0054 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIDataStore_Equipment*                     m_EquipmentDataStore;                             		// 0x0058 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_PanelEnum;                                      		// 0x005C (0x0001) [0x0000000000000000]              
	class UUIPanel*                                    m_Panel;                                          		// 0x0060 (0x0004) [0x0000000000000000]              
	int                                                m_NumPerks;                                       		// 0x0064 (0x0004) [0x0000000000000000]              
	class UUIPanel*                                    m_pnlWeaponDisplay;                               		// 0x0068 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_PerkImage1;                                     		// 0x006C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_PerkImage2;                                     		// 0x0070 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_PerkImage3;                                     		// 0x0074 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblExplosiveName;                               		// 0x0078 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblPrimaryWeaponName;                           		// 0x007C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSecondaryWeaponName;                         		// 0x0080 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgPrimaryWeapon;                               		// 0x0084 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSecondaryWeapon;                             		// 0x0088 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgExplosiveWeapon;                             		// 0x008C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblExplosiveDisplayName;                        		// 0x0090 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblWeaponDisplayName;                           		// 0x0094 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblPerkDisplayName;                             		// 0x0098 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_CurrentList;                                    		// 0x009C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_PrimaryWeaponsAlsoSecondary : 1;                		// 0x00A0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_HeavyWeaponsAlsoSecondary : 1;                  		// 0x00A0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	TArray< struct UYUICharacterCustomPanel_FYS_ContentPackInfoItem > m_ContentPackInfo;                                		// 0x00A4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 40981 ];

		return pClassPointer;
	};

	void CheckForInvalidWeapon ( );
	void CheckSpecialCases ( );
	void SetUpPerks ( );
	void LoadWeaponPanelDisplay ( int Index );
	void InitWeaponDisplayRef ( );
	void SetCharacterMesh ( );
	void SetPerkIcon ( class UUIImage* Image, int Position );
	void SetClassIcon ( class UUIImage* Image, int SlotNumber, class UYUIDataProvider_MajorPerks* AltProvider );
	void HandleSelection ( );
	void ResetPanel ( );
	void OnDeactivate ( );
	void OnActivate ( );
	void InitWidgetRef ( );
	void InitWidget ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void Init ( unsigned char panelEnum, class UUIScreenObject* Parent, struct FString panelName );
};

UClass* UYUICharacterCustomPanel::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_PerkSlots
// 0x0000 (0x01EC - 0x01EC)
class UYUIDataProvider_PerkSlots : public UYUIDataProvider_Equipment
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41081 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_PerkSlots::pClassPointer = NULL;

// Class SRGame.YPerk_CombatOperative
// 0x0004 (0x0054 - 0x0050)
class UYPerk_CombatOperative : public UYPerk
{
public:
	float                                              m_ammoMultiplier;                                 		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41094 ];

		return pClassPointer;
	};

};

UClass* UYPerk_CombatOperative::pClassPointer = NULL;

// Class SRGame.YWeapon_Pistol
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Pistol : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41101 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Pistol::pClassPointer = NULL;

// Class SRGame.YWeapon_SIGP220
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_SIGP220 : public AYWeapon_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41100 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_SIGP220::pClassPointer = NULL;

// Class SRGame.YWeapon_SubmachineGun
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_SubmachineGun : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41103 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_SubmachineGun::pClassPointer = NULL;

// Class SRGame.YWeapon_HnKUMP45
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_HnKUMP45 : public AYWeapon_SubmachineGun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41102 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_HnKUMP45::pClassPointer = NULL;

// Class SRGame.YUICharacterCustomKitPanel
// 0x005C (0x010C - 0x00B0)
class UYUICharacterCustomKitPanel : public UYUICharacterCustomPanel
{
public:
	class UYUIDataProvider_CharacterKitCategories*     m_CategoryProviders[ 0x3 ];                       		// 0x00B0 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_KitList;                                        		// 0x00BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_CurrentPage;                                    		// 0x00C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKitIndex;                                    		// 0x00C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnLeftButton;                                  		// 0x00C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnRightButton;                                 		// 0x00CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_ResourceListItem >              m_HeadGearList;                                   		// 0x00D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_ResourceListItem >              m_AccessoriesList;                                		// 0x00DC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_ResourceListItem >              m_PatternList;                                    		// 0x00E8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UUIPanel*                                    m_pnlItemDisplay;                                 		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKitObjectName;                               		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgKitObjectIcon;                               		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKitObjectDescription;                        		// 0x0100 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlLockedPanel;                                 		// 0x0104 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblLockedText;                                  		// 0x0108 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41105 ];

		return pClassPointer;
	};

	void SortResourceListByUnlockLevel ( TArray< struct FYS_ResourceListItem >* List );
	struct FString GetResourceName ( struct FName resourcePath );
	void GetResourceList ( struct FYMP_HandleAssetPair assetPair, struct UYUICharacterCustomPanel_FYS_ContentPackInfoItem ContentPack, unsigned long prestigeLevel, TArray< struct FYS_ResourceListItem >* patternList );
	void HandlePatternsSelection ( );
	void OnPatterns_SelectionChange ( int Item );
	void DisplayPatternsList ( );
	void PopulatePatternsData ( );
	void HandleAccessoriesSelection ( );
	void OnAccessories_SelectionChange ( int Item );
	void DisplayAccessoriesList ( );
	void PopulateAccessoriesData ( );
	void HandleHeadSelection ( );
	void OnHead_SelectionChange ( int Item );
	void DisplayHeadList ( );
	void PopulateHeadData ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void OnPageChange ( );
	void HandleSelection ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnRightButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnLeftButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnMenu_SelectionChange ( class UYSimpleList* List, int Item );
	void OnMenu_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void OnDeactivate ( );
	void OnActivate ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void Init ( unsigned char panelEnum, class UUIScreenObject* Parent, struct FString panelName );
};

UClass* UYUICharacterCustomKitPanel::pClassPointer = NULL;

// Class SRGame.YSeqEvt_IntelMenuTransition
// 0x0004 (0x0114 - 0x0110)
class UYSeqEvt_IntelMenuTransition : public USequenceEvent
{
public:
	int                                                m_IntelID;                                        		// 0x0110 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41610 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqEvt_IntelMenuTransition::pClassPointer = NULL;

// Class SRGame.YGameSettingsParty
// 0x0000 (0x00D8 - 0x00D8)
class UYGameSettingsParty : public UYGameSettingsMultiplayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41734 ];

		return pClassPointer;
	};

	unsigned char GetMapEnum ( struct FString MapName );
	void SetMapEnumFromString ( struct FString MapName );
};

UClass* UYGameSettingsParty::pClassPointer = NULL;

// Class SRGame.YSeqEvt_MenuTransition
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_MenuTransition : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41823 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqEvt_MenuTransition::pClassPointer = NULL;

// Class SRGame.UIAnim_Test
// 0x0004 (0x0778 - 0x0774)
class UUIAnim_Test : public UYUIFrontEnd
{
public:
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41824 ];

		return pClassPointer;
	};

	bool ClickBack ( class UUIScreenObject* EventObject, int PlayerIndex );
	void InitButton ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitWidgetRef ( );
};

UClass* UUIAnim_Test::pClassPointer = NULL;

// Class SRGame.UIAnim_Test1
// 0x0024 (0x079C - 0x0778)
class UUIAnim_Test1 : public UUIAnim_Test
{
public:
	class UUIList*                                     m_List1;                                          		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIList*                                     m_List2;                                          		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIList*                                     m_List3;                                          		// 0x0780 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIList*                                     m_List4;                                          		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_PanelAll;                                       		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bRotate : 1;                                    		// 0x078C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bFade : 1;                                      		// 0x078C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bEnterRight : 1;                                		// 0x078C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bEnterLeft : 1;                                 		// 0x078C (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	TArray< class UUIAnimationSeq* >                   AnimSequencePool;                                 		// 0x0790 (0x000C) [0x0000000004400009]              ( CPF_Edit | CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41837 ];

		return pClassPointer;
	};

	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool PageLeft ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool PageRight ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool PageDown ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool PageUp ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool ClickSelect ( class UUIScreenObject* EventObject, int PlayerIndex );
	void InitButton ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitWidgetRef ( );
};

UClass* UUIAnim_Test1::pClassPointer = NULL;

// Class SRGame.UIAnim_Test2
// 0x0000 (0x0778 - 0x0778)
class UUIAnim_Test2 : public UUIAnim_Test
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41880 ];

		return pClassPointer;
	};

	void SceneActivated ( unsigned long bInitialActivation );
};

UClass* UUIAnim_Test2::pClassPointer = NULL;

// Class SRGame.UIAnim_Test3
// 0x0074 (0x07EC - 0x0778)
class UUIAnim_Test3 : public UUIAnim_Test
{
public:
	class UUILabelButton*                              m_ButtonTest1;                                    		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabelButton*                              m_ButtonTest2;                                    		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabelButton*                              m_ButtonTest3;                                    		// 0x0780 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabelButton*                              m_ButtonTest4;                                    		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIList*                                     m_ListTest1;                                      		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIList*                                     m_ListTest2;                                      		// 0x078C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIList*                                     m_ListTest3;                                      		// 0x0790 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIList*                                     m_ListTest4;                                      		// 0x0794 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_PanelTest1;                                     		// 0x0798 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_PanelTest2;                                     		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_PanelTest3;                                     		// 0x07A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_PanelTest4;                                     		// 0x07A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bTest1 : 1;                                     		// 0x07A8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bTest2 : 1;                                     		// 0x07A8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bTest3 : 1;                                     		// 0x07A8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bTest4 : 1;                                     		// 0x07A8 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	class UUIAnimationSeq*                             m_seqTranslationIn;                               		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIAnimationSeq*                             m_seqTranslationOut;                              		// 0x07B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_vList3PositionStart;                            		// 0x07B4 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_vList3PositionEnd;                              		// 0x07C0 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UUIAnimationSeq*                             m_seqZoomIn;                                      		// 0x07CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIAnimationSeq*                             m_seqZoomOut;                                     		// 0x07D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_vList4LeftPositionStart;                        		// 0x07D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_vList4LeftPositionEnd;                          		// 0x07D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_vList4RightPosition;                            		// 0x07DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_vList4BottomPositionStart;                      		// 0x07E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_vList4BottomPositionEnd;                        		// 0x07E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_vList4TopPosition;                              		// 0x07E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41886 ];

		return pClassPointer;
	};

	void Test4 ( );
	void Test4Pressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool Test4Clicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void Test3 ( );
	void Test3Pressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool Test3Clicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void Test2 ( );
	void Test2Pressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool Test2Clicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void Test1 ( );
	void Test1Pressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool Test1Clicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void InitAnim ( );
	void BindButton ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitWidgetRef ( );
};

UClass* UUIAnim_Test3::pClassPointer = NULL;

// Class SRGame.UTConsole
// 0x0004 (0x01DC - 0x01D8)
class UUTConsole : public UConsole
{
public:
	int                                                TextCount;                                        		// 0x01D8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41964 ];

		return pClassPointer;
	};

	void OutputTextLine ( struct FString Text );
	bool InputKey ( int ControllerId, struct FName Key, unsigned char Event, float AmountDepressed, unsigned long bGamepad );
};

UClass* UUTConsole::pClassPointer = NULL;

// Class SRGame.UTDataStore_GameSearchDM
// 0x0014 (0x00C0 - 0x00AC)
class UUTDataStore_GameSearchDM : public UUTDataStore_GameSearchBase
{
public:
	class UClass*                                      HistoryGameSearchDataStoreClass;                  		// 0x00AC (0x0004) [0x0000000000000000]              
	class UUTDataStore_GameSearchHistory*              HistoryGameSearchDataStore;                       		// 0x00B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FGameSearchSettingsStorage >        StoredGameSearchValues;                           		// 0x00B4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42010 ];

		return pClassPointer;
	};

	void SaveGameSearchParameters ( );
	void LoadGameSearchParameters ( );
	int FindStoredSettingValueIndex ( int StoredGameSearchIndex, int LocalizedSettingId, unsigned long bAddIfNecessary );
	int FindStoredSearchIndex ( struct FName GameSearchName );
	bool HasOutstandingQueries ( unsigned long bRestrictCheckToSelf );
	bool SubmitGameSearch ( unsigned char ControllerIndex, unsigned long bInvalidateExistingSearchResults );
	void Registered ( class ULocalPlayer* PlayerOwner );
};

UClass* UUTDataStore_GameSearchDM::pClassPointer = NULL;

// Class SRGame.UTDataStore_GameSearchPersonal
// 0x00B8 (0x0164 - 0x00AC)
class UUTDataStore_GameSearchPersonal : public UUTDataStore_GameSearchBase
{
public:
	class UUTDataStore_GameSearchDM*                   PrimaryGameSearchDataStore;                       		// 0x00AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     ServerUniqueId[ 0xF ];                            		// 0x00B0 (0x00B4) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42016 ];

		return pClassPointer;
	};

	void GetServerStringList ( TArray< struct FString >* out_ServerList );
	void GetServerIdList ( TArray< struct FUniqueNetId >* out_ServerList );
	bool RemoveServer ( int ControllerId, struct FUniqueNetId IdToRemove );
	bool AddServer ( int ControllerId, struct FUniqueNetId IdToAdd );
	int FindServerIndexById ( int ControllerId, struct FUniqueNetId* IdToFind );
	int FindServerIndexByString ( int ControllerId, struct FString IdToFind );
	bool GetPlayerNetId ( int ControllerId, struct FUniqueNetId* out_PlayerId );
	struct FString GetPlayerName ( int ControllerId );
	bool OverrideQuerySubmission ( unsigned char ControllerId, class UOnlineGameSearch* Search );
	bool HasOutstandingQueries ( unsigned long bRestrictCheckToSelf );
};

UClass* UUTDataStore_GameSearchPersonal::pClassPointer = NULL;

// Class SRGame.UTDataStore_GameSearchHistory
// 0x0008 (0x016C - 0x0164)
class UUTDataStore_GameSearchHistory : public UUTDataStore_GameSearchPersonal
{
public:
	class UClass*                                      FavoritesGameSearchDataStoreClass;                		// 0x0164 (0x0004) [0x0000000000000000]              
	class UUTDataStore_GameSearchFavorites*            FavoritesGameSearchDataStore;                     		// 0x0168 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42015 ];

		return pClassPointer;
	};

	bool HasOutstandingQueries ( unsigned long bRestrictCheckToSelf );
	void Registered ( class ULocalPlayer* PlayerOwner );
};

UClass* UUTDataStore_GameSearchHistory::pClassPointer = NULL;

// Class SRGame.UTDataStore_GameSearchFavorites
// 0x0004 (0x0168 - 0x0164)
class UUTDataStore_GameSearchFavorites : public UUTDataStore_GameSearchPersonal
{
public:
	class UUTDataStore_GameSearchHistory*              HistoryGameSearchDataStore;                       		// 0x0164 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42040 ];

		return pClassPointer;
	};

	bool HasOutstandingQueries ( unsigned long bRestrictCheckToSelf );
};

UClass* UUTDataStore_GameSearchFavorites::pClassPointer = NULL;

// Class SRGame.YGameSearchCommon
// 0x0000 (0x0104 - 0x0104)
class UYGameSearchCommon : public UOnlineGameSearch
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42073 ];

		return pClassPointer;
	};

};

UClass* UYGameSearchCommon::pClassPointer = NULL;

// Class SRGame.YGameSearchTDM
// 0x0000 (0x0104 - 0x0104)
class UYGameSearchTDM : public UYGameSearchCommon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42072 ];

		return pClassPointer;
	};

};

UClass* UYGameSearchTDM::pClassPointer = NULL;

// Class SRGame.YGameSettingsTDM
// 0x0000 (0x00D8 - 0x00D8)
class UYGameSettingsTDM : public UYGameSettingsMultiplayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42074 ];

		return pClassPointer;
	};

};

UClass* UYGameSettingsTDM::pClassPointer = NULL;

// Class SRGame.YGameSearchTE
// 0x0000 (0x0104 - 0x0104)
class UYGameSearchTE : public UYGameSearchCommon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42075 ];

		return pClassPointer;
	};

};

UClass* UYGameSearchTE::pClassPointer = NULL;

// Class SRGame.YGameSettingsTE
// 0x0000 (0x00D8 - 0x00D8)
class UYGameSettingsTE : public UYGameSettingsMultiplayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42076 ];

		return pClassPointer;
	};

};

UClass* UYGameSettingsTE::pClassPointer = NULL;

// Class SRGame.YUIScene_MessageBox
// 0x0000 (0x0778 - 0x0778)
class UYUIScene_MessageBox : public UUIMessageBoxBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42155 ];

		return pClassPointer;
	};

	bool AllowsToProcessPendingInvite ( );
	void HandleSceneActivated ( class UUIScene* ActivatedScene, unsigned long bInitialActivation );
};

UClass* UYUIScene_MessageBox::pClassPointer = NULL;

// Class SRGame.YAccessControl
// 0x0000 (0x02CC - 0x02CC)
class AYAccessControl : public AAccessControl
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42400 ];

		return pClassPointer;
	};

	bool KickPlayer ( class APlayerController* C, struct FString KickReason );
};

UClass* AYAccessControl::pClassPointer = NULL;

// Class SRGame.YActorFactory_AmbientSound
// 0x0000 (0x0060 - 0x0060)
class UYActorFactory_AmbientSound : public UActorFactoryAmbientSound
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42518 ];

		return pClassPointer;
	};

};

UClass* UYActorFactory_AmbientSound::pClassPointer = NULL;

// Class SRGame.YActorFactory_AmbientSound_Toggleable
// 0x0000 (0x0060 - 0x0060)
class UYActorFactory_AmbientSound_Toggleable : public UActorFactoryAmbientSound
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42520 ];

		return pClassPointer;
	};

};

UClass* UYActorFactory_AmbientSound_Toggleable::pClassPointer = NULL;

// Class SRGame.YAmbientSound_Toggleable
// 0x0014 (0x0228 - 0x0214)
class AYAmbientSound_Toggleable : public AYAmbientSound
{
public:
	unsigned long                                      bFadeOnToggle : 1;                                		// 0x0214 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              FadeInDuration;                                   		// 0x0218 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              FadeInVolumeLevel;                                		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              FadeOutDuration;                                  		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              FadeOutVolumeLevel;                               		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42522 ];

		return pClassPointer;
	};

	void StopPlayback ( );
	void StartPlayback ( );
	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYAmbientSound_Toggleable::pClassPointer = NULL;

// Class SRGame.YDataProvider_Objectives
// 0x001C (0x00A8 - 0x008C)
class UYDataProvider_Objectives : public UYUIResourceDataProvider
{
public:
	unsigned char                                      m_objectiveID;                                    		// 0x008C (0x0001) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_Title;                                          		// 0x0090 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	TArray< struct FYS_ObjectiveItem >                 m_objectives;                                     		// 0x009C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42543 ];

		return pClassPointer;
	};

};

UClass* UYDataProvider_Objectives::pClassPointer = NULL;

// Class SRGame.YGamepadInputScheme
// 0x05C8 (0x0604 - 0x003C)
class UYGamepadInputScheme : public UObject
{
public:
	struct FYS_GamepadInputInfo                        m_infos[ 0x14 ];                                  		// 0x003C (0x05A0) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_holdInterval;                                   		// 0x05DC (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_vaultOnlyFromAimOver : 1;                       		// 0x05E0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_slipOutOnlyWhenPressingForward : 1;             		// 0x05E0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_sprintCoverDashEnabled : 1;                     		// 0x05E0 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_autoSprintCoverDashEnabled : 1;                 		// 0x05E0 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_leaveCoverByStick : 1;                          		// 0x05E0 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_aimOutOnlyByZoom : 1;                           		// 0x05E0 (0x0004) [0x0000000000004000] [0x00000020] ( CPF_Config )
	unsigned char                                      m_swatTurnButtonType;                             		// 0x05E4 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_vaultButtonType;                                		// 0x05E5 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_dropDownButtonType;                             		// 0x05E6 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_slipOutButtonType;                              		// 0x05E7 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_defaultButtonType;                              		// 0x05E8 (0x0001) [0x0000000000000000]              
	struct FString                                     m_actionMessageSetName;                           		// 0x05EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __GamepadEvent__Delegate;                         		// 0x05F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42745 ];

		return pClassPointer;
	};

	bool OnGamepadEvent ( unsigned char Button, unsigned char inputEvent );
	void ResetButtonStates ( );
	void Tick ( float DeltaTime );
	bool HasButtonInput ( );
	void OnButtonReleased ( unsigned char Button );
	void OnButtonPressed ( unsigned char Button );
	void Register ( unsigned char Button, unsigned char inputEvent, struct FScriptDelegate callback );
	void CopyButtonCallbacks ( class UYGamepadInputScheme* otherScheme, unsigned char Src, unsigned char dst );
	void CopySchemeAndConvertToPlayStation ( class UYGamepadInputScheme* otherScheme );
	void CopyScheme ( class UYGamepadInputScheme* otherScheme );
	bool GamepadEvent ( );
};

UClass* UYGamepadInputScheme::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleGenericGrenadeUsage
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleGenericGrenadeUsage : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43112 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_ToggleGenericGrenadeUsage::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleAIGrenadeReaction
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleAIGrenadeReaction : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43117 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ToggleAIGrenadeReaction::pClassPointer = NULL;

// Class SRGame.YSeqAct_AssignEquipment
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_AssignEquipment : public USequenceAction
{
public:
	unsigned char                                      m_equipment;                                      		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class AYGamePawn*                                  m_pawn;                                           		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43355 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_AssignEquipment::pClassPointer = NULL;

// Class SRGame.YSeqAct_CancelSquadCommand
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_CancelSquadCommand : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43415 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_CancelSquadCommand::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_DifficultyInfo
// 0x0010 (0x00D8 - 0x00C8)
class UYUIDataProvider_DifficultyInfo : public UYUIDataProvider_MatchSetting
{
public:
	unsigned char                                      DifficultyId;                                     		// 0x00C8 (0x0001) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_diffIcon;                                       		// 0x00CC (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43594 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_DifficultyInfo::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_Coop
// 0x000C (0x0798 - 0x078C)
class AYGameReplicationInfo_Coop : public AYGameReplicationInfo_MP
{
public:
	unsigned char                                      m_endGamePlayersWin;                              		// 0x078C (0x0001) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_endGameMessage;                                 		// 0x0790 (0x0008) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43978 ];

		return pClassPointer;
	};

	void SetTeam ( int Idx, class ATeamInfo* TeamInfo );
	void CreateObjectPool ( );
	bool CheckForBalance ( class AYPlayerController_MP* PC );
	bool ShouldShowDBNOIndicator ( );
};

UClass* AYGameReplicationInfo_Coop::pClassPointer = NULL;

// Class SRGame.YGameMessage_SP
// 0x0030 (0x0080 - 0x0050)
class UYGameMessage_SP : public ULocalMessage
{
public:
	struct FString                                     m_sitRepAvailableMessage;                         		// 0x0050 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_objectiveUpdatedMessage;                        		// 0x005C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_objectiveCompletedMessage;                      		// 0x0068 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_checkpointReachedMessage;                       		// 0x0074 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44068 ];

		return pClassPointer;
	};

	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYGameMessage_SP::pClassPointer = NULL;

// Class SRGame.YIHitFeedback
// 0x0000 (0x003C - 0x003C)
class UYIHitFeedback : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44137 ];

		return pClassPointer;
	};

	void InstantRecoverBuckets ( );
	void TurnOff ( );
	void DrawImpacts ( class AYHUD* HUD, float deltaSec );
	void AddHit ( class AActor* Inst, int Damage, struct FVector Momentum );
	void AddLocation ( struct FVector Loc, int Damage, struct FVector Momentum );
	void Initialize ( class AYGamePawn* pwn );
};

UClass* UYIHitFeedback::pClassPointer = NULL;

// Class SRGame.YContentAssetHolderBase
// 0x0024 (0x0060 - 0x003C)
class UYContentAssetHolderBase : public UObject
{
public:
	TArray< class UObject* >                           m_miscContentRefs;                                		// 0x003C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UClass* >                            m_refClasses;                                     		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class USkeletalMesh* >                     m_characterMeshes;                                		// 0x0054 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44213 ];

		return pClassPointer;
	};

};

UClass* UYContentAssetHolderBase::pClassPointer = NULL;

// Class SRGame.YLocalMessage
// 0x001C (0x006C - 0x0050)
class UYLocalMessage : public ULocalMessage
{
public:
	float                                              PosX;                                             		// 0x0050 (0x0004) [0x0000000000000000]              
	unsigned char                                      PosXAlign;                                        		// 0x0054 (0x0001) [0x0000000000000000]              
	int                                                MessageArea;                                      		// 0x0058 (0x0004) [0x0000000000000000]              
	int                                                AnnouncementPriority;                             		// 0x005C (0x0004) [0x0000000000000000]              
	unsigned long                                      bShowPortrait : 1;                                		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              AnnouncementVolume;                               		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              AnnouncementDelay;                                		// 0x0068 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44234 ];

		return pClassPointer;
	};

	void PlayTeamSpecificVoice ( class AYPlayerController* P, int konradVoiceId, int specopsVoiceId );
	float GetPos ( int Switch, class AHUD* myHUD );
	bool AddAnnouncement ( class AYAnnouncer* Announcer, int MessageIndex, class APlayerReplicationInfo* PRI, class UObject* OptionalObject );
	bool ShouldBeRemoved ( class AYQueuedAnnouncement* MyAnnouncement, class UClass* NewAnnouncementClass, int NewMessageIndex );
	class UYSoundCueFMOD* AnnouncementSound ( int MessageIndex, class UObject* OptionalObject, class APlayerController* PC );
	unsigned char AnnouncementLevel ( unsigned char MessageIndex );
};

UClass* UYLocalMessage::pClassPointer = NULL;

// Class SRGame.YGameplayAnnouncement
// 0x0018 (0x0084 - 0x006C)
class UYGameplayAnnouncement : public UYLocalMessage
{
public:
	TArray< int >                                      m_konradVoice;                                    		// 0x006C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      m_specopsVoice;                                   		// 0x0078 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44233 ];

		return pClassPointer;
	};

	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYGameplayAnnouncement::pClassPointer = NULL;

// Class SRGame.YStartupMessage
// 0x0068 (0x00D4 - 0x006C)
class UYStartupMessage : public UYLocalMessage
{
public:
	struct FString                                     WaitingForOtherPlayers;                           		// 0x006C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     WaitingForOtherPlayersToBeReady;                  		// 0x0078 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     MatchAboutToBegin;                                		// 0x0084 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     MatchHasBegun;                                    		// 0x0090 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     RoundHasBegun;                                    		// 0x009C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     OverTime;                                         		// 0x00A8 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     NotReady;                                         		// 0x00B4 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     SinglePlayer;                                     		// 0x00C0 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	class UYSoundCueFMOD*                              m_startupSound;                                   		// 0x00CC (0x0004) [0x0000000000000000]              
	class UYMusicPart*                                 m_startupMusic;                                   		// 0x00D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44236 ];

		return pClassPointer;
	};

	struct FString GetLocalizedStartUpMessage ( int StartUpStage );
	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	class UYSoundCueFMOD* AnnouncementSound ( int MessageIndex, class UObject* OptionalObject, class APlayerController* PC );
	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYStartupMessage::pClassPointer = NULL;

// Class SRGame.YVictoryMessage
// 0x0018 (0x0084 - 0x006C)
class UYVictoryMessage : public UYLocalMessage
{
public:
	class UYSoundCueFMOD*                              VictorySounds[ 0x6 ];                             		// 0x006C (0x0018) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44238 ];

		return pClassPointer;
	};

	bool AddAnnouncement ( class AYAnnouncer* Announcer, int MessageIndex, class APlayerReplicationInfo* PRI, class UObject* OptionalObject );
	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	class UYSoundCueFMOD* AnnouncementSound ( int MessageIndex, class UObject* OptionalObject, class APlayerController* PC );
	unsigned char AnnouncementLevel ( unsigned char MessageIndex );
};

UClass* UYVictoryMessage::pClassPointer = NULL;

// Class SRGame.YDBNORule_SinglePlayer
// 0x0000 (0x0068 - 0x0068)
class UYDBNORule_SinglePlayer : public UYDBNORule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44355 ];

		return pClassPointer;
	};

	int GetDBNORuleSet ( class AYGamePawn* pwn, struct FYS_DBNORuleSet* Ruleset );
};

UClass* UYDBNORule_SinglePlayer::pClassPointer = NULL;

// Class SRGame.YDBNORule_MultiPlayer
// 0x000C (0x0074 - 0x0068)
class UYDBNORule_MultiPlayer : public UYDBNORule
{
public:
	unsigned long                                      m_instantDeathWithHeadShot : 1;                   		// 0x0068 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_instantDeathWithExplosive : 1;                  		// 0x0068 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_instantDeathWithHeadShotForFeignDeathPerk : 1;  		// 0x0068 (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_instantDeathWithExplosiveForFeignDeathPerk : 1; 		// 0x0068 (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	int                                                m_instantDeathDamageAmount;                       		// 0x006C (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_instantDeathDamageAmountForFeignDeathPerk;      		// 0x0070 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44356 ];

		return pClassPointer;
	};

	bool UseMinDurationForTeamRevive ( );
	bool UseMinDurationForSuicide ( );
	int GetDBNORuleSet ( class AYGamePawn* pwn, struct FYS_DBNORuleSet* Ruleset );
	float GetBleedoutDuration ( struct FYS_DBNORuleSet Ruleset, class AYPlayerReplicationInfo* PRI );
	bool CanSelfRevive ( class AYGamePawn* pwn, struct FYS_DBNORuleSet Ruleset, struct FYS_PawnDBNOInfo pwnInfo, unsigned long pwnInfoValid );
	bool CanBeRevivedByTeammate ( class AYGamePawn* pwn, struct FYS_DBNORuleSet Ruleset, struct FYS_PawnDBNOInfo pwnInfo, unsigned long pwnInfoValid );
	unsigned char CheckForExitingDBNO ( int pwnInfoIndex );
	unsigned char CheckForEnteringDBNO ( class AYGamePawn* pwn, class UClass* dmgTypeClass, struct FVector Momentum, float Damage, struct FTraceHitInfo HitInfo, class AController* Instigator, unsigned long wasHeadshot, unsigned long makesHeadExplode, unsigned char* enterCondition );
	bool CheckForNoMercyPerk ( class AController* Instigator );
	bool IsInstantDeath ( class AYGamePawn* pwn, int Damage, class UClass* YDamageType, struct FTraceHitInfo HitInfo );
};

UClass* UYDBNORule_MultiPlayer::pClassPointer = NULL;

// Class SRGame.YDBNORule_CrossPlayer
// 0x0000 (0x0074 - 0x0074)
class UYDBNORule_CrossPlayer : public UYDBNORule_MultiPlayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44357 ];

		return pClassPointer;
	};

	unsigned char CheckForExitingDBNO ( int pwnInfoIndex );
	bool TemporaryPreventDBNO ( class AYGamePawn* pwn );
	int GetDBNORuleSet ( class AYGamePawn* pwn, struct FYS_DBNORuleSet* Ruleset );
	bool IsInstantDeath ( class AYGamePawn* pwn, int Damage, class UClass* YDamageType, struct FTraceHitInfo HitInfo );
};

UClass* UYDBNORule_CrossPlayer::pClassPointer = NULL;

// Class SRGame.YDBNORule_Horde
// 0x0000 (0x0068 - 0x0068)
class UYDBNORule_Horde : public UYDBNORule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44358 ];

		return pClassPointer;
	};

	bool CanBeRevivedByTeammate ( class AYGamePawn* pwn, struct FYS_DBNORuleSet Ruleset, struct FYS_PawnDBNOInfo pwnInfo, unsigned long pwnInfoValid );
	int GetDBNORuleSet ( class AYGamePawn* pwn, struct FYS_DBNORuleSet* Ruleset );
};

UClass* UYDBNORule_Horde::pClassPointer = NULL;

// Class SRGame.YDBNORule_Test
// 0x0000 (0x0068 - 0x0068)
class UYDBNORule_Test : public UYDBNORule
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44359 ];

		return pClassPointer;
	};

	int GetDBNORuleSet ( class AYGamePawn* pwn, struct FYS_DBNORuleSet* Ruleset );
};

UClass* UYDBNORule_Test::pClassPointer = NULL;

// Class SRGame.YPawn_Adams
// 0x0000 (0x2710 - 0x2710)
class AYPawn_Adams : public AYPawn_StealthRanger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44472 ];

		return pClassPointer;
	};

	void OnSetSquadEvolution ( class UYSeqAct_SetSquadEvolution* seqAct );
	void PostBeginPlay ( );
};

UClass* AYPawn_Adams::pClassPointer = NULL;

// Class SRGame.YPawn_Lugo
// 0x0004 (0x2714 - 0x2710)
class AYPawn_Lugo : public AYPawn_StealthRanger
{
public:
	class UStaticMesh*                                 m_LugosCapMesh;                                   		// 0x2710 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44473 ];

		return pClassPointer;
	};

	void SpawnLugosCap ( );
	void PostBeginPlay ( );
	void OnSetSquadEvolution ( class UYSeqAct_SetSquadEvolution* seqAct );
};

UClass* AYPawn_Lugo::pClassPointer = NULL;

// Class SRGame.YPerk_SpecialWeapons
// 0x0004 (0x0054 - 0x0050)
class UYPerk_SpecialWeapons : public UYPerk
{
public:
	float                                              m_armorEffectiveness;                             		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44548 ];

		return pClassPointer;
	};

};

UClass* UYPerk_SpecialWeapons::pClassPointer = NULL;

// Class SRGame.YSeqEvent_InnocentKill
// 0x0010 (0x0120 - 0x0110)
class UYSeqEvent_InnocentKill : public USequenceEvent
{
public:
	class APawn*                                       m_victim;                                         		// 0x0110 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_combat : 1;                                     		// 0x0114 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_friendlyFire : 1;                               		// 0x0114 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                m_numDamages;                                     		// 0x0118 (0x0004) [0x0000000000000000]              
	int                                                m_numKills;                                       		// 0x011C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44576 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_InnocentKill::pClassPointer = NULL;

// Class SRGame.YSeqEvent_EntityDied
// 0x000C (0x011C - 0x0110)
class UYSeqEvent_EntityDied : public USequenceEvent
{
public:
	class APawn*                                       m_killedPawn;                                     		// 0x0110 (0x0004) [0x0000000000000000]              
	class AController*                                 m_victimCtrl;                                     		// 0x0114 (0x0004) [0x0000000000000000]              
	class AController*                                 m_killerCtrl;                                     		// 0x0118 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44697 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_EntityDied::pClassPointer = NULL;

// Class SRGame.YSeqEvent_SandstormStart
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_SandstormStart : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44781 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_SandstormStart::pClassPointer = NULL;

// Class SRGame.YSeqEvent_SandstormStop
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_SandstormStop : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44792 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_SandstormStop::pClassPointer = NULL;

// Class SRGame.YDeathMessage
// 0x001C (0x0088 - 0x006C)
class UYDeathMessage : public UYLocalMessage
{
public:
	struct FString                                     KilledString;                                     		// 0x006C (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     SomeoneString;                                    		// 0x0078 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	unsigned long                                      bNoConsoleDeathMessages : 1;                      		// 0x0084 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44803 ];

		return pClassPointer;
	};

	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYDeathMessage::pClassPointer = NULL;

// Class SRGame.YGameMessage
// 0x0000 (0x0164 - 0x0164)
class UYGameMessage : public UGameMessage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44804 ];

		return pClassPointer;
	};

	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYGameMessage::pClassPointer = NULL;

// Class SRGame.YPawn_AdamsAlone
// 0x0000 (0x2710 - 0x2710)
class AYPawn_AdamsAlone : public AYPawn_Adams
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44928 ];

		return pClassPointer;
	};

};

UClass* AYPawn_AdamsAlone::pClassPointer = NULL;

// Class SRGame.YPawn_Guide
// 0x0000 (0x2708 - 0x2708)
class AYPawn_Guide : public AYPawn_Infantry
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44931 ];

		return pClassPointer;
	};

	void OnScanEnded ( );
	bool IsSilhouetteLocked ( );
	void OnDelayStopSilhouette ( );
	void OnStopFeedbackSilhouette ( float Duration );
	void OnStartFeedbackSilhouette ( float Duration );
	void InitReflectionChannel ( );
	void Tick ( float DeltaTime );
};

UClass* AYPawn_Guide::pClassPointer = NULL;

// Class SRGame.YPawn_Riggs
// 0x0000 (0x2708 - 0x2708)
class AYPawn_Riggs : public AYPawn_Guide
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44930 ];

		return pClassPointer;
	};

	void InitAnimSystem ( );
	unsigned char GetScanableType ( int m_scanningTeamIdx );
};

UClass* AYPawn_Riggs::pClassPointer = NULL;

// Class SRGame.YPawn_FakeLugo
// 0x0000 (0x2708 - 0x2708)
class AYPawn_FakeLugo : public AYPawn_Riggs
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44929 ];

		return pClassPointer;
	};

};

UClass* AYPawn_FakeLugo::pClassPointer = NULL;

// Class SRGame.YPawn_FakeGould
// 0x0000 (0x2708 - 0x2708)
class AYPawn_FakeGould : public AYPawn_Guide
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44932 ];

		return pClassPointer;
	};

};

UClass* AYPawn_FakeGould::pClassPointer = NULL;

// Class SRGame.YPawn_MP_Civilian
// 0x0000 (0x270C - 0x270C)
class AYPawn_MP_Civilian : public AYPawn_Civilian
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44933 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MP_Civilian::pClassPointer = NULL;

// Class SRGame.YPawn_EnemyAssault
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemyAssault : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44934 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemyAssault::pClassPointer = NULL;

// Class SRGame.YPawn_EnemyPistol
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemyPistol : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44935 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemyPistol::pClassPointer = NULL;

// Class SRGame.YPawn_EnemySMG
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemySMG : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44936 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemySMG::pClassPointer = NULL;

// Class SRGame.YPawn_EnemyShotgun
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemyShotgun : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44937 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemyShotgun::pClassPointer = NULL;

// Class SRGame.YPawn_EnemyMachine
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemyMachine : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44938 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemyMachine::pClassPointer = NULL;

// Class SRGame.YPawn_EliteAssault
// 0x0000 (0x2710 - 0x2710)
class AYPawn_EliteAssault : public AYPawn_EnemyElite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44939 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EliteAssault::pClassPointer = NULL;

// Class SRGame.YPawn_EliteShotgun
// 0x0000 (0x2710 - 0x2710)
class AYPawn_EliteShotgun : public AYPawn_EnemyElite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44940 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EliteShotgun::pClassPointer = NULL;

// Class SRGame.YPawn_EliteSMG
// 0x0000 (0x2710 - 0x2710)
class AYPawn_EliteSMG : public AYPawn_EnemyElite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44941 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EliteSMG::pClassPointer = NULL;

// Class SRGame.YPawn_EliteAA12
// 0x0000 (0x2710 - 0x2710)
class AYPawn_EliteAA12 : public AYPawn_EnemyElite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44942 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EliteAA12::pClassPointer = NULL;

// Class SRGame.YPawn_EliteSniper
// 0x0000 (0x2710 - 0x2710)
class AYPawn_EliteSniper : public AYPawn_EnemyElite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44943 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EliteSniper::pClassPointer = NULL;

// Class SRGame.YPawn_CivilianMale
// 0x0000 (0x270C - 0x270C)
class AYPawn_CivilianMale : public AYPawn_Civilian
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44944 ];

		return pClassPointer;
	};

};

UClass* AYPawn_CivilianMale::pClassPointer = NULL;

// Class SRGame.YPawn_CivilianFemale
// 0x0000 (0x270C - 0x270C)
class AYPawn_CivilianFemale : public AYPawn_Civilian
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44945 ];

		return pClassPointer;
	};

};

UClass* AYPawn_CivilianFemale::pClassPointer = NULL;

// Class SRGame.YPawn_CivilianChild
// 0x0000 (0x270C - 0x270C)
class AYPawn_CivilianChild : public AYPawn_Civilian
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44946 ];

		return pClassPointer;
	};

};

UClass* AYPawn_CivilianChild::pClassPointer = NULL;

// Class SRGame.YPawn_EnemyMarauder
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemyMarauder : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44948 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemyMarauder::pClassPointer = NULL;

// Class SRGame.YPawn_MarauderAssault
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MarauderAssault : public AYPawn_EnemyMarauder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44947 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MarauderAssault::pClassPointer = NULL;

// Class SRGame.YPawn_MarauderRifle
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MarauderRifle : public AYPawn_EnemyMarauder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44949 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MarauderRifle::pClassPointer = NULL;

// Class SRGame.YPawn_MarauderShotgun
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MarauderShotgun : public AYPawn_EnemyMarauder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44950 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MarauderShotgun::pClassPointer = NULL;

// Class SRGame.YPawn_MarauderPistol
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MarauderPistol : public AYPawn_EnemyMarauder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44951 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MarauderPistol::pClassPointer = NULL;

// Class SRGame.YPawn_MarauderSMG
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MarauderSMG : public AYPawn_EnemyMarauder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44952 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MarauderSMG::pClassPointer = NULL;

// Class SRGame.YPawn_GuideUnarmed
// 0x0000 (0x2708 - 0x2708)
class AYPawn_GuideUnarmed : public AYPawn_Guide
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44953 ];

		return pClassPointer;
	};

	void InitAnimSystem ( );
};

UClass* AYPawn_GuideUnarmed::pClassPointer = NULL;

// Class SRGame.YPawn_MarauderRPG
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MarauderRPG : public AYPawn_EnemyMarauder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44954 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MarauderRPG::pClassPointer = NULL;

// Class SRGame.YPawn_EnemyRPG
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemyRPG : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44955 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemyRPG::pClassPointer = NULL;

// Class SRGame.YPawn_EliteRPG
// 0x0000 (0x2710 - 0x2710)
class AYPawn_EliteRPG : public AYPawn_EnemyElite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44956 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EliteRPG::pClassPointer = NULL;

// Class SRGame.YPawn_HeavyTrooperMachine
// 0x0000 (0x2728 - 0x2728)
class AYPawn_HeavyTrooperMachine : public AYPawn_HeavyTrooper
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44957 ];

		return pClassPointer;
	};

};

UClass* AYPawn_HeavyTrooperMachine::pClassPointer = NULL;

// Class SRGame.YPawn_HeavyTrooperAA12
// 0x0000 (0x2728 - 0x2728)
class AYPawn_HeavyTrooperAA12 : public AYPawn_HeavyTrooper
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44958 ];

		return pClassPointer;
	};

};

UClass* AYPawn_HeavyTrooperAA12::pClassPointer = NULL;

// Class SRGame.YPawn_EnemyAssaultAK47
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemyAssaultAK47 : public AYPawn_EnemyAssault
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44959 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemyAssaultAK47::pClassPointer = NULL;

// Class SRGame.YPawn_EliteAssaultFamas
// 0x0000 (0x2710 - 0x2710)
class AYPawn_EliteAssaultFamas : public AYPawn_EliteAssault
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44960 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EliteAssaultFamas::pClassPointer = NULL;

// Class SRGame.YPawn_MediumEnemy
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MediumEnemy : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44962 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MediumEnemy::pClassPointer = NULL;

// Class SRGame.YPawn_MediumEnemyAssault
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MediumEnemyAssault : public AYPawn_MediumEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44961 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MediumEnemyAssault::pClassPointer = NULL;

// Class SRGame.YPawn_MediumEnemyAssaultAK47
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MediumEnemyAssaultAK47 : public AYPawn_MediumEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44963 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MediumEnemyAssaultAK47::pClassPointer = NULL;

// Class SRGame.YPawn_MediumEnemySniper
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MediumEnemySniper : public AYPawn_MediumEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44964 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MediumEnemySniper::pClassPointer = NULL;

// Class SRGame.YPawn_MediumEnemyPistol
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MediumEnemyPistol : public AYPawn_MediumEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44965 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MediumEnemyPistol::pClassPointer = NULL;

// Class SRGame.YPawn_MediumEnemySMG
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MediumEnemySMG : public AYPawn_MediumEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44966 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MediumEnemySMG::pClassPointer = NULL;

// Class SRGame.YPawn_MediumEnemyShotgun
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MediumEnemyShotgun : public AYPawn_MediumEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44967 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MediumEnemyShotgun::pClassPointer = NULL;

// Class SRGame.YPawn_MediumEnemyMachine
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MediumEnemyMachine : public AYPawn_MediumEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44968 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MediumEnemyMachine::pClassPointer = NULL;

// Class SRGame.YPawn_MediumEnemyRPG
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MediumEnemyRPG : public AYPawn_MediumEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44969 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MediumEnemyRPG::pClassPointer = NULL;

// Class SRGame.YPawn_EnemyAssaultHK417
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemyAssaultHK417 : public AYPawn_EnemyAssault
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44970 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemyAssaultHK417::pClassPointer = NULL;

// Class SRGame.YPawn_MediumEnemyAssaultHK417
// 0x0000 (0x2708 - 0x2708)
class AYPawn_MediumEnemyAssaultHK417 : public AYPawn_MediumEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44971 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MediumEnemyAssaultHK417::pClassPointer = NULL;

// Class SRGame.YPawn_EliteAssaultHK417
// 0x0000 (0x2710 - 0x2710)
class AYPawn_EliteAssaultHK417 : public AYPawn_EliteAssault
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44972 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EliteAssaultHK417::pClassPointer = NULL;

// Class SRGame.YPawn_EnemyMilkor
// 0x0000 (0x2708 - 0x2708)
class AYPawn_EnemyMilkor : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44973 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EnemyMilkor::pClassPointer = NULL;

// Class SRGame.YPawn_EliteMachine
// 0x0000 (0x2710 - 0x2710)
class AYPawn_EliteMachine : public AYPawn_EnemyElite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44974 ];

		return pClassPointer;
	};

};

UClass* AYPawn_EliteMachine::pClassPointer = NULL;

// Class SRGame.YSeqEvent_PawnRevived
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_PawnRevived : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 45099 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_PawnRevived::pClassPointer = NULL;

// Class SRGame.YWeapon_Launcher
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Launcher : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46205 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Launcher::pClassPointer = NULL;

// Class SRGame.YWeapon_RPG
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_RPG : public AYWeapon_Launcher
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46204 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_RPG::pClassPointer = NULL;

// Class SRGame.YWeapon_Blowtorch
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Blowtorch : public AYWeapon_RPG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46203 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Blowtorch::pClassPointer = NULL;

// Class SRGame.YWeapon_PDA
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_PDA : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46212 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_PDA::pClassPointer = NULL;

// Class SRGame.YTrigger_Interaction
// 0x0000 (0x0204 - 0x0204)
class AYTrigger_Interaction : public ATrigger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46235 ];

		return pClassPointer;
	};

	void StopInteract ( class APawn* InInstigator );
	void StartInteract ( class APawn* InInstigator );
};

UClass* AYTrigger_Interaction::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetInstantDeathAvoidance
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_SetInstantDeathAvoidance : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46512 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetInstantDeathAvoidance::pClassPointer = NULL;

// Class SRGame.YDamageType_Grenade
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Grenade : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46554 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Grenade::pClassPointer = NULL;

// Class SRGame.YDamageType_Fallen
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Fallen : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46577 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Fallen::pClassPointer = NULL;

// Class SRGame.YPawnSoundGroup
// 0x0078 (0x00B4 - 0x003C)
class UYPawnSoundGroup : public UObject
{
public:
	struct FYS_WeaponFlybySoundsProjectile             m_flybySoundsProjectile;                          		// 0x003C (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_WeaponFlybySoundsShotgun                m_flybySoundsShotgun;                             		// 0x0044 (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_DashSoundsBody                          m_dashSoundsBody;                                 		// 0x004C (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_DashSoundsVoice                         m_dashSoundsVoice;                                		// 0x0058 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_SlideIntoCoverSounds                    m_slideIntoCoverSounds;                           		// 0x0064 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_MovementSounds                          m_movementSounds;                                 		// 0x0070 (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_PawnEffortSounds                        m_effortSounds;                                   		// 0x007C (0x000C) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_PawnCoverMovementSounds                 m_coverMovementSounds;                            		// 0x0088 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_DBNOSounds                              m_DBNOSounds;                                     		// 0x0098 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_ZiplineAndRappelSounds                  m_ziplineAndRappelSounds;                         		// 0x009C (0x0008) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	struct FYS_PawnCoverChangeSounds                   m_pawnCoverChangeSounds;                          		// 0x00A4 (0x0010) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46725 ];

		return pClassPointer;
	};

	void PlayLeanOverSound ( class AYGamePawn* GP );
	void PlayLeanAroundSound ( class AYGamePawn* GP );
	void PlayAimOverSound ( class AYGamePawn* GP );
	void PlayAimOutSound ( class AYGamePawn* GP );
	class UYSoundCueFMOD* GetDBNOMoaningSound ( );
	class UYSoundCueFMOD* GetCoverWalkSound ( unsigned long isCrouched );
	class UYSoundCueFMOD* GetLeanOverSound ( );
	class UYSoundCueFMOD* GetLeanSound ( );
	class UYSoundCueFMOD* GetEffortSound ( unsigned char Status );
	class UYSoundCueFMOD* GetZiplineOrRappelSound ( unsigned char moveType );
	void PlayToggleCrouchSound ( class AYGamePawn* GP, unsigned long goingToCrouch );
	void PlayQuickturnSound ( class AYGamePawn* GP );
	class UYSoundCueFMOD* GetSlideIntoCoverSound ( unsigned char dashType );
	void PlayDashIntoCoverSounds ( class AYGamePawn* GP, unsigned char dashType );
	class UYSoundCueFMOD* GetFlyBySound ( unsigned long leftToRight, unsigned long Projectile );
	void PlayLandingSound ( class AYGamePawn* GP, class UPhysicalMaterial* MaterialType, unsigned long isHardLanding );
	void PlayJumpSound ( class AYGamePawn* GP, class UPhysicalMaterial* MaterialType, unsigned long isLongJump );
	class UYSoundCueFMOD* GetFootstepSound ( class UClass* PawnClass, int FootDown, class UPhysicalMaterial* MaterialType, unsigned long IsSprinting, unsigned long isCautious );
};

UClass* UYPawnSoundGroup::pClassPointer = NULL;

// Class SRGame.YSeqAct_GiveHealth
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_GiveHealth : public USequenceAction
{
public:
	float                                              m_value;                                          		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_time;                                           		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_increaseHealthValue : 1;                        		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_increaseHealthMaximum : 1;                      		// 0x00FC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46743 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_GiveHealth::pClassPointer = NULL;

// Class SRGame.YDamageType_TeamChange
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_TeamChange : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46759 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_TeamChange::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetForcedVaporizationType
// 0x0001 (0x00F5 - 0x00F4)
class UYSeqAct_SetForcedVaporizationType : public USequenceAction
{
public:
	unsigned char                                      m_vaporizationType;                               		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46795 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetForcedVaporizationType::pClassPointer = NULL;

// Class SRGame.YDamageType_StickyGrenade
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_StickyGrenade : public UYDamageType_Mine
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46823 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_StickyGrenade::pClassPointer = NULL;

// Class SRGame.YDamageType_Execution
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Execution : public UYDamageType_Melee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46826 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Execution::pClassPointer = NULL;

// Class SRGame.YDamageType_Logout
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Logout : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46846 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Logout::pClassPointer = NULL;

// Class SRGame.YSeqAct_BlendToDeathRagdoll
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_BlendToDeathRagdoll : public USequenceAction
{
public:
	float                                              m_blendTime;                                      		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 47340 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_BlendToDeathRagdoll::pClassPointer = NULL;

// Class SRGame.YSeqAct_OverrideIdleSA
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_OverrideIdleSA : public USequenceAction
{
public:
	class UYSpecialActionSet*                          m_overridingSet;                                  		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_overrideIdleIntervall : 1;                      		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_overrideIdleIntervallMin;                       		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_overrideIdleIntervallMax;                       		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 48468 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_OverrideIdleSA::pClassPointer = NULL;

// Class SRGame.YSeqAct_ClearOverrideIdleSA
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ClearOverrideIdleSA : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 48475 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_ClearOverrideIdleSA::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetAnimationModifier
// 0x0001 (0x00F5 - 0x00F4)
class UYSeqAct_SetAnimationModifier : public USequenceAction
{
public:
	unsigned char                                      m_animModifier;                                   		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 48478 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetAnimationModifier::pClassPointer = NULL;

// Class SRGame.YPawn_Coop
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_Coop : public AYPawn_Multiplayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 48883 ];

		return pClassPointer;
	};

	void ResetZoom ( );
	void LootAmmoFromExecuted ( float grenadeChance );
	bool IsPawnReadyForWeaponInit ( );
	void InitPawnPerk ( );
	bool AdjustHeadShotDamage ( class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, struct FTraceHitInfo HitInfo, int* inDamage, struct FVector* Momentum );
	float GetDamageMultiplier ( class UClass* DamageType );
	void AdjustDamage ( class AController* InstigatedBy, struct FVector HitLocation, class UClass* DamageType, struct FTraceHitInfo HitInfo, int* inDamage, struct FVector* Momentum );
	float GetAccuracyModifier ( );
	bool HurtRadius ( float BaseDamage, float DamageRadius, class UClass* DamageType, float Momentum, struct FVector HurtOrigin, class AActor* IgnoredActor, class AController* InstigatedByController, unsigned long bDoFullDamage );
	float GetExplosiveDamageReductionFactor ( );
	float GetDamageReductionFactor ( );
	void Tick ( float DeltaTime );
	unsigned char DetermineDBNOSubState ( unsigned long bExcludeRagdollDBNO );
	void InitShyfflr ( );
	bool YDied ( class AController* Killer, class UClass* DamageType, struct FVector HitLocation, unsigned char dbnoExitCondition, unsigned long killedByHeadshot, unsigned long makesHeadExplode, float lastTakenDamage, struct FVector Momentum );
	void ReplicatedEvent ( struct FName VarName );
	void SetSkeletalMesh ( class USkeletalMesh* NewMesh );
	void InternalInitHealthSystem ( float healthPercentage );
	void OnSetMaterial ( class USeqAct_SetMaterial* Action );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
};

UClass* AYPawn_Coop::pClassPointer = NULL;

// Class SRGame.YSpecialMove_DropDown
// 0x0038 (0x011C - 0x00E4)
class UYSpecialMove_DropDown : public UYSpecialMoveDestination
{
public:
	float                                              m_dropDownDistanceToCover;                        		// 0x00E4 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FYS_MovementAnimProperties                  m_animProperties;                                 		// 0x00E8 (0x0014) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_rootMotionEndVelocity;                          		// 0x00FC (0x000C) [0x0000000000000000]              
	float                                              m_rootMotionEndVelocityTime;                      		// 0x0108 (0x0004) [0x0000000000000002]              ( CPF_Const )
	unsigned long                                      m_crouchCylinderLocked : 1;                       		// 0x010C (0x0004) [0x0000000000000000] [0x00000001] 
	class UAnimNodeSequence*                           m_currentAnimSequence;                            		// 0x0110 (0x0004) [0x0000000000000000]              
	float                                              m_animCorrectionLengthOffset;                     		// 0x0114 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_relativeCollisionCylinderRadius;                		// 0x0118 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 49109 ];

		return pClassPointer;
	};

	void Hit ( struct FVector HitLocation, struct FVector HitNormal, class AActor* Other, class UPrimitiveComponent* OtherComp );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void CalcAnimStartPosition ( struct FVector coverLocation, struct FRotator coverRotation, float coverHeight, struct FVector* animStartLocation, struct FRotator* animStartRotation );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void OnReachedDestinationInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	void InitAnimProperties ( );
	void Init ( unsigned char specialMove, class AYGamePawn* GamePawn );
};

UClass* UYSpecialMove_DropDown::pClassPointer = NULL;

// Class SRGame.YSeqAct_SpecialMove
// 0x0007 (0x010C - 0x0105)
class UYSeqAct_SpecialMove : public UYSeqAct_Latent
{
public:
	unsigned char                                      m_specialMove;                                    		// 0x0105 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_movementDirection;                              		// 0x0106 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UObject*                                     m_instigator;                                     		// 0x0108 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 49151 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void OnInputImpulse ( int inputLinkIndex );
};

UClass* UYSeqAct_SpecialMove::pClassPointer = NULL;

// Class SRGame.YSeqAct_StopCustomAnimation
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_StopCustomAnimation : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 49211 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_StopCustomAnimation::pClassPointer = NULL;

// Class SRGame.YSeqAct_DeathAnimation
// 0x00D3 (0x01D8 - 0x0105)
class UYSeqAct_DeathAnimation : public UYSeqAct_Latent
{
public:
	struct FName                                       m_animName;                                       		// 0x0108 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UAnimSet*                                    m_animSet;                                        		// 0x0110 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FYS_FaceFXAnim                              m_faceFXAnim;                                     		// 0x0114 (0x001C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	struct FVector                                     m_startLocationOffset;                            		// 0x0130 (0x000C) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FRotator                                    m_startRotationOffset;                            		// 0x013C (0x000C) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FVector2D                                   m_relativeCollisionCylinderSize;                  		// 0x0148 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	struct FYS_CustomAnimationTemplate                 m_customAnimationTemplate;                        		// 0x0150 (0x007C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	float                                              m_physicsBlendTime;                               		// 0x01CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_physicsBlendStartTime;                          		// 0x01D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_wantsStumbleCheck : 1;                          		// 0x01D4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 49251 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	class AActor* GetAlignToActor ( );
	void GetStartPositionOffset ( struct FVector* startLocationOffet, struct FRotator* startRotationOffset );
	struct FYS_CustomAnimationParameters GetAnimParameters ( );
	void GetAnimInfo ( struct FYS_AnimInfo* AnimInfo, class UAnimSet** AnimSet );
	void OnInputImpulse ( int inputLinkIndex );
};

UClass* UYSeqAct_DeathAnimation::pClassPointer = NULL;

// Class SRGame.YSpecialMove_DeathAnimation
// 0x0030 (0x00E8 - 0x00B8)
class UYSpecialMove_DeathAnimation : public UYSpecialMove
{
public:
	struct FYS_AnimID                                  m_animID;                                         		// 0x00B8 (0x0004) [0x0000000000000000]              
	class UYSeqAct_DeathAnimation*                     m_deathAnimationAction;                           		// 0x00BC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_animStartLocation;                              		// 0x00C0 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_animStartRotation;                              		// 0x00CC (0x000C) [0x0000000000000000]              
	unsigned long                                      m_interpolateToLocation : 1;                      		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_interpolateToRotation : 1;                      		// 0x00D8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_wantsStumbleCheck : 1;                          		// 0x00D8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_isStumbled : 1;                                 		// 0x00D8 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	float                                              m_locationInterpSpeed;                            		// 0x00DC (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_rotationInterpSpeed;                            		// 0x00E0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UAnimNodeSequence*                           m_animSequenceNode;                               		// 0x00E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 49254 ];

		return pClassPointer;
	};

	class UYSeqAct_DeathAnimation* GetSequenceAction ( );
	void TickSpecialMove ( float DeltaTime );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_DeathAnimation::pClassPointer = NULL;

// Class SRGame.YSpecialMove_Quickturn
// 0x0004 (0x00F8 - 0x00F4)
class UYSpecialMove_Quickturn : public UYSpecialMove_StartSprint
{
public:
	unsigned char                                      m_backAnimCrcLeft;                                		// 0x00F4 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_backAnimCrcRight;                               		// 0x00F5 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_backAnimStdLeft;                                		// 0x00F6 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_backAnimStdRight;                               		// 0x00F7 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 49315 ];

		return pClassPointer;
	};

	bool OnStopSpecialMoveInternal ( );
	struct FYS_AnimID GetAnimID ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_Quickturn::pClassPointer = NULL;

// Class SRGame.YSeqAct_ForceCrosshair
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ForceCrosshair : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 49707 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ForceCrosshair::pClassPointer = NULL;

// Class SRGame.YSpecialMove_PlayMeleeAttack
// 0x002C (0x0110 - 0x00E4)
class UYSpecialMove_PlayMeleeAttack : public UYSpecialMoveDestination
{
public:
	TArray< unsigned char >                            m_meleeAttackAnimSetsIdle;                        		// 0x00E4 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_meleeAttackAnimSetsUpperBody;                   		// 0x00F0 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	int                                                m_lastPlayedVariation;                            		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_usedAnimVariation;                              		// 0x0100 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_checkIdleCancel : 1;                            		// 0x0104 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_interpolationRunning : 1;                       		// 0x0104 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_interpolationDone : 1;                          		// 0x0104 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_meleeCamFocusActive : 1;                        		// 0x0104 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	float                                              m_interpolationTime;                              		// 0x0108 (0x0004) [0x0000000000000000]              
	class AYPlayerController*                          m_cachedPlayerController;                         		// 0x010C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 49968 ];

		return pClassPointer;
	};

	struct FYS_AnimID GetAnimID ( int variation, unsigned long wantsIdleAnim );
	void TickSpecialMove ( float DeltaTime );
	void EnableControls ( unsigned long Enable );
	struct FVector GetBestAttackPos ( struct FVector dirToPawn, class AYGamePawn* meleeTarget );
	void InterpolationFinished ( unsigned long finished );
	void StartInterpolation ( );
	void OnReachedDestinationInternal ( );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	int GetPlaybackVariation ( );
};

UClass* UYSpecialMove_PlayMeleeAttack::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetSpecialActionSetList
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetSpecialActionSetList : public USequenceAction
{
public:
	class UYSpecialActionSetList*                      m_saSetList;                                      		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 50184 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetSpecialActionSetList::pClassPointer = NULL;

// Class SRGame.YSeqEvent_EnemyContact
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_EnemyContact : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 50521 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_EnemyContact::pClassPointer = NULL;

// Class SRGame.YSeqAct_TakeDown
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_TakeDown : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 50579 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_TakeDown::pClassPointer = NULL;

// Class SRGame.YDamageType_DeathDBNOKill
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_DeathDBNOKill : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 50757 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_DeathDBNOKill::pClassPointer = NULL;

// Class SRGame.YSeqEvent_PawnDown
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_PawnDown : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 50779 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_PawnDown::pClassPointer = NULL;

// Class SRGame.YPawnVFXGroup
// 0x0000 (0x003C - 0x003C)
class UYPawnVFXGroup : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 50817 ];

		return pClassPointer;
	};

	class UParticleSystem* GetLandingParticleEffect ( class UClass* PawnClass, class UPhysicalMaterial* matName, unsigned long isHardLanding );
	class UMaterialInstance* GetLandingDecalMaterial ( class UClass* PawnClass, class UPhysicalMaterial* matName, unsigned long isHardLanding );
	void DoVisualLandingFeedback ( class AYGamePawn* GP, class UPhysicalMaterial* matName, unsigned long isHardLanding );
	class UParticleSystem* GetJumpParticleEffect ( class UClass* PawnClass, class UPhysicalMaterial* matName, unsigned long isLongJump );
	class UMaterialInstance* GetJumpDecalMaterial ( class UClass* PawnClass, class UPhysicalMaterial* matName, unsigned long isLongJump );
	void DoVisualJumpFeedback ( class AYGamePawn* GP, class UPhysicalMaterial* matName, unsigned long isLongJump );
	class UParticleSystem* GetFootstepParticleEffect ( class UClass* PawnClass, class UPhysicalMaterial* matName, unsigned long IsSprinting, unsigned long isCautious );
	class UMaterialInstance* GetFootstepDecalMaterial ( class UClass* PawnClass, class UPhysicalMaterial* matName, unsigned long IsSprinting, unsigned long isCautious, int FootDown );
	void DoVisualFootStepFeedback ( class AYGamePawn* GP, int FootDown, class UPhysicalMaterial* footMat, struct FVector Loc, struct FVector footDir, unsigned long IsSprinting, unsigned long isCautious );
	void DoVisualFeedback ( class AYGamePawn* GP, class UMaterialInstance* Mat, class UParticleSystem* ps, struct FVector Loc, struct FVector footDir, float testDistUp, float testDistDown, int FootDown );
	class UPhysicalMaterial* GetMaterialBelowPawn ( class AYGamePawn* GP );
};

UClass* UYPawnVFXGroup::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetNPCCategory
// 0x0001 (0x00F5 - 0x00F4)
class UYSeqAct_SetNPCCategory : public USequenceAction
{
public:
	unsigned char                                      m_NPCCategory;                                    		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51135 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetNPCCategory::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleDBNO
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_ToggleDBNO : public USequenceAction
{
public:
	unsigned long                                      m_DBNOIsEnabled : 1;                              		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51139 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ToggleDBNO::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleDeathDBNO
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleDeathDBNO : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51143 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ToggleDeathDBNO::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleDemigod
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleDemigod : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51146 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ToggleDemigod::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleSuppressGenericVoiceOver
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleSuppressGenericVoiceOver : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51156 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ToggleSuppressGenericVoiceOver::pClassPointer = NULL;

// Class SRGame.YAnimNotify_Interpolate
// 0x000C (0x004C - 0x0040)
class UYAnimNotify_Interpolate : public UAnimNotify_Scripted
{
public:
	unsigned long                                      m_interpolateLocation : 1;                        		// 0x0040 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_interpolateRotation : 1;                        		// 0x0040 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_changeRootMotion : 1;                           		// 0x0040 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_disableRootMotionRotation : 1;                  		// 0x0040 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_clearAllInterpolationWhenTriggered : 1;         		// 0x0040 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned char                                      m_interpolationTime;                              		// 0x0044 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_changeRootMotionMode;                           		// 0x0045 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_interpolationTimeCustom;                        		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51208 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_Interpolate::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetPawnSpeeds
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_SetPawnSpeeds : public USequenceAction
{
public:
	unsigned long                                      m_changeMovementSpeed : 1;                        		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_changeCoverSpeed : 1;                           		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	float                                              m_changeMovementSpeedMultiplier;                  		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_changeCoverSpeedMultiplier;                     		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51226 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetPawnSpeeds::pClassPointer = NULL;

// Class SRGame.YSeqAct_HideLoadingMovie
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_HideLoadingMovie : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51304 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_HideLoadingMovie::pClassPointer = NULL;

// Class SRGame.YArmable
// 0x0000 (0x003C - 0x003C)
class UYArmable : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51909 ];

		return pClassPointer;
	};

};

UClass* UYArmable::pClassPointer = NULL;

// Class SRGame.YPlayerCamDP_PlayerPawn4
// 0x0000 (0x0060 - 0x0060)
class UYPlayerCamDP_PlayerPawn4 : public UYPlayerCamDataProvider
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51918 ];

		return pClassPointer;
	};

	int GetNumBaseOffsets ( );
	struct FVector GetBaseOffset ( int Index );
	int GetSideChangeTransitionIndex ( );
	int GetInitTransitionIndex ( );
	int GetDefaultTransitionIndex ( );
	class UYPlayerCamTransition* GetCamTransition ( int Index );
	int GetNumCamTransitions ( );
	int GetDefaultCamModeIndex ( );
	int GetAnyCamModeIndex ( );
	class UYPlayerCamMode* GetCamMode ( int Index );
	int GetNumCamModes ( );
};

UClass* UYPlayerCamDP_PlayerPawn4::pClassPointer = NULL;

// Class SRGame.YAnimInfoPosture
// 0x0000 (0x44C4 - 0x44C4)
class UYAnimInfoPosture : public UYAnimInfoSpecialIdle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51922 ];

		return pClassPointer;
	};

};

UClass* UYAnimInfoPosture::pClassPointer = NULL;

// Class SRGame.YAnimInfoTransition
// 0x0000 (0x44C4 - 0x44C4)
class UYAnimInfoTransition : public UYAnimInfoPosture
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51921 ];

		return pClassPointer;
	};

};

UClass* UYAnimInfoTransition::pClassPointer = NULL;

// Class SRGame.YAnimInfoHuman
// 0x0000 (0x44C4 - 0x44C4)
class UYAnimInfoHuman : public UYAnimInfoTransition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51920 ];

		return pClassPointer;
	};

};

UClass* UYAnimInfoHuman::pClassPointer = NULL;

// Class SRGame.YAnimInfoInfantry
// 0x0000 (0x44C4 - 0x44C4)
class UYAnimInfoInfantry : public UYAnimInfoHuman
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51919 ];

		return pClassPointer;
	};

};

UClass* UYAnimInfoInfantry::pClassPointer = NULL;

// Class SRGame.YSpecialMove_CoverMantle
// 0x0000 (0x0214 - 0x0214)
class UYSpecialMove_CoverMantle : public UYSpecialMove_CoverVault
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51927 ];

		return pClassPointer;
	};

	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_CoverMantle::pClassPointer = NULL;

// Class SRGame.YSpecialMove_CoverVaultRun
// 0x0000 (0x0214 - 0x0214)
class UYSpecialMove_CoverVaultRun : public UYSpecialMove_CoverVault
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51928 ];

		return pClassPointer;
	};

	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_CoverVaultRun::pClassPointer = NULL;

// Class SRGame.YSpecialMove_CoverVaultAuto
// 0x0000 (0x0214 - 0x0214)
class UYSpecialMove_CoverVaultAuto : public UYSpecialMove_CoverVaultRun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51929 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_CoverVaultAuto::pClassPointer = NULL;

// Class SRGame.YSpecialMove_MeleeAttack
// 0x0000 (0x00C4 - 0x00C4)
class UYSpecialMove_MeleeAttack : public UYSpecialMove_MeleeAttackBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51930 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_MeleeAttack::pClassPointer = NULL;

// Class SRGame.YSpecialMove_SlipOut
// 0x002C (0x00E4 - 0x00B8)
class UYSpecialMove_SlipOut : public UYSpecialMove
{
public:
	struct FYS_AnimID                                  m_slipOutAnim;                                    		// 0x00B8 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_slipOutAnimDir;                                 		// 0x00BC (0x0001) [0x0000000000000000]              
	unsigned char                                      m_slipOutDirection;                               		// 0x00BD (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_animIDs[ 0x2 ];                                 		// 0x00BE (0x0002) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_relativeCollisionCylinderSize;                  		// 0x00C0 (0x0008) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_rotateToTargetDirectionPct;                     		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_currentRotateToTargetDirectionPct;              		// 0x00CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeSequence*                           m_currentAnimSequence;                            		// 0x00D0 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_adjustingRotation : 1;                          		// 0x00D4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_collisionCylinderIsShrinked : 1;                		// 0x00D4 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_doMeleeAttack : 1;                              		// 0x00D4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_meleeAttackStarted : 1;                         		// 0x00D4 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	float                                              m_timeSinceStart;                                 		// 0x00D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_collisionCylinderResetTime;                     		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_doMeleeAttackDelayPct;                          		// 0x00E0 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51932 ];

		return pClassPointer;
	};

	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	struct FYS_AnimID GetMeleeAnimID ( );
	struct FYS_AnimID GetAnimationFromSpecialMoveData ( struct FYS_SpecialMoveData* Data, struct FYS_PawnState* pawnState, float* rotateToTargetDirectionPct );
	void LeaveCover ( );
	void TickSpecialMove ( float DeltaTime );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	void StartSprint ( );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_SlipOut::pClassPointer = NULL;

// Class SRGame.YSpecialMove_SlipOutFront
// 0x0000 (0x00E4 - 0x00E4)
class UYSpecialMove_SlipOutFront : public UYSpecialMove_SlipOut
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51931 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
};

UClass* UYSpecialMove_SlipOutFront::pClassPointer = NULL;

// Class SRGame.YSpecialMove_SlipOutSide
// 0x000C (0x00F0 - 0x00E4)
class UYSpecialMove_SlipOutSide : public UYSpecialMove_SlipOut
{
public:
	unsigned char                                      m_animIDsPeek[ 0x2 ];                             		// 0x00E4 (0x0002) [0x0000000000000000]              
	unsigned char                                      m_animIDsStepOut[ 0x2 ];                          		// 0x00E6 (0x0002) [0x0000000000000000]              
	float                                              m_rotateToTargetDirectionPctPeek;                 		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_rotateToTargetDirectionPctStepOut;              		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51933 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	struct FYS_AnimID GetAnimationFromSpecialMoveData ( struct FYS_SpecialMoveData* Data, struct FYS_PawnState* pawnState, float* rotateToTargetDirectionPct );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_SlipOutSide::pClassPointer = NULL;

// Class SRGame.YSpecialMove_SlipOutAlong
// 0x0000 (0x00E4 - 0x00E4)
class UYSpecialMove_SlipOutAlong : public UYSpecialMove_SlipOut
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51934 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
};

UClass* UYSpecialMove_SlipOutAlong::pClassPointer = NULL;

// Class SRGame.YSpecialMove_SlipOutAway
// 0x0000 (0x00E4 - 0x00E4)
class UYSpecialMove_SlipOutAway : public UYSpecialMove_SlipOut
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51935 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
};

UClass* UYSpecialMove_SlipOutAway::pClassPointer = NULL;

// Class SRGame.YSpecialMove_SlipOutAround
// 0x0000 (0x00E4 - 0x00E4)
class UYSpecialMove_SlipOutAround : public UYSpecialMove_SlipOut
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51936 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_SlipOutAround::pClassPointer = NULL;

// Class SRGame.YSpecialMove_DashIntoCoverSprint
// 0x0000 (0x0150 - 0x0150)
class UYSpecialMove_DashIntoCoverSprint : public UYSpecialMove_IntoCover
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51937 ];

		return pClassPointer;
	};

	bool OnStopSpecialMoveInternal ( );
};

UClass* UYSpecialMove_DashIntoCoverSprint::pClassPointer = NULL;

// Class SRGame.YSpecialMove_DashIntoCoverRun
// 0x0000 (0x0150 - 0x0150)
class UYSpecialMove_DashIntoCoverRun : public UYSpecialMove_IntoCover
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51938 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_DashIntoCoverRun::pClassPointer = NULL;

// Class SRGame.YSpecialMove_DashIntoCoverWalk
// 0x0000 (0x0150 - 0x0150)
class UYSpecialMove_DashIntoCoverWalk : public UYSpecialMove_IntoCover
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51939 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_DashIntoCoverWalk::pClassPointer = NULL;

// Class SRGame.YSpecialMove_IntoCoverSnap
// 0x0000 (0x0150 - 0x0150)
class UYSpecialMove_IntoCoverSnap : public UYSpecialMove_IntoCover
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51940 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_IntoCoverSnap::pClassPointer = NULL;

// Class SRGame.YSpecialMove_LeaveCover
// 0x0010 (0x00C8 - 0x00B8)
class UYSpecialMove_LeaveCover : public UYSpecialMove
{
public:
	struct FYS_AnimID                                  m_currentAnimID;                                  		// 0x00B8 (0x0004) [0x0000000000000000]              
	TArray< struct FYS_LeaveCoverTransition >          m_leaveCoverTransitions;                          		// 0x00BC (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51942 ];

		return pClassPointer;
	};

	unsigned char GetAIMovementDirection ( unsigned char Dir );
	struct FYS_AnimID GetAnimIDInternal ( unsigned char coverStance, unsigned long mirrored, unsigned char moveDir, unsigned long Crouched );
	struct FYS_AnimID GetAnimID ( struct FYS_SpecialMoveData* Data );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_LeaveCover::pClassPointer = NULL;

// Class SRGame.YSpecialMove_LeaveCoverCenter
// 0x0000 (0x00C8 - 0x00C8)
class UYSpecialMove_LeaveCoverCenter : public UYSpecialMove_LeaveCover
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51941 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_LeaveCoverCenter::pClassPointer = NULL;

// Class SRGame.YSpecialMove_LeaveCoverEdge
// 0x0000 (0x00C8 - 0x00C8)
class UYSpecialMove_LeaveCoverEdge : public UYSpecialMove_LeaveCoverCenter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51943 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_LeaveCoverEdge::pClassPointer = NULL;

// Class SRGame.YSpecialMove_BeingRevived
// 0x0028 (0x010C - 0x00E4)
class UYSpecialMove_BeingRevived : public UYSpecialMoveDestination
{
public:
	TArray< struct FYS_ReviveReactionAnimSet >         m_reactionAnimSets;                               		// 0x00E4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_variationIndex;                                 		// 0x00F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYGamePawn*                                  m_healer;                                         		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_AnimSet                                 m_currentAnimSet;                                 		// 0x00F8 (0x0014) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51944 ];

		return pClassPointer;
	};

	void PlayAnimation ( float animSpeed );
	struct FYS_AnimID GetAnimID ( );
	void OnCancelSpecialMoveInternal ( );
	void TickSpecialMove ( float DeltaTime );
	bool OnStopSpecialMoveInternal ( );
	void OnReachedDestinationInternal ( );
	void PlayIntoAnimation ( );
	void HandleRagdollState ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	void StartBeingRevived ( float animSpeed );
};

UClass* UYSpecialMove_BeingRevived::pClassPointer = NULL;

// Class SRGame.YSpecialMove_IntelOpStop
// 0x0000 (0x00B8 - 0x00B8)
class UYSpecialMove_IntelOpStop : public UYSpecialMove
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51946 ];

		return pClassPointer;
	};

	void StopIntelOp ( class UYSpecialMove_IntelOp* intelOpSpecialMove );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_IntelOpStop::pClassPointer = NULL;

// Class SRGame.YSpecialMove_IntelOpStopSucceeded
// 0x0000 (0x00B8 - 0x00B8)
class UYSpecialMove_IntelOpStopSucceeded : public UYSpecialMove_IntelOpStop
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51945 ];

		return pClassPointer;
	};

	void StopIntelOp ( class UYSpecialMove_IntelOp* intelOpSpecialMove );
};

UClass* UYSpecialMove_IntelOpStopSucceeded::pClassPointer = NULL;

// Class SRGame.YSpecialMove_IntelOpStopFailed
// 0x0000 (0x00B8 - 0x00B8)
class UYSpecialMove_IntelOpStopFailed : public UYSpecialMove_IntelOpStop
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51947 ];

		return pClassPointer;
	};

	void StopIntelOp ( class UYSpecialMove_IntelOp* intelOpSpecialMove );
};

UClass* UYSpecialMove_IntelOpStopFailed::pClassPointer = NULL;

// Class SRGame.YSpecialMove_PickUp
// 0x0000 (0x00E4 - 0x00E4)
class UYSpecialMove_PickUp : public UYSpecialMoveDestination
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51949 ];

		return pClassPointer;
	};

	bool FreePickup ( );
	bool AllocatePickup ( );
};

UClass* UYSpecialMove_PickUp::pClassPointer = NULL;

// Class SRGame.YSpecialMove_PickUpWeapon
// 0x001D (0x0101 - 0x00E4)
class UYSpecialMove_PickUpWeapon : public UYSpecialMove_PickUp
{
public:
	struct UYSpecialMove_PickUpWeapon_FYS_PickUpWeaponAnimation m_animations[ 0x2 ];                              		// 0x00E4 (0x0018) [0x0000000000000000]              
	struct FYS_AnimID                                  m_currentAnimID;                                  		// 0x00FC (0x0004) [0x0000000000000000]              
	unsigned char                                      m_weaponPickedUp;                                 		// 0x0100 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51948 ];

		return pClassPointer;
	};

	struct FYS_AnimID GetAnimID ( unsigned long Crouched, float* pickUpDelay );
	void PickUpWeapon ( );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	void Init ( unsigned char specialMove, class AYGamePawn* GamePawn );
};

UClass* UYSpecialMove_PickUpWeapon::pClassPointer = NULL;

// Class SRGame.YSpecialMove_PickUpWeaponFromRack
// 0x0073 (0x0174 - 0x0101)
class UYSpecialMove_PickUpWeaponFromRack : public UYSpecialMove_PickUpWeapon
{
public:
	struct FVector                                     m_startLocation;                                  		// 0x0104 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_startRotation;                                  		// 0x0110 (0x000C) [0x0000000000000000]              
	class AYPickup_Weapon*                             m_weaponPickup;                                   		// 0x011C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_offset;                                         		// 0x0120 (0x000C) [0x0000000000000000]              
	struct FYS_SpecialMoveData                         m_data;                                           		// 0x012C (0x0044) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_forceSpecialMove : 1;                           		// 0x0170 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51950 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void OnReachedDestinationInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_PickUpWeaponFromRack::pClassPointer = NULL;

// Class SRGame.YSpecialMove_PickUpFromCrate
// 0x0077 (0x0178 - 0x0101)
class UYSpecialMove_PickUpFromCrate : public UYSpecialMove_PickUpWeapon
{
public:
	struct FVector                                     m_startLocation;                                  		// 0x0104 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_startRotation;                                  		// 0x0110 (0x000C) [0x0000000000000000]              
	class AActor*                                      m_ammoCrate;                                      		// 0x011C (0x0004) [0x0000000000000000]              
	class AYPickup_AmmoCrate*                          m_ammoCratePickup;                                		// 0x0120 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_offset;                                         		// 0x0124 (0x000C) [0x0000000000000000]              
	struct FYS_SpecialMoveData                         m_data;                                           		// 0x0130 (0x0044) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_forceSpecialMove : 1;                           		// 0x0174 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51951 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	bool OnStopSpecialMoveInternal ( );
	void OnReachedDestinationInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_PickUpFromCrate::pClassPointer = NULL;

// Class SRGame.YSpecialMove_PickUpFromBox
// 0x0000 (0x0101 - 0x0101)
class UYSpecialMove_PickUpFromBox : public UYSpecialMove_PickUpWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51952 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
};

UClass* UYSpecialMove_PickUpFromBox::pClassPointer = NULL;

// Class SRGame.YSpecialMove_StartSprintFromWalk
// 0x0000 (0x00F4 - 0x00F4)
class UYSpecialMove_StartSprintFromWalk : public UYSpecialMove_StartSprint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51953 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_StartSprintFromWalk::pClassPointer = NULL;

// Class SRGame.YSpecialMove_StartSprintFromRun
// 0x0000 (0x00F4 - 0x00F4)
class UYSpecialMove_StartSprintFromRun : public UYSpecialMove_StartSprint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51954 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_StartSprintFromRun::pClassPointer = NULL;

// Class SRGame.YSpecialMove_FastRopePrepare
// 0x0008 (0x0124 - 0x011C)
class UYSpecialMove_FastRopePrepare : public UYSpecialMove_FastRope
{
public:
	unsigned char                                      m_animID;                                         		// 0x011C (0x0001) [0x0000000000000000]              
	unsigned long                                      m_resetPhysicsMode : 1;                           		// 0x0120 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51955 ];

		return pClassPointer;
	};

	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void AnimationEnded ( );
	void PlayAnimation ( );
	void OnReachedDestinationInternal ( );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_FastRopePrepare::pClassPointer = NULL;

// Class SRGame.YSpecialMove_FastRopeRappel
// 0x00A8 (0x01C4 - 0x011C)
class UYSpecialMove_FastRopeRappel : public UYSpecialMove_FastRope
{
public:
	struct FYS_MiscAnimProperties                      m_animProperties[ 0x4 ];                          		// 0x011C (0x0050) [0x0000000000000000]              
	unsigned long                                      m_animPropertiesInitialized : 1;                  		// 0x016C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_resetPhysicsMode : 1;                           		// 0x016C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_networkPositionCorrectionPrevented : 1;         		// 0x016C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_ropeIsGrabbed : 1;                              		// 0x016C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_ropeIsGrabbedFeet : 1;                          		// 0x016C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_ropeIsReleasedFeet : 1;                         		// 0x016C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_dropKickEnabled : 1;                            		// 0x016C (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_drawKickRadius : 1;                             		// 0x016C (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_hasBeenStopped : 1;                             		// 0x016C (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	struct FVector                                     m_endLocation;                                    		// 0x0170 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_endRotation;                                    		// 0x017C (0x000C) [0x0000000000000000]              
	unsigned char                                      m_currentAnimState;                               		// 0x0188 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_currentCamState;                                		// 0x0189 (0x0001) [0x0000000000000000]              
	int                                                m_idleCamMode;                                    		// 0x018C (0x0004) [0x0000000000000000]              
	int                                                m_endCamMode;                                     		// 0x0190 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_handsOffset;                                    		// 0x0194 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_feetOffset;                                     		// 0x01A0 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_SpecialMoveDetectionParams              m_dropKickDetectionParams;                        		// 0x01AC (0x0018) [0x0000000000004001]              ( CPF_Edit | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51956 ];

		return pClassPointer;
	};

	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void HandleEnableCollision ( );
	void HandleGroundReached ( );
	void HandleRopeReleasedFeet ( );
	void HandleRopeReleased ( );
	void HandleRopeGrabbedFeet ( );
	void HandleRopeGrabbed ( );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	struct FVector GetFixedViewTargetRotation ( );
	bool IsGroundTargetReached ( struct FVector endAnimRootMotion, float rootMotionFactor, float* heightDiff );
	void OnEndAnimationEnded ( );
	bool CanPlaySpecialMoveDeathAnimation ( );
	void PlayEndAnimation ( );
	void PlayRappelAnimation ( );
	void OnBeginAnimationEnded ( );
	void TickSpecialMove ( float DeltaTime );
	void PlayBeginAnimation ( );
	void WaitForBeginAnimation ( );
	void PlayHolsterAnimation ( );
	bool ResetPhysics ( );
	void OnReachedDestinationInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void OnCancelSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	void InitSpecialAnimSetProperties ( );
};

UClass* UYSpecialMove_FastRopeRappel::pClassPointer = NULL;

// Class SRGame.YSpecialMove_FastRopeRappelStraight
// 0x0034 (0x01F8 - 0x01C4)
class UYSpecialMove_FastRopeRappelStraight : public UYSpecialMove_FastRopeRappel
{
public:
	float                                              m_rappelingTime;                                  		// 0x01C4 (0x0004) [0x0000000000000000]              
	float                                              m_distPerSecond;                                  		// 0x01C8 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_rappelingStartLocation;                         		// 0x01CC (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rappelingStartRotation;                         		// 0x01D8 (0x000C) [0x0000000000000000]              
	float                                              m_startSpeed;                                     		// 0x01E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_endSpeed;                                       		// 0x01E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_expSpeed;                                       		// 0x01EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxYawRot;                                      		// 0x01F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_loopSoundPlaying : 1;                           		// 0x01F4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51957 ];

		return pClassPointer;
	};

	bool OnStopSpecialMoveInternal ( );
	void PlayEndAnimation ( );
	void TickSpecialMove ( float DeltaTime );
	void EndFastRopeSound ( );
	void StartFastRopeSound ( );
	void PlayRappelAnimation ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_FastRopeRappelStraight::pClassPointer = NULL;

// Class SRGame.YSpecialMove_FastRopeRappelStraightNoTurn
// 0x0000 (0x01F8 - 0x01F8)
class UYSpecialMove_FastRopeRappelStraightNoTurn : public UYSpecialMove_FastRopeRappelStraight
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51958 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_FastRopeRappelStraightNoTurn::pClassPointer = NULL;

// Class SRGame.YSpecialMove_TakeHumanShield
// 0x0004 (0x00C8 - 0x00C4)
class UYSpecialMove_TakeHumanShield : public UYSpecialMove_MeleeAttackBase
{
public:
	float                                              m_humanShieldStartDistance;                       		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51959 ];

		return pClassPointer;
	};

	struct FVector GetBestAttackPos ( struct FVector dirToPawn, class AYGamePawn* meleeTarget );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void EnableHumanShieldCaptorPhysics ( );
	void OnTakenHumanShield ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_TakeHumanShield::pClassPointer = NULL;

// Class SRGame.YSpecialMove_TakenAsHumanShield
// 0x000C (0x00F0 - 0x00E4)
class UYSpecialMove_TakenAsHumanShield : public UYSpecialMoveDestination
{
public:
	class AYGamePawn*                                  m_captor;                                         		// 0x00E4 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_takenAnimID;                                    		// 0x00E8 (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_captiveAnimID;                                  		// 0x00E9 (0x0001) [0x0000000000000002]              ( CPF_Const )
	struct FYS_AnimID                                  m_playingAnimID;                                  		// 0x00EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51960 ];

		return pClassPointer;
	};

	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	void OnCancelSpecialMoveInternal ( );
	void EnableHumanShieldPhysics ( );
	bool OnStopSpecialMoveInternal ( );
	bool IsInAttackRange ( );
	void FinishedTakenAnim ( );
	void OnReachedDestinationInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool PlayCaptivePose ( );
};

UClass* UYSpecialMove_TakenAsHumanShield::pClassPointer = NULL;

// Class SRGame.YSpecialMove_ReleaseHumanShield
// 0x0001 (0x00B9 - 0x00B8)
class UYSpecialMove_ReleaseHumanShield : public UYSpecialMove
{
public:
	unsigned char                                      m_releaseAnimID;                                  		// 0x00B8 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51961 ];

		return pClassPointer;
	};

	void OnCancelSpecialMoveInternal ( );
	void DisableHumanShieldCaptorPhysics ( );
	bool OnStopSpecialMoveInternal ( );
	bool PlayReleaseAnim ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	struct FYS_AnimID GetAnimID ( );
};

UClass* UYSpecialMove_ReleaseHumanShield::pClassPointer = NULL;

// Class SRGame.YSpecialMove_ReleasedFromHumanShield
// 0x0010 (0x00C8 - 0x00B8)
class UYSpecialMove_ReleasedFromHumanShield : public UYSpecialMove
{
public:
	unsigned char                                      m_animIDFlee;                                     		// 0x00B8 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_animIDKilled;                                   		// 0x00B9 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_killed : 1;                                     		// 0x00BC (0x0004) [0x0000000000000000] [0x00000001] 
	class AYGamePawn*                                  m_captor;                                         		// 0x00C0 (0x0004) [0x0000000000000000]              
	struct FYS_AnimID                                  m_animID;                                         		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51962 ];

		return pClassPointer;
	};

	void TickSpecialMove ( float DeltaTime );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool PlayStumbleAnim ( );
	void DisableHumanShieldPhysics ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	struct FYS_AnimID GetAnimID ( );
};

UClass* UYSpecialMove_ReleasedFromHumanShield::pClassPointer = NULL;

// Class SRGame.YSpecialMove_RecoverFromRagdoll
// 0x0014 (0x00CC - 0x00B8)
class UYSpecialMove_RecoverFromRagdoll : public UYSpecialMove
{
public:
	float                                              m_blendTimeToGo;                                  		// 0x00B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_animIDs[ 0x6 ];                                 		// 0x00BC (0x0006) [0x0000000000000000]              
	unsigned char                                      m_getUpAnimID;                                    		// 0x00C2 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_playing : 1;                                    		// 0x00C4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_normalSpeedActive : 1;                          		// 0x00C4 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	float                                              m_animTimeToGo;                                   		// 0x00C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51963 ];

		return pClassPointer;
	};

	void PickRecoverAnim ( unsigned long getupFromBack, struct FRotator* NewRotation );
	void SetupRotationAndAnimation ( );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	void OnFinishedRecoverAnim ( );
	void StartNormalPlayback ( );
	void TickSpecialMove ( float DeltaTime );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_RecoverFromRagdoll::pClassPointer = NULL;

// Class SRGame.YSpecialMove_RecoverFromRagdollToAnimDBNO
// 0x0009 (0x00D5 - 0x00CC)
class UYSpecialMove_RecoverFromRagdollToAnimDBNO : public UYSpecialMove_RecoverFromRagdoll
{
public:
	float                                              m_idleStartTime;                                  		// 0x00CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_isInIdlePhase : 1;                              		// 0x00D0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_onFinishedRecoverAnimWasCalled : 1;             		// 0x00D0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned char                                      m_currentAnim;                                    		// 0x00D4 (0x0001) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51964 ];

		return pClassPointer;
	};

	void PickRecoverAnim ( unsigned long getupFromBack, struct FRotator* NewRotation );
	bool OnStopSpecialMoveInternal ( );
	void StartGetupAnim ( );
	void OnFinishedRecoverAnim ( );
	void OnCancelSpecialMoveInternal ( );
	void TickSpecialMove ( float DeltaTime );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_RecoverFromRagdollToAnimDBNO::pClassPointer = NULL;

// Class SRGame.YSpecialMove_RecoverFromRagdollToDeathDBNO
// 0x0010 (0x00C8 - 0x00B8)
class UYSpecialMove_RecoverFromRagdollToDeathDBNO : public UYSpecialMove
{
public:
	float                                              m_blendTimeToGo;                                  		// 0x00B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_getupFromBack : 1;                              		// 0x00BC (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_playing : 1;                                    		// 0x00BC (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_normalSpeedActive : 1;                          		// 0x00BC (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	float                                              m_mainStatePreBlendinTime;                        		// 0x00C0 (0x0004) [0x0000000000000000]              
	float                                              m_pawnBlendTime;                                  		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51965 ];

		return pClassPointer;
	};

	void SetupRotationAndAnimation ( );
	void TickSpecialMove ( float DeltaTime );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_RecoverFromRagdollToDeathDBNO::pClassPointer = NULL;

// Class SRGame.YSpecialMove_TurretRemote
// 0x0000 (0x0190 - 0x0190)
class UYSpecialMove_TurretRemote : public UYSpecialMove_TurretEnter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51966 ];

		return pClassPointer;
	};

	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_TurretRemote::pClassPointer = NULL;

// Class SRGame.YSpecialMove_TurretLeaveQuick
// 0x0008 (0x00C0 - 0x00B8)
class UYSpecialMove_TurretLeaveQuick : public UYSpecialMove
{
public:
	class AYTrigger_TurretInteraction*                 m_turretInteraction;                              		// 0x00B8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_wasCrouchedAtStart : 1;                         		// 0x00BC (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51967 ];

		return pClassPointer;
	};

	void OnLeaveTurretFinished ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_TurretLeaveQuick::pClassPointer = NULL;

// Class SRGame.YSpecialMove_MoveToActorPos
// 0x0000 (0x00E4 - 0x00E4)
class UYSpecialMove_MoveToActorPos : public UYSpecialMoveDestination
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51968 ];

		return pClassPointer;
	};

	void OnReachedDestinationTimeoutInternal ( );
	void OnCancelSpecialMoveInternal ( );
	void OnReachedDestinationInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_MoveToActorPos::pClassPointer = NULL;

// Class SRGame.YIcon_Waypoint
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_Waypoint : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51970 ];

		return pClassPointer;
	};

};

UClass* UYIcon_Waypoint::pClassPointer = NULL;

// Class SRGame.YIcon_Hostile
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_Hostile : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51971 ];

		return pClassPointer;
	};

};

UClass* UYIcon_Hostile::pClassPointer = NULL;

// Class SRGame.YArrow_Hostile
// 0x0000 (0x0168 - 0x0168)
class UYArrow_Hostile : public UYMarkerArrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51972 ];

		return pClassPointer;
	};

};

UClass* UYArrow_Hostile::pClassPointer = NULL;

// Class SRGame.YSeqEvent_TargetedByAnAttackCommand
// 0x0004 (0x0114 - 0x0110)
class UYSeqEvent_TargetedByAnAttackCommand : public USequenceEvent
{
public:
	unsigned long                                      m_aiReceivesAttackCommand : 1;                    		// 0x0110 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 51981 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_TargetedByAnAttackCommand::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_Menu
// 0x0008 (0x06B0 - 0x06A8)
class AYGameReplicationInfo_Menu : public AYGameReplicationInfo_MPBase
{
public:
	unsigned char                                      m_PartyMenuType;                                  		// 0x06A8 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_HostQuitMenu : 1;                               		// 0x06AC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 52515 ];

		return pClassPointer;
	};

	void GoToPartyMenu ( );
	void SetPartyMenuType ( unsigned char partyType );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYGameReplicationInfo_Menu::pClassPointer = NULL;

// Class SRGame.YGameSearchMultiplayer
// 0x0000 (0x0104 - 0x0104)
class UYGameSearchMultiplayer : public UOnlineGameSearch
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 52617 ];

		return pClassPointer;
	};

	void SetNeededFreeSlots ( int NeededFreeSlots );
	void SetExodusMode ( unsigned char exodusMode );
	bool IsRanked ( );
	void SetRanked ( unsigned long bRanked );
	void SetMapEnum ( unsigned char Map );
	int GetTuningMask ( );
	void SetTuningMask ( int TuningMask );
	int GetPlaylistId ( );
	void SetPlaylistId ( int MPPlaylistId );
	void SetMultiplayerModeEnum ( unsigned char MPMode );
	void SetAIDifficulty ( unsigned char Difficulty );
};

UClass* UYGameSearchMultiplayer::pClassPointer = NULL;

// Class SRGame.YSeqEvent_ProfileReadComplete
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_ProfileReadComplete : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 52786 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_ProfileReadComplete::pClassPointer = NULL;

// Class SRGame.YAnnouncer
// 0x001C (0x0214 - 0x01F8)
class AYAnnouncer : public AInfo
{
public:
	unsigned char                                      AnnouncerLevel;                                   		// 0x01F8 (0x0001) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	class UClass*                                      PlayingAnnouncementClass;                         		// 0x01FC (0x0004) [0x0000000000000000]              
	int                                                PlayingAnnouncementIndex;                         		// 0x0200 (0x0004) [0x0000000000000000]              
	class AYQueuedAnnouncement*                        Queue;                                            		// 0x0204 (0x0004) [0x0000000000000000]              
	class AYPlayerController*                          PlayerOwner;                                      		// 0x0208 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              AnnouncerSoundCue;                                		// 0x020C (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             CurrentAnnouncementComponent;                     		// 0x0210 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 52800 ];

		return pClassPointer;
	};

	void PlayAnnouncement ( class UClass* InMessageClass, int MessageIndex, class APlayerReplicationInfo* PRI, class UObject* OptionalObject );
	void AnnouncementFinished ( class UAudioComponent* AC );
	void PlayAnnouncementNow ( class UClass* InMessageClass, int MessageIndex, class APlayerReplicationInfo* PRI, class UObject* OptionalObject );
	void PlayNextAnnouncement ( );
	void PostBeginPlay ( );
	void Destroyed ( );
};

UClass* AYAnnouncer::pClassPointer = NULL;

// Class SRGame.YSeqEvt_LookingAtPOI
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_LookingAtPOI : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 53124 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqEvt_LookingAtPOI::pClassPointer = NULL;

// Class SRGame.YSeqAct_CamOverrideMode
// 0x00A8 (0x019C - 0x00F4)
class UYSeqAct_CamOverrideMode : public USequenceAction
{
public:
	float                                              m_distance;                                       		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_offset;                                         		// 0x00F8 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_FOV;                                            		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_aimingFOV;                                      		// 0x0108 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_time;                                           		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_FOVToggleTime;                                  		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_safePos;                                        		// 0x0114 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_rotationSpeed;                                  		// 0x0120 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_rotationDamping;                                		// 0x012C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_translationDamping;                             		// 0x0138 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_useFuehlerIgel : 1;                             		// 0x0144 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_noCollisionDetection : 1;                       		// 0x0144 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_playerInvisible : 1;                            		// 0x0144 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_ignorePawnMeshSmoothing : 1;                    		// 0x0144 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_useReferenceViewTargetLocation : 1;             		// 0x0144 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_useReferenceViewTargetRotation : 1;             		// 0x0144 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_useRotationLimits : 1;                          		// 0x0144 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	float                                              m_playerInvisibleDelay;                           		// 0x0148 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AActor*                                      m_referenceViewTarget;                            		// 0x014C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_posRotationLimits;                              		// 0x0150 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_negRotationLimits;                              		// 0x015C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_posRotLimitsSoftRegion;                         		// 0x0168 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_negRotLimitsSoftRegion;                         		// 0x0174 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleDistanceAdaptionStartAngle;               		// 0x0180 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleDistanceAdaptionMaxValue;                 		// 0x0184 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleDistanceAdaptionSmoothing;                		// 0x0188 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleForwardMovementUp;                        		// 0x018C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleForwardMovementDown;                      		// 0x0190 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleForwardMovementUpStartAngle;              		// 0x0194 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_yAngleForwardMovementDownStartAngle;            		// 0x0198 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 53255 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_CamOverrideMode::pClassPointer = NULL;

// Class SRGame.YPlayerController_Coop
// 0x0000 (0x129C - 0x129C)
class AYPlayerController_Coop : public AYPlayerController_MP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 53352 ];

		return pClassPointer;
	};

	struct FString GetRequiredDLCSimpleName ( );
	void ClientShowScoreboardCOOP ( unsigned char endGamePlayersWin, struct FName endGameMessage );
	void DisableLoadingMovieForDebugging ( );
	void ClientInitialize ( );
	void ClientStartOnlineGame ( );
	bool StopSecondaryByInterrupt ( unsigned long noRefire, unsigned long forceInterrupt );
	bool GamePad_ToggleScndWeaponMode ( );
	void ClientIncrementCollectedXP ( int EventID, int earnedXP, unsigned char eventPriority, int ChallengeID );
	void ServerIncrementCollectedXP ( int EventID, int earnedXP, unsigned char eventPriority );
	void Destroyed ( );
	void OnStartDownButNotOut ( );
	unsigned char GetSquadTag ( );
	void SetSquadTag ( unsigned char DesiredSquadPosition );
	void ServerCycleSpectatingCamera ( unsigned long bPreviousCamera );
	bool SupportsAimSnapOn ( );
	void ClientSetProfileStat ( int StatId, int Value );
	void ClientAddProfileStat ( int StatId, int Value );
	void ClientSetOnlineStatus ( );
};

UClass* AYPlayerController_Coop::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_IntelCollectibleDetailsMenu
// 0x000C (0x0780 - 0x0774)
class UYUIFrontEnd_IntelCollectibleDetailsMenu : public UYUIFrontEnd
{
public:
	class UUILabel*                                    m_lblMainText;                                    		// 0x0774 (0x0004) [0x0000000000000000]              
	class UUIScrollFrame*                              m_scrollFrame;                                    		// 0x0778 (0x0004) [0x0000000000000000]              
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 53551 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void SetIntelCollectible ( class UYDataProvider_IntelCollectibles* Provider, class USurface* imgToDisplay );
	void OnSceneDeactivatedCallback ( class UUIScene* DeactivatedScene );
	void SetVisibility ( unsigned long bIsVisible );
	void OnSelectItem ( int PlayerIndex );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_IntelCollectibleDetailsMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_IntelCollectibleDetails
// 0x000C (0x078C - 0x0780)
class UYUIFrontEnd_IntelCollectibleDetails : public UYUIFrontEnd_IntelCollectibleDetailsMenu
{
public:
	class UUILabel*                                    m_lblShortDesc;                                   		// 0x0780 (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_imgIntelItem;                                   		// 0x0784 (0x0004) [0x0000000000000000]              
	class AYRemoteSpeaker_Generic*                     m_remoteSpeaker;                                  		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 53550 ];

		return pClassPointer;
	};

	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void StopTalking ( );
	void OnSceneDeactivatedCallback ( class UUIScene* DeactivatedScene );
	void SceneActivated ( unsigned long bInitialActivation );
	void SetIntelCollectible ( class UYDataProvider_IntelCollectibles* Provider, class USurface* imgToDisplay );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_IntelCollectibleDetails::pClassPointer = NULL;

// Class SRGame.YSeqEvent_PawnFired
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_PawnFired : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 53716 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_PawnFired::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleCinematicMode
// 0x0004 (0x00FC - 0x00F8)
class UYSeqAct_ToggleCinematicMode : public USeqAct_ToggleCinematicMode
{
public:
	unsigned long                                      m_suppressGenericVoiceOver : 1;                   		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_putPlayerSquad2Godmode : 1;                     		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_putEveryone2Godmode : 1;                        		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_reviveDBNOSquadmembers : 1;                     		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_hideAllPawns : 1;                               		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_cinematicInputMode : 1;                         		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 53892 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ToggleCinematicMode::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetGeneralCommand
// 0x0020 (0x0114 - 0x00F4)
class UYSeqAct_SetGeneralCommand : public USequenceAction
{
public:
	unsigned char                                      m_command;                                        		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     m_customText;                                     		// 0x00F8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     m_customDescription;                              		// 0x0104 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_icon;                                           		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54160 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SetGeneralCommand::pClassPointer = NULL;

// Class SRGame.YMessagePayloadDummy
// 0x00D8 (0x0114 - 0x003C)
class UYMessagePayloadDummy : public UObject
{
public:
	struct FYS_ContextCommandInfo                      m_command;                                        		// 0x003C (0x00D8) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54186 ];

		return pClassPointer;
	};

};

UClass* UYMessagePayloadDummy::pClassPointer = NULL;

// Class SRGame.YSquadMessage
// 0x0000 (0x006C - 0x006C)
class UYSquadMessage : public UYLocalMessage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54191 ];

		return pClassPointer;
	};

	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYSquadMessage::pClassPointer = NULL;

// Class SRGame.YSeqAct_UIMessage
// 0x0020 (0x0114 - 0x00F4)
class UYSeqAct_UIMessage : public USequenceAction
{
public:
	struct FString                                     m_message;                                        		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     m_headline;                                       		// 0x0100 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_duration;                                       		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYUIScene_UIMessage*                         m_messageSceneTemplate;                           		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54295 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_UIMessage::pClassPointer = NULL;

// Class SRGame.YSeqAct_ChapterDisplay
// 0x0004 (0x0118 - 0x0114)
class UYSeqAct_ChapterDisplay : public UYSeqAct_UIMessage
{
public:
	unsigned long                                      m_bIsEpilogue : 1;                                		// 0x0114 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54294 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_ChapterDisplay::pClassPointer = NULL;

// Class SRGame.YSeqEvent_GrenadeTutorial
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_GrenadeTutorial : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54351 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_GrenadeTutorial::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleSPGameOver
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleSPGameOver : public USeqAct_Toggle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54385 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ToggleSPGameOver::pClassPointer = NULL;

// Class SRGame.YUIScene_GameOver
// 0x0020 (0x0780 - 0x0760)
class UYUIScene_GameOver : public UYUIScene_Hud
{
public:
	class UUILabel*                                    m_lblRestart;                                     		// 0x0760 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_lblReason;                                      		// 0x0764 (0x0004) [0x0000000000000000]              
	struct FString                                     m_loadLastCheckpointMsg;                          		// 0x0768 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_gameOver;                                       		// 0x0774 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54411 ];

		return pClassPointer;
	};

	void PostInitialize ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void SetReason ( struct FString Reason );
};

UClass* UYUIScene_GameOver::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_DifficultyScreen
// 0x00AC (0x0820 - 0x0774)
class UYUIFrontEnd_DifficultyScreen : public UYUIFrontEnd
{
public:
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblDifficultyName;                              		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_tbDifficultyDesc;                               		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_IconImages                              m_iconImages[ 0x4 ];                              		// 0x0780 (0x0040) [0x0000000000000000]              
	int                                                m_diffUnlockInfo[ 0x4 ];                          		// 0x07C0 (0x0010) [0x0000000000000000]              
	class UUIButton*                                   m_diffButtons[ 0x4 ];                             		// 0x07D0 (0x0010) [0x0000000000000000]              
	class UUIButton*                                   m_leftButton;                                     		// 0x07E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_rightButton;                                    		// 0x07E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_diffSymbol;                                     		// 0x07E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_currentSelection;                               		// 0x07EC (0x0004) [0x0000000000000000]              
	struct FLinearColor                                m_greyOutColor;                                   		// 0x07F0 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_normalColor;                                    		// 0x0800 (0x0010) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_buttonHasBeenPressed : 1;                       		// 0x0810 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_diffSelected : 1;                               		// 0x0810 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	struct FScriptDelegate                             __OnDifficultyLevelSelected__Delegate;            		// 0x0814 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54458 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool IsRightKey ( struct FInputEventParameters* EventParms );
	bool IsLeftKey ( struct FInputEventParameters* EventParms );
	bool IsPressedKey ( struct FInputEventParameters* EventParms );
	bool IsBackKey ( struct FInputEventParameters* EventParms );
	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	bool CheckForInputLock ( struct FInputEventParameters* EventParms );
	void SelectPrevLevel ( );
	void SelectNextLevel ( );
	void BackSelected ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool MenuLevel ( );
	bool SelectNewLevel ( int NewSelection );
	bool OnDiffButtonClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void DifficultySelected ( );
	void UpdateCurrentSelected ( class UYDataProvider_DifficultyInfo* DiffDataProvider, unsigned long DiffLocked );
	void UpdateIcon ( class UYDataProvider_DifficultyInfo* DiffDataProvider, int DiffIndex, unsigned long IconSelected, unsigned long DiffLocked );
	void UpdateScene ( );
	bool OnRightButtonClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnLeftButtonClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	int CheckInsaneUnlocked ( );
	void SetUnlockInfo ( );
	void InitWidget ( );
	void InitDiffButtonsWidgetRef ( );
	void InitDiffIconsWidgetRef ( );
	void InitWidgetRef ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void PostInitialize ( );
	void OnDifficultyLevelSelected ( unsigned char Difficulty );
};

UClass* UYUIFrontEnd_DifficultyScreen::pClassPointer = NULL;

// Class SRGame.YTimerMessage
// 0x0040 (0x00AC - 0x006C)
class UYTimerMessage : public UYLocalMessage
{
public:
	class UYSoundCueFMOD*                              AnnouncementSounds[ 0x4 ];                        		// 0x006C (0x0010) [0x0000000000000000]              
	struct FString                                     AnnouncementText[ 0x4 ];                          		// 0x007C (0x0030) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54470 ];

		return pClassPointer;
	};

	int GetFontSize ( int Switch, class APlayerReplicationInfo* RelatedPRI1, class APlayerReplicationInfo* RelatedPRI2, class APlayerReplicationInfo* LocalPlayer );
	class UYSoundCueFMOD* AnnouncementSound ( int MessageIndex, class UObject* OptionalObject, class APlayerController* PC );
	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYTimerMessage::pClassPointer = NULL;

// Class SRGame.YSeqAct_CamOverrideFOV
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_CamOverrideFOV : public USequenceAction
{
public:
	float                                              m_FOV;                                            		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_time;                                           		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54597 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_CamOverrideFOV::pClassPointer = NULL;

// Class SRGame.YSeqAct_DeathFromAbove
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_DeathFromAbove : public USequenceAction
{
public:
	class AActor*                                      m_cameraOrigin;                                   		// 0x00F4 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_fakeTarget;                                     		// 0x00F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54602 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_DeathFromAbove::pClassPointer = NULL;

// Class SRGame.YCameraActorDeathFromAbove
// 0x001C (0x0394 - 0x0378)
class AYCameraActorDeathFromAbove : public AYCameraActor
{
public:
	float                                              m_movementRadius;                                 		// 0x0378 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_accelerationRate;                               		// 0x037C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UYUIScene_Mortar*                            DFAScene;                                         		// 0x0380 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UAudioComponent*                             m_movementSoundComponent;                         		// 0x0384 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_zoomSoundComponent;                             		// 0x0388 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_defaultFOV;                                     		// 0x038C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_zoomedFOV;                                      		// 0x0390 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54604 ];

		return pClassPointer;
	};

};

UClass* AYCameraActorDeathFromAbove::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetDamageCamShakeStrength
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_SetDamageCamShakeStrength : public USequenceAction
{
public:
	float                                              m_targetValue;                                    		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_interpolationTime;                              		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54665 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetDamageCamShakeStrength::pClassPointer = NULL;

// Class SRGame.YSeqAct_TogglePlayerStats
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_TogglePlayerStats : public USeqAct_ToggleHUD
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 54756 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_TogglePlayerStats::pClassPointer = NULL;

// Class SRGame.YPawn_AIDebug
// 0x0004 (0x270C - 0x2708)
class AYPawn_AIDebug : public AYPawn_Infantry
{
public:
	class UClass*                                      m_originalPawnClass;                              		// 0x2708 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 55495 ];

		return pClassPointer;
	};

};

UClass* AYPawn_AIDebug::pClassPointer = NULL;

// Class SRGame.YPawn_CivilianDebug
// 0x0004 (0x2710 - 0x270C)
class AYPawn_CivilianDebug : public AYPawn_Civilian
{
public:
	class UClass*                                      m_originalPawnClass;                              		// 0x270C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 55497 ];

		return pClassPointer;
	};

};

UClass* AYPawn_CivilianDebug::pClassPointer = NULL;

// Class SRGame.YAnimTestMarker_Icon
// 0x0000 (0x01A8 - 0x01A8)
class UYAnimTestMarker_Icon : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 55513 ];

		return pClassPointer;
	};

};

UClass* UYAnimTestMarker_Icon::pClassPointer = NULL;

// Class SRGame.YAnimTestMarker_IconTexture
// 0x0000 (0x01A8 - 0x01A8)
class UYAnimTestMarker_IconTexture : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 55514 ];

		return pClassPointer;
	};

};

UClass* UYAnimTestMarker_IconTexture::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetMood
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_SetMood : public USequenceAction
{
public:
	class UYMoodSetup2*                                m_targetMood;                                     		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_interpolationTime;                              		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 55638 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetMood::pClassPointer = NULL;

// Class SRGame.YSeqAct_ClearMoodOverride
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_ClearMoodOverride : public USequenceAction
{
public:
	float                                              m_interpolationTime;                              		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 55643 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_ClearMoodOverride::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetLowPassFilter
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_SetLowPassFilter : public USequenceAction
{
public:
	unsigned long                                      m_active : 1;                                     		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_cutoffFrequency;                                		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_resonance;                                      		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_interpolationTime;                              		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 55647 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetLowPassFilter::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetHighPassFilter
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_SetHighPassFilter : public USequenceAction
{
public:
	unsigned long                                      m_active : 1;                                     		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_cutoffFrequency;                                		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_resonance;                                      		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_interpolationTime;                              		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 55654 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetHighPassFilter::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetParamEQ
// 0x0014 (0x0108 - 0x00F4)
class UYSeqAct_SetParamEQ : public USequenceAction
{
public:
	unsigned long                                      m_active : 1;                                     		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_centerFrequency;                                		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_bandWidth;                                      		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_gain;                                           		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_interpolationTime;                              		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 55661 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetParamEQ::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Lobby_Coop
// 0x0024 (0x0950 - 0x092C)
class UYUIFrontEnd_Lobby_Coop : public UYUIFrontEnd_Lobby
{
public:
	class UUILabel*                                    m_coopRules;                                      		// 0x092C (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_coopTimeLimit;                                  		// 0x0930 (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_coopMapImage;                                   		// 0x0934 (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_coopDifficulty;                                 		// 0x0938 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_coopMapNameTitle;                               		// 0x093C (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_coopMapName;                                    		// 0x0940 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_coopDifficultyTextTitle;                        		// 0x0944 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_coopDifficultyText;                             		// 0x0948 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_hasDoneButtonRefresh : 1;                       		// 0x094C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 55939 ];

		return pClassPointer;
	};

	struct FString GetRequiredDLCSimpleName ( );
	bool OnLeaveMessageBoxSelection ( class UUIMessageBoxBase* LeaveMessageBox, struct FName SelectedOption, int PlayerIndex );
	bool OnLeaveClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void NewMapSelected ( unsigned char NewMap );
	void NewDiffSelected ( int NewDifficulty );
	bool OpenChangeSettingsMenu ( int PlayerIndex );
	void UpdateCoopDiffDelegate ( );
	void UpdateMultiplayerMapDelegate ( );
	void UpdateButtonCallbacks ( unsigned long Enable );
	void InitWidget ( );
	void UpdateReadyPanelVisibility ( class UUIPanel* Parent );
	void UpdatePlayersListsVisibility ( );
	struct FString GetPlayerNameForIndex ( int PlayerIndex, class UYUIListPlayer* BoundList );
	void UpdateDiffIcon ( );
	int GetDiffSetting ( );
	void UpdateMapVisuals ( );
	void UpdateCoopLabelsAndImages ( );
	void SceneActivated ( unsigned long bInitialActivation );
	class AYPlayerReplicationInfo_MPBase* GetSelectedPRI ( );
	bool IsModeReadyToStartGame ( );
	void ShowTimerImage ( unsigned long shouldShow );
	void RefreshButtonBarFormatting ( class UUICalloutButtonPanel* ButtonPanel );
	bool ShouldShowSwitcher ( class AYGameReplicationInfo_MPBase* GRIMP );
	void OnTick ( float DeltaTime );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_Lobby_Coop::pClassPointer = NULL;

// Class SRGame.YCameraFXEmitter_Blood3
// 0x0000 (0x021C - 0x021C)
class AYCameraFXEmitter_Blood3 : public AYCameraFXEmitter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 56181 ];

		return pClassPointer;
	};

};

UClass* AYCameraFXEmitter_Blood3::pClassPointer = NULL;

// Class SRGame.YHitDirectionIndicator
// 0x003C (0x00A8 - 0x006C)
class UYHitDirectionIndicator : public UYDirectionIndicator
{
public:
	float                                              m_duration;                                       		// 0x006C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_flashDuration;                                  		// 0x0070 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_initialThreat;                                  		// 0x0074 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_threatStep;                                     		// 0x0078 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxThreat;                                      		// 0x007C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_maxThreatScale;                                 		// 0x0080 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_threatScaleStep;                                		// 0x0084 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	unsigned long                                      m_flashOnFirstImpact : 1;                         		// 0x0088 (0x0004) [0x0000000000004001] [0x00000001] ( CPF_Edit | CPF_Config )
	TArray< struct FYS_HitIndicatorImpact >            m_impacts;                                        		// 0x008C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FYS_HitIndicatorProjectileImpact >  m_projectileImpacts;                              		// 0x0098 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_arrowMaterialTemplate;                          		// 0x00A4 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 56215 ];

		return pClassPointer;
	};

	void InstantRecoverBuckets ( );
	void TurnOff ( );
	void DrawImpacts ( class AYHUD* HUD, float deltaSec );
	void AddHit ( class AActor* Inst, int Damage, struct FVector Momentum );
	void AddLocation ( struct FVector Loc, int Damage, struct FVector Momentum );
	void Initialize ( class AYGamePawn* pwn );
};

UClass* UYHitDirectionIndicator::pClassPointer = NULL;

// Class SRGame.YSavedMove
// 0x0000 (0x00E8 - 0x00E8)
class UYSavedMove : public USavedMove
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 56223 ];

		return pClassPointer;
	};

	bool CanCombineWith ( class USavedMove* NewMove, class APawn* inPawn, float MaxDelta );
};

UClass* UYSavedMove::pClassPointer = NULL;

// Class SRGame.YSeqEvent_WeaponEquipped
// 0x0004 (0x0114 - 0x0110)
class UYSeqEvent_WeaponEquipped : public USequenceEvent
{
public:
	class UClass*                                      m_weaponClass;                                    		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 56224 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_WeaponEquipped::pClassPointer = NULL;

// Class SRGame.YAdmin
// 0x0000 (0x1058 - 0x1058)
class AYAdmin : public AYPlayerController
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 56225 ];

		return pClassPointer;
	};

	void ServerSwitch ( struct FString URL );
	void Switch ( struct FString URL );
	void ServerRestartMap ( );
	void RestartMap ( );
	void PlayerList ( );
	void ServerKick ( struct FString S );
	void Kick ( struct FString S );
	void KickBan ( struct FString S );
	void ServerAdmin ( struct FString CommandLine );
	void Admin ( struct FString CommandLine );
	void PostBeginPlay ( );
};

UClass* AYAdmin::pClassPointer = NULL;

// Class SRGame.YSeqAct_TriggerPlayerSquadTrigger
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_TriggerPlayerSquadTrigger : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 56384 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_TriggerPlayerSquadTrigger::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetArmorMultiplier
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetArmorMultiplier : public USequenceAction
{
public:
	float                                              m_armorMultiplier;                                		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57080 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetArmorMultiplier::pClassPointer = NULL;

// Class SRGame.YAnimNotify_AIEnterCover
// 0x0002 (0x0042 - 0x0040)
class UYAnimNotify_AIEnterCover : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_coverStance;                                    		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_coverDirection;                                 		// 0x0041 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57086 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_AIEnterCover::pClassPointer = NULL;

// Class SRGame.YAnimNotify_AIChangeState
// 0x0001 (0x0041 - 0x0040)
class UYAnimNotify_AIChangeState : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_state;                                          		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57094 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_AIChangeState::pClassPointer = NULL;

// Class SRGame.YProj_FragGrenade
// 0x0000 (0x0678 - 0x0678)
class AYProj_FragGrenade : public AYProj_Physical
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57266 ];

		return pClassPointer;
	};

};

UClass* AYProj_FragGrenade::pClassPointer = NULL;

// Class SRGame.YProj_FragGrenadeAI
// 0x0000 (0x0678 - 0x0678)
class AYProj_FragGrenadeAI : public AYProj_FragGrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57265 ];

		return pClassPointer;
	};

};

UClass* AYProj_FragGrenadeAI::pClassPointer = NULL;

// Class SRGame.YProj_PercussionGrenade
// 0x0000 (0x0678 - 0x0678)
class AYProj_PercussionGrenade : public AYProj_Physical
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57268 ];

		return pClassPointer;
	};

};

UClass* AYProj_PercussionGrenade::pClassPointer = NULL;

// Class SRGame.YProj_PercussionGrenadeAI
// 0x0000 (0x0678 - 0x0678)
class AYProj_PercussionGrenadeAI : public AYProj_PercussionGrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57267 ];

		return pClassPointer;
	};

};

UClass* AYProj_PercussionGrenadeAI::pClassPointer = NULL;

// Class SRGame.YProj_ProxyGrenade_SP
// 0x002C (0x06A4 - 0x0678)
class AYProj_ProxyGrenade_SP : public AYProj_Physical
{
public:
	int                                                m_updateCounter;                                  		// 0x0678 (0x0004) [0x0000000000000000]              
	float                                              m_lastUpdate;                                     		// 0x067C (0x0004) [0x0000000000000000]              
	float                                              m_runningTime;                                    		// 0x0680 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsSoundPlaying : 1;                            		// 0x0684 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIsSoundPlaying2 : 1;                           		// 0x0684 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bActive : 1;                                    		// 0x0684 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bOnExplode : 1;                                 		// 0x0684 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bExploding : 1;                                 		// 0x0684 (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              m_proximationRange;                               		// 0x0688 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_activationTime;                                 		// 0x068C (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	float                                              m_explodeDelay;                                   		// 0x0690 (0x0004) [0x0000000000004001]              ( CPF_Edit | CPF_Config )
	class UYSoundCueFMOD*                              m_finalSound;                                     		// 0x0694 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceTimeVarying*                m_flashMaterial;                                  		// 0x0698 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   m_redMaterial;                                    		// 0x069C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   m_greenMaterial;                                  		// 0x06A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57270 ];

		return pClassPointer;
	};

	void CheckEnemies ( );
	void Tick ( float DeltaTime );
	void TimeExplosion ( class AYGamePawn* ThrowingPawn );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void InitTracer ( struct FVector StartLoc, struct FVector endLoc, class AYGamePawn* causer );
};

UClass* AYProj_ProxyGrenade_SP::pClassPointer = NULL;

// Class SRGame.YProj_ProxyGrenadeAI
// 0x0000 (0x06A4 - 0x06A4)
class AYProj_ProxyGrenadeAI : public AYProj_ProxyGrenade_SP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57269 ];

		return pClassPointer;
	};

};

UClass* AYProj_ProxyGrenadeAI::pClassPointer = NULL;

// Class SRGame.YProj_StickyGrenade_SP
// 0x0000 (0x0694 - 0x0694)
class AYProj_StickyGrenade_SP : public AYProj_StickyGrenade_Base
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57272 ];

		return pClassPointer;
	};

};

UClass* AYProj_StickyGrenade_SP::pClassPointer = NULL;

// Class SRGame.YProj_StickyGrenadeAI
// 0x0000 (0x0694 - 0x0694)
class AYProj_StickyGrenadeAI : public AYProj_StickyGrenade_SP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57271 ];

		return pClassPointer;
	};

};

UClass* AYProj_StickyGrenadeAI::pClassPointer = NULL;

// Class SRGame.YProj_PhosphorGrenadeAI
// 0x0000 (0x069C - 0x069C)
class AYProj_PhosphorGrenadeAI : public AYProj_PhosphorGrenade_SP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57273 ];

		return pClassPointer;
	};

};

UClass* AYProj_PhosphorGrenadeAI::pClassPointer = NULL;

// Class SRGame.YProj_StunGrenade_SP
// 0x0000 (0x0678 - 0x0678)
class AYProj_StunGrenade_SP : public AYProj_Physical
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57275 ];

		return pClassPointer;
	};

};

UClass* AYProj_StunGrenade_SP::pClassPointer = NULL;

// Class SRGame.YProj_StunGrenadeAI
// 0x0000 (0x0678 - 0x0678)
class AYProj_StunGrenadeAI : public AYProj_StunGrenade_SP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57274 ];

		return pClassPointer;
	};

};

UClass* AYProj_StunGrenadeAI::pClassPointer = NULL;

// Class SRGame.YProj_Stone
// 0x0000 (0x0678 - 0x0678)
class AYProj_Stone : public AYProj_Physical
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57276 ];

		return pClassPointer;
	};

	void InformPawnsAboutExplosion ( );
};

UClass* AYProj_Stone::pClassPointer = NULL;

// Class SRGame.YProj_FragGrenadePlayerSquadAI
// 0x0000 (0x0678 - 0x0678)
class AYProj_FragGrenadePlayerSquadAI : public AYProj_FragGrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57277 ];

		return pClassPointer;
	};

};

UClass* AYProj_FragGrenadePlayerSquadAI::pClassPointer = NULL;

// Class SRGame.YProj_StunGrenadePlayerSquadAI
// 0x0000 (0x0678 - 0x0678)
class AYProj_StunGrenadePlayerSquadAI : public AYProj_StunGrenade_SP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57278 ];

		return pClassPointer;
	};

};

UClass* AYProj_StunGrenadePlayerSquadAI::pClassPointer = NULL;

// Class SRGame.YProj_FragGrenadeAINoCollision
// 0x0020 (0x0698 - 0x0678)
class AYProj_FragGrenadeAINoCollision : public AYProj_FragGrenadeAI
{
public:
	unsigned long                                      m_playingAnimation : 1;                           		// 0x0678 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FVector                                     m_endPosition;                                    		// 0x067C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_previousDistance;                               		// 0x0688 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_animationDirection;                             		// 0x068C (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57279 ];

		return pClassPointer;
	};

	void OnExplode ( );
	void AdjustEndPosition ( struct FVector StartLoc, struct FVector* endLoc );
	void PlayLandingAnimation ( );
	void Tick ( float DeltaTime );
	void InitGrenade ( class AActor* callActorMethodsHere, class AYProj_Physical* spawnedGrenade, unsigned char throwMode, struct FVector Start, struct FVector End, struct FVector AimDir );
};

UClass* AYProj_FragGrenadeAINoCollision::pClassPointer = NULL;

// Class SRGame.YProj_PercussionGrenadeAINoCollision
// 0x0020 (0x0698 - 0x0678)
class AYProj_PercussionGrenadeAINoCollision : public AYProj_PercussionGrenadeAI
{
public:
	unsigned long                                      m_playingAnimation : 1;                           		// 0x0678 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FVector                                     m_endPosition;                                    		// 0x067C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_previousDistance;                               		// 0x0688 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_animationDirection;                             		// 0x068C (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57280 ];

		return pClassPointer;
	};

	void OnExplode ( );
	void AdjustEndPosition ( struct FVector StartLoc, struct FVector* endLoc );
	void PlayLandingAnimation ( );
	void Tick ( float DeltaTime );
	void InitGrenade ( class AActor* callActorMethodsHere, class AYProj_Physical* spawnedGrenade, unsigned char throwMode, struct FVector Start, struct FVector End, struct FVector AimDir );
};

UClass* AYProj_PercussionGrenadeAINoCollision::pClassPointer = NULL;

// Class SRGame.YProj_ProxyGrenadeAINoCollision
// 0x0020 (0x06C4 - 0x06A4)
class AYProj_ProxyGrenadeAINoCollision : public AYProj_ProxyGrenadeAI
{
public:
	unsigned long                                      m_playingAnimation : 1;                           		// 0x06A4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FVector                                     m_endPosition;                                    		// 0x06A8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_previousDistance;                               		// 0x06B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_animationDirection;                             		// 0x06B8 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57281 ];

		return pClassPointer;
	};

	void OnExplode ( );
	void AdjustEndPosition ( struct FVector StartLoc, struct FVector* endLoc );
	void PlayLandingAnimation ( );
	void Tick ( float DeltaTime );
	void InitGrenade ( class AActor* callActorMethodsHere, class AYProj_Physical* spawnedGrenade, unsigned char throwMode, struct FVector Start, struct FVector End, struct FVector AimDir );
};

UClass* AYProj_ProxyGrenadeAINoCollision::pClassPointer = NULL;

// Class SRGame.YProj_StickyGrenadeAINoCollision
// 0x0020 (0x06B4 - 0x0694)
class AYProj_StickyGrenadeAINoCollision : public AYProj_StickyGrenadeAI
{
public:
	unsigned long                                      m_playingAnimation : 1;                           		// 0x0694 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FVector                                     m_endPosition;                                    		// 0x0698 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_previousDistance;                               		// 0x06A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_animationDirection;                             		// 0x06A8 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57282 ];

		return pClassPointer;
	};

	void OnExplode ( );
	void AdjustEndPosition ( struct FVector StartLoc, struct FVector* endLoc );
	void PlayLandingAnimation ( );
	void Tick ( float DeltaTime );
	void InitGrenade ( class AActor* callActorMethodsHere, class AYProj_Physical* spawnedGrenade, unsigned char throwMode, struct FVector Start, struct FVector End, struct FVector AimDir );
};

UClass* AYProj_StickyGrenadeAINoCollision::pClassPointer = NULL;

// Class SRGame.YProj_PhosphorGrenadeAINoCollision
// 0x0020 (0x06BC - 0x069C)
class AYProj_PhosphorGrenadeAINoCollision : public AYProj_PhosphorGrenadeAI
{
public:
	unsigned long                                      m_playingAnimation : 1;                           		// 0x069C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FVector                                     m_endPosition;                                    		// 0x06A0 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_previousDistance;                               		// 0x06AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_animationDirection;                             		// 0x06B0 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57283 ];

		return pClassPointer;
	};

	void OnExplode ( );
	void AdjustEndPosition ( struct FVector StartLoc, struct FVector* endLoc );
	void PlayLandingAnimation ( );
	void Tick ( float DeltaTime );
	void InitGrenade ( class AActor* callActorMethodsHere, class AYProj_Physical* spawnedGrenade, unsigned char throwMode, struct FVector Start, struct FVector End, struct FVector AimDir );
};

UClass* AYProj_PhosphorGrenadeAINoCollision::pClassPointer = NULL;

// Class SRGame.YProj_StunGrenadeAINoCollision
// 0x0020 (0x0698 - 0x0678)
class AYProj_StunGrenadeAINoCollision : public AYProj_StunGrenadeAI
{
public:
	unsigned long                                      m_playingAnimation : 1;                           		// 0x0678 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FVector                                     m_endPosition;                                    		// 0x067C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_previousDistance;                               		// 0x0688 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_animationDirection;                             		// 0x068C (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57284 ];

		return pClassPointer;
	};

	void OnExplode ( );
	void AdjustEndPosition ( struct FVector StartLoc, struct FVector* endLoc );
	void PlayLandingAnimation ( );
	void Tick ( float DeltaTime );
	void InitGrenade ( class AActor* callActorMethodsHere, class AYProj_Physical* spawnedGrenade, unsigned char throwMode, struct FVector Start, struct FVector End, struct FVector AimDir );
};

UClass* AYProj_StunGrenadeAINoCollision::pClassPointer = NULL;

// Class SRGame.YProj_FragGrenadePlayerSquadAI_NoCollision
// 0x0020 (0x0698 - 0x0678)
class AYProj_FragGrenadePlayerSquadAI_NoCollision : public AYProj_FragGrenadePlayerSquadAI
{
public:
	unsigned long                                      m_playingAnimation : 1;                           		// 0x0678 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FVector                                     m_endPosition;                                    		// 0x067C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_previousDistance;                               		// 0x0688 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_animationDirection;                             		// 0x068C (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57285 ];

		return pClassPointer;
	};

	void OnExplode ( );
	void AdjustEndPosition ( struct FVector StartLoc, struct FVector* endLoc );
	void PlayLandingAnimation ( );
	void Tick ( float DeltaTime );
	void InitGrenade ( class AActor* callActorMethodsHere, class AYProj_Physical* spawnedGrenade, unsigned char throwMode, struct FVector Start, struct FVector End, struct FVector AimDir );
};

UClass* AYProj_FragGrenadePlayerSquadAI_NoCollision::pClassPointer = NULL;

// Class SRGame.YProj_StunGrenadePlayerSquadAI_NoCollision
// 0x0020 (0x0698 - 0x0678)
class AYProj_StunGrenadePlayerSquadAI_NoCollision : public AYProj_StunGrenadePlayerSquadAI
{
public:
	unsigned long                                      m_playingAnimation : 1;                           		// 0x0678 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FVector                                     m_endPosition;                                    		// 0x067C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_previousDistance;                               		// 0x0688 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FRotator                                    m_animationDirection;                             		// 0x068C (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57286 ];

		return pClassPointer;
	};

	void OnExplode ( );
	void AdjustEndPosition ( struct FVector StartLoc, struct FVector* endLoc );
	void PlayLandingAnimation ( );
	void Tick ( float DeltaTime );
	void InitGrenade ( class AActor* callActorMethodsHere, class AYProj_Physical* spawnedGrenade, unsigned char throwMode, struct FVector Start, struct FVector End, struct FVector AimDir );
};

UClass* AYProj_StunGrenadePlayerSquadAI_NoCollision::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleAIMayReactToStun
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleAIMayReactToStun : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57391 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_ToggleAIMayReactToStun::pClassPointer = NULL;

// Class SRGame.YSeqAct_StunAI
// 0x0001 (0x00F5 - 0x00F4)
class UYSeqAct_StunAI : public USequenceAction
{
public:
	unsigned char                                      m_stun;                                           		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57394 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_StunAI::pClassPointer = NULL;

// Class SRGame.YSeqAct_AllowReactionToLineOfFire
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_AllowReactionToLineOfFire : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57402 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_AllowReactionToLineOfFire::pClassPointer = NULL;

// Class SRGame.YAnimInfoCivilian
// 0x0000 (0x44C4 - 0x44C4)
class UYAnimInfoCivilian : public UYAnimInfoHuman
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 57949 ];

		return pClassPointer;
	};

};

UClass* UYAnimInfoCivilian::pClassPointer = NULL;

// Class SRGame.YAnimNotify_AdrenalineInjection
// 0x0000 (0x0040 - 0x0040)
class UYAnimNotify_AdrenalineInjection : public UAnimNotify_Scripted
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58385 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_AdrenalineInjection::pClassPointer = NULL;

// Class SRGame.YAnimNotify_BlowtorchEffects
// 0x0008 (0x0048 - 0x0040)
class UYAnimNotify_BlowtorchEffects : public UAnimNotify_Scripted
{
public:
	float                                              m_chance;                                         		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_emitting : 1;                                   		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58408 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_BlowtorchEffects::pClassPointer = NULL;

// Class SRGame.YAnimNotify_CameraAnim
// 0x0018 (0x0058 - 0x0040)
class UYAnimNotify_CameraAnim : public UAnimNotify_Scripted
{
public:
	class UCameraAnim*                                 m_cameraAnim;                                     		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_rate;                                           		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_scale;                                          		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeInTime;                                     		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeOutTime;                                    		// 0x0050 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_looped : 1;                                     		// 0x0054 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_randomStartTime : 1;                            		// 0x0054 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58416 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_CameraAnim::pClassPointer = NULL;

// Class SRGame.YAnimNotify_DeathMuscleStrengthFade
// 0x0008 (0x0048 - 0x0040)
class UYAnimNotify_DeathMuscleStrengthFade : public UAnimNotify_Scripted
{
public:
	float                                              m_fadeTarget;                                     		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeTime;                                       		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58429 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_DeathMuscleStrengthFade::pClassPointer = NULL;

// Class SRGame.YAnimNotify_DeathPhysicsBlend
// 0x0004 (0x0044 - 0x0040)
class UYAnimNotify_DeathPhysicsBlend : public UAnimNotify_Scripted
{
public:
	float                                              m_blendTime;                                      		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58437 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_DeathPhysicsBlend::pClassPointer = NULL;

// Class SRGame.YAnimNotify_EnableDeathAnim
// 0x0000 (0x0040 - 0x0040)
class UYAnimNotify_EnableDeathAnim : public UAnimNotify_Scripted
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58465 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_EnableDeathAnim::pClassPointer = NULL;

// Class SRGame.YAnimNotify_Execution
// 0x000C (0x004C - 0x0040)
class UYAnimNotify_Execution : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_notityType;                                     		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_weaponFireStyle;                                		// 0x0041 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_ragdollBlendTime;                               		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_autoFireDuration;                               		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58471 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_Execution::pClassPointer = NULL;

// Class SRGame.YAnimNotify_FakeFireEffects
// 0x0004 (0x0044 - 0x0040)
class UYAnimNotify_FakeFireEffects : public UAnimNotify_Scripted
{
public:
	float                                              m_chance;                                         		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58485 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_FakeFireEffects::pClassPointer = NULL;

// Class SRGame.YAnimNotify_FireWeapon
// 0x0008 (0x0048 - 0x0040)
class UYAnimNotify_FireWeapon : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_weaponFireStyle;                                		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_autoFireDuration;                               		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58492 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_FireWeapon::pClassPointer = NULL;

// Class SRGame.YAnimNotify_GiveDeathAnimHint
// 0x0001 (0x0041 - 0x0040)
class UYAnimNotify_GiveDeathAnimHint : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_deathAnimHint;                                  		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58500 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_GiveDeathAnimHint::pClassPointer = NULL;

// Class SRGame.YAnimNotify_GrenadeThrow
// 0x0000 (0x0040 - 0x0040)
class UYAnimNotify_GrenadeThrow : public UAnimNotify_Scripted
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58506 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_GrenadeThrow::pClassPointer = NULL;

// Class SRGame.YAnimNotify_HideLaserSight
// 0x0000 (0x0040 - 0x0040)
class UYAnimNotify_HideLaserSight : public UAnimNotify_Scripted
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58512 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_HideLaserSight::pClassPointer = NULL;

// Class SRGame.YAnimNotify_HolsterWeapon
// 0x0000 (0x0040 - 0x0040)
class UYAnimNotify_HolsterWeapon : public UAnimNotify_Scripted
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58519 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_HolsterWeapon::pClassPointer = NULL;

// Class SRGame.YAnimNotify_Jump
// 0x0004 (0x0044 - 0x0040)
class UYAnimNotify_Jump : public UAnimNotify_Scripted
{
public:
	unsigned long                                      m_isLongJump : 1;                                 		// 0x0040 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58532 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_Jump::pClassPointer = NULL;

// Class SRGame.YAnimNotify_KnockDown
// 0x0001 (0x0041 - 0x0040)
class UYAnimNotify_KnockDown : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_notifyType;                                     		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58544 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_KnockDown::pClassPointer = NULL;

// Class SRGame.YAnimNotify_Land
// 0x0004 (0x0044 - 0x0040)
class UYAnimNotify_Land : public UAnimNotify_Scripted
{
public:
	unsigned long                                      m_isHardLanding : 1;                              		// 0x0040 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58552 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_Land::pClassPointer = NULL;

// Class SRGame.YAnimNotify_MeleeAttack
// 0x0001 (0x0041 - 0x0040)
class UYAnimNotify_MeleeAttack : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_attackType;                                     		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58559 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_MeleeAttack::pClassPointer = NULL;

// Class SRGame.YAnimNotify_ReequipWeapon
// 0x0000 (0x0041 - 0x0041)
class UYAnimNotify_ReequipWeapon : public UYAnimNotify_DetachWeaponBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58566 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_ReequipWeapon::pClassPointer = NULL;

// Class SRGame.YAnimNotify_Rope
// 0x0001 (0x0041 - 0x0040)
class UYAnimNotify_Rope : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_action;                                         		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58572 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_Rope::pClassPointer = NULL;

// Class SRGame.YAnimNotify_ShowGrenade
// 0x0000 (0x0040 - 0x0040)
class UYAnimNotify_ShowGrenade : public UAnimNotify_Scripted
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58580 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_ShowGrenade::pClassPointer = NULL;

// Class SRGame.YAnimNotify_ShowHealingSyringe
// 0x0001 (0x0041 - 0x0040)
class UYAnimNotify_ShowHealingSyringe : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_eventType;                                      		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58586 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_ShowHealingSyringe::pClassPointer = NULL;

// Class SRGame.YAnimNotify_ShowHideWeaponSubmesh
// 0x0002 (0x0042 - 0x0040)
class UYAnimNotify_ShowHideWeaponSubmesh : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_submeshType;                                    		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_eventType;                                      		// 0x0041 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58594 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_ShowHideWeaponSubmesh::pClassPointer = NULL;

// Class SRGame.YAnimNotify_ShowLaserSight
// 0x0000 (0x0040 - 0x0040)
class UYAnimNotify_ShowLaserSight : public UAnimNotify_Scripted
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58602 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_ShowLaserSight::pClassPointer = NULL;

// Class SRGame.YAnimNotify_ShowScndModeMesh
// 0x0002 (0x0042 - 0x0040)
class UYAnimNotify_ShowScndModeMesh : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_submeshType;                                    		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_eventType;                                      		// 0x0041 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58610 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_ShowScndModeMesh::pClassPointer = NULL;

// Class SRGame.YAnimNotify_SpecialMove
// 0x0002 (0x0042 - 0x0040)
class UYAnimNotify_SpecialMove : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_specialMove;                                    		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_movePhase;                                      		// 0x0041 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58622 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_SpecialMove::pClassPointer = NULL;

// Class SRGame.YAnimNotify_Sprint
// 0x000C (0x004C - 0x0040)
class UYAnimNotify_Sprint : public UAnimNotify_Scripted
{
public:
	int                                                m_footDown;                                       		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_playGearSounds : 1;                             		// 0x0044 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class UYSoundCueFMOD*                              m_gearSoundCue;                                   		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58630 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_Sprint::pClassPointer = NULL;

// Class SRGame.YAnimNotify_StartWeaponAnim
// 0x0010 (0x0050 - 0x0040)
class UYAnimNotify_StartWeaponAnim : public UAnimNotify_Scripted
{
public:
	struct FName                                       m_weaponAnimName;                                 		// 0x0040 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_weaponAnimNameMirrored;                         		// 0x0048 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58639 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_StartWeaponAnim::pClassPointer = NULL;

// Class SRGame.YAnimNotify_TacticalReloadStopper
// 0x0000 (0x0040 - 0x0040)
class UYAnimNotify_TacticalReloadStopper : public UAnimNotify_Scripted
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58647 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_TacticalReloadStopper::pClassPointer = NULL;

// Class SRGame.YAnimNotify_TossWeapon
// 0x0004 (0x0044 - 0x0040)
class UYAnimNotify_TossWeapon : public UAnimNotify_Scripted
{
public:
	unsigned long                                      m_ignoreForPlayerSquad : 1;                       		// 0x0040 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58654 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_TossWeapon::pClassPointer = NULL;

// Class SRGame.YAnimNotify_Zipline
// 0x0001 (0x0041 - 0x0040)
class UYAnimNotify_Zipline : public UAnimNotify_Scripted
{
public:
	unsigned char                                      m_notityType;                                     		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 58662 ];

		return pClassPointer;
	};

	void Notify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UYAnimNotify_Zipline::pClassPointer = NULL;

// Class SRGame.YQueuedAnnouncement
// 0x0014 (0x020C - 0x01F8)
class AYQueuedAnnouncement : public AInfo
{
public:
	class AYQueuedAnnouncement*                        nextAnnouncement;                                 		// 0x01F8 (0x0004) [0x0000000000000000]              
	class UClass*                                      AnnouncementClass;                                		// 0x01FC (0x0004) [0x0000000000000000]              
	int                                                MessageIndex;                                     		// 0x0200 (0x0004) [0x0000000000000000]              
	class APlayerReplicationInfo*                      PRI;                                              		// 0x0204 (0x0004) [0x0000000000000000]              
	class UObject*                                     OptionalObject;                                   		// 0x0208 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 59445 ];

		return pClassPointer;
	};

};

UClass* AYQueuedAnnouncement::pClassPointer = NULL;

// Class SRGame.YAnnihilationMessage
// 0x0048 (0x00B4 - 0x006C)
class UYAnnihilationMessage : public UYLocalMessage
{
public:
	struct FString                                     m_TeamAnnihilatedString[ 0x3 ];                   		// 0x006C (0x0024) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	int                                                m_specopsVoice[ 0x3 ];                            		// 0x0090 (0x000C) [0x0000000000000000]              
	int                                                m_konradVoice[ 0x3 ];                             		// 0x009C (0x000C) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_annihilationSound[ 0x3 ];                       		// 0x00A8 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 59483 ];

		return pClassPointer;
	};

	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	class UYSoundCueFMOD* AnnouncementSound ( int MessageIndex, class UObject* OptionalObject, class APlayerController* PC );
};

UClass* UYAnnihilationMessage::pClassPointer = NULL;

// Class SRGame.YArrow_MP
// 0x0000 (0x0168 - 0x0168)
class UYArrow_MP : public UYMarkerArrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 59563 ];

		return pClassPointer;
	};

};

UClass* UYArrow_MP::pClassPointer = NULL;

// Class SRGame.YArrow_SquadDBNO
// 0x0000 (0x0168 - 0x0168)
class UYArrow_SquadDBNO : public UYMarkerArrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 59566 ];

		return pClassPointer;
	};

};

UClass* UYArrow_SquadDBNO::pClassPointer = NULL;

// Class SRGame.YArrow_Turret
// 0x0000 (0x0168 - 0x0168)
class UYArrow_Turret : public UYMarkerArrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 59581 ];

		return pClassPointer;
	};

};

UClass* UYArrow_Turret::pClassPointer = NULL;

// Class SRGame.YArrow_Waypoint
// 0x0000 (0x0168 - 0x0168)
class UYArrow_Waypoint : public UYMarkerArrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 59583 ];

		return pClassPointer;
	};

};

UClass* UYArrow_Waypoint::pClassPointer = NULL;

// Class SRGame.YProj_MPStone
// 0x0000 (0x0678 - 0x0678)
class AYProj_MPStone : public AYProj_Stone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 60522 ];

		return pClassPointer;
	};

	void OnStoneDone ( );
	void PostBeginPlay ( );
	void PlayExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal );
};

UClass* AYProj_MPStone::pClassPointer = NULL;

// Class SRGame.YArsenalManager_Coop
// 0x0000 (0x0918 - 0x0918)
class AYArsenalManager_Coop : public AYArsMgr_Standard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 60534 ];

		return pClassPointer;
	};

	void ClientSetCurrentGrenadeCount ( int Index, int grenadeCount );
	void SetCurrentGrenadeCount ( int Index, int grenadeCount );
	void ClientSetCurrentGrenadeType ( int Index, unsigned char grenadeType );
	void SetCurrentGrenadeType ( int Index, unsigned char grenadeType );
	class AYProj_Physical* ClientGetCurrentGrenadeDefObj ( unsigned char currentGrenadeType, class UYProjData_Mesh** meshData );
	void ClientUpdateCurrentGrenade ( unsigned char currentGrenadeType );
	void UpdateCurrentGrenade ( );
	void ToggleGrenade ( int Direction );
	void LootAmmoFromExecuted ( unsigned long alsoAddGrenades, float grenadeChance );
};

UClass* AYArsenalManager_Coop::pClassPointer = NULL;

// Class SRGame.YPickupMessage
// 0x0014 (0x0080 - 0x006C)
class UYPickupMessage : public UYLocalMessage
{
public:
	unsigned char                                      m_sceneStackPriority;                             		// 0x006C (0x0001) [0x0000000000000002]              ( CPF_Const )
	class UYUIScene_IntelCollectiblePopup*             m_templateIntelCollectiblePopup;                  		// 0x0070 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FString                                     m_popupMessage;                                   		// 0x0074 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 60556 ];

		return pClassPointer;
	};

	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYPickupMessage::pClassPointer = NULL;

// Class SRGame.YWeapon_MPStone
// 0x0000 (0x0CB4 - 0x0CB4)
class AYWeapon_MPStone : public AYWeapon_MPCustom
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 60710 ];

		return pClassPointer;
	};

	class AController* GetDamageInstigator ( );
};

UClass* AYWeapon_MPStone::pClassPointer = NULL;

// Class SRGame.YCameraFXEmitter_Blood1
// 0x0000 (0x021C - 0x021C)
class AYCameraFXEmitter_Blood1 : public AYCameraFXEmitter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62594 ];

		return pClassPointer;
	};

};

UClass* AYCameraFXEmitter_Blood1::pClassPointer = NULL;

// Class SRGame.YCameraFXEmitter_Blood2
// 0x0000 (0x021C - 0x021C)
class AYCameraFXEmitter_Blood2 : public AYCameraFXEmitter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62598 ];

		return pClassPointer;
	};

};

UClass* AYCameraFXEmitter_Blood2::pClassPointer = NULL;

// Class SRGame.YSeqEvt_HD_CapturePointStateChange
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_HD_CapturePointStateChange : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62873 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_HD_CapturePointStateChange::pClassPointer = NULL;

// Class SRGame.YIcon_VP_Marker
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_VP_Marker : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62887 ];

		return pClassPointer;
	};

};

UClass* UYIcon_VP_Marker::pClassPointer = NULL;

// Class SRGame.YCFCD_Pawn_Coop
// 0x0001 (0x003D - 0x003C)
class UYCFCD_Pawn_Coop : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62888 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_Pawn_Coop::pClassPointer = NULL;

// Class SRGame.YCFCD_PawnEasy
// 0x0001 (0x003D - 0x003C)
class UYCFCD_PawnEasy : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62891 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_PawnEasy::pClassPointer = NULL;

// Class SRGame.YCFCD_PawnEasy_Coop
// 0x0001 (0x003D - 0x003C)
class UYCFCD_PawnEasy_Coop : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62894 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_PawnEasy_Coop::pClassPointer = NULL;

// Class SRGame.YCFCD_PawnHard
// 0x0001 (0x003D - 0x003C)
class UYCFCD_PawnHard : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62897 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_PawnHard::pClassPointer = NULL;

// Class SRGame.YCFCD_PawnHard_Coop
// 0x0001 (0x003D - 0x003C)
class UYCFCD_PawnHard_Coop : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62900 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_PawnHard_Coop::pClassPointer = NULL;

// Class SRGame.YCFCD_PawnInsane
// 0x0001 (0x003D - 0x003C)
class UYCFCD_PawnInsane : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62903 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_PawnInsane::pClassPointer = NULL;

// Class SRGame.YCFCD_PawnInsane_Coop
// 0x0001 (0x003D - 0x003C)
class UYCFCD_PawnInsane_Coop : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62906 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_PawnInsane_Coop::pClassPointer = NULL;

// Class SRGame.YCFCD_Weapon_Coop
// 0x0001 (0x003D - 0x003C)
class UYCFCD_Weapon_Coop : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62909 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_Weapon_Coop::pClassPointer = NULL;

// Class SRGame.YCFCD_WeaponEasy
// 0x0001 (0x003D - 0x003C)
class UYCFCD_WeaponEasy : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62912 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_WeaponEasy::pClassPointer = NULL;

// Class SRGame.YCFCD_WeaponEasy_Coop
// 0x0001 (0x003D - 0x003C)
class UYCFCD_WeaponEasy_Coop : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62915 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_WeaponEasy_Coop::pClassPointer = NULL;

// Class SRGame.YCFCD_WeaponHard
// 0x0001 (0x003D - 0x003C)
class UYCFCD_WeaponHard : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62918 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_WeaponHard::pClassPointer = NULL;

// Class SRGame.YCFCD_WeaponHard_Coop
// 0x0001 (0x003D - 0x003C)
class UYCFCD_WeaponHard_Coop : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62921 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_WeaponHard_Coop::pClassPointer = NULL;

// Class SRGame.YCFCD_WeaponInsane
// 0x0001 (0x003D - 0x003C)
class UYCFCD_WeaponInsane : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62924 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_WeaponInsane::pClassPointer = NULL;

// Class SRGame.YCFCD_WeaponInsane_Coop
// 0x0001 (0x003D - 0x003C)
class UYCFCD_WeaponInsane_Coop : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62927 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_WeaponInsane_Coop::pClassPointer = NULL;

// Class SRGame.YCFCD_WeaponModMultiplayer
// 0x0001 (0x003D - 0x003C)
class UYCFCD_WeaponModMultiplayer : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62930 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_WeaponModMultiplayer::pClassPointer = NULL;

// Class SRGame.YCFCD_WeaponMultiplayer
// 0x0001 (0x003D - 0x003C)
class UYCFCD_WeaponMultiplayer : public UYConfigFileCreationDummy
{
public:
	unsigned char                                      m_myConfigType;                                   		// 0x003C (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 62933 ];

		return pClassPointer;
	};

};

UClass* UYCFCD_WeaponMultiplayer::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheapShooter_ChangeStanding
// 0x0001 (0x00F5 - 0x00F4)
class UYSeqAct_CheapShooter_ChangeStanding : public USequenceAction
{
public:
	unsigned char                                      m_standing;                                       		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 63335 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_CheapShooter_ChangeStanding::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheapShooter_ChangeSpeed
// 0x0001 (0x00F5 - 0x00F4)
class UYSeqAct_CheapShooter_ChangeSpeed : public USequenceAction
{
public:
	unsigned char                                      m_speed;                                          		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 63432 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_CheapShooter_ChangeSpeed::pClassPointer = NULL;

// Class SRGame.YSeqEvt_BD_VitalStateChanged
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_BD_VitalStateChanged : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 63827 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqEvt_BD_VitalStateChanged::pClassPointer = NULL;

// Class SRGame.YDamageType_BarrettM99
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_BarrettM99 : public UYDamageType_Sniper
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 63851 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_BarrettM99::pClassPointer = NULL;

// Class SRGame.YPlayerController_Buried
// 0x0050 (0x12EC - 0x129C)
class AYPlayerController_Buried : public AYPlayerController_MP
{
public:
	class AYVitalPoint*                                m_currentVP;                                      		// 0x129C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fRepairedTime;                                  		// 0x12A0 (0x0004) [0x0000000000000000]              
	struct FString                                     m_playerActionMessagesBuried[ 0x3 ];              		// 0x12A4 (0x0024) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_playerInteractionMessagesBuried[ 0x3 ];         		// 0x12C8 (0x0024) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 63853 ];

		return pClassPointer;
	};

	void CancelMatchAndQuitToMainMenu ( struct FString ErrorTitle, struct FString ErrorMsg, unsigned long OnLoginChange, unsigned long forceMessageOnPS3 );
	void StopVitalPointAction ( );
	void GetSpecialMoveMessages ( );
	void ServerSetInUse ( class AYVitalPoint* VP, unsigned long bInUse );
	void ShowVitalPointDestroyedMessage ( class APlayerReplicationInfo* destroyer );
	void ShowVitalPointRepairedMessage ( class APlayerReplicationInfo* repairer );
	void ServerDoRepair ( class AYVitalPoint* VP );
	bool ConditionalDoRepair ( );
	bool CheckHoldEnough ( float fTime );
	float GetRemainingRepairTime ( );
	float GetElapsedTime ( );
	void ShowHVTWeaponsFreeMessage ( unsigned long bSameTeam );
	void OnVitalPointStatusChanged ( class AYVitalPoint* VP );
	void UpdateSpecialMoveButtonAction ( unsigned char buttonType, unsigned long updateNow );
	bool GamePad_StopContextSpecialMove ( );
	bool GamePad_EndAContextSensativeMove ( );
	void ServerStopRepairVitalPoint ( );
	bool GamePad_StartAContextSensativeMove ( );
	void ServerStartRepairVitalPoint ( );
	void CheckActivateVP ( );
	void NotifyTeamChanged ( );
	float GetRespawnDelay ( );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
};

UClass* AYPlayerController_Buried::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_Buried
// 0x0014 (0x0610 - 0x05FC)
class AYPlayerReplicationInfo_Buried : public AYPlayerReplicationInfo_MP
{
public:
	float                                              m_fDestroyStat;                                   		// 0x05FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fExtraHandDamageStat;                           		// 0x0600 (0x0004) [0x0000000000000000]              
	float                                              m_fFriendlyDestroyStat;                           		// 0x0604 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_repairStat;                                     		// 0x0608 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_DestroyedStat;                                  		// 0x060C (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 63855 ];

		return pClassPointer;
	};

	void Reset ( );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
};

UClass* AYPlayerReplicationInfo_Buried::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_CA
// 0x0008 (0x0604 - 0x05FC)
class AYPlayerReplicationInfo_CA : public AYPlayerReplicationInfo_MP
{
public:
	int                                                m_NumKilledChoppers;                              		// 0x05FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_NumMarkedBases;                                 		// 0x0600 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 63915 ];

		return pClassPointer;
	};

	void CopyProtertiesForHotSwap ( class AYPlayerReplicationInfo_CA* PRI );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
	void Reset ( );
};

UClass* AYPlayerReplicationInfo_CA::pClassPointer = NULL;

// Class SRGame.YGameEventMessage
// 0x0000 (0x006C - 0x006C)
class UYGameEventMessage : public UYLocalMessage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 63916 ];

		return pClassPointer;
	};

	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYGameEventMessage::pClassPointer = NULL;

// Class SRGame.YSeqEvt_CA_ChopperAttack
// 0x0004 (0x0114 - 0x0110)
class UYSeqEvt_CA_ChopperAttack : public USequenceEvent
{
public:
	class AController*                                 m_controllerCA;                                   		// 0x0110 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 63926 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_CA_ChopperAttack::pClassPointer = NULL;

// Class SRGame.YPlayerController_CA
// 0x00D0 (0x136C - 0x129C)
class AYPlayerController_CA : public AYPlayerController_MP
{
public:
	class AYChopperCallBase*                           m_Radio;                                          		// 0x129C (0x0004) [0x0000000000000000]              
	class AYChopperDestroyBase*                        m_TargetBase;                                     		// 0x12A0 (0x0004) [0x0000000000000000]              
	struct FString                                     m_playerActionMessagesCA[ 0x9 ];                  		// 0x12A4 (0x006C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	class UYSoundCueFMOD*                              m_ChopperCallChopper;                             		// 0x1310 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSoundCueFMOD*                              m_ChopperMarkBase;                                		// 0x1314 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYComStation*                                m_currentComStation;                              		// 0x1318 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_playerActionMessagesChopper[ 0x3 ];             		// 0x131C (0x0024) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_playerInteractionMessagesChopper[ 0x3 ];        		// 0x1340 (0x0024) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	class UYSoundCueFMOD*                              m_ChopperDeactivateSound;                         		// 0x1364 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSoundCueFMOD*                              m_ChopperReactivateSound;                         		// 0x1368 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 63936 ];

		return pClassPointer;
	};

	float GetRemainingDeactivationTime ( );
	float GetRemainingActivationTime ( );
	float GetElapsedTime ( );
	void StopChopperActions ( );
	void ServerDoActivate ( class AYComStation* CS );
	void ServerDoDeactivate ( class AYComStation* CS );
	void ServerAnnounceStationAttack ( class AYComStation* CS );
	void ServerSetInUse ( class AYComStation* CS, unsigned long bInUse );
	void ConditionalDoActivate ( );
	void ConditionalDoDeactivate ( );
	void GetSpecialMoveMessages ( );
	void UpdateSpecialMoveButtonAction ( unsigned char buttonType, unsigned long updateNow );
	bool CheckHoldEnough ( float fTime );
	bool GamePad_EndAContextSensativeMove ( );
	void ServerStopHackComputer ( );
	bool GamePad_StartAContextSensativeMove ( );
	void ServerStartHackComputer ( );
	void CheckActivateComStation ( );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void ServerDoCall ( class AYChopperCallBase* CB );
	void ServerDoMark ( class AYChopperDestroyBase* DB );
	bool ConditionalDoCall ( );
	bool ConditionalDoMark ( );
	void ServerStopMarkBase ( );
	void ServerStopChopperAttack ( );
	float GetRemainingMarkTime ( );
	float GetRemainingCallTime ( );
	bool GamePad_StopContextSpecialMove ( );
	void StopAction ( );
	void ClientStopAction ( );
	void CheckActivateBase ( );
	void ServerStartMarkBase ( );
	void ServerStartCallChopperAttack ( );
	void PostBeginPlay ( );
};

UClass* AYPlayerController_CA::pClassPointer = NULL;

// Class SRGame.YSeqEvt_OL_ComStationChanged
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_OL_ComStationChanged : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64090 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqEvt_OL_ComStationChanged::pClassPointer = NULL;

// Class SRGame.YIcon_Com_Marker
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_Com_Marker : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64125 ];

		return pClassPointer;
	};

};

UClass* UYIcon_Com_Marker::pClassPointer = NULL;

// Class SRGame.YComStationDetonator
// 0x0000 (0x02FC - 0x02FC)
class AYComStationDetonator : public AYVitalPoint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64126 ];

		return pClassPointer;
	};

};

UClass* AYComStationDetonator::pClassPointer = NULL;

// Class SRGame.YCrosshair_GrenadeThrow
// 0x0000 (0x0060 - 0x0060)
class UYCrosshair_GrenadeThrow : public UYCrosshair
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64206 ];

		return pClassPointer;
	};

};

UClass* UYCrosshair_GrenadeThrow::pClassPointer = NULL;

// Class SRGame.YCrosshair_MiniGun
// 0x0000 (0x0074 - 0x0074)
class UYCrosshair_MiniGun : public UYCrosshair_MachineGun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64235 ];

		return pClassPointer;
	};

};

UClass* UYCrosshair_MiniGun::pClassPointer = NULL;

// Class SRGame.YCrosshair_Pistol
// 0x0000 (0x0148 - 0x0148)
class UYCrosshair_Pistol : public UYCrosshair_Projectile
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64264 ];

		return pClassPointer;
	};

};

UClass* UYCrosshair_Pistol::pClassPointer = NULL;

// Class SRGame.YCrosshair_SMG
// 0x0000 (0x0148 - 0x0148)
class UYCrosshair_SMG : public UYCrosshair_Projectile
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64294 ];

		return pClassPointer;
	};

};

UClass* UYCrosshair_SMG::pClassPointer = NULL;

// Class SRGame.YCrossPlayerMessage
// 0x0030 (0x009C - 0x006C)
class UYCrossPlayerMessage : public UYLocalMessage
{
public:
	struct FString                                     m_attemptsOtherMessageBegin;                      		// 0x006C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_attemptsSpecOpsMessageBegin;                    		// 0x0078 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_attemptsMessageEnd;                             		// 0x0084 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_lastAttempt;                                    		// 0x0090 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64306 ];

		return pClassPointer;
	};

	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYCrossPlayerMessage::pClassPointer = NULL;

// Class SRGame.YCrowdPathNode
// 0x0000 (0x02D0 - 0x02D0)
class AYCrowdPathNode : public APathNode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64327 ];

		return pClassPointer;
	};

	void OnSetCrowdPath ( class UYSeqAct_SetCrowdPath* inAction );
	struct FString GetDebugAbbrev ( );
};

UClass* AYCrowdPathNode::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetCrowdPath
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_SetCrowdPath : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64332 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetCrowdPath::pClassPointer = NULL;

// Class SRGame.YDamageType_AA12
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_AA12 : public UYDamageType_Shotgun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64469 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_AA12::pClassPointer = NULL;

// Class SRGame.YDamageType_AssaultRifle
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_AssaultRifle : public UYDamageType_Projectile
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64471 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_AssaultRifle::pClassPointer = NULL;

// Class SRGame.YDamageType_AK47
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_AK47 : public UYDamageType_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64473 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_AK47::pClassPointer = NULL;

// Class SRGame.YDamageType_AK74
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_AK74 : public UYDamageType_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64475 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_AK74::pClassPointer = NULL;

// Class SRGame.YDamageType_SMG
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_SMG : public UYDamageType_Projectile
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64477 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_SMG::pClassPointer = NULL;

// Class SRGame.YDamageType_AKS74u
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_AKS74u : public UYDamageType_SMG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64479 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_AKS74u::pClassPointer = NULL;

// Class SRGame.YDamageType_BenelliM1014
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_BenelliM1014 : public UYDamageType_Shotgun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64482 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_BenelliM1014::pClassPointer = NULL;

// Class SRGame.YDamageType_Pistol
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Pistol : public UYDamageType_Projectile
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64487 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Pistol::pClassPointer = NULL;

// Class SRGame.YDamageType_DesertEagle50AE
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_DesertEagle50AE : public UYDamageType_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64489 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_DesertEagle50AE::pClassPointer = NULL;

// Class SRGame.YDamageType_FAMAS
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_FAMAS : public UYDamageType_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64495 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_FAMAS::pClassPointer = NULL;

// Class SRGame.YDamageType_FireExtinguisher
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_FireExtinguisher : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64497 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_FireExtinguisher::pClassPointer = NULL;

// Class SRGame.YDamageType_FNP45
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_FNP45 : public UYDamageType_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64499 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_FNP45::pClassPointer = NULL;

// Class SRGame.YDamageType_FNP90
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_FNP90 : public UYDamageType_SMG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64501 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_FNP90::pClassPointer = NULL;

// Class SRGame.YDamageType_Glock18
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Glock18 : public UYDamageType_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64503 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Glock18::pClassPointer = NULL;

// Class SRGame.YDamageType_HK417
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_HK417 : public UYDamageType_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64506 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_HK417::pClassPointer = NULL;

// Class SRGame.YDamageType_HnKUMP45
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_HnKUMP45 : public UYDamageType_SMG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64508 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_HnKUMP45::pClassPointer = NULL;

// Class SRGame.YDamageType_M110SniperSystem
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_M110SniperSystem : public UYDamageType_Sniper
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64511 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_M110SniperSystem::pClassPointer = NULL;

// Class SRGame.YDamageType_M4Carbine
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_M4Carbine : public UYDamageType_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64513 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_M4Carbine::pClassPointer = NULL;

// Class SRGame.YDamageType_M9A1
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_M9A1 : public UYDamageType_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64515 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_M9A1::pClassPointer = NULL;

// Class SRGame.YDamageType_Melee_MP
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Melee_MP : public UYDamageType_Melee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64517 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Melee_MP::pClassPointer = NULL;

// Class SRGame.YDamageType_MicroUzi
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_MicroUzi : public UYDamageType_SMG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64519 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_MicroUzi::pClassPointer = NULL;

// Class SRGame.YDamageType_MilkorMGL
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_MilkorMGL : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64521 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_MilkorMGL::pClassPointer = NULL;

// Class SRGame.YDamageType_Turret
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Turret : public UYDamageType_Projectile
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64523 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Turret::pClassPointer = NULL;

// Class SRGame.YDamageType_MiniGun
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_MiniGun : public UYDamageType_Turret
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64525 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_MiniGun::pClassPointer = NULL;

// Class SRGame.YDamageType_MiniGunOnFlight
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_MiniGunOnFlight : public UYDamageType_MiniGun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64527 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_MiniGunOnFlight::pClassPointer = NULL;

// Class SRGame.YDamageType_Mossberg590A1
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Mossberg590A1 : public UYDamageType_Shotgun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64529 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Mossberg590A1::pClassPointer = NULL;

// Class SRGame.YDamageType_MP7
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_MP7 : public UYDamageType_SMG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64531 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_MP7::pClassPointer = NULL;

// Class SRGame.YDamageType_MSG90
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_MSG90 : public UYDamageType_Sniper
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64533 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_MSG90::pClassPointer = NULL;

// Class SRGame.YDamageType_OTs14Groza
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_OTs14Groza : public UYDamageType_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64535 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_OTs14Groza::pClassPointer = NULL;

// Class SRGame.YDamageType_Percussion
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_Percussion : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64537 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_Percussion::pClassPointer = NULL;

// Class SRGame.YDamageType_ProjBounce
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_ProjBounce : public UYDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64539 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_ProjBounce::pClassPointer = NULL;

// Class SRGame.YDamageType_PythonElite
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_PythonElite : public UYDamageType_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64541 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_PythonElite::pClassPointer = NULL;

// Class SRGame.YDamageType_RageGrenade
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_RageGrenade : public UYDamageType_Grenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64543 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_RageGrenade::pClassPointer = NULL;

// Class SRGame.YDamageType_RPG
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_RPG : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64545 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_RPG::pClassPointer = NULL;

// Class SRGame.YDamageType_RPG_Chopper
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_RPG_Chopper : public UYDamageType_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64547 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_RPG_Chopper::pClassPointer = NULL;

// Class SRGame.YDamageType_SAW
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_SAW : public UYDamageType_Projectile
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64549 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_SAW::pClassPointer = NULL;

// Class SRGame.YDamageType_SawedOffShotgun
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_SawedOffShotgun : public UYDamageType_Shotgun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64551 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_SawedOffShotgun::pClassPointer = NULL;

// Class SRGame.YDamageType_SCAR
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_SCAR : public UYDamageType_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64553 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_SCAR::pClassPointer = NULL;

// Class SRGame.YDamageType_SIGP220
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_SIGP220 : public UYDamageType_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64555 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_SIGP220::pClassPointer = NULL;

// Class SRGame.YDamageType_SteyrElite
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_SteyrElite : public UYDamageType_Sniper
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64557 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_SteyrElite::pClassPointer = NULL;

// Class SRGame.YDamageType_TAR21
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_TAR21 : public UYDamageType_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64567 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_TAR21::pClassPointer = NULL;

// Class SRGame.YDamageType_TDIVector
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_TDIVector : public UYDamageType_SMG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64569 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_TDIVector::pClassPointer = NULL;

// Class SRGame.YDamageType_VaultMelee_MP
// 0x0000 (0x00C4 - 0x00C4)
class UYDamageType_VaultMelee_MP : public UYDamageType_Melee_MP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64572 ];

		return pClassPointer;
	};

};

UClass* UYDamageType_VaultMelee_MP::pClassPointer = NULL;

// Class SRGame.YDataProvider_DifficultyInfo
// 0x0040 (0x00CC - 0x008C)
class UYDataProvider_DifficultyInfo : public UYUIResourceDataProvider
{
public:
	unsigned char                                      m_level;                                          		// 0x008C (0x0001) [0x0000000000004000]              ( CPF_Config )
	struct FString                                     m_name;                                           		// 0x0090 (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_description;                                    		// 0x009C (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_image;                                          		// 0x00A8 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_imageSelected;                                  		// 0x00B4 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )
	struct FString                                     m_imageLocked;                                    		// 0x00C0 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64574 ];

		return pClassPointer;
	};

};

UClass* UYDataProvider_DifficultyInfo::pClassPointer = NULL;

// Class SRGame.YDataStore_GameSettingsMultiplayer
// 0x0000 (0x008C - 0x008C)
class UYDataStore_GameSettingsMultiplayer : public UUIDataStore_OnlineGameSettings
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64598 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_GameSettingsMultiplayer::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsBuried
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsBuried : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64633 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsBuried::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadBase
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadBase : public UOnlineStatsRead
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64637 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadBase::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadMode
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadMode : public UYLeaderboardReadBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64636 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadMode::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadBuried
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadBuried : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64635 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadBuried::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsChopper
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsChopper : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64638 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsChopper::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadChopper
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadChopper : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64640 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadChopper::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsCP
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsCP : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64641 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsCP::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadCP
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadCP : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64643 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadCP::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsDelivery
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsDelivery : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64644 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsDelivery::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadDelivery
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadDelivery : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64646 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadDelivery::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsDM
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsDM : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64647 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsDM::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadDM
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadDM : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64649 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadDM::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsHD
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsHD : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64650 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsHD::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadHD
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadHD : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64652 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadHD::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadKills
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadKills : public UYLeaderboardReadBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64653 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadKills::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsOffline
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsOffline : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64654 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsOffline::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadOffline
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadOffline : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64656 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadOffline::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsRP
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsRP : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64657 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsRP::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadRP
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadRP : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64659 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadRP::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsSDM
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsSDM : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64660 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsSDM::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadSDM
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadSDM : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64662 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadSDM::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsSpecialDelivery
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsSpecialDelivery : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64663 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsSpecialDelivery::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadSpecialDelivery
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadSpecialDelivery : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64665 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadSpecialDelivery::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsSpoils
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsSpoils : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64666 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsSpoils::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadSpoils
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadSpoils : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64668 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadSpoils::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsTDM
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsTDM : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64669 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsTDM::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadTDM
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadTDM : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64671 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadTDM::pClassPointer = NULL;

// Class SRGame.YDataStore_OnlineStatsTE
// 0x0000 (0x0114 - 0x0114)
class UYDataStore_OnlineStatsTE : public UYDataStore_OnlineStatsMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64672 ];

		return pClassPointer;
	};

};

UClass* UYDataStore_OnlineStatsTE::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadTE
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadTE : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64674 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadTE::pClassPointer = NULL;

// Class SRGame.YDBNORule_Coop
// 0x0000 (0x0068 - 0x0068)
class UYDBNORule_Coop : public UYDBNORule_SinglePlayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64683 ];

		return pClassPointer;
	};

};

UClass* UYDBNORule_Coop::pClassPointer = NULL;

// Class SRGame.YPerk_Survivor
// 0x0008 (0x0058 - 0x0050)
class UYPerk_Survivor : public UYPerk
{
public:
	int                                                m_maxNumberOfSelfRevives;                         		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_dbnoTimer;                                      		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64746 ];

		return pClassPointer;
	};

	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	void RemovePerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
};

UClass* UYPerk_Survivor::pClassPointer = NULL;

// Class SRGame.YDBNORule_Deathmatch
// 0x0000 (0x0074 - 0x0074)
class UYDBNORule_Deathmatch : public UYDBNORule_MultiPlayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64782 ];

		return pClassPointer;
	};

	unsigned char CheckForEnteringDBNO ( class AYGamePawn* pwn, class UClass* dmgTypeClass, struct FVector Momentum, float Damage, struct FTraceHitInfo HitInfo, class AController* Instigator, unsigned long wasHeadshot, unsigned long makesHeadExplode, unsigned char* enterCondition );
};

UClass* UYDBNORule_Deathmatch::pClassPointer = NULL;

// Class SRGame.YDBNORule_Exodus
// 0x0000 (0x0074 - 0x0074)
class UYDBNORule_Exodus : public UYDBNORule_CrossPlayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64797 ];

		return pClassPointer;
	};

};

UClass* UYDBNORule_Exodus::pClassPointer = NULL;

// Class SRGame.YDeathMessageParams
// 0x0018 (0x0054 - 0x003C)
class UYDeathMessageParams : public UObject
{
public:
	int                                                m_killFlags;                                      		// 0x003C (0x0004) [0x0000000000000000]              
	struct FString                                     m_usedWeaponChar;                                 		// 0x0040 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_weaponFontIndex;                                		// 0x004C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_damageType;                                     		// 0x0050 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64905 ];

		return pClassPointer;
	};

	bool HasKillFlag ( unsigned char flag );
	void SetKillFlag ( unsigned char flag );
	void ClearKillFlags ( );
};

UClass* UYDeathMessageParams::pClassPointer = NULL;

// Class SRGame.YDeathMessage_SP
// 0x0000 (0x0088 - 0x0088)
class UYDeathMessage_SP : public UYDeathMessage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 64917 ];

		return pClassPointer;
	};

	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYDeathMessage_SP::pClassPointer = NULL;

// Class SRGame.YPlayerController_Delivery
// 0x0008 (0x12A4 - 0x129C)
class AYPlayerController_Delivery : public AYPlayerController_MP
{
public:
	class UYSoundCueFMOD*                              m_DeliveryPackagePickup;                          		// 0x129C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSoundCueFMOD*                              m_DeliveryArmPackage;                             		// 0x12A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 65223 ];

		return pClassPointer;
	};

	void RemovePackageAndRespawn ( );
	float GetRemainingDetonateTime ( );
	float GetRemainingDisarmTime ( );
	float GetRemainingArmTime ( );
	float GetElapsedTime ( );
	void ResetArmingFlags ( );
	void SetBombAndStations ( int currentAttackingTeam );
	void StopDestroyPointAction ( );
	void ClientStopDestroyPointAction ( );
	void GetSpecialMoveMessages ( );
	void ServerDoExplode ( );
	void ServerDoDisarm ( class AYDeliveryPackage* DP );
	void CreateExplosion ( class AYDeliveryPackage* P );
	bool ConditionalDoDisarm ( );
	void ConditionalDoExplode ( );
	void ServerDoArm ( );
	bool ConditionalDoArm ( );
	void ClientIncrementKillStats ( class APlayerReplicationInfo* Killer, class APlayerReplicationInfo* Killed, class UClass* DamageType );
	void UpdateSpecialMoveButtonAction ( unsigned char buttonType, unsigned long updateNow );
	bool CheckHoldEnough ( float fTime );
	bool GamePad_StopContextSpecialMove ( );
	void OnJustDied ( class UClass* dmgType );
	void RespawnThePackage ( );
	class AYDeliveryPackage* SpawnThePackage ( unsigned char TeamID );
	void DisarmThePackage ( );
	void ArmThePackage ( );
	bool GamePad_StopPickup ( );
	void ServerStopDisarmExplosive ( );
	bool GamePad_Pickup ( );
	void ServerStartDisarmExplosive ( );
	bool GamePad_EndAContextSensativeMove ( );
	void ServerStopPlaceExplosive ( );
	bool GamePad_StartAContextSensativeMove ( );
	void ServerStartPlaceExplosive ( );
	void IsEnemyNearPackage ( );
	void CheckActivateDP ( );
	void OnPickupPackage ( class AYDeliveryPackage* P );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
};

UClass* AYPlayerController_Delivery::pClassPointer = NULL;

// Class SRGame.YHUD_TDM
// 0x0000 (0x0750 - 0x0750)
class AYHUD_TDM : public AYHUD_MP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 65228 ];

		return pClassPointer;
	};

	unsigned char GetMultiplayerModeId ( );
	void UpdateScorePanel ( );
	struct FString GetPermanentScoreString ( );
	void DisplaySpawnIndicator ( );
	void DrawGameHud ( float dt );
};

UClass* AYHUD_TDM::pClassPointer = NULL;

// Class SRGame.YHUD_Delivery
// 0x0000 (0x0750 - 0x0750)
class AYHUD_Delivery : public AYHUD_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 65227 ];

		return pClassPointer;
	};

	void UpdateScorePanel ( );
	unsigned char GetMultiplayerModeId ( );
	void PostRender ( );
	void DisplayCountdownClock ( );
	void ShowHasBombIcon ( unsigned long show );
	void DrawGameHud ( float dt );
};

UClass* AYHUD_Delivery::pClassPointer = NULL;

// Class SRGame.YIcon_DeliveryPackage
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_DeliveryPackage : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 65238 ];

		return pClassPointer;
	};

};

UClass* UYIcon_DeliveryPackage::pClassPointer = NULL;

// Class SRGame.YSeqEvt_HD_StationStateChanged
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_HD_StationStateChanged : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 65304 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_HD_StationStateChanged::pClassPointer = NULL;

// Class SRGame.YEffectInteractionItem
// 0x0020 (0x005C - 0x003C)
class UYEffectInteractionItem : public UObject
{
public:
	float                                              m_delay;                                          		// 0x003C (0x0004) [0x0000000000000000]              
	TArray< class AEmitter* >                          m_emitters;                                       		// 0x0040 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class AYAmbientSound* >                    m_sounds;                                         		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AYTrigger_EffectsInteraction*                m_interactionTrigger;                             		// 0x0058 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 65786 ];

		return pClassPointer;
	};

	void StopEffects ( );
	void StartEffects ( );
};

UClass* UYEffectInteractionItem::pClassPointer = NULL;

// Class SRGame.YEmitterPool
// 0x0000 (0x0250 - 0x0250)
class AYEmitterPool : public AEmitterPool
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 65798 ];

		return pClassPointer;
	};

};

UClass* AYEmitterPool::pClassPointer = NULL;

// Class SRGame.YExplodingEntity
// 0x0038 (0x0230 - 0x01F8)
class AYExplodingEntity : public AActor
{
public:
	class UParticleSystem*                             m_explosionEffectTemplate;                        		// 0x01F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UPointLightComponent*                        m_explosionLight;                                 		// 0x01FC (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_explosionLightDuration;                         		// 0x0200 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	class UYSoundCueFMOD*                              m_explosionSound;                                 		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_damagesEnabled : 1;                             		// 0x0208 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_selfDamage : 1;                                 		// 0x0208 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bTriggeringExplosion : 1;                       		// 0x0208 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	class UClass*                                      m_damageType;                                     		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_baseDamage;                                     		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxDamageRange;                                 		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minDamageRange;                                 		// 0x0218 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_ProjGroundDecalDesc                     m_explosionGroundDecal;                           		// 0x021C (0x0010) [0x0000000000000001]              ( CPF_Edit )
	class UYDamageEvaluationParams*                    m_damageEval;                                     		// 0x022C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 65820 ];

		return pClassPointer;
	};

	void ApplyDamages ( class AActor* Originator );
	void SwitchOffExplosionLight ( );
	void SpawnDecals ( );
	void PlayExplosionEffects ( );
	void InformPawns ( );
	void TriggerExplosion ( class AActor* Originator );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYExplodingEntity::pClassPointer = NULL;

// Class SRGame.YGameCrowdAgent
// 0x0000 (0x0448 - 0x0448)
class AYGameCrowdAgent : public AGameCrowdAgentSkeletal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 66253 ];

		return pClassPointer;
	};

	void PlayDeath ( struct FVector KillMomentum );
};

UClass* AYGameCrowdAgent::pClassPointer = NULL;

// Class SRGame.YOOMHandler
// 0x000C (0x0048 - 0x003C)
class UYOOMHandler : public UObject
{
public:
	TArray< struct FString >                           Commands;                                         		// 0x003C (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 66263 ];

		return pClassPointer;
	};

	void CatchOOM ( struct FString mainMemoryInUse );
	bool OOMMessageOptionSelected ( class UUIMessageBoxBase* Sender, struct FName SelectedOption, int PlayerIndex );
	void ExecOOMCommands ( );
};

UClass* UYOOMHandler::pClassPointer = NULL;

// Class SRGame.YObjectPoolScript
// 0x0000 (0x0850 - 0x0850)
class AYObjectPoolScript : public AYObjectPool
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 66613 ];

		return pClassPointer;
	};

	void CreateEmitterPool ( unsigned long bIsMultiplayer );
	void CreateMeshesMP ( );
	void CreateEmittersMP ( );
	void CreateMeshesSP ( );
	void CreateEmittersSP ( );
};

UClass* AYObjectPoolScript::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteBase
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteBase : public UOnlineStatsWrite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 66901 ];

		return pClassPointer;
	};

	void CopyAndWriteAllStats ( struct FUniqueNetId UniqId, class AYPlayerReplicationInfo_MP* PRI, unsigned long bIsPureServer, class UOnlineStatsInterface* StatsInterface );
	void CopyAllStats ( class AYPlayerReplicationInfo_MP* PRI );
};

UClass* UYLeaderboardWriteBase::pClassPointer = NULL;

// Class SRGame.YSeqEvt_SpawningPlayerSetArsenal
// 0x0024 (0x0134 - 0x0110)
class UYSeqEvt_SpawningPlayerSetArsenal : public USequenceEvent
{
public:
	unsigned long                                      m_shareArsenalOnBothTeams : 1;                    		// 0x0110 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FYS_MPTeamArsenal                           m_teamArsenals[ 0x2 ];                            		// 0x0114 (0x0020) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 66950 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_SpawningPlayerSetArsenal::pClassPointer = NULL;

// Class SRGame.YSeqEvt_MP_TimerEnded
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_MP_TimerEnded : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 67378 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_MP_TimerEnded::pClassPointer = NULL;

// Class SRGame.YSeqEvt_MP_TimerTick
// 0x0004 (0x0114 - 0x0110)
class UYSeqEvt_MP_TimerTick : public USequenceEvent
{
public:
	int                                                m_remaingingTime;                                 		// 0x0110 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 67383 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_MP_TimerTick::pClassPointer = NULL;

// Class SRGame.YSpawnArea
// 0x0001 (0x0235 - 0x0234)
class AYSpawnArea : public AVolume
{
public:
	unsigned char                                      m_spawningTeam;                                   		// 0x0234 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 67562 ];

		return pClassPointer;
	};

};

UClass* AYSpawnArea::pClassPointer = NULL;

// Class SRGame.YPerk_SpecOpsPerks
// 0x0018 (0x0068 - 0x0050)
class UYPerk_SpecOpsPerks : public UYPerk
{
public:
	float                                              m_meleeBonusXP;                                   		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_PistolDamageBonus;                              		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_ZiplineDamageReduction;                         		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_pistolAccuracyModifier;                         		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_armorSpeedIncrease;                             		// 0x0060 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_healthDropChance;                               		// 0x0064 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 67580 ];

		return pClassPointer;
	};

};

UClass* UYPerk_SpecOpsPerks::pClassPointer = NULL;

// Class SRGame.YSeqEvent_GameEnded
// 0x0004 (0x0114 - 0x0110)
class UYSeqEvent_GameEnded : public USequenceEvent
{
public:
	class AActor*                                      Winner;                                           		// 0x0110 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 67887 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqEvent_GameEnded::pClassPointer = NULL;

// Class SRGame.YSeqEvt_RoundEnded
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_RoundEnded : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 67904 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_RoundEnded::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteKills
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteKills : public UYLeaderboardWriteBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 67955 ];

		return pClassPointer;
	};

	void CopyAllStats ( class AYPlayerReplicationInfo_MP* PRI );
};

UClass* UYLeaderboardWriteKills::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteMode
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteMode : public UYLeaderboardWriteBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68007 ];

		return pClassPointer;
	};

	void CopyAllStats ( class AYPlayerReplicationInfo_MP* PRI );
	void CopyStreak ( class AYPlayerReplicationInfo_MP* PRI );
};

UClass* UYLeaderboardWriteMode::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteBuried
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteBuried : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68006 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteBuried::pClassPointer = NULL;

// Class SRGame.YHUD_Buried
// 0x0040 (0x0790 - 0x0750)
class AYHUD_Buried : public AYHUD_TDM
{
public:
	struct FLinearColor                                m_yourTeamIconColor;                              		// 0x0750 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	struct FLinearColor                                m_enemyTeamIconColor;                             		// 0x0760 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	struct FLinearColor                                m_unrevealedHVTColor;                             		// 0x0770 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	struct FLinearColor                                m_revealedHVTColor;                               		// 0x0780 (0x0010) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68008 ];

		return pClassPointer;
	};

	void UpdateScoreAsSequentialIcons ( int numberOfYourVitalPoints, int numberOfYourVitalPointsActive, int numberOfEnemyVitalPoints, int numberOfEnemyVitalPointsActive );
	void UpdateScoreAsIdentifierIcons ( int numberOfYourVitalPoints, int numberOfYourVitalPointsActive, int numberOfEnemyVitalPoints, int numberOfEnemyVitalPointsActive );
	void UpdateScoreAsText ( int numberOfYourVitalPoints, int numberOfYourVitalPointsActive, int numberOfEnemyVitalPoints, int numberOfEnemyVitalPointsActive );
	void UpdateScorePanel ( );
	unsigned char GetMultiplayerModeId ( );
};

UClass* AYHUD_Buried::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteModeTeam
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteModeTeam : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68075 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteModeTeam::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteChopper
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteChopper : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68074 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteChopper::pClassPointer = NULL;

// Class SRGame.YHUD_CA
// 0x0030 (0x0780 - 0x0750)
class AYHUD_CA : public AYHUD_TDM
{
public:
	struct FLinearColor                                m_teamIconColor;                                  		// 0x0750 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	struct FLinearColor                                m_enemyIconColor;                                 		// 0x0760 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	struct FLinearColor                                m_disabledIconColor;                              		// 0x0770 (0x0010) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68076 ];

		return pClassPointer;
	};

	void UpdateScoreAsText ( int numberOfSatellitesActive, int numberOfSatellites, int remainingHelicopters );
	void UpdateScoreAsIcons ( int numberOfSatellitesActive, int numberOfSatellites, int remainingHelicopters, int numberOfSatellitesUnderAttack );
	void UpdateScorePanel ( );
	unsigned char GetMultiplayerModeId ( );
};

UClass* AYHUD_CA::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteDM
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteDM : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68133 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteDM::pClassPointer = NULL;

// Class SRGame.YHUD_DM
// 0x0000 (0x0750 - 0x0750)
class AYHUD_DM : public AYHUD_MP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68134 ];

		return pClassPointer;
	};

	unsigned char GetMultiplayerModeId ( );
	void UpdateScorePanel ( );
	struct FString GetPermanentScoreString ( );
};

UClass* AYHUD_DM::pClassPointer = NULL;

// Class SRGame.YPlayerController_CoopDecoy
// 0x0000 (0x129C - 0x129C)
class AYPlayerController_CoopDecoy : public AYPlayerController_Coop
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68182 ];

		return pClassPointer;
	};

	void ClientSetHUD ( class UClass* newHUDType );
	void LoadAndSpawn ( struct FScriptDelegate in_delegate, unsigned long b_forceClientLoadSpawn );
};

UClass* AYPlayerController_CoopDecoy::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_Coop
// 0x0001 (0x05FD - 0x05FC)
class AYPlayerReplicationInfo_Coop : public AYPlayerReplicationInfo_MP
{
public:
	unsigned char                                      m_SquadTag;                                       		// 0x05FC (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68247 ];

		return pClassPointer;
	};

	bool NeedToLoadMeshes ( );
	void ClientAddPickupEventMessage ( struct FString Message, struct FString Icon, struct FString msg2 );
};

UClass* AYPlayerReplicationInfo_Coop::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteCP
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteCP : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68475 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteCP::pClassPointer = NULL;

// Class SRGame.YHUD_CP
// 0x0060 (0x07B0 - 0x0750)
class AYHUD_CP : public AYHUD_TDM
{
public:
	unsigned long                                      m_bDisplayRespawnTimer : 1;                       		// 0x0750 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	struct FString                                     m_eliteChallengeLevelText[ 0x6 ];                 		// 0x0754 (0x0048) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_sSkipChoreoMessage;                             		// 0x079C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	float                                              m_fCPInviteMsgDuration;                           		// 0x07A8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fCPInviteMsgFadeOutDuration;                    		// 0x07AC (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68476 ];

		return pClassPointer;
	};

	void NotifyHUDMatchStart ( );
	void SetInviteCPMessage ( unsigned long bShouldDisplayInvite );
	void UpdateSkipChoreo ( );
	unsigned char GetMultiplayerModeId ( );
	void SetCPKonradScore ( int iScore, int iPlayerRank, int iPlayersCount, int iClassLevel );
	void SetCPObjectif ( struct FString sObjectif );
	void SetCPChallengeProgression ( struct FString sEliteChallenge, int iEliteProgress, int iEliteTarget, int iBossProgress, int iBossTarget );
	void UpdateScorePanel ( );
	struct FString GetPermanentScoreString ( );
	void DisplayPermanentScore ( );
	void DrawGameHud ( float dt );
};

UClass* AYHUD_CP::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteTE
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteTE : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68567 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteTE::pClassPointer = NULL;

// Class SRGame.YHUD_TE
// 0x0000 (0x0750 - 0x0750)
class AYHUD_TE : public AYHUD_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68568 ];

		return pClassPointer;
	};

	void UpdateScorePanel ( );
	void SetPawn ( class APawn* Pawn );
	unsigned char GetMultiplayerModeId ( );
	bool ShouldDisplayWaitingForMatch ( );
};

UClass* AYHUD_TE::pClassPointer = NULL;

// Class SRGame.YGameInfo_ExodusCoop
// 0x0000 (0x0C8C - 0x0C8C)
class AYGameInfo_ExodusCoop : public AYGameInfo_CP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68569 ];

		return pClassPointer;
	};

	bool ProcessRoundEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
};

UClass* AYGameInfo_ExodusCoop::pClassPointer = NULL;

// Class SRGame.YGameInfo_ExodusVersus
// 0x0004 (0x0C90 - 0x0C8C)
class AYGameInfo_ExodusVersus : public AYGameInfo_CP
{
public:
	unsigned long                                      m_bMustReturnToLobbyToSwapTeam : 1;               		// 0x0C8C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68585 ];

		return pClassPointer;
	};

	bool ProcessRoundEnded ( class APlayerReplicationInfo* Winner, struct FString Reason );
};

UClass* AYGameInfo_ExodusVersus::pClassPointer = NULL;

// Class SRGame.YGameSettingsCampaign
// 0x0000 (0x00C4 - 0x00C4)
class UYGameSettingsCampaign : public UOnlineGameSettings
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68623 ];

		return pClassPointer;
	};

};

UClass* UYGameSettingsCampaign::pClassPointer = NULL;

// Class SRGame.YSeqEvent_CheckpointLoaded
// 0x0008 (0x0118 - 0x0110)
class UYSeqEvent_CheckpointLoaded : public USequenceEvent
{
public:
	struct FName                                       m_associatedCheckpoint;                           		// 0x0110 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68768 ];

		return pClassPointer;
	};

	bool ShouldTriggerFor ( struct FName InName );
};

UClass* UYSeqEvent_CheckpointLoaded::pClassPointer = NULL;

// Class SRGame.YSeqEvent_CheckpointLoadedFadeToWhite
// 0x0000 (0x0118 - 0x0118)
class UYSeqEvent_CheckpointLoadedFadeToWhite : public UYSeqEvent_CheckpointLoaded
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68769 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_CheckpointLoadedFadeToWhite::pClassPointer = NULL;

// Class SRGame.YPlayerController_HD
// 0x007C (0x1318 - 0x129C)
class AYPlayerController_HD : public AYPlayerController_MP
{
public:
	class AYDestroyPoint*                              m_currentDP;                                      		// 0x129C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_playerActionMessagesHD[ 0x5 ];                  		// 0x12A0 (0x003C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_playerInteractionMessagesHD[ 0x5 ];             		// 0x12DC (0x003C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68838 ];

		return pClassPointer;
	};

	float GetRemainingRepairTime ( );
	float GetRemainingSabotageTime ( );
	float GetElapsedTime ( );
	void StopDestroyPointAction ( );
	void ClientStopDestroyPointAction ( );
	void GetSpecialMoveMessages ( );
	void ServerSetInUse ( class AYDestroyPoint* DP, int bInUse );
	void ShowStationRepairedMessage ( unsigned long sameTeam, class APlayerReplicationInfo* repairer );
	void ServerDoRepair ( class AYDestroyPoint* DP );
	bool ConditionalDoRepair ( );
	void ShowStationSabotageMessage ( unsigned long sameTeam, class APlayerReplicationInfo* destroyer );
	void ServerDoSabotage ( class AYDestroyPoint* DP );
	void ServerAnnounceAttack ( int TeamNum );
	bool ConditionalDoSabotage ( );
	void UpdateSpecialMoveButtonAction ( unsigned char buttonType, unsigned long updateNow );
	bool CheckHoldEnough ( float fTime );
	bool GamePad_EndAContextSensativeMove ( );
	void ServerStopHackComputer ( );
	bool GamePad_StartAContextSensativeMove ( );
	void ServerStartHackComputer ( );
	bool GamePad_StopContextSpecialMove ( );
	void CheckActivateDP ( );
	float GetRespawnDelay ( );
	class AYDestroyPoint* GetMyDP ( );
	void NotifyTeamChanged ( );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
};

UClass* AYPlayerController_HD::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteHD
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteHD : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68849 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteHD::pClassPointer = NULL;

// Class SRGame.YHUD_HD
// 0x0004 (0x0754 - 0x0750)
class AYHUD_HD : public AYHUD_TDM
{
public:
	unsigned long                                      m_bPrevFrameFriendlyDescription : 1;              		// 0x0750 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bPrevFrameEnemyDescription : 1;                 		// 0x0750 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68850 ];

		return pClassPointer;
	};

	void UpdateScorePanel ( );
	unsigned char GetMultiplayerModeId ( );
};

UClass* AYHUD_HD::pClassPointer = NULL;

// Class SRGame.YGameInfo_Lobby
// 0x0014 (0x0B40 - 0x0B2C)
class AYGameInfo_Lobby : public AYGameInfo_MP
{
public:
	unsigned char                                      m_lastExodusMap;                                  		// 0x0B2C (0x0001) [0x0000000000004000]              ( CPF_Config )
	int                                                m_nLobbyTimeOut;                                  		// 0x0B30 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_nLobbyTimeOutForExodus;                         		// 0x0B34 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_nVoteTimeOut;                                   		// 0x0B38 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	int                                                m_RandomMapDrawCountMax;                          		// 0x0B3C (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68902 ];

		return pClassPointer;
	};

	void UpdateMuteList ( class AYPlayerController_MPBase* Other );
	void PreLogin ( struct FString Options, struct FString Address, struct FString* ErrorMessage );
	void StartStatSession ( );
	void UpdateGameSettingsCounts ( );
	void RemoveLingeringControllers ( );
	bool HasMinNetPlayers ( );
	void ForceControllerToBeReady ( class AYPlayerController_MPBase* PC );
	bool NeedPlayers ( );
	void HandleSeamlessTravelPlayer ( class AController** C );
	void ProcessPostMatch ( );
	bool IsLastMatchOver ( struct FName PreviousStateName );
	bool IsLastMatchWithExperienceSystem ( );
	void StartLobbyMapVote ( class AYGameReplicationInfo_MPBase* GRI, class UYGameSettingsMultiplayer* GameSettings );
	void UpdatePlayerRank ( );
	void LobbyMapVoteEnded ( );
	class UYGameSettingsMultiplayer* GetSettings ( );
	void TellClientsToReturnToPartyHost ( );
	void PreBeginPlay ( );
};

UClass* AYGameInfo_Lobby::pClassPointer = NULL;

// Class SRGame.YPlayerController_Lobby
// 0x0004 (0x111C - 0x1118)
class AYPlayerController_Lobby : public AYPlayerController_MPBase
{
public:
	unsigned long                                      m_bShouldExitReturnToOnlineMenu : 1;              		// 0x1118 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68950 ];

		return pClassPointer;
	};

	void ServerQuitCoopLobby ( );
	void ClientTravelToSession ( struct FName SessionName, class UClass* SearchClass, unsigned char* PlatformSpecificInfo );
	void ShowLeaveGameMessageBox ( struct FString Title, struct FString msg );
	void ClientReturnToParty ( struct FUniqueNetId RequestingPlayerId );
	void ClientSetOnlineStatus ( );
	void SpawnDefaultHUD ( );
	void Possess ( class APawn* inPawn, unsigned long bVehicleTransition );
	void ReceivedPlayer ( );
	void CancelMatchAndQuitToMainMenu ( struct FString ErrorTitle, struct FString ErrorMsg, unsigned long OnLoginChange, unsigned long forceMessageOnPS3 );
	bool ShouldExitReturnToOnlineMenu ( );
};

UClass* AYPlayerController_Lobby::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_Lobby
// 0x003C (0x06E4 - 0x06A8)
class AYGameReplicationInfo_Lobby : public AYGameReplicationInfo_MPBase
{
public:
	struct FYExodusScoreInfoReplicated                 m_exodusScores[ 0x5 ];                            		// 0x06A8 (0x003C) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 68997 ];

		return pClassPointer;
	};

	void Timer ( );
	void UpdateExodusScores ( );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYGameReplicationInfo_Lobby::pClassPointer = NULL;

// Class SRGame.YHUD_Menu
// 0x0000 (0x06D1 - 0x06D1)
class AYHUD_Menu : public AYHUD
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69033 ];

		return pClassPointer;
	};

	void DrawEngineHUD ( );
	void DrawHUD ( );
	void PostRender ( );
};

UClass* AYHUD_Menu::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_Lobby
// 0x0004 (0x04D4 - 0x04D0)
class AYPlayerReplicationInfo_Lobby : public AYPlayerReplicationInfo_MPBase
{
public:
	unsigned long                                      m_bReceivedXp : 1;                                		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bReceivedRank : 1;                              		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_clientInitialized : 1;                          		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69034 ];

		return pClassPointer;
	};

	void ServerSetMutedByRemote ( struct FUniqueNetId MutedPlayer, unsigned long muted );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
	bool ShouldBroadCastWelcomeMessage ( unsigned long bExiting );
	void UpdateCurrentRankLevelDatabinding ( );
	void OnXpInfoReplication ( );
	void ConditionnalOpenPostMatchScene ( );
	void ServerUnmuteAllPlayers ( );
	void ClientInitialize ( class AController* C );
};

UClass* AYPlayerReplicationInfo_Lobby::pClassPointer = NULL;

// Class SRGame.YGameInfo_LobbyQM
// 0x0000 (0x0B40 - 0x0B40)
class AYGameInfo_LobbyQM : public AYGameInfo_Lobby
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69035 ];

		return pClassPointer;
	};

};

UClass* AYGameInfo_LobbyQM::pClassPointer = NULL;

// Class SRGame.YPlayerController_Menu
// 0x0004 (0x111C - 0x1118)
class AYPlayerController_Menu : public AYPlayerController_MPBase
{
public:
	class UYProfileSettings*                           ProfileSettings;                                  		// 0x1118 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69047 ];

		return pClassPointer;
	};

	void ClientTakeDownWaitingForHostScreen ( );
	void LoadSettingsFromProfile ( unsigned long bLoadCharacter );
	void OnProfileWriteComplete ( unsigned char LocalUserNum, unsigned long bWasSuccessful );
	void ClientTravelToSession ( struct FName SessionName, class UClass* SearchClass, unsigned char* PlatformSpecificInfo );
	void ClearSaveOnlineProfileDelegate ( struct FScriptDelegate WriteProfileSettingsCompleteDelegate );
	void SaveOnlineProfile ( struct FScriptDelegate WriteProfileSettingsCompleteDelegate );
	void UnregisterPlayerDataStores ( );
	void RegisterCustomPlayerDataStores ( );
	void SetOtherProfilePresencesToIdle ( );
	void ClientSetOnlineStatusToCampaign ( );
	void ClientSetOnlineStatus ( );
	void Possess ( class APawn* inPawn, unsigned long bVehicleTransition );
	void ServerSetUniquePlayerId ( struct FUniqueNetId UniqueId, unsigned long bWasInvited );
	void InitUniquePlayerId ( );
};

UClass* AYPlayerController_Menu::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_Menu
// 0x0000 (0x04D0 - 0x04D0)
class AYPlayerReplicationInfo_Menu : public AYPlayerReplicationInfo_MPBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69134 ];

		return pClassPointer;
	};

	void UpdateTeamDataProvider ( );
};

UClass* AYPlayerReplicationInfo_Menu::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_Offline
// 0x0008 (0x0604 - 0x05FC)
class AYPlayerReplicationInfo_Offline : public AYPlayerReplicationInfo_MP
{
public:
	int                                                m_comStationsActivated;                           		// 0x05FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_comStationsDeactivated;                         		// 0x0600 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69159 ];

		return pClassPointer;
	};

	void Reset ( );
	void CopyProperties ( class APlayerReplicationInfo* PRI );
};

UClass* AYPlayerReplicationInfo_Offline::pClassPointer = NULL;

// Class SRGame.YPlayerController_Offline
// 0x0054 (0x12F0 - 0x129C)
class AYPlayerController_Offline : public AYPlayerController_MP
{
public:
	class AYComStation*                                m_currentComStation;                              		// 0x129C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_playerActionMessagesOffline[ 0x3 ];             		// 0x12A0 (0x0024) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_playerInteractionMessagesOffline[ 0x3 ];        		// 0x12C4 (0x0024) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	class UYSoundCueFMOD*                              m_OfflineDeactivateSound;                         		// 0x12E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSoundCueFMOD*                              m_OfflineReactivateSound;                         		// 0x12EC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69166 ];

		return pClassPointer;
	};

	float GetRemainingDeactivationTime ( );
	float GetRemainingActivationTime ( );
	float GetElapsedTime ( );
	void StopOfflineActions ( );
	void ServerDoActivate ( class AYComStation* CS );
	void ServerDoDeactivate ( class AYComStation* CS );
	void ServerAnnounceStationAttack ( class AYComStation* CS );
	void ServerSetInUse ( class AYComStation* CS, unsigned long bInUse );
	void ConditionalDoActivate ( );
	void ConditionalDoDeactivate ( );
	void GetSpecialMoveMessages ( );
	void UpdateSpecialMoveButtonAction ( unsigned char buttonType, unsigned long updateNow );
	bool CheckHoldEnough ( float fTime );
	bool GamePad_EndAContextSensativeMove ( );
	void ServerStopHackComputer ( );
	bool GamePad_StartAContextSensativeMove ( );
	void ServerStartHackComputer ( );
	void CheckActivateComStation ( );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
};

UClass* AYPlayerController_Offline::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteOffline
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteOffline : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69189 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteOffline::pClassPointer = NULL;

// Class SRGame.YHUD_Offline
// 0x0000 (0x0750 - 0x0750)
class AYHUD_Offline : public AYHUD_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69190 ];

		return pClassPointer;
	};

	void UpdateScorePanel ( );
	unsigned char GetMultiplayerModeId ( );
};

UClass* AYHUD_Offline::pClassPointer = NULL;

// Class SRGame.YGameInfo_Party
// 0x0000 (0x05E1 - 0x05E1)
class AYGameInfo_Party : public AYGameInfo_Menu
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69191 ];

		return pClassPointer;
	};

};

UClass* AYGameInfo_Party::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteRP
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteRP : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69228 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteRP::pClassPointer = NULL;

// Class SRGame.YHUD_RP
// 0x0018 (0x0768 - 0x0750)
class AYHUD_RP : public AYHUD_TDM
{
public:
	struct FString                                     m_changingCapturePointMessage;                    		// 0x0750 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_changeCapturePointTimerMessage;                 		// 0x075C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69229 ];

		return pClassPointer;
	};

	unsigned char GetMultiplayerModeId ( );
	void DisplayCapturePointTimer ( );
	void DrawGameHud ( float dt );
};

UClass* AYHUD_RP::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteSDM
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteSDM : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69285 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteSDM::pClassPointer = NULL;

// Class SRGame.YHUD_SDM
// 0x0024 (0x0774 - 0x0750)
class AYHUD_SDM : public AYHUD_TDM
{
public:
	int                                                m_PlayerMessageX;                                 		// 0x0750 (0x0004) [0x0000000000000000]              
	int                                                m_PlayerMessageYSpecops;                          		// 0x0754 (0x0004) [0x0000000000000000]              
	int                                                m_PlayerMessageYKonrad;                           		// 0x0758 (0x0004) [0x0000000000000000]              
	struct FString                                     m_respawningSquadMessage;                         		// 0x075C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_squadRespawnTimerMessage;                       		// 0x0768 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69286 ];

		return pClassPointer;
	};

	unsigned char GetMultiplayerModeId ( );
	void DisplayPlayerCount ( );
	void DisplayRespawnTimer ( );
	void DrawGameHud ( float dt );
};

UClass* AYHUD_SDM::pClassPointer = NULL;

// Class SRGame.YPlayerController_SW
// 0x0064 (0x1300 - 0x129C)
class AYPlayerController_SW : public AYPlayerController_MP
{
public:
	class UYSoundCueFMOD*                              m_SpoilsDepositSound;                             		// 0x129C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSoundCueFMOD*                              m_SpoilsPickupSound;                              		// 0x12A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYSoundCueFMOD*                              m_SpoilsStealSound;                               		// 0x12A4 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_weaponDroppedForPistol;                         		// 0x12A8 (0x0004) [0x0000000000000000]              
	int                                                m_startAmmoCount;                                 		// 0x12AC (0x0004) [0x0000000000000000]              
	int                                                m_maxAmmoCount;                                   		// 0x12B0 (0x0004) [0x0000000000000000]              
	class AYTrigger_GoldPointInteraction*              m_capturePoint;                                   		// 0x12B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_playerActionMessagesSW[ 0x3 ];                  		// 0x12B8 (0x0024) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_playerInteractionMessagesSW[ 0x3 ];             		// 0x12DC (0x0024) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69322 ];

		return pClassPointer;
	};

	float GetRemainingDepositTime ( );
	float GetElapsedTime ( );
	void StopGoldPointAction ( );
	void ClientStopGoldPointAction ( );
	void PostBeginPlay ( );
	void GetSpecialMoveMessages ( );
	void RespawnGold ( );
	void TossGold ( class AYGoldTreasurePointVolume* CP );
	void UpdateGoldCarried ( int numCarried );
	void OnGoldPickupDLC2 ( unsigned long wasStolen );
	void OnGoldPickup ( );
	void ForceLootCarryingWeapon ( );
	void ServerTossGold ( );
	bool GamePad_NextWeapon ( );
	void OnJustDied ( class UClass* dmgType );
	void ServerDoDeposit ( class AYGoldTreasurePointVolume* CP );
	bool ConditionalDoDeposit ( );
	void UpdateSpecialMoveButtonAction ( unsigned char buttonType, unsigned long updateNow );
	bool CheckHoldEnough ( float fTime );
	bool GamePad_EndAContextSensativeMove ( );
	bool GamePad_StartAContextSensativeMove ( );
	void CheckActivateGP ( );
	bool GamePad_StopPickup ( );
	bool GamePad_Pickup ( );
	class AYGoldTreasurePointVolume* GetMyGP ( );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
};

UClass* AYPlayerController_SW::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteSpoils
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteSpoils : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69343 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteSpoils::pClassPointer = NULL;

// Class SRGame.YHUD_SW
// 0x000C (0x075C - 0x0750)
class AYHUD_SW : public AYHUD_TDM
{
public:
	struct FString                                     m_bankedString;                                   		// 0x0750 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69344 ];

		return pClassPointer;
	};

	unsigned char GetMultiplayerModeId ( );
	void UpdateScorePanel ( );
	void SetGoldAmount ( int Amount );
	void SetVisible ( unsigned long show );
};

UClass* AYHUD_SW::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteTDM
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteTDM : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69354 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteTDM::pClassPointer = NULL;

// Class SRGame.YGameInfo_TDMS
// 0x0000 (0x0B2C - 0x0B2C)
class AYGameInfo_TDMS : public AYGameInfo_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 69355 ];

		return pClassPointer;
	};

};

UClass* AYGameInfo_TDMS::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_LobbyQM
// 0x0000 (0x06E4 - 0x06E4)
class AYGameReplicationInfo_LobbyQM : public AYGameReplicationInfo_Lobby
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 70112 ];

		return pClassPointer;
	};

};

UClass* AYGameReplicationInfo_LobbyQM::pClassPointer = NULL;

// Class SRGame.YGameReplicationInfo_Party
// 0x0000 (0x0570 - 0x0570)
class AYGameReplicationInfo_Party : public AYGameReplicationInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 70157 ];

		return pClassPointer;
	};

};

UClass* AYGameReplicationInfo_Party::pClassPointer = NULL;

// Class SRGame.YGoldDepot
// 0x0018 (0x0210 - 0x01F8)
class AYGoldDepot : public AActor
{
public:
	float                                              m_fGoldRespawnTime;                               		// 0x01F8 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPercentChanceSmall;                            		// 0x01FC (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPercentChanceMedium;                           		// 0x0200 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_fPercentChanceLarge;                            		// 0x0204 (0x0004) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bLastActive : 1;                                		// 0x0208 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bActive : 1;                                    		// 0x0208 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bHasPickup : 1;                                 		// 0x0208 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	class AYPickupGold*                                m_Pickup;                                         		// 0x020C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 70191 ];

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void GoldRespawn ( );
	void Tick ( float DeltaTime );
	void SetDepotActive ( unsigned long Active );
	void CreatePickup ( );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYGoldDepot::pClassPointer = NULL;

// Class SRGame.YGameSearchDM
// 0x0000 (0x0104 - 0x0104)
class UYGameSearchDM : public UYGameSearchCommon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 70417 ];

		return pClassPointer;
	};

};

UClass* UYGameSearchDM::pClassPointer = NULL;

// Class SRGame.YGameSettingsDM
// 0x0000 (0x00D8 - 0x00D8)
class UYGameSettingsDM : public UYGameSettingsMultiplayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 70419 ];

		return pClassPointer;
	};

};

UClass* UYGameSettingsDM::pClassPointer = NULL;

// Class SRGame.YGameSearchJoinFromInvite
// 0x0000 (0x0104 - 0x0104)
class UYGameSearchJoinFromInvite : public UOnlineGameSearch
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 70420 ];

		return pClassPointer;
	};

};

UClass* UYGameSearchJoinFromInvite::pClassPointer = NULL;

// Class SRGame.YGameSearchQM
// 0x0000 (0x0104 - 0x0104)
class UYGameSearchQM : public UYGameSearchMultiplayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 70575 ];

		return pClassPointer;
	};

};

UClass* UYGameSearchQM::pClassPointer = NULL;

// Class SRGame.YTrigger_GoldPointInteraction
// 0x0004 (0x0208 - 0x0204)
class AYTrigger_GoldPointInteraction : public AYTrigger_Interaction
{
public:
	class AYGoldTreasurePointVolume*                   m_goldPoint;                                      		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 71006 ];

		return pClassPointer;
	};

};

UClass* AYTrigger_GoldPointInteraction::pClassPointer = NULL;

// Class SRGame.YHUD_Coop
// 0x0000 (0x0750 - 0x0750)
class AYHUD_Coop : public AYHUD_DM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 71289 ];

		return pClassPointer;
	};

	void AddMessage ( struct FString Message, int colorID );
	void UpdateDBNOIndicators ( );
	void DrawGameHud ( float dt );
	void SetShowScores ( unsigned long bNewValue );
	unsigned char GetMultiplayerModeId ( );
	void UpdateScorePanel ( );
	struct FString GetPermanentScoreString ( );
	void AddPickupEventMessage ( struct FString Message, struct FString Icon, struct FString msg2 );
};

UClass* AYHUD_Coop::pClassPointer = NULL;

// Class SRGame.YXPMessage
// 0x0008 (0x0074 - 0x006C)
class UYXPMessage : public UYLocalMessage
{
public:
	struct FColor                                      m_xpIncreaseColor;                                		// 0x006C (0x0004) [0x0000000000000000]              
	struct FColor                                      m_xpLossColor;                                    		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 71714 ];

		return pClassPointer;
	};

	struct FColor GetColor ( int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYXPMessage::pClassPointer = NULL;

// Class SRGame.YXPEventMessage
// 0x0000 (0x0074 - 0x0074)
class UYXPEventMessage : public UYXPMessage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 71715 ];

		return pClassPointer;
	};

	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYXPEventMessage::pClassPointer = NULL;

// Class SRGame.YUIScene_Coop_MatchResult
// 0x0018 (0x075C - 0x0744)
class UYUIScene_Coop_MatchResult : public UYUIScenes
{
public:
	class UUIPanel*                                    m_LosePanel;                                      		// 0x0744 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_WinPanel;                                       		// 0x0748 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_MenuList;                                       		// 0x074C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_winMessageLabel;                                		// 0x0750 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_loseMessageLabel;                               		// 0x0754 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_pnlButtonBar;                                   		// 0x0758 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72190 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void SetLoseCondition ( struct FName msg );
	void SetWinCondition ( struct FName msg );
	void SelectQuitGame ( );
	void SelectRestartGame ( );
	void OnSelectItem ( int PlayerIndex );
	void OnMenu_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void OnMenu_ItemChosen ( class UYSimpleList* SourceList, int SelectedIndex, int PlayerIndex );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void BeginSceneLostFocusAnimation ( );
	void SceneActivated ( unsigned long bInitialActivation );
	bool OnSelectClicked ( class UUIScreenObject* InButton, int InPlayerIndex );
	void InitWidgetRef ( );
	void PostInitialize ( );
};

UClass* UYUIScene_Coop_MatchResult::pClassPointer = NULL;

// Class SRGame.YUIScene_HUD_Life_SP_Coop
// 0x0000 (0x0A94 - 0x0A94)
class UYUIScene_HUD_Life_SP_Coop : public UYUIScene_HUD_Life_SP
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72209 ];

		return pClassPointer;
	};

	void AddMessage ( struct FString sMessage, int colorName );
	void AddKillEventMessage ( class AYPlayerReplicationInfo* killerPRI, class AYPlayerReplicationInfo* victimPRI, class UYDeathMessageParams* Params );
	class UUILabel* GetCoopLabel_Counter_numbers ( );
	class UUILabel* GetCoopLabel_Counter_title ( );
	class UUILabel* GetCoopLabel_Timer ( );
	class UUILabel* GetCoopLabel__Objective ( );
	class UUIPanel* GetCoopPanel__Hide ( );
	void InitializeCoopWidgets ( );
};

UClass* UYUIScene_HUD_Life_SP_Coop::pClassPointer = NULL;

// Class SRGame.YHUD_ExodusVersus
// 0x000C (0x07BC - 0x07B0)
class AYHUD_ExodusVersus : public AYHUD_CP
{
public:
	class UYUIScene_MatchSummary*                      MatchSummarySceneTemplate;                        		// 0x07B0 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_matchSummaryDelay;                              		// 0x07B4 (0x0004) [0x0000000000004000]              ( CPF_Config )
	class UYUIScene_Scoreboard_ExodusVersus*           RoundSummarySceneTemplate;                        		// 0x07B8 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72383 ];

		return pClassPointer;
	};

	void ShowMatchEndScoreboard ( );
	void SetShowScores ( unsigned long bNewValue );
	void ShowMatchSummary ( );
};

UClass* AYHUD_ExodusVersus::pClassPointer = NULL;

// Class SRGame.YUIScene_Scoreboard_ExodusVersus
// 0x0018 (0x078C - 0x0774)
class UYUIScene_Scoreboard_ExodusVersus : public UYUIFrontEnd
{
public:
	class UUILabel*                                    m_lblOutcome;                                     		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblKonradText;                                  		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTotalScore;                                  		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblDFOScore;                                    		// 0x0780 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblOCScore;                                     		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSBScore;                                     		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72385 ];

		return pClassPointer;
	};

	void Cancel ( int ControllerId );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnSelectItem ( int PlayerIndex );
	void InitWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIScene_Scoreboard_ExodusVersus::pClassPointer = NULL;

// Class SRGame.YUIScene_MatchSummary
// 0x002C (0x07A0 - 0x0774)
class UYUIScene_MatchSummary : public UYUIFrontEnd
{
public:
	class UUILabel*                                    m_lblOutcome;                                     		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FTeamResults                                m_TeamResults[ 0x2 ];                             		// 0x0778 (0x0020) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTeams[ 0x2 ];                                		// 0x0798 (0x0008) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72388 ];

		return pClassPointer;
	};

	void InitWidget ( );
	void InitTeamWidgets ( );
	void InitTeamWidgetRef ( class UUIPanel* pnl, struct FTeamResults* teamRes );
	void InitWidgetRef ( );
};

UClass* UYUIScene_MatchSummary::pClassPointer = NULL;

// Class SRGame.YHUD_Revival
// 0x0000 (0x0750 - 0x0750)
class AYHUD_Revival : public AYHUD_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72550 ];

		return pClassPointer;
	};

};

UClass* AYHUD_Revival::pClassPointer = NULL;

// Class SRGame.YIcon_AdrenalineBoost
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_AdrenalineBoost : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72795 ];

		return pClassPointer;
	};

};

UClass* UYIcon_AdrenalineBoost::pClassPointer = NULL;

// Class SRGame.YIcon_AttackBase_Marker
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_AttackBase_Marker : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72842 ];

		return pClassPointer;
	};

};

UClass* UYIcon_AttackBase_Marker::pClassPointer = NULL;

// Class SRGame.YIcon_GameplayIconBase
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_GameplayIconBase : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72845 ];

		return pClassPointer;
	};

};

UClass* UYIcon_GameplayIconBase::pClassPointer = NULL;

// Class SRGame.YIcon_AttackTarget
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_AttackTarget : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72847 ];

		return pClassPointer;
	};

};

UClass* UYIcon_AttackTarget::pClassPointer = NULL;

// Class SRGame.YIcon_Bomb
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_Bomb : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72849 ];

		return pClassPointer;
	};

};

UClass* UYIcon_Bomb::pClassPointer = NULL;

// Class SRGame.YIcon_BreachDoor
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_BreachDoor : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72853 ];

		return pClassPointer;
	};

};

UClass* UYIcon_BreachDoor::pClassPointer = NULL;

// Class SRGame.YIcon_Buff
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_Buff : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72856 ];

		return pClassPointer;
	};

};

UClass* UYIcon_Buff::pClassPointer = NULL;

// Class SRGame.YIcon_ClearArea
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_ClearArea : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72859 ];

		return pClassPointer;
	};

};

UClass* UYIcon_ClearArea::pClassPointer = NULL;

// Class SRGame.YIcon_Gold
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_Gold : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72878 ];

		return pClassPointer;
	};

};

UClass* UYIcon_Gold::pClassPointer = NULL;

// Class SRGame.YIcon_Gold_Marker
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_Gold_Marker : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72881 ];

		return pClassPointer;
	};

};

UClass* UYIcon_Gold_Marker::pClassPointer = NULL;

// Class SRGame.YIcon_Heal
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_Heal : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72899 ];

		return pClassPointer;
	};

};

UClass* UYIcon_Heal::pClassPointer = NULL;

// Class SRGame.YIcon_Info
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_Info : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72902 ];

		return pClassPointer;
	};

};

UClass* UYIcon_Info::pClassPointer = NULL;

// Class SRGame.YIcon_MortarTarget
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_MortarTarget : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72917 ];

		return pClassPointer;
	};

};

UClass* UYIcon_MortarTarget::pClassPointer = NULL;

// Class SRGame.YIcon_MP_C4Throw
// 0x0000 (0x01F8 - 0x01F8)
class UYIcon_MP_C4Throw : public UYIcon_MP_GrenadeThrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72942 ];

		return pClassPointer;
	};

};

UClass* UYIcon_MP_C4Throw::pClassPointer = NULL;

// Class SRGame.YIcon_MP_Dead
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_MP_Dead : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72955 ];

		return pClassPointer;
	};

};

UClass* UYIcon_MP_Dead::pClassPointer = NULL;

// Class SRGame.YIcon_MP_GrenadeThrow_Frag
// 0x0000 (0x01F8 - 0x01F8)
class UYIcon_MP_GrenadeThrow_Frag : public UYIcon_MP_GrenadeThrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72958 ];

		return pClassPointer;
	};

};

UClass* UYIcon_MP_GrenadeThrow_Frag::pClassPointer = NULL;

// Class SRGame.YIcon_MP_GrenadeThrow_Sticky
// 0x0000 (0x01F8 - 0x01F8)
class UYIcon_MP_GrenadeThrow_Sticky : public UYIcon_MP_GrenadeThrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72960 ];

		return pClassPointer;
	};

};

UClass* UYIcon_MP_GrenadeThrow_Sticky::pClassPointer = NULL;

// Class SRGame.YIcon_MP_GrenadeThrow_Stun
// 0x0000 (0x01F8 - 0x01F8)
class UYIcon_MP_GrenadeThrow_Stun : public UYIcon_MP_GrenadeThrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72964 ];

		return pClassPointer;
	};

};

UClass* UYIcon_MP_GrenadeThrow_Stun::pClassPointer = NULL;

// Class SRGame.YIcon_MP_MineExploding
// 0x0000 (0x01F8 - 0x01F8)
class UYIcon_MP_MineExploding : public UYIcon_MP_GrenadeThrow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72975 ];

		return pClassPointer;
	};

};

UClass* UYIcon_MP_MineExploding::pClassPointer = NULL;

// Class SRGame.YIcon_MP_OfficerOrders
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_MP_OfficerOrders : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72979 ];

		return pClassPointer;
	};

};

UClass* UYIcon_MP_OfficerOrders::pClassPointer = NULL;

// Class SRGame.YIcon_MP_OfficerSupply
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_MP_OfficerSupply : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72982 ];

		return pClassPointer;
	};

};

UClass* UYIcon_MP_OfficerSupply::pClassPointer = NULL;

// Class SRGame.YIcon_RadioBase_Marker
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_RadioBase_Marker : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72984 ];

		return pClassPointer;
	};

};

UClass* UYIcon_RadioBase_Marker::pClassPointer = NULL;

// Class SRGame.YIcon_RocketWarning
// 0x0000 (0x01B8 - 0x01B8)
class UYIcon_RocketWarning : public UYIcon_SquadDBNO
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72995 ];

		return pClassPointer;
	};

};

UClass* UYIcon_RocketWarning::pClassPointer = NULL;

// Class SRGame.YIcon_SandAvalance
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_SandAvalance : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 72998 ];

		return pClassPointer;
	};

};

UClass* UYIcon_SandAvalance::pClassPointer = NULL;

// Class SRGame.YIcon_ShootExplosive
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_ShootExplosive : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73001 ];

		return pClassPointer;
	};

};

UClass* UYIcon_ShootExplosive::pClassPointer = NULL;

// Class SRGame.YIcon_ShootThis
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_ShootThis : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73004 ];

		return pClassPointer;
	};

};

UClass* UYIcon_ShootThis::pClassPointer = NULL;

// Class SRGame.YIcon_SilentAttack
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_SilentAttack : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73007 ];

		return pClassPointer;
	};

};

UClass* UYIcon_SilentAttack::pClassPointer = NULL;

// Class SRGame.YIcon_SniperAttack
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_SniperAttack : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73010 ];

		return pClassPointer;
	};

};

UClass* UYIcon_SniperAttack::pClassPointer = NULL;

// Class SRGame.YIcon_UseC4
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_UseC4 : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73013 ];

		return pClassPointer;
	};

};

UClass* UYIcon_UseC4::pClassPointer = NULL;

// Class SRGame.YIcon_VP_Uplink_Marker
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_VP_Uplink_Marker : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73018 ];

		return pClassPointer;
	};

};

UClass* UYIcon_VP_Uplink_Marker::pClassPointer = NULL;

// Class SRGame.YIcon_Warning
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_Warning : public UYIcon_GameplayIconBase
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73020 ];

		return pClassPointer;
	};

};

UClass* UYIcon_Warning::pClassPointer = NULL;

// Class SRGame.YIcon_WeaponPickup
// 0x0000 (0x01A8 - 0x01A8)
class UYIcon_WeaponPickup : public UYMarkerIcon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73024 ];

		return pClassPointer;
	};

};

UClass* UYIcon_WeaponPickup::pClassPointer = NULL;

// Class SRGame.YIniLocPatcherMcp
// 0x000C (0x00B8 - 0x00AC)
class UYIniLocPatcherMcp : public UIniLocPatcherMcp
{
public:
	struct FScriptDelegate                             __OnReadManifestComplete__Delegate;               		// 0x00AC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73170 ];

		return pClassPointer;
	};

	void OnReadFilesCompleted ( );
	void ShowUpdatingUI ( );
	void OnReadFileComplete ( unsigned long bWasSuccessful, struct FString Filename );
	void DownloadFiles ( );
	void OnReadFilesStarted ( );
	void ReadManifestComplete ( unsigned long bWasSuccessful, TArray< unsigned char > manifest );
	void OnConnectionStatusChange ( unsigned char NewStatus, struct FUniqueNetId NewId );
	void BeginLiveTuning ( );
	void Init ( );
	void OnReadManifestComplete ( unsigned long bWasSuccessful, TArray< unsigned char > manifest );
};

UClass* UYIniLocPatcherMcp::pClassPointer = NULL;

// Class SRGame.YIPSGNode
// 0x0000 (0x003C - 0x003C)
class UYIPSGNode : public UInterface
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73216 ];

		return pClassPointer;
	};

};

UClass* UYIPSGNode::pClassPointer = NULL;

// Class SRGame.YKActorFromStaticTriggerVolume
// 0x001C (0x0250 - 0x0234)
class AYKActorFromStaticTriggerVolume : public AVolume
{
public:
	struct FVector                                     m_ImpulseDirection;                               		// 0x0234 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_ImpulseMagnitude;                               		// 0x0240 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_ImpulseLocation;                                		// 0x0244 (0x000C) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73241 ];

		return pClassPointer;
	};

	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* AYKActorFromStaticTriggerVolume::pClassPointer = NULL;

// Class SRGame.YKillerMessage
// 0x0050 (0x00BC - 0x006C)
class UYKillerMessage : public UYLocalMessage
{
public:
	struct FString                                     YouKilled;                                        		// 0x006C (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     YouKilledTrailer;                                 		// 0x0078 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     YouTeamKilled;                                    		// 0x0084 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     YouTeamKilledTrailer;                             		// 0x0090 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     YouSpawnKilled;                                   		// 0x009C (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     YouSpawnKilledTrailer;                            		// 0x00A8 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FColor                                      m_standardKillColor;                              		// 0x00B4 (0x0004) [0x0000000000000000]              
	struct FColor                                      m_invalidKillColor;                               		// 0x00B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73253 ];

		return pClassPointer;
	};

	struct FColor GetColor ( int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYKillerMessage::pClassPointer = NULL;

// Class SRGame.YKismetUtils
// 0x0000 (0x003C - 0x003C)
class UYKismetUtils : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73276 ];

		return pClassPointer;
	};

	void GetPawnVars ( class USequenceOp* Sequence, struct FString Desc, TArray< class AYGamePawn* >* pawnVars );
};

UClass* UYKismetUtils::pClassPointer = NULL;

// Class SRGame.YLeaderboardClanTag
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardClanTag : public UOnlineStatsRead
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73288 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardClanTag::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadBuriedKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadBuriedKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73599 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadBuriedKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadBuriedSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadBuriedSpecops : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73601 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadBuriedSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadChopperKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadChopperKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73604 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadChopperKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadChopperSpecOps
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadChopperSpecOps : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73606 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadChopperSpecOps::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadCPKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadCPKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73609 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadCPKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadCPSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadCPSpecops : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73611 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadCPSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadDeliveryKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadDeliveryKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73614 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadDeliveryKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadDeliverySpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadDeliverySpecops : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73616 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadDeliverySpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadDMKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadDMKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73619 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadDMKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadDMSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadDMSpecops : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73621 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadDMSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadHDKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadHDKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73624 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadHDKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadHDSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadHDSpecops : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73626 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadHDSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadKillsKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadKillsKonrad : public UYLeaderboardReadKills
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73629 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadKillsKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadKillsSpecOps
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadKillsSpecOps : public UYLeaderboardReadKills
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73631 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadKillsSpecOps::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadOfflineKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadOfflineKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73634 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadOfflineKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadOfflineSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadOfflineSpecops : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73636 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadOfflineSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadRPKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadRPKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73639 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadRPKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadRPSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadRPSpecops : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73641 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadRPSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadSDMKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadSDMKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73644 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadSDMKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadSDMSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadSDMSpecops : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73646 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadSDMSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadSpecialDeliveryKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadSpecialDeliveryKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73649 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadSpecialDeliveryKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadSpecialDeliverySpecOps
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadSpecialDeliverySpecOps : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73651 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadSpecialDeliverySpecOps::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadSpoilsKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadSpoilsKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73654 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadSpoilsKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadSpoilsSpecOps
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadSpoilsSpecOps : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73656 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadSpoilsSpecOps::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadTDMKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadTDMKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73659 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadTDMKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadTDMSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadTDMSpecops : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73661 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadTDMSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadTEKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadTEKonrad : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73664 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadTEKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardReadTESpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardReadTESpecops : public UYLeaderboardReadMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73666 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardReadTESpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteBuriedKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteBuriedKonrad : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73756 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteBuriedKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteBuriedSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteBuriedSpecops : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73758 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteBuriedSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteChopperKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteChopperKonrad : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73762 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteChopperKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteChopperSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteChopperSpecops : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73764 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteChopperSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteCPKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteCPKonrad : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73767 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteCPKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteCPSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteCPSpecops : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73769 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteCPSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteDelivery
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteDelivery : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73771 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteDelivery::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteDeliveryKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteDeliveryKonrad : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73773 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteDeliveryKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteDeliverySpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteDeliverySpecops : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73775 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteDeliverySpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteDMKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteDMKonrad : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73778 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteDMKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteDMSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteDMSpecops : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73780 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteDMSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteHDKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteHDKonrad : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73783 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteHDKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteHDSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteHDSpecops : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73785 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteHDSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteKillsKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteKillsKonrad : public UYLeaderboardWriteKills
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73791 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteKillsKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteKillsSpecOps
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteKillsSpecOps : public UYLeaderboardWriteKills
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73793 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteKillsSpecOps::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteOfflineKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteOfflineKonrad : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73796 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteOfflineKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteOfflineSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteOfflineSpecops : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73798 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteOfflineSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteRPKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteRPKonrad : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73801 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteRPKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteRPSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteRPSpecops : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73803 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteRPSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteSDMKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteSDMKonrad : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73806 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteSDMKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteSDMSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteSDMSpecops : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73808 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteSDMSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteSpecialDelivery
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteSpecialDelivery : public UYLeaderboardWriteMode
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73810 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteSpecialDelivery::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteSpecialDeliveryKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteSpecialDeliveryKonrad : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73812 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteSpecialDeliveryKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteSpecialDeliverySpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteSpecialDeliverySpecops : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73814 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteSpecialDeliverySpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteSpoilsKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteSpoilsKonrad : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73817 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteSpoilsKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteSpoilsSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteSpoilsSpecops : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73819 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteSpoilsSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteTDMKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteTDMKonrad : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73822 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteTDMKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteTDMSpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteTDMSpecops : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73824 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteTDMSpecops::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteTEKonrad
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteTEKonrad : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73827 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteTEKonrad::pClassPointer = NULL;

// Class SRGame.YLeaderboardWriteTESpecops
// 0x0000 (0x0088 - 0x0088)
class UYLeaderboardWriteTESpecops : public UYLeaderboardWriteModeTeam
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73829 ];

		return pClassPointer;
	};

};

UClass* UYLeaderboardWriteTESpecops::pClassPointer = NULL;

// Class SRGame.YMatchmakingBaseComponent
// 0x000C (0x0048 - 0x003C)
class UYMatchmakingBaseComponent : public UObject
{
public:
	class UYMatchmakingManager*                        m_MatchmakingMgr;                                 		// 0x003C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UOnlineSubsystemCommonImpl*                  m_OnlineSubCommon;                                		// 0x0040 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bInAsyncWork : 1;                               		// 0x0044 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 73977 ];

		return pClassPointer;
	};

	void Reset ( );
	bool IsPlayerInTeamList ( struct FUniqueNetId PlayerUId, TArray< struct FPlayerReservation >* TeamList );
	int UpdateTeamListIndex ( TArray< class ATeamInfo* > Teams, TArray< class APlayerReplicationInfo* > PRIs, int TeamNum, TArray< struct FPlayerReservation >* TeamList );
	bool IsZeroId ( struct FUniqueNetId Id );
	int GetOppositTeam ( int TeamNum );
	bool InitComponent ( class UYMatchmakingManager* MatchmakingMgr, class UOnlineSubsystemCommonImpl* OnlineSubCommon );
};

UClass* UYMatchmakingBaseComponent::pClassPointer = NULL;

// Class SRGame.YMatchmakingHostComponent
// 0x0025 (0x006D - 0x0048)
class UYMatchmakingHostComponent : public UYMatchmakingBaseComponent
{
public:
	class UPartyBeaconHost*                            m_HostSessionReservationBeacon;                   		// 0x0048 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bHostBeaconTellClientsToTravel : 1;             		// 0x004C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bAllowStartWithNonFullReservation : 1;          		// 0x004C (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_bInGameHosting : 1;                             		// 0x004C (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                m_HostControllerIndex;                            		// 0x0050 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_HostTeamNum;                                    		// 0x0054 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_MaxIdleHostTime;                                		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_IdleHostTime;                                   		// 0x005C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_HostFullname;                                   		// 0x0060 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      m_chosenMap;                                      		// 0x006C (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 74014 ];

		return pClassPointer;
	};

	bool CanJoinPlayableTeam_MP ( unsigned char TeamNum, class AController* C, unsigned long bBalanceTeams, class UYGameSettingsMultiplayer* GameSettings );
	bool CanSwitchToPlayableTeam_MP ( unsigned char DesiredTeamNum, class AController* C, class UYGameSettingsMultiplayer* GameSettings, int MinPlayerInTeam );
	unsigned char PickTeam_HRD ( unsigned char DesiredTeamNum, class AController* C, class UYGameSettingsMultiplayer* GameSettings );
	unsigned char PickTeam_CP ( unsigned char DesiredTeamNum, class AController* C, unsigned long bBalanceTeams, class UYGameSettingsMultiplayer* GameSettings );
	unsigned char PickTeam_Versus ( unsigned char DesiredTeamNum, class AController* C, unsigned long bBalanceTeams, class UYGameSettingsMultiplayer* GameSettings );
	unsigned char PickTeam_MP ( unsigned char DesiredTeamNum, class AController* C, unsigned long bBalanceTeams, class UYGameSettingsMultiplayer* GameSettings );
	void Pause ( );
	void Reset ( );
	void ClearDelegates ( );
	void Tick ( float DeltaTime );
	int FindPartyReservation ( struct FUniqueNetId PartyLeaderId, int TeamNum, TArray< struct FPartyReservation >* Parties );
	void UpdatePlayerTeam ( struct FUniqueNetId PlayerID, int OldTeamIndex, int NewTeamIndex );
	void UpdateGameOnlineStatus ( unsigned long checkLastManStanding );
	bool FindPartyMemberReservation ( class AGameReplicationInfo* GRI, struct FUniqueNetId PlayerID, TArray< struct FPartyReservation >* Parties, int* FoundPartyIndex, int* FoundPartyMemberIndex );
	void UnregisterPlayer ( struct FUniqueNetId PlayerID );
	bool RegisterPlayer ( struct FUniqueNetId PlayerID, int TeamIndex, unsigned long bWasFromInvite );
	bool IsMPBot ( class AController* Other );
	int GetPlayerCountInTeam ( unsigned char TeamNum, unsigned long includingReserved );
	unsigned char PickTeam ( unsigned char DesiredTeamNum, class AController* ctrl );
	unsigned char GetBestTeamToJoin ( unsigned char DesiredTeamNum, int* TeamFreeSlotCount );
	void CopyCurrentPlayersFromBeacon ( class UPartyBeaconHost* beacon, TArray< struct FCurrentPlayerMet >* Players );
	void BuildCurrentPlayerListFromBeacon ( class UPartyBeaconHost* beacon );
	void RegisterRemoteMembersToGameSession ( );
	bool HostBeaconTellClientsToTravel ( );
	bool HostBeaconTellClientsToTravelToOnlineMenu ( );
	bool isCoopGame ( );
	void TravelToLobby ( );
	void TravelToSession ( );
	void TravelToOnlineMenu ( );
	void HostIdleTimer ( );
	void ClearHostIdleTimer ( );
	void StartHostIdleTimer ( );
	void DestroyHostReservationBeacon ( );
	void OnSessionClientCancellationReceived ( struct FUniqueNetId CancellingPartyLeader );
	void OnSessionReservationChange ( );
	void OnSessionReservationsFull ( );
	int OnSessionClientTeamAssignmentRequest ( int DesiredPartyTeamNum, int NumPlayersInParty );
	bool InitOnlineMatch ( int PartyPlayerCount, unsigned char FactionId );
	bool InitSystemLinkMatch ( unsigned char FactionId );
	unsigned char GetTeamAssignement ( unsigned char DesiredTeamIndex, int NumPlayersInParty );
	void OnCreateHostMatchComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void FinishCreateHostMatch ( struct FName SessionName, unsigned long bWasSuccessful );
	void CreateHostMatch ( class AYGameInfo* GI, int HostControllerIndex, struct FString HostFullName, unsigned long bInGameHosting );
	void PostTravel ( class AYGameInfo* CurrentGameInfo );
	void PreTravel ( );
	bool IsHostBeaconValid ( );
};

UClass* UYMatchmakingHostComponent::pClassPointer = NULL;

// Class SRGame.YMatchmakingHostInviteComponent
// 0x0008 (0x0050 - 0x0048)
class UYMatchmakingHostInviteComponent : public UYMatchmakingBaseComponent
{
public:
	class UPartyBeaconHost*                            m_PartyInviteConnectionBeacon;                    		// 0x0048 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bPartyInviteBeaconTellClientsHostIsReady : 1;   		// 0x004C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bPartyInviteBeaconTellClientsToTravel : 1;      		// 0x004C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 74294 ];

		return pClassPointer;
	};

	void PostTravel ( );
	void UnPause ( );
	void Pause ( );
	void Reset ( );
	void SetPartyTeamNum ( int PartyTeamNum );
	void Tick ( float DeltaTime );
	void DestroyPartyInviteConnectionBeacon ( );
	void DiscardPartyInviteBeaconClientConnections ( );
	bool PartyInviteBeaconTellClientsToTravel ( );
	void PartyInviteBeaconTellClientsHostIsReady ( );
	void OnPartyInviteConnectionRequest ( );
	int OnPartyInviteTeamAssignmentRequest ( int PartyTeamNum, int NumPlayersInParty );
	bool InitializePartyInviteConnectionBeacon ( struct FUniqueNetId PlayerID );
	bool ContinuePartyInviteConnectionBeacon ( struct FUniqueNetId PlayerID );
	void UnregisterPlayer ( struct FUniqueNetId PlayerID );
};

UClass* UYMatchmakingHostInviteComponent::pClassPointer = NULL;

// Class SRGame.YMatchmakingJoinComponent
// 0x001C (0x0064 - 0x0048)
class UYMatchmakingJoinComponent : public UYMatchmakingBaseComponent
{
public:
	unsigned char                                      m_FailureState;                                   		// 0x0048 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class UPartyBeaconClient*                          m_ClientBeacon;                                   		// 0x004C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bSplitPartyOnBothTeams : 1;                     		// 0x0050 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bSendRequestForPartyInOppositTeam : 1;          		// 0x0050 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	int                                                m_JoiningPlayerControllerIndex;                   		// 0x0054 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_JoinedSessionURL;                               		// 0x0058 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 74337 ];

		return pClassPointer;
	};

	void Reset ( );
	void ClearDelegates ( );
	void ResetClientConnection ( );
	void PauseClientConnection ( );
	void TravelToJoinedSession ( );
	void OnJoinSpecificSessionComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void JoinSpecificSession ( struct FOnlineGameSearchResult SessionToJoin, class AYGameInfo* GI, int ControllerIndex );
	bool FinishJoinSession ( );
	void OnJoinMatchComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void OnSessionTravelRequestReceived ( struct FName SessionName, class UClass* SearchClass, unsigned char* PlatformSpecificInfo );
	void OnSessionHostIsReady ( );
	void OnSessionReservationRequestComplete ( unsigned char ReservationResult, int TeamNum, struct FUniqueNetId HostId );
	void CloseConnectionToBeacon ( );
	void ProcessFailedReservation ( );
	bool IsTeamListInTeam ( TArray< class APlayerReplicationInfo* > PRIs, int TeamNum, TArray< struct FPlayerReservation >* TeamList );
	void ProcessReservationResponse ( unsigned char ReservationResult, int TeamNum );
	void OnSessionCancellationRequestComplete ( );
	void OnSessionHostHasCancelled ( );
	bool RequestHostReservationForPartyInTeam ( class UPartyBeaconClient* ClientPartyBeacon, struct FUniqueNetId PartyLeader, int PartyTeamNum, TArray< struct FPlayerReservation >* PartyTeamList );
	bool ConnectToHostAndRequestReservationForPartyInTeam ( struct FOnlineGameSearchResult SessionToJoin, class UPartyBeaconClient* ClientPartyBeacon, struct FUniqueNetId PartyLeader, int PartyTeamNum, TArray< struct FPlayerReservation >* PartyTeamList );
	void RequestHostReservationForParty ( struct FOnlineGameSearchResult SessionToJoin, class AYGameInfo* GameInfo, struct FUniqueNetId PlayerID, int ControllerId );
	unsigned char GetFailureState ( );
	bool HasFailed ( );
	bool IsClientBeaconValid ( );
};

UClass* UYMatchmakingJoinComponent::pClassPointer = NULL;

// Class SRGame.YMatchmakingJoinInviteComponent
// 0x0028 (0x0070 - 0x0048)
class UYMatchmakingJoinInviteComponent : public UYMatchmakingBaseComponent
{
public:
	class AYPlayerController*                          m_pc;                                             		// 0x0048 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bCanJoinOppositTeam : 1;                        		// 0x004C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bDelayedCloseConnectionToPartyBeacon : 1;       		// 0x004C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bDelayedCloseConnectionToGameBeacon : 1;        		// 0x004C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	class UOnlineGameSearch*                           m_InvitedPartySessionSearchInfo;                  		// 0x0050 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UPartyBeaconClient*                          m_PartyClient;                                    		// 0x0054 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UOnlineGameSearch*                           m_InvitedGameSessionSearchInfo;                   		// 0x0058 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UPartyBeaconClient*                          m_GameClient;                                     		// 0x005C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FUniqueNetId                                m_InvitingPlayerId;                               		// 0x0060 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_waitForTravelInformationInterval;               		// 0x0068 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_currentlyWaited;                                		// 0x006C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 74456 ];

		return pClassPointer;
	};

	bool IsJoiningFriendSession ( );
	void UpdateJoiningPlayerTeam ( class APlayerController* PC, int TeamNum );
	void Reset ( );
	void ResetClientConnection ( );
	void PauseClientConnection ( );
	void Tick ( float DeltaTime );
	void TravelToJoinedSession ( );
	void InitMatchmakingAndTravel ( );
	void OnJoinGameInviteComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void OnJoinGameRequestReceived ( struct FName SessionName, class UClass* SearchClass, unsigned char* PlatformSpecificInfo );
	void OnGameCancellationRequestComplete ( );
	void OnGameConnectionCancelled ( );
	void OnGameReservationRequestComplete ( unsigned char ReservationResult, int TeamNum, struct FUniqueNetId HostId );
	void ClearGameInviteSessionInfo ( );
	void CancelConnectionToGameBeacon ( );
	void ClearGameBeaconDelegates ( );
	void DelayedCloseConnectionToGameBeacon ( );
	void CloseConnectionToGameBeacon ( );
	void ConnectToGameBeacon ( class UClass* SearchClass, unsigned char* PlatformSpecificInfo, int TeamNum );
	void OnGameSessionInfoReceived ( struct FName SessionName, class UClass* SearchClass, unsigned char* PlatformSpecificInfo );
	void OnPartyCancellationRequestComplete ( );
	void OnPartyConnectionCancelled ( );
	void OnPartyHostIsReady ( );
	void OnPartyConnectionRequestComplete ( unsigned char ReservationResult, int TeamNum, struct FUniqueNetId HostId );
	void ClearPartyInviteSessionInfo ( );
	void CancelConnectionToPartyBeacon ( );
	void ClearPartyBeaconDelegates ( );
	void DelayedCloseConnectionToPartyBeacon ( );
	void CloseConnectionToPartyBeacon ( );
	void ConnectToPartyBeacon ( class AYPlayerController* PC, unsigned long bCanJoinOppositTeam );
	bool IsClientBeaconValid ( );
};

UClass* UYMatchmakingJoinInviteComponent::pClassPointer = NULL;

// Class SRGame.YMatchmakingPartyComponent
// 0x0014 (0x005C - 0x0048)
class UYMatchmakingPartyComponent : public UYMatchmakingBaseComponent
{
public:
	unsigned long                                      m_bCreateOnlineSession : 1;                       		// 0x0048 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	int                                                m_PartyLeaderControllerIndex;                     		// 0x004C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UOnlineGameSettings*                         m_PartySettings;                                  		// 0x0050 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_PartySessionName;                               		// 0x0054 (0x0008) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 74572 ];

		return pClassPointer;
	};

	void Reset ( );
	void ClearDelegates ( );
	void OnCreatePartyComplete ( struct FName SessionName, unsigned long bWasSuccessful );
	void CreateParty ( unsigned long bCreateOnlineSession, int PartyLeaderControllerIndex );
	void ContinueParty ( unsigned long bCreateOnlineSession, int PartyLeaderControllerIndex );
	void InitPartySettings ( class UOnlineGameSettings* PartySettings, struct FName PartySessionName );
};

UClass* UYMatchmakingPartyComponent::pClassPointer = NULL;

// Class SRGame.YMatchmakingSearchComponent
// 0x003C (0x0084 - 0x0048)
class UYMatchmakingSearchComponent : public UYMatchmakingBaseComponent
{
public:
	class UYGameSearchMultiplayer*                     m_SessionMatchSearch;                             		// 0x0048 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_SessionSearchCount;                             		// 0x004C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_MaxSessionSearchCount;                          		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_SearchingPlayerControllerIndex;                 		// 0x0054 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_MaxPing;                                        		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_BestSessionIndex;                               		// 0x005C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< int >                                      m_ReservationsWithNoSpace;                        		// 0x0060 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FUniqueNetId >                      m_SessionsToIgnore;                               		// 0x006C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FScriptDelegate                             __SortResultsDelegate__Delegate;                  		// 0x0078 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 74574 ];

		return pClassPointer;
	};

	void ResetBestSessionVars ( );
	void ResetFindSession ( );
	void ResetSessionSearchCount ( );
	void ResetSessionSearch ( );
	void Reset ( );
	void ClearDelegates ( );
	void AddCurrentBestSessionHasNoSpace ( );
	void AddCurrentBestSessionToIgnore ( );
	bool ShouldHostMatch ( );
	void UpdateSessionSearchSettings ( class UYGameSearchMultiplayer* SessionSearchSettings, int PlaylistId, unsigned char MPModeId, unsigned char MPMapId, unsigned char AIDifficulty, unsigned long bRankedSession, int NeededTeamFreeSlots );
	void EndSessionMatching ( );
	struct FOnlineGameSearchResult GetBestSession ( );
	bool ChooseBestSession ( );
	void ContinueSessionMatching ( );
	void ResumeFindingSessions ( );
	int SortResultsDelegate ( struct FOnlineGameSearchResult A, struct FOnlineGameSearchResult B );
	void OnFindMatchingSessionsComplete ( unsigned long bWasSuccessful );
	void FindMatchingSessions ( int SearchingPlayerControllerIndex, int PlaylistId, unsigned char MPModeId, unsigned char MPMapId, unsigned char AIDifficulty, unsigned long bRankedSession, int NeededFreeSlots );
	void InitFindSession ( int ControllerIndex, class UYGameSearchMultiplayer* MultiplayerGameSearch );
};

UClass* UYMatchmakingSearchComponent::pClassPointer = NULL;

// Class SRGame.YMPFogVolumeConstantDensityInfo
// 0x0000 (0x0204 - 0x0204)
class AYMPFogVolumeConstantDensityInfo : public AFogVolumeDensityInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75218 ];

		return pClassPointer;
	};

	void SetLocalPawnCanSeeInSandstorms ( unsigned long bCanSee );
};

UClass* AYMPFogVolumeConstantDensityInfo::pClassPointer = NULL;

// Class SRGame.YOverheating
// 0x0024 (0x0060 - 0x003C)
class UYOverheating : public UObject
{
public:
	float                                              m_heatLevel;                                      		// 0x003C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_overheated : 1;                                 		// 0x0040 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_heatReductionPerSecond;                         		// 0x0044 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_MaterialInstance;                               		// 0x0048 (0x0004) [0x0000000000000000]              
	class UParticleSystemComponent*                    m_overheatPSC;                                    		// 0x004C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UParticleSystemComponent*                    m_overheatingPSC;                                 		// 0x0050 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_overheatedAC;                                   		// 0x0054 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_overheatingAC;                                  		// 0x0058 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_overheatMatIndex;                               		// 0x005C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75542 ];

		return pClassPointer;
	};

	void UpdateOverheatingFX ( );
	void SetOverheating ( float newHeat );
	float TickOverheating ( float DeltaTime );
	void DeactivateOverheated ( );
	void ActivateOverheated ( );
	float AddHeat ( float heatAdded );
	void InitOverHeating ( float heatReduction, class AActor* basedOn, class USkeletalMeshComponent* skelMeshCmp, class UParticleSystem* overHeatEffectTemplate, class UParticleSystem* overHeatingEffectTemplate, class USoundCue* overheatedSoundCue, class USoundCue* overheatingSoundCue, struct FName BoneName );
};

UClass* UYOverheating::pClassPointer = NULL;

// Class SRGame.YSpecialMove_CoverVaultAuto_AI
// 0x0000 (0x0214 - 0x0214)
class UYSpecialMove_CoverVaultAuto_AI : public UYSpecialMove_CoverVaultAuto
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75832 ];

		return pClassPointer;
	};

	void UpdateAnimationIndex ( struct FYS_SpecialMoveData* Data, struct FYS_CoverData* coverData );
};

UClass* UYSpecialMove_CoverVaultAuto_AI::pClassPointer = NULL;

// Class SRGame.YSpecialMove_LeaveCoverEdgeAI
// 0x0000 (0x00C8 - 0x00C8)
class UYSpecialMove_LeaveCoverEdgeAI : public UYSpecialMove_LeaveCoverEdge
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75833 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_LeaveCoverEdgeAI::pClassPointer = NULL;

// Class SRGame.YWeapon_Machinegun
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Machinegun : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75836 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Machinegun::pClassPointer = NULL;

// Class SRGame.YWeapon_SAW
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_SAW : public AYWeapon_Machinegun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75835 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_SAW::pClassPointer = NULL;

// Class SRGame.YWeapon_SAW_Adams
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_SAW_Adams : public AYWeapon_SAW
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75834 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_SAW_Adams::pClassPointer = NULL;

// Class SRGame.YWeapon_BenelliM1014
// 0x0000 (0x0D18 - 0x0D18)
class AYWeapon_BenelliM1014 : public AYWeapon_Shotgun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75837 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_BenelliM1014::pClassPointer = NULL;

// Class SRGame.YSpecialMove_CoverVaultAuto_Elite
// 0x0000 (0x0214 - 0x0214)
class UYSpecialMove_CoverVaultAuto_Elite : public UYSpecialMove_CoverVaultAuto_AI
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75972 ];

		return pClassPointer;
	};

};

UClass* UYSpecialMove_CoverVaultAuto_Elite::pClassPointer = NULL;

// Class SRGame.YWeapon_MicroUzi
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_MicroUzi : public AYWeapon_SubmachineGun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75987 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_MicroUzi::pClassPointer = NULL;

// Class SRGame.YWeapon_MicroUzi_Commando
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_MicroUzi_Commando : public AYWeapon_MicroUzi
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75986 ];

		return pClassPointer;
	};

	class UClass* GetPickupClass ( );
};

UClass* AYWeapon_MicroUzi_Commando::pClassPointer = NULL;

// Class SRGame.YWeapon_Knife
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Knife : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 75988 ];

		return pClassPointer;
	};

	class UClass* GetPickupClass ( );
};

UClass* AYWeapon_Knife::pClassPointer = NULL;

// Class SRGame.YPerk_TacticalOfficer
// 0x0018 (0x0068 - 0x0050)
class UYPerk_TacticalOfficer : public UYPerk
{
public:
	float                                              m_damageMoveSpeedModifier;                        		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_maxDamageMultiplier;                            		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_minDamageMultiplier;                            		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_teammateEnableDistance[ 0x2 ];                  		// 0x005C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_teammateNearbyDamageReduction;                  		// 0x0064 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76221 ];

		return pClassPointer;
	};

	int AdjustDamage ( int inDamage, class AYPawn_Multiplayer* myPawn, class AYPawn_Multiplayer* InstigatorPawn );
	void TacticalOfficerTick ( class AYPawn_Multiplayer* P );
};

UClass* UYPerk_TacticalOfficer::pClassPointer = NULL;

// Class SRGame.YPerk_CoverRat
// 0x0004 (0x0054 - 0x0050)
class UYPerk_CoverRat : public UYPerk
{
public:
	float                                              m_accuracyModifier;                               		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76268 ];

		return pClassPointer;
	};

	int AdjustDamage ( int inDamage, class AYPawn_Multiplayer* myPawn, class AYPawn_Multiplayer* InstigatorPawn );
};

UClass* UYPerk_CoverRat::pClassPointer = NULL;

// Class SRGame.YPerk_Trapper
// 0x0014 (0x0064 - 0x0050)
class UYPerk_Trapper : public UYPerk
{
public:
	float                                              m_damageModifier;                                 		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_OffsetDistance;                                 		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FVector                                     m_offset;                                         		// 0x0058 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76282 ];

		return pClassPointer;
	};

	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	void RemovePerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
};

UClass* UYPerk_Trapper::pClassPointer = NULL;

// Class SRGame.YPerk_JazzHands
// 0x0008 (0x0058 - 0x0050)
class UYPerk_JazzHands : public UYPerk
{
public:
	float                                              m_reloadSpeedRate;                                		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_animSpeedMultiplier;                            		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76304 ];

		return pClassPointer;
	};

};

UClass* UYPerk_JazzHands::pClassPointer = NULL;

// Class SRGame.YPerk_NoMercy
// 0x0004 (0x0054 - 0x0050)
class UYPerk_NoMercy : public UYPerk
{
public:
	float                                              m_sidearmAccuracyModifier;                        		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76335 ];

		return pClassPointer;
	};

};

UClass* UYPerk_NoMercy::pClassPointer = NULL;

// Class SRGame.YSpecialMove_PlayAdrenalineInjection
// 0x0024 (0x0108 - 0x00E4)
class UYSpecialMove_PlayAdrenalineInjection : public UYSpecialMoveDestination
{
public:
	TArray< unsigned char >                            m_adrenalineInjectionAnimSetsIdle;                		// 0x00E4 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_adrenalineInjectionAnimSetsUpperBody;           		// 0x00F0 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	int                                                m_lastPlayedVariation;                            		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_usedAnimVariation;                              		// 0x0100 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_checkIdleCancel : 1;                            		// 0x0104 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76771 ];

		return pClassPointer;
	};

	struct FYS_AnimID GetAnimID ( int variation, unsigned long wantsIdleAnim );
	void TickSpecialMove ( float DeltaTime );
	void OnReachedDestinationInternal ( );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	int GetPlaybackVariation ( );
};

UClass* UYSpecialMove_PlayAdrenalineInjection::pClassPointer = NULL;

// Class SRGame.YWeapon_AssaultRifle
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_AssaultRifle : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76812 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_AssaultRifle::pClassPointer = NULL;

// Class SRGame.YWeapon_M4Carbine
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_M4Carbine : public AYWeapon_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76811 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_M4Carbine::pClassPointer = NULL;

// Class SRGame.YWeapon_M9A1
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_M9A1 : public AYWeapon_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76813 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_M9A1::pClassPointer = NULL;

// Class SRGame.YWeapon_AA12
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_AA12 : public AYWeapon_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76912 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_AA12::pClassPointer = NULL;

// Class SRGame.YWeapon_SCAR
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_SCAR : public AYWeapon_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76925 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_SCAR::pClassPointer = NULL;

// Class SRGame.YWeapon_DesertEagle50AE
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_DesertEagle50AE : public AYWeapon_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76926 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_DesertEagle50AE::pClassPointer = NULL;

// Class SRGame.YWeapon_FAMAS
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_FAMAS : public AYWeapon_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76939 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_FAMAS::pClassPointer = NULL;

// Class SRGame.YWeapon_HK417
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_HK417 : public AYWeapon_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76952 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_HK417::pClassPointer = NULL;

// Class SRGame.YWeapon_RPG_AI
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_RPG_AI : public AYWeapon_RPG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 76977 ];

		return pClassPointer;
	};

	class UClass* GetPickupClass ( );
};

UClass* AYWeapon_RPG_AI::pClassPointer = NULL;

// Class SRGame.YWeapon_FNP90
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_FNP90 : public AYWeapon_SubmachineGun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77003 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_FNP90::pClassPointer = NULL;

// Class SRGame.YWeapon_FNP90_EliteAI
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_FNP90_EliteAI : public AYWeapon_FNP90
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77002 ];

		return pClassPointer;
	};

	class UClass* GetPickupClass ( );
};

UClass* AYWeapon_FNP90_EliteAI::pClassPointer = NULL;

// Class SRGame.YWeapon_BarrettM99
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_BarrettM99 : public AYWeapon_Sniper
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77016 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_BarrettM99::pClassPointer = NULL;

// Class SRGame.YWeapon_AK47
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_AK47 : public AYWeapon_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77041 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_AK47::pClassPointer = NULL;

// Class SRGame.YWeapon_MilkorMGL
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_MilkorMGL : public AYWeapon_Launcher
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77091 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_MilkorMGL::pClassPointer = NULL;

// Class SRGame.YWeapon_MilkorMGL_AI
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_MilkorMGL_AI : public AYWeapon_MilkorMGL
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77090 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_MilkorMGL_AI::pClassPointer = NULL;

// Class SRGame.YWeapon_SawedOffShotgun
// 0x0000 (0x0D18 - 0x0D18)
class AYWeapon_SawedOffShotgun : public AYWeapon_Shotgun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77128 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_SawedOffShotgun::pClassPointer = NULL;

// Class SRGame.YWeapon_SteyrElite
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_SteyrElite : public AYWeapon_Sniper
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77152 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_SteyrElite::pClassPointer = NULL;

// Class SRGame.YWeapon_PythonElite
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_PythonElite : public AYWeapon_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77210 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_PythonElite::pClassPointer = NULL;

// Class SRGame.YSpecialMove_TakeHitResistMelee
// 0x0020 (0x016C - 0x014C)
class UYSpecialMove_TakeHitResistMelee : public UYSpecialMove_TakeHit
{
public:
	struct FYS_TakeHitAnimations                       m_animationsResistAttack[ 0x2 ];                  		// 0x014C (0x0020) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77261 ];

		return pClassPointer;
	};

	struct FYS_AnimID GetAnimID ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_TakeHitResistMelee::pClassPointer = NULL;

// Class SRGame.YPawn_HordePlayer
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_HordePlayer : public AYPawn_MPStealthRanger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77310 ];

		return pClassPointer;
	};

};

UClass* AYPawn_HordePlayer::pClassPointer = NULL;

// Class SRGame.YPawn_HordePlayerA
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_HordePlayerA : public AYPawn_HordePlayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77324 ];

		return pClassPointer;
	};

};

UClass* AYPawn_HordePlayerA::pClassPointer = NULL;

// Class SRGame.YPawn_HordePlayerB
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_HordePlayerB : public AYPawn_HordePlayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77338 ];

		return pClassPointer;
	};

};

UClass* AYPawn_HordePlayerB::pClassPointer = NULL;

// Class SRGame.YPawn_HordePlayerC
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_HordePlayerC : public AYPawn_HordePlayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77352 ];

		return pClassPointer;
	};

};

UClass* AYPawn_HordePlayerC::pClassPointer = NULL;

// Class SRGame.YPawn_HordePlayerD
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_HordePlayerD : public AYPawn_HordePlayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77366 ];

		return pClassPointer;
	};

};

UClass* AYPawn_HordePlayerD::pClassPointer = NULL;

// Class SRGame.YWeapon_TAR21
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_TAR21 : public AYWeapon_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77404 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_TAR21::pClassPointer = NULL;

// Class SRGame.YWeapon_SteyrElite_Lugo
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_SteyrElite_Lugo : public AYWeapon_SteyrElite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77405 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_SteyrElite_Lugo::pClassPointer = NULL;

// Class SRGame.YPawn_LugoCanDie
// 0x0000 (0x2708 - 0x2708)
class AYPawn_LugoCanDie : public AYPawn_Enemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77406 ];

		return pClassPointer;
	};

};

UClass* AYPawn_LugoCanDie::pClassPointer = NULL;

// Class SRGame.YPawn_MP_Fari
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_MP_Fari : public AYPawn_MPStealthRanger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77623 ];

		return pClassPointer;
	};

	class UYPerk_Fremen* GetPerkFremen ( );
	void PostBeginPlay ( );
};

UClass* AYPawn_MP_Fari::pClassPointer = NULL;

// Class SRGame.YPawn_MPExplosiveExpert
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_MPExplosiveExpert : public AYPawn_MPStealthRanger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77653 ];

		return pClassPointer;
	};

	float GetExplosiveDamageReductionFactor ( );
	void OnThrowGrenade ( class AYProj_Physical* SpawnedProjectile );
	void IncrementDamageStats ( int Damage, class UClass* YDamageType, class AController* InstigatedBy, class AActor* DamageCauser, struct FName BoneName );
	float GetGrenadeSpeedMultiplier ( );
	class UYPerk_ExplosiveExpert* GetPerkExplosiveExpert ( );
	int GetStartGrenadeCount ( );
	int GetMaxGrenadeCount ( );
};

UClass* AYPawn_MPExplosiveExpert::pClassPointer = NULL;

// Class SRGame.YPerk_ExplosiveExpert
// 0x003F (0x0090 - 0x0051)
class UYPerk_ExplosiveExpert : public UYPerk_Major
{
public:
	float                                              m_grenadeSpeedMultiplier[ 0x2 ];                  		// 0x0054 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_explosiveDamageReductionFactor[ 0x2 ];          		// 0x005C (0x0008) [0x0000000000004000]              ( CPF_Config )
	struct FName                                       m_damageParamName[ 0x2 ];                         		// 0x0064 (0x0010) [0x0000000000004000]              ( CPF_Config )
	float                                              m_detectionRadius[ 0x2 ];                         		// 0x0074 (0x0008) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bDetectWhileRunning : 1;                        		// 0x007C (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_bDetectWhileRunningLevel2 : 1;                  		// 0x007C (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_bDetectWhileSprinting : 1;                      		// 0x007C (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_bDetectWhileSprintingLevel2 : 1;                		// 0x007C (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	int                                                m_maxGrenadeCount[ 0x2 ];                         		// 0x0080 (0x0008) [0x0000000000004000]              ( CPF_Config )
	int                                                m_startGrenadeCount[ 0x2 ];                       		// 0x0088 (0x0008) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77656 ];

		return pClassPointer;
	};

	float GetExplosiveDamageRedutionFactor ( );
	bool DetectWhileSprinting ( );
	bool DetectWhileRunning ( );
	float GetGrenadeSpeedMultiplier ( );
	struct FName GetDamageParamName ( );
	float GetDetectionRadius ( );
	int GetStartGrenadeCount ( );
	int GetMaxGrenadeCount ( );
};

UClass* UYPerk_ExplosiveExpert::pClassPointer = NULL;

// Class SRGame.YPawn_MPFremen
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_MPFremen : public AYPawn_MPEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77699 ];

		return pClassPointer;
	};

	class UYPerk_Fremen* GetPerkFremen ( );
	void PostBeginPlay ( );
};

UClass* AYPawn_MPFremen::pClassPointer = NULL;

// Class SRGame.YPawn_MPHeavyTrooper
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_MPHeavyTrooper : public AYPawn_MPStealthRanger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77716 ];

		return pClassPointer;
	};

	float GetNonExplosiveDamageReductionFactor ( );
	float GetAmmoMultiplier ( );
	class UYPerk_HeavyTrooper* GetPerkHeavyTrooper ( );
};

UClass* AYPawn_MPHeavyTrooper::pClassPointer = NULL;

// Class SRGame.YPerk_HeavyTrooper
// 0x0017 (0x0068 - 0x0051)
class UYPerk_HeavyTrooper : public UYPerk_Major
{
public:
	float                                              m_ammoMultiplier[ 0x2 ];                          		// 0x0054 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_damageReductionFactor[ 0x2 ];                   		// 0x005C (0x0008) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bDoesntFallFromExplosion : 1;                   		// 0x0064 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_bDoesntFallFromExplosionLevel2 : 1;             		// 0x0064 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77719 ];

		return pClassPointer;
	};

	bool DoesntFallFromExplosion ( );
	float GetAmmoMultiplier ( );
	float GetArmorMultiplier ( );
};

UClass* UYPerk_HeavyTrooper::pClassPointer = NULL;

// Class SRGame.YPawn_MPKonradNoPerk
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_MPKonradNoPerk : public AYPawn_MPEnemy
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77774 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MPKonradNoPerk::pClassPointer = NULL;

// Class SRGame.YPerk_Rage
// 0x003F (0x0090 - 0x0051)
class UYPerk_Rage : public UYPerk_Major
{
public:
	float                                              m_damageMultiplier[ 0x2 ];                        		// 0x0054 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_accuracyModifier[ 0x2 ];                        		// 0x005C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_healthModifier[ 0x2 ];                          		// 0x0064 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sprintSpeedMultiplier[ 0x2 ];                   		// 0x006C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_meleeDamageMultiplier[ 0x2 ];                   		// 0x0074 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_explosionTimer[ 0x2 ];                          		// 0x007C (0x0008) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_bDropGrenadeWhenDying : 1;                      		// 0x0084 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_bDropGrenadeWhenDyingLevel2 : 1;                		// 0x0084 (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	class UYSoundCueFMOD*                              m_berserkSound;                                   		// 0x0088 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_dropGrenadeAfterDeathSound;                     		// 0x008C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77799 ];

		return pClassPointer;
	};

	bool DropGrenadeWhenDying ( );
	float GetHealthModifier ( );
	float GetDamageMultiplier ( );
	float GetExplosionTimer ( );
	float GetAccuracyModifier ( );
	class UYSoundCueFMOD* GetRagingDropGrenadeSounds ( );
	class UYSoundCueFMOD* GetRagingBerserkSound ( );
	float GetSpeedMultiplier ( );
	float GetMeleeMultiplier ( );
	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
};

UClass* UYPerk_Rage::pClassPointer = NULL;

// Class SRGame.YProj_MPRageGrenade
// 0x0000 (0x0678 - 0x0678)
class AYProj_MPRageGrenade : public AYProj_MPFragGrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77875 ];

		return pClassPointer;
	};

};

UClass* AYProj_MPRageGrenade::pClassPointer = NULL;

// Class SRGame.YPawn_MPSpecopsNoPerk
// 0x0000 (0x28A4 - 0x28A4)
class AYPawn_MPSpecopsNoPerk : public AYPawn_MPStealthRanger
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77877 ];

		return pClassPointer;
	};

};

UClass* AYPawn_MPSpecopsNoPerk::pClassPointer = NULL;

// Class SRGame.YPawn_MPTacticalExpert
// 0x0010 (0x28B4 - 0x28A4)
class AYPawn_MPTacticalExpert : public AYPawn_MPStealthRanger
{
public:
	float                                              m_teammateEnableDistance;                         		// 0x28A4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bWasMoving : 1;                                 		// 0x28A8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_isSonarScanning : 1;                            		// 0x28A8 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bSonarScanningStarted : 1;                      		// 0x28A8 (0x0004) [0x0000000000000000] [0x00000004] 
	class UYSoundCueFMOD*                              m_sonarChargeSound;                               		// 0x28AC (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              m_sonarEffectSound;                               		// 0x28B0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77891 ];

		return pClassPointer;
	};

	bool ReloadWeapon ( );
	void OnEndRaiseGrenade ( );
	void OnWeaponFired ( );
	void TakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool ShouldPlayScanEffect ( );
	void ServerSetIsSonarScanning ( unsigned long B );
	void SetSonarScanning ( unsigned long B );
	bool IsSonarScanning ( );
	void OnEndSonarView ( );
	void OnEndSonarEffect ( );
	void OnStartSonarEffect ( );
	void OnStartSonarCountdown ( );
	void SetSonarDelayTimer ( unsigned long bSet );
	void RestoreCrosshairMat ( );
	void CancelSonarEffect ( );
	void TacticalExpertTick ( );
	bool CanStartSonarEffect ( );
	void Tick ( float DeltaTime );
	float GetTeammateEnableDistance ( );
	void SetTeammateEnableDistance ( float Distance );
	class UYPerk_TacticalExpert* GetPerkTacticalExpert ( );
};

UClass* AYPawn_MPTacticalExpert::pClassPointer = NULL;

// Class SRGame.YPerk_TacticalExpert
// 0x004F (0x00A0 - 0x0051)
class UYPerk_TacticalExpert : public UYPerk_Major
{
public:
	float                                              m_enemyScanTimer[ 0x2 ];                          		// 0x0054 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_enemyViewDistance[ 0x2 ];                       		// 0x005C (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_scanTimer[ 0x2 ];                               		// 0x0064 (0x0008) [0x0000000000004000]              ( CPF_Config )
	unsigned long                                      m_sprintingTriggersScan : 1;                      		// 0x006C (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      m_sprintingTriggersScanLevel2 : 1;                		// 0x006C (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	unsigned long                                      m_scanningTriggersScan : 1;                       		// 0x006C (0x0004) [0x0000000000004000] [0x00000004] ( CPF_Config )
	unsigned long                                      m_scanningTriggersScanLevel2 : 1;                 		// 0x006C (0x0004) [0x0000000000004000] [0x00000008] ( CPF_Config )
	unsigned long                                      m_shootingTriggersScan : 1;                       		// 0x006C (0x0004) [0x0000000000004000] [0x00000010] ( CPF_Config )
	unsigned long                                      m_shootingTriggersScanLevel2 : 1;                 		// 0x006C (0x0004) [0x0000000000004000] [0x00000020] ( CPF_Config )
	unsigned long                                      m_talkingTriggersScan : 1;                        		// 0x006C (0x0004) [0x0000000000004000] [0x00000040] ( CPF_Config )
	unsigned long                                      m_talkingTriggersScanLevel2 : 1;                  		// 0x006C (0x0004) [0x0000000000004000] [0x00000080] ( CPF_Config )
	unsigned long                                      m_bTakingDamageCancelsSonar : 1;                  		// 0x006C (0x0004) [0x0000000000004000] [0x00000100] ( CPF_Config )
	unsigned long                                      m_bTakingDamageCancelsSonarLevel2 : 1;            		// 0x006C (0x0004) [0x0000000000004000] [0x00000200] ( CPF_Config )
	unsigned long                                      m_bShootingCancelsSonar : 1;                      		// 0x006C (0x0004) [0x0000000000004000] [0x00000400] ( CPF_Config )
	unsigned long                                      m_bShootingCancelsSonarLevel2 : 1;                		// 0x006C (0x0004) [0x0000000000004000] [0x00000800] ( CPF_Config )
	unsigned long                                      m_bReloadingCancelsSonar : 1;                     		// 0x006C (0x0004) [0x0000000000004000] [0x00001000] ( CPF_Config )
	unsigned long                                      m_bReloadingCancelsSonarLevel2 : 1;               		// 0x006C (0x0004) [0x0000000000004000] [0x00002000] ( CPF_Config )
	unsigned long                                      m_bSonarRefireRequiresMove : 1;                   		// 0x006C (0x0004) [0x0000000000004000] [0x00004000] ( CPF_Config )
	unsigned long                                      m_bSonarRefireRequiresMoveLevel2 : 1;             		// 0x006C (0x0004) [0x0000000000004000] [0x00008000] ( CPF_Config )
	unsigned long                                      m_bSonarRequiresCrouch : 1;                       		// 0x006C (0x0004) [0x0000000000004000] [0x00010000] ( CPF_Config )
	unsigned long                                      m_bSonarRequiresCrouchLevel2 : 1;                 		// 0x006C (0x0004) [0x0000000000004000] [0x00020000] ( CPF_Config )
	unsigned long                                      m_bAimingCancelsSonar : 1;                        		// 0x006C (0x0004) [0x0000000000004000] [0x00040000] ( CPF_Config )
	unsigned long                                      m_bAimingCancelsSonarLevel2 : 1;                  		// 0x006C (0x0004) [0x0000000000004000] [0x00080000] ( CPF_Config )
	unsigned long                                      m_bTeammatesSeeSonar : 1;                         		// 0x006C (0x0004) [0x0000000000004000] [0x00100000] ( CPF_Config )
	unsigned long                                      m_bTeammatesSeeSonarLevel2 : 1;                   		// 0x006C (0x0004) [0x0000000000004000] [0x00200000] ( CPF_Config )
	float                                              m_teammateEnableDistance[ 0x2 ];                  		// 0x0070 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sonarDelayTime[ 0x2 ];                          		// 0x0078 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sonarScanInfoLifetime[ 0x2 ];                   		// 0x0080 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sonarEffectTime[ 0x2 ];                         		// 0x0088 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sonarLaunchTime[ 0x2 ];                         		// 0x0090 (0x0008) [0x0000000000004000]              ( CPF_Config )
	float                                              m_sonarRange[ 0x2 ];                              		// 0x0098 (0x0008) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 77900 ];

		return pClassPointer;
	};

	bool SonarRefireRequiresMove ( );
	bool AimingCancelsSonar ( );
	bool SonarRequiresCrouch ( );
	bool ShootingCancelsSonar ( );
	float GetSonarLaunchTime ( );
	float GetSonarEffectTime ( );
	float GetSonarScanInfoLifetime ( );
	float GetSonarDelayTime ( );
	float GetScanTimer ( );
	bool TalkingTriggersScan ( );
	bool TakingDamageCancelsSonar ( );
	bool SprintingTriggersScan ( );
	float GetTeammateEnableDistance ( );
	float GetEnemyScanTimer ( );
	float GetEnemyViewDistance ( );
	bool ScanningTriggersScan ( );
	bool ShootingTriggersScan ( );
};

UClass* UYPerk_TacticalExpert::pClassPointer = NULL;

// Class SRGame.YPerk_BlindFire
// 0x0004 (0x0054 - 0x0050)
class UYPerk_BlindFire : public UYPerk
{
public:
	float                                              m_accuracyModifier;                               		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78297 ];

		return pClassPointer;
	};

};

UClass* UYPerk_BlindFire::pClassPointer = NULL;

// Class SRGame.YPerk_CombatReady
// 0x0004 (0x0054 - 0x0050)
class UYPerk_CombatReady : public UYPerk
{
public:
	float                                              m_DetectDist;                                     		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78332 ];

		return pClassPointer;
	};

};

UClass* UYPerk_CombatReady::pClassPointer = NULL;

// Class SRGame.YPerk_Commando
// 0x000C (0x005C - 0x0050)
class UYPerk_Commando : public UYPerk
{
public:
	float                                              m_extraMagazines;                                 		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_regenerationTimeModifier;                       		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delayTimeModifier;                              		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78335 ];

		return pClassPointer;
	};

};

UClass* UYPerk_Commando::pClassPointer = NULL;

// Class SRGame.YPerk_ExtendedClips
// 0x0004 (0x0054 - 0x0050)
class UYPerk_ExtendedClips : public UYPerk
{
public:
	float                                              m_ammoMultiplier;                                 		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78373 ];

		return pClassPointer;
	};

};

UClass* UYPerk_ExtendedClips::pClassPointer = NULL;

// Class SRGame.YPerk_FastReload
// 0x0004 (0x0054 - 0x0050)
class UYPerk_FastReload : public UYPerk
{
public:
	float                                              m_reloadSpeedRate;                                		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78376 ];

		return pClassPointer;
	};

};

UClass* UYPerk_FastReload::pClassPointer = NULL;

// Class SRGame.YPerk_FastSwap
// 0x0004 (0x0054 - 0x0050)
class UYPerk_FastSwap : public UYPerk
{
public:
	float                                              m_animSpeedMultiplier;                            		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78379 ];

		return pClassPointer;
	};

};

UClass* UYPerk_FastSwap::pClassPointer = NULL;

// Class SRGame.YPerk_FeintDeath
// 0x0004 (0x0054 - 0x0050)
class UYPerk_FeintDeath : public UYPerk
{
public:
	float                                              m_dbnoTimer;                                      		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78382 ];

		return pClassPointer;
	};

};

UClass* UYPerk_FeintDeath::pClassPointer = NULL;

// Class SRGame.YPerk_FieldOperative
// 0x0008 (0x0058 - 0x0050)
class UYPerk_FieldOperative : public UYPerk
{
public:
	float                                              m_ammoMultiplier;                                 		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_ViewDist;                                       		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78385 ];

		return pClassPointer;
	};

	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	void RemovePerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
};

UClass* UYPerk_FieldOperative::pClassPointer = NULL;

// Class SRGame.YPerk_FremenFari
// 0x0000 (0x0064 - 0x0064)
class UYPerk_FremenFari : public UYPerk_Fremen
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78422 ];

		return pClassPointer;
	};

};

UClass* UYPerk_FremenFari::pClassPointer = NULL;

// Class SRGame.YPerk_Horde
// 0x0000 (0x0051 - 0x0051)
class UYPerk_Horde : public UYPerk_Major
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78439 ];

		return pClassPointer;
	};

};

UClass* UYPerk_Horde::pClassPointer = NULL;

// Class SRGame.YPerk_HordeAdams
// 0x0000 (0x0051 - 0x0051)
class UYPerk_HordeAdams : public UYPerk_Horde
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78441 ];

		return pClassPointer;
	};

};

UClass* UYPerk_HordeAdams::pClassPointer = NULL;

// Class SRGame.YPerk_HordeLugo
// 0x0000 (0x0051 - 0x0051)
class UYPerk_HordeLugo : public UYPerk_Horde
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78443 ];

		return pClassPointer;
	};

};

UClass* UYPerk_HordeLugo::pClassPointer = NULL;

// Class SRGame.YPerk_HordeRiggs
// 0x0000 (0x0051 - 0x0051)
class UYPerk_HordeRiggs : public UYPerk_Horde
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78445 ];

		return pClassPointer;
	};

};

UClass* UYPerk_HordeRiggs::pClassPointer = NULL;

// Class SRGame.YPerk_HordeWalker
// 0x0000 (0x0051 - 0x0051)
class UYPerk_HordeWalker : public UYPerk_Horde
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78447 ];

		return pClassPointer;
	};

};

UClass* UYPerk_HordeWalker::pClassPointer = NULL;

// Class SRGame.YPerk_KonradNoPerk
// 0x0000 (0x0051 - 0x0051)
class UYPerk_KonradNoPerk : public UYPerk_Major
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78485 ];

		return pClassPointer;
	};

	int GetPerkLevel ( );
};

UClass* UYPerk_KonradNoPerk::pClassPointer = NULL;

// Class SRGame.YPerk_Learning
// 0x0004 (0x0054 - 0x0050)
class UYPerk_Learning : public UYPerk
{
public:
	float                                              m_xpModifier;                                     		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78493 ];

		return pClassPointer;
	};

};

UClass* UYPerk_Learning::pClassPointer = NULL;

// Class SRGame.YPerk_Melee
// 0x0000 (0x0050 - 0x0050)
class UYPerk_Melee : public UYPerk
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78520 ];

		return pClassPointer;
	};

};

UClass* UYPerk_Melee::pClassPointer = NULL;

// Class SRGame.YPerk_MeleeRush
// 0x0004 (0x0054 - 0x0050)
class UYPerk_MeleeRush : public UYPerk
{
public:
	float                                              m_meleeRange;                                     		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78522 ];

		return pClassPointer;
	};

};

UClass* UYPerk_MeleeRush::pClassPointer = NULL;

// Class SRGame.YPerk_NoPerk
// 0x0000 (0x0050 - 0x0050)
class UYPerk_NoPerk : public UYPerk
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78535 ];

		return pClassPointer;
	};

};

UClass* UYPerk_NoPerk::pClassPointer = NULL;

// Class SRGame.YPerk_Reaper
// 0x0000 (0x0050 - 0x0050)
class UYPerk_Reaper : public UYPerk
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78576 ];

		return pClassPointer;
	};

	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	void RemovePerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
};

UClass* UYPerk_Reaper::pClassPointer = NULL;

// Class SRGame.YPerk_RecoilSuppressor
// 0x0004 (0x0054 - 0x0050)
class UYPerk_RecoilSuppressor : public UYPerk
{
public:
	float                                              m_recoilMultiplier;                               		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78584 ];

		return pClassPointer;
	};

};

UClass* UYPerk_RecoilSuppressor::pClassPointer = NULL;

// Class SRGame.YPerk_Regeneration
// 0x0008 (0x0058 - 0x0050)
class UYPerk_Regeneration : public UYPerk
{
public:
	float                                              m_regenerationTimeModifier;                       		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_delayTimeModifier;                              		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78587 ];

		return pClassPointer;
	};

	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	void RemovePerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
};

UClass* UYPerk_Regeneration::pClassPointer = NULL;

// Class SRGame.YPerk_Runner
// 0x0004 (0x0054 - 0x0050)
class UYPerk_Runner : public UYPerk
{
public:
	float                                              m_sprintMaxTime;                                  		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78597 ];

		return pClassPointer;
	};

};

UClass* UYPerk_Runner::pClassPointer = NULL;

// Class SRGame.YPerk_Scrambler
// 0x0004 (0x0054 - 0x0050)
class UYPerk_Scrambler : public UYPerk
{
public:
	float                                              m_explosiveStunTimeModifier;                      		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78617 ];

		return pClassPointer;
	};

	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	void RemovePerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
};

UClass* UYPerk_Scrambler::pClassPointer = NULL;

// Class SRGame.YPerk_SlowBreath
// 0x0004 (0x0054 - 0x0050)
class UYPerk_SlowBreath : public UYPerk
{
public:
	float                                              m_shakeModifier;                                  		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78628 ];

		return pClassPointer;
	};

};

UClass* UYPerk_SlowBreath::pClassPointer = NULL;

// Class SRGame.YPerk_SpecopsNoPerk
// 0x0000 (0x0051 - 0x0051)
class UYPerk_SpecopsNoPerk : public UYPerk_Major
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78693 ];

		return pClassPointer;
	};

	int GetPerkLevel ( );
};

UClass* UYPerk_SpecopsNoPerk::pClassPointer = NULL;

// Class SRGame.YPerk_Speedy
// 0x0004 (0x0054 - 0x0050)
class UYPerk_Speedy : public UYPerk
{
public:
	float                                              m_runSpeedMultiplier;                             		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78701 ];

		return pClassPointer;
	};

	void RemovePerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
};

UClass* UYPerk_Speedy::pClassPointer = NULL;

// Class SRGame.YPerk_SteadyAim
// 0x0004 (0x0054 - 0x0050)
class UYPerk_SteadyAim : public UYPerk
{
public:
	float                                              m_accuracyModifier;                               		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78710 ];

		return pClassPointer;
	};

};

UClass* UYPerk_SteadyAim::pClassPointer = NULL;

// Class SRGame.YPerk_Stealthy
// 0x0004 (0x0054 - 0x0050)
class UYPerk_Stealthy : public UYPerk
{
public:
	float                                              m_explosiveStunTimeModifier;                      		// 0x0050 (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78713 ];

		return pClassPointer;
	};

	void ApplyPerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
	void RemovePerk ( class AYPawn_Multiplayer* yPawn, int perkSlot );
};

UClass* UYPerk_Stealthy::pClassPointer = NULL;

// Class SRGame.YPerk_UnknownKiller
// 0x0000 (0x0050 - 0x0050)
class UYPerk_UnknownKiller : public UYPerk
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78802 ];

		return pClassPointer;
	};

};

UClass* UYPerk_UnknownKiller::pClassPointer = NULL;

// Class SRGame.YPhosphorHazardArea
// 0x0050 (0x0248 - 0x01F8)
class AYPhosphorHazardArea : public AActor
{
public:
	class UCylinderComponent*                          CylinderComponent;                                		// 0x01F8 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )
	float                                              m_endRadius;                                      		// 0x01FC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_startPosition;                                  		// 0x0200 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_endPosition;                                    		// 0x020C (0x000C) [0x0000000000000000]              
	float                                              m_endHeight;                                      		// 0x0218 (0x0004) [0x0000000000000000]              
	float                                              m_speed;                                          		// 0x021C (0x0004) [0x0000000000000000]              
	float                                              DamagePerSec;                                     		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      DamageType;                                       		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bPainCausing : 1;                                 		// 0x0228 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              PainInterval;                                     		// 0x022C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AController*                                 DamageInstigator;                                 		// 0x0230 (0x0004) [0x0000000000000000]              
	class AYProj_Physical*                             m_causingGrenade;                                 		// 0x0234 (0x0004) [0x0000000000000000]              
	class UAudioComponent*                             m_burningSoundComponent;                          		// 0x0238 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_burnSoundStartTime;                             		// 0x023C (0x0004) [0x0000000000000000]              
	float                                              m_burnSoundFadeoutTime;                           		// 0x0240 (0x0004) [0x0000000000000000]              
	class AYWeapon*                                    m_causingWeapon;                                  		// 0x0244 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78804 ];

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	void Destroyed ( );
	void DisplayDebug ( class AHUD* H, float* out_YL, float* out_YPos );
	void CausePainTo ( class AActor* Other );
	void Touch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void Timer ( );
	void StartTimer ( );
};

UClass* AYPhosphorHazardArea::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Carpet
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Carpet : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78865 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Carpet::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Concrete
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Concrete : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78878 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Concrete::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Default
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Default : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78892 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Default::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Sand
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Sand : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78904 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Sand::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Dirt
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Dirt : public UYPhysMatProp_Sand
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78925 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Dirt::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Electronics
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Electronics : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78936 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Electronics::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Fabric
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Fabric : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78949 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Fabric::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Metal
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Metal : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78961 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Metal::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_FireExtinguisher
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_FireExtinguisher : public UYPhysMatProp_Metal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78985 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_FireExtinguisher::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_FleshFresh
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_FleshFresh : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 78996 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_FleshFresh::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_FleshOld
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_FleshOld : public UYPhysMatProp_FleshFresh
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79011 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_FleshOld::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_FoliageDried
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_FoliageDried : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79020 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_FoliageDried::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_FoliageGreen
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_FoliageGreen : public UYPhysMatProp_FoliageDried
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79034 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_FoliageGreen::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_GlassWindow
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_GlassWindow : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79042 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_GlassWindow::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_GlassBulletproof
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_GlassBulletproof : public UYPhysMatProp_GlassWindow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79064 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_GlassBulletproof::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_GlassSafety
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_GlassSafety : public UYPhysMatProp_GlassWindow
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79075 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_GlassSafety::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Gravel
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Gravel : public UYPhysMatProp_Concrete
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79098 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Gravel::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Helicopter
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Helicopter : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79112 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Helicopter::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Marble
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Marble : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79116 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Marble::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_MetalPaint
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_MetalPaint : public UYPhysMatProp_Metal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79130 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_MetalPaint::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_MetalSheet
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_MetalSheet : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79144 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_MetalSheet::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_MetalSheet_Perforated
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_MetalSheet_Perforated : public UYPhysMatProp_MetalSheet
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79164 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_MetalSheet_Perforated::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_MP_Ceiling
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_MP_Ceiling : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79178 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_MP_Ceiling::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_MP_Sand
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_MP_Sand : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79187 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_MP_Sand::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_MP_Sand_Ceiling
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_MP_Sand_Ceiling : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79194 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_MP_Sand_Ceiling::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Pawn_Enemy_Chest
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Pawn_Enemy_Chest : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79201 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Pawn_Enemy_Chest::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Pawn_Enemy_Head
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Pawn_Enemy_Head : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79210 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Pawn_Enemy_Head::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Pawn_Enemy_Limbs
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Pawn_Enemy_Limbs : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79219 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Pawn_Enemy_Limbs::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Pawn_Player_Chest
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Pawn_Player_Chest : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79228 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Pawn_Player_Chest::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Pawn_Player_Head
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Pawn_Player_Head : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79236 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Pawn_Player_Head::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Pawn_Player_Limbs
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Pawn_Player_Limbs : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79244 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Pawn_Player_Limbs::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Pawn_Squad_Chest
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Pawn_Squad_Chest : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79252 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Pawn_Squad_Chest::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Pawn_Squad_Head
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Pawn_Squad_Head : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79260 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Pawn_Squad_Head::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Pawn_Squad_Limbs
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Pawn_Squad_Limbs : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79268 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Pawn_Squad_Limbs::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_PropaneTank
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_PropaneTank : public UYPhysMatProp_Metal
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79276 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_PropaneTank::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_SandBags
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_SandBags : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79287 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_SandBags::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Stone
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Stone : public UYPhysMatProp_Concrete
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79300 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Stone::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Tarmac
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Tarmac : public UYPhysMatProp_Concrete
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79314 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Tarmac::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Tiles
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Tiles : public UYPhysMatProp_Marble
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79333 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Tiles::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Wood
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Wood : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79347 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Wood::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_TreeTrunk
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_TreeTrunk : public UYPhysMatProp_Wood
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79369 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_TreeTrunk::pClassPointer = NULL;

// Class SRGame.YPhysMatProp_Water
// 0x0000 (0x0065 - 0x0065)
class UYPhysMatProp_Water : public UYPhysicalMaterialProperty
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79382 ];

		return pClassPointer;
	};

};

UClass* UYPhysMatProp_Water::pClassPointer = NULL;

// Class SRGame.YWeaponSubmeshData
// 0x0020 (0x005C - 0x003C)
class UYWeaponSubmeshData : public UObject
{
public:
	struct FName                                       m_boneName;                                       		// 0x003C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMesh*                               m_skelMeshTemplate;                               		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UPhysicsAsset*                               m_physAsset;                                      		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_socketName;                                     		// 0x004C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_socketNameMirrored;                             		// 0x0054 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79801 ];

		return pClassPointer;
	};

};

UClass* UYWeaponSubmeshData::pClassPointer = NULL;

// Class SRGame.YPickupGold_Large
// 0x0000 (0x0324 - 0x0324)
class AYPickupGold_Large : public AYPickupGold
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79892 ];

		return pClassPointer;
	};

};

UClass* AYPickupGold_Large::pClassPointer = NULL;

// Class SRGame.YPickupGold_Medium
// 0x0000 (0x0324 - 0x0324)
class AYPickupGold_Medium : public AYPickupGold
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79897 ];

		return pClassPointer;
	};

};

UClass* AYPickupGold_Medium::pClassPointer = NULL;

// Class SRGame.YPickupGold_Small
// 0x0000 (0x0324 - 0x0324)
class AYPickupGold_Small : public AYPickupGold
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79902 ];

		return pClassPointer;
	};

};

UClass* AYPickupGold_Small::pClassPointer = NULL;

// Class SRGame.YUIScene_ObjectivesPopup
// 0x0010 (0x0754 - 0x0744)
class UYUIScene_ObjectivesPopup : public UYUIScenes
{
public:
	class UUILabel*                                    m_titleLabel;                                     		// 0x0744 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_objectiveDetails;                               		// 0x0748 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_background;                                     		// 0x074C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              ShowDuration;                                     		// 0x0750 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79910 ];

		return pClassPointer;
	};

	bool BeginSceneCloseAnimation ( unsigned long bCloseChildScenes );
	void BeginSceneOpenAnimation ( );
	void AutoClose ( );
	void Init ( struct FString Title, struct FString details, class UObject* Content, float popupDuration );
	void SceneActivated ( unsigned long bInitialActivation );
};

UClass* UYUIScene_ObjectivesPopup::pClassPointer = NULL;

// Class SRGame.YUIScene_IntelCollectiblePopup
// 0x0000 (0x0754 - 0x0754)
class UYUIScene_IntelCollectiblePopup : public UYUIScene_ObjectivesPopup
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 79909 ];

		return pClassPointer;
	};

	bool BeginSceneCloseAnimation ( unsigned long bCloseChildScenes );
	void Init ( struct FString Title, struct FString details, class UObject* Content, float popupDuration );
};

UClass* UYUIScene_IntelCollectiblePopup::pClassPointer = NULL;

// Class SRGame.YPlayerCamDP_MPPlayerPawn
// 0x0000 (0x0060 - 0x0060)
class UYPlayerCamDP_MPPlayerPawn : public UYPlayerCamDP_PlayerPawn4
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 80634 ];

		return pClassPointer;
	};

};

UClass* UYPlayerCamDP_MPPlayerPawn::pClassPointer = NULL;

// Class SRGame.YUIScene_Scoreboard_DM
// 0x0000 (0x07AC - 0x07AC)
class UYUIScene_Scoreboard_DM : public UYUIScene_Scoreboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 81123 ];

		return pClassPointer;
	};

	void PostInitialize ( );
};

UClass* UYUIScene_Scoreboard_DM::pClassPointer = NULL;

// Class SRGame.YUIScene_CommonItems
// 0x0034 (0x07A8 - 0x0774)
class UYUIScene_CommonItems : public UYUIFrontEnd
{
public:
	class UUICalloutButtonPanel*                       m_ButtonBar;                                      		// 0x0774 (0x0004) [0x0000000000000000]              
	int                                                m_offset;                                         		// 0x0778 (0x0004) [0x0000000000000000]              
	int                                                m_numItems;                                       		// 0x077C (0x0004) [0x0000000000000000]              
	int                                                m_selectedIndex;                                  		// 0x0780 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_hasChangedSelection : 1;                        		// 0x0784 (0x0004) [0x0000000000000000] [0x00000001] 
	class UYUIDataStore_Equipment*                     m_EquipmentDataStore;                             		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_LockedItemImage;                                		// 0x078C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_numVisibleButtons;                              		// 0x0798 (0x0004) [0x0000000000000000]              
	int                                                m_numItemsInRow;                                  		// 0x079C (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_ScrollMarker;                                   		// 0x07A0 (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_ScrollBackground;                               		// 0x07A4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 81127 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void ApplyChanges ( );
	bool IsItemUnlocked ( int Index );
	bool OnChooseItem ( class UUIScreenObject* EventObject, int PlayerIndex );
	int GetProviderIndexFromScreen ( int Index );
	bool IsProviderOnScreen ( int Index );
	void ScrollDown ( int ScrollValue );
	void ScrollUp ( int ScrollValue );
	bool OnPageUp ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnPageDown ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void PostInitialize ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void OnSelectItem ( int PlayerIndex );
	void InitWidgetRef ( );
};

UClass* UYUIScene_CommonItems::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Rewards
// 0x00A0 (0x0848 - 0x07A8)
class UYUIFrontEnd_Rewards : public UYUIScene_CommonItems
{
public:
	struct FYSRewards_Row                              m_Rows[ 0x4 ];                                    		// 0x07A8 (0x0060) [0x0000000000000000]              
	class UUIScene*                                    m_MatchEndXPSceneRef;                             		// 0x0808 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UYUIDataProvider_Equipment* >        equipmentProviders;                               		// 0x080C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct UYUIFrontEnd_Rewards_FYS_ContentPackInfoItem > m_ContentPackInfo;                                		// 0x0818 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FKit_Data >                         kitData;                                          		// 0x0824 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_ArmorTypes;                                     		// 0x0830 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UYUIDataProvider_PlaylistInfo* >     playlistsUnlocked;                                		// 0x083C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 81187 ];

		return pClassPointer;
	};

	void AddDataToOutProvider ( TArray< struct FKitInfo > m_KitGearList, unsigned char kitType, unsigned char TeamID, TArray< struct FKit_Data >* OutProviders );
	struct FString GetResourceName ( struct FName resourcePath );
	void GetResourceList ( struct FYMP_HandleAssetPair assetPair, struct UYUIFrontEnd_Rewards_FYS_ContentPackInfoItem ContentPack, int Level, unsigned long prestigeLevel, TArray< struct FKitInfo >* patternList );
	void CollectPatterns ( int Level );
	void CollectArmor ( int Level );
	void CollectAccessories ( int Level );
	void CollectHeads ( int Level );
	void GetUnlockedPlaylists ( int Level );
	void AddUniqueItem ( class UYUIDataProvider_Equipment* Provider, TArray< class UYUIDataProvider_Equipment* >* OutProviders );
	void AddCompletedChallenges ( int Level, TArray< class UYUIDataProvider_Equipment* >* OutProviders );
	int LastLevel ( class AYPlayerController* PC );
	bool JustLeveledUp ( class AYPlayerController* PC );
	int FindPerkPlaytime ( unsigned char perk );
	bool GetUnlockedLevel2Perks ( int TeamID, int rankLevel, TArray< class UYUIDataProvider_Equipment* >* OutProviders );
	bool GetUnlockedItemsLevelUp ( int TeamID, int rankLevel, TArray< class UYUIDataProvider_Equipment* >* OutProviders );
	void ApplyChanges ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool OnCloseClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void InitWidgetRef ( );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_Rewards::pClassPointer = NULL;

// Class SRGame.YTrigger_CapnVantagePoint
// 0x0004 (0x0208 - 0x0204)
class AYTrigger_CapnVantagePoint : public AYTrigger_Interaction
{
public:
	class AActor*                                      m_YachtActor;                                     		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 82061 ];

		return pClassPointer;
	};

	bool CheckAchieve ( class AYPlayerController_MP* controllerMP );
};

UClass* AYTrigger_CapnVantagePoint::pClassPointer = NULL;

// Class SRGame.YTrigger_DPInteraction
// 0x0004 (0x0208 - 0x0204)
class AYTrigger_DPInteraction : public AYTrigger_Interaction
{
public:
	class AYDestroyPoint*                              m_destroyPoint;                                   		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 82572 ];

		return pClassPointer;
	};

};

UClass* AYTrigger_DPInteraction::pClassPointer = NULL;

// Class SRGame.YTrigger_InteractionHold
// 0x0008 (0x020C - 0x0204)
class AYTrigger_InteractionHold : public AYTrigger_Interaction
{
public:
	class APawn*                                       m_currentInstigator;                              		// 0x0204 (0x0004) [0x0000000000000000]              
	float                                              m_fStartTime;                                     		// 0x0208 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 82614 ];

		return pClassPointer;
	};

	void Reset ( );
	bool CanDoInteraction ( class AController* PC );
	void Tick ( float DeltaTime );
	void UnTouch ( class AActor* Other );
	void Cleanup ( );
	void CompleteInteract ( );
	void StopInteract ( class APawn* InInstigator );
	void StartInteract ( class APawn* InInstigator );
	float GetRemainingTime ( );
	float GetElapsedTime ( );
	void SetText ( );
	void ActivateEvent ( int indice );
	class UYSeqEvt_InteractionHold* GetEvent ( );
};

UClass* AYTrigger_InteractionHold::pClassPointer = NULL;

// Class SRGame.YWeapon_FNP45
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_FNP45 : public AYWeapon_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 82834 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_FNP45::pClassPointer = NULL;

// Class SRGame.YWeapon_Expl_Grenade
// 0x0000 (0x0CA9 - 0x0CA9)
class AYWeapon_Expl_Grenade : public AYWeapon_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 82835 ];

		return pClassPointer;
	};

	class AController* GetDamageInstigator ( );
};

UClass* AYWeapon_Expl_Grenade::pClassPointer = NULL;

// Class SRGame.YTrigger_VPInteraction
// 0x0004 (0x0208 - 0x0204)
class AYTrigger_VPInteraction : public AYTrigger_Interaction
{
public:
	class AYVitalPoint*                                m_vitalPoint;                                     		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 82854 ];

		return pClassPointer;
	};

};

UClass* AYTrigger_VPInteraction::pClassPointer = NULL;

// Class SRGame.YTrigger_OLComStation
// 0x0004 (0x0208 - 0x0204)
class AYTrigger_OLComStation : public AYTrigger_Interaction
{
public:
	class AYComStation*                                m_comStation;                                     		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 82971 ];

		return pClassPointer;
	};

};

UClass* AYTrigger_OLComStation::pClassPointer = NULL;

// Class SRGame.YPlayerController_LobbyQM
// 0x0000 (0x111C - 0x111C)
class AYPlayerController_LobbyQM : public AYPlayerController_Lobby
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 83482 ];

		return pClassPointer;
	};

};

UClass* AYPlayerController_LobbyQM::pClassPointer = NULL;

// Class SRGame.YPlayerController_Party
// 0x0000 (0x111C - 0x111C)
class AYPlayerController_Party : public AYPlayerController_Menu
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 83598 ];

		return pClassPointer;
	};

};

UClass* AYPlayerController_Party::pClassPointer = NULL;

// Class SRGame.YPlayerController_SDM
// 0x0034 (0x12D0 - 0x129C)
class AYPlayerController_SDM : public AYPlayerController_MP
{
public:
	class AYRADStation*                                m_currentRADStation;                              		// 0x129C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_playerActionMessagesSDM[ 0x2 ];                 		// 0x12A0 (0x0018) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_playerInteractionMessagesSDM[ 0x2 ];            		// 0x12B8 (0x0018) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 83601 ];

		return pClassPointer;
	};

	void StopSDMActions ( );
	void ServerDoActivate ( class AYRADStation* RS, int Team );
	void ServerDoDeactivate ( class AYRADStation* RS, int Team );
	void ServerRespawnTeam ( int Team );
	void ConditionalDoActivate ( );
	void ConditionalDoDeactivate ( );
	void GetSpecialMoveMessages ( );
	void UpdateSpecialMoveButtonAction ( unsigned char buttonType, unsigned long updateNow );
	bool GamePad_EndAContextSensativeMove ( );
	bool GamePad_StartAContextSensativeMove ( );
	void CheckActivateRADStation ( );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void PostBeginPlay ( );
};

UClass* AYPlayerController_SDM::pClassPointer = NULL;

// Class SRGame.YTrigger_RADStation
// 0x0004 (0x0208 - 0x0204)
class AYTrigger_RADStation : public AYTrigger_Interaction
{
public:
	class AYRADStation*                                m_RADStation;                                     		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 83616 ];

		return pClassPointer;
	};

};

UClass* AYTrigger_RADStation::pClassPointer = NULL;

// Class SRGame.YSquadLeaderMessage
// 0x0024 (0x0090 - 0x006C)
class UYSquadLeaderMessage : public UYLocalMessage
{
public:
	struct FString                                     m_becameLeader;                                   		// 0x006C (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_lostLeadership;                                 		// 0x0078 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_newLeaderIs;                                    		// 0x0084 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 84063 ];

		return pClassPointer;
	};

	void DisplayHudMessage ( class AHUD* H, class APlayerReplicationInfo* PRI1, class APlayerReplicationInfo* PRI2, int Switch, struct FString Message );
	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	struct FColor GetConsoleColor ( class APlayerReplicationInfo* RelatedPRI );
};

UClass* UYSquadLeaderMessage::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_SystemLink
// 0x0014 (0x07B0 - 0x079C)
class UYUIFrontEnd_SystemLink : public UYUIFrontEnd_BasicMenu
{
public:
	int                                                m_exodusProgressionToUnlockVersus;                		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     m_SceneCharacterCreation;                         		// 0x07A0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UYUIScrollingTextPanel*                      m_MessageOfTheDay;                                		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 84097 ];

		return pClassPointer;
	};

	void SceneActivated ( unsigned long bInitialActivation );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	void InitWidget ( );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_SystemLink::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_LobbyQM
// 0x0000 (0x04D4 - 0x04D4)
class AYPlayerReplicationInfo_LobbyQM : public AYPlayerReplicationInfo_Lobby
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 84452 ];

		return pClassPointer;
	};

	void SetVoteIndex ( int Index );
};

UClass* AYPlayerReplicationInfo_LobbyQM::pClassPointer = NULL;

// Class SRGame.YPlayerReplicationInfo_Party
// 0x0000 (0x03B8 - 0x03B8)
class AYPlayerReplicationInfo_Party : public AYPlayerReplicationInfo
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 84464 ];

		return pClassPointer;
	};

};

UClass* AYPlayerReplicationInfo_Party::pClassPointer = NULL;

// Class SRGame.YProj_FNSCARgrenade
// 0x0000 (0x0678 - 0x0678)
class AYProj_FNSCARgrenade : public AYProj_Physical
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85110 ];

		return pClassPointer;
	};

};

UClass* AYProj_FNSCARgrenade::pClassPointer = NULL;

// Class SRGame.YProj_Guided
// 0x0058 (0x0434 - 0x03DC)
class AYProj_Guided : public AYProjectile
{
public:
	class AActor*                                      m_currentLockTarget;                              		// 0x03DC (0x0004) [0x0000000000000000]              
	float                                              m_rotationSpeedRad;                               		// 0x03E0 (0x0004) [0x0000000000000000]              
	float                                              m_timeSinceLastLog;                               		// 0x03E4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_lastLocation;                                   		// 0x03E8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_preImpactLocation;                              		// 0x03F4 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_pawnCameraLocation;                             		// 0x0400 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_pawnCameraDirection;                            		// 0x040C (0x000C) [0x0000000000000000]              
	float                                              m_timeleftAttractedToCamLine;                     		// 0x0418 (0x0004) [0x0000000000000000]              
	float                                              m_cameraLineAttraction;                           		// 0x041C (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_timeToStartHeading;                             		// 0x0420 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_rotationSpeed;                                  		// 0x0424 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_fullRotationCloseRange;                         		// 0x0428 (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	float                                              m_triggerOnApproachRange;                         		// 0x042C (0x0004) [0x0000000000004002]              ( CPF_Const | CPF_Config )
	class AYGamePawn*                                  m_causingPawn;                                    		// 0x0430 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85191 ];

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	void GetWeapon ( );
	void ClearPawn ( );
	void InitTracer ( struct FVector StartLoc, struct FVector endLoc, class AYGamePawn* causer );
	void SetTargetActor ( class AActor* TargetActor );
	void Explode ( struct FVector HitLocation, struct FVector HitNormal );
	void HitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYProj_Guided::pClassPointer = NULL;

// Class SRGame.YProj_MilkorMGLgrenade
// 0x0000 (0x0678 - 0x0678)
class AYProj_MilkorMGLgrenade : public AYProj_Physical
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85236 ];

		return pClassPointer;
	};

};

UClass* AYProj_MilkorMGLgrenade::pClassPointer = NULL;

// Class SRGame.YProj_MilkorMGLgrenade_AI
// 0x0000 (0x0678 - 0x0678)
class AYProj_MilkorMGLgrenade_AI : public AYProj_MilkorMGLgrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85242 ];

		return pClassPointer;
	};

};

UClass* AYProj_MilkorMGLgrenade_AI::pClassPointer = NULL;

// Class SRGame.YProj_MilkorMGLgrenade_Truckride
// 0x0000 (0x0678 - 0x0678)
class AYProj_MilkorMGLgrenade_Truckride : public AYProj_MilkorMGLgrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85247 ];

		return pClassPointer;
	};

};

UClass* AYProj_MilkorMGLgrenade_Truckride::pClassPointer = NULL;

// Class SRGame.YProj_Mk47StrikerGrenade
// 0x0000 (0x0678 - 0x0678)
class AYProj_Mk47StrikerGrenade : public AYProj_Physical
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85252 ];

		return pClassPointer;
	};

};

UClass* AYProj_Mk47StrikerGrenade::pClassPointer = NULL;

// Class SRGame.YProj_Mortar
// 0x0024 (0x069C - 0x0678)
class AYProj_Mortar : public AYProj_Physical
{
public:
	float                                              m_timeToReachCloseTargets;                        		// 0x0678 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_timeToReachFarTargets;                          		// 0x067C (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_closeTargetRange;                               		// 0x0680 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	float                                              m_farTargetRange;                                 		// 0x0684 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector                                     m_impactLoc;                                      		// 0x0688 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_explosionHeight;                                		// 0x0694 (0x0004) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	unsigned long                                      m_armed : 1;                                      		// 0x0698 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85258 ];

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	void InitTracer ( struct FVector StartLoc, struct FVector endLoc, class AYGamePawn* causer );
	void CalcExactCurve ( struct FVector StartLoc, struct FVector endLoc, float* startSpeed, struct FVector* AimDir );
};

UClass* AYProj_Mortar::pClassPointer = NULL;

// Class SRGame.YProj_RPG
// 0x0000 (0x0678 - 0x0678)
class AYProj_RPG : public AYProj_Physical
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85649 ];

		return pClassPointer;
	};

	float GetThrowSpeedModifier ( class AYGamePawn* ThrowingPawn );
};

UClass* AYProj_RPG::pClassPointer = NULL;

// Class SRGame.YProj_RPG_AI
// 0x0000 (0x0678 - 0x0678)
class AYProj_RPG_AI : public AYProj_RPG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85658 ];

		return pClassPointer;
	};

	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* AYProj_RPG_AI::pClassPointer = NULL;

// Class SRGame.YProj_RPG_Chopper
// 0x0000 (0x0678 - 0x0678)
class AYProj_RPG_Chopper : public AYProj_RPG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85668 ];

		return pClassPointer;
	};

	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* AYProj_RPG_Chopper::pClassPointer = NULL;

// Class SRGame.YProj_Smartbullet
// 0x0000 (0x0434 - 0x0434)
class AYProj_Smartbullet : public AYProj_Guided
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85678 ];

		return pClassPointer;
	};

};

UClass* AYProj_Smartbullet::pClassPointer = NULL;

// Class SRGame.YProj_Warhead
// 0x0000 (0x0434 - 0x0434)
class AYProj_Warhead : public AYProj_Guided
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85882 ];

		return pClassPointer;
	};

};

UClass* AYProj_Warhead::pClassPointer = NULL;

// Class SRGame.YPrototypeGameMessage
// 0x05A0 (0x060C - 0x006C)
class UYPrototypeGameMessage : public UYLocalMessage
{
public:
	struct FString                                     m_sameTeamMessage[ 0x3C ];                        		// 0x006C (0x02D0) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_otherTeamMessage[ 0x3C ];                       		// 0x033C (0x02D0) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85898 ];

		return pClassPointer;
	};

	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYPrototypeGameMessage::pClassPointer = NULL;

// Class SRGame.YSeqEvt_TM_RADStationActivated
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_TM_RADStationActivated : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 85957 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_TM_RADStationActivated::pClassPointer = NULL;

// Class SRGame.YScope
// 0x0018 (0x0054 - 0x003C)
class UYScope : public UObject
{
public:
	class AYWeapon*                                    m_owningWeapon;                                   		// 0x003C (0x0004) [0x0000000000000000]              
	class UYUIScene_Scope*                             m_scopeSceneTemplate;                             		// 0x0040 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UYUIScene_Scope*                             m_scopeScene;                                     		// 0x0044 (0x0004) [0x0000000000000000]              
	float                                              m_rotHMultiplier;                                 		// 0x0048 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_rotVMultiplier;                                 		// 0x004C (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                m_scenePriority;                                  		// 0x0050 (0x0004) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 86501 ];

		return pClassPointer;
	};

	class UYUIScenes* OpenScene ( class UYUIScenes* Template );
	void GetCameraRotationModifier ( float* turnH, float* turnV );
	void CleanupScope ( );
	void InitScope ( class AYWeapon* Owner );
};

UClass* UYScope::pClassPointer = NULL;

// Class SRGame.YRemoteSpeaker_Placeable
// 0x0000 (0x0248 - 0x0248)
class AYRemoteSpeaker_Placeable : public AYRemoteSpeaker_Generic
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87092 ];

		return pClassPointer;
	};

};

UClass* AYRemoteSpeaker_Placeable::pClassPointer = NULL;

// Class SRGame.YSeqEvent_FastRope
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_FastRope : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87163 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_FastRope::pClassPointer = NULL;

// Class SRGame.YSA_SimpleRef
// 0x0030 (0x0074 - 0x0044)
class UYSA_SimpleRef : public UYSpecialAction
{
public:
	struct FName                                       m_animName;                                       		// 0x0044 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UAnimSet*                                    m_animSet;                                        		// 0x004C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_animType;                                       		// 0x0050 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_priority;                                       		// 0x0051 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FYS_FaceFXAnim                              m_faceFXAnim;                                     		// 0x0054 (0x001C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_loopAnimation : 1;                              		// 0x0070 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87190 ];

		return pClassPointer;
	};

	void GetAnimInfo ( struct FYS_AnimInfo* AnimInfo, class UAnimSet** AnimSet, unsigned char* looped );
	bool HasSoundCue ( );
	bool HasAnim ( );
	bool PlayAnimInternal ( class AYGamePawn* Pawn );
	class UYSpecialActionInstance* GetInstanceFromPawn ( class AYGamePawn* Pawn );
};

UClass* UYSA_SimpleRef::pClassPointer = NULL;

// Class SRGame.YSandBomb
// 0x0010 (0x0210 - 0x0200)
class AYSandBomb : public AStaticMeshActor
{
public:
	float                                              m_health;                                         		// 0x0200 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_reenableIntervall;                              		// 0x0204 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              m_currentDamage;                                  		// 0x0208 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_enabled : 1;                                    		// 0x020C (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87283 ];

		return pClassPointer;
	};

	void ReenableSandBomb ( );
	void TakeDamage ( int DamageAmount, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void PostBeginPlay ( );
};

UClass* AYSandBomb::pClassPointer = NULL;

// Class SRGame.YSeqEvent_SandBombTriggered
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_SandBombTriggered : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87294 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_SandBombTriggered::pClassPointer = NULL;

// Class SRGame.YSeqEvt_PawnEntersStorm
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_PawnEntersStorm : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87314 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_PawnEntersStorm::pClassPointer = NULL;

// Class SRGame.YUIScene_ScopeBarret
// 0x0000 (0x0858 - 0x0858)
class UYUIScene_ScopeBarret : public UYUIScene_Scope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87467 ];

		return pClassPointer;
	};

};

UClass* UYUIScene_ScopeBarret::pClassPointer = NULL;

// Class SRGame.YScope_Barrett
// 0x0000 (0x0054 - 0x0054)
class UYScope_Barrett : public UYScope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87470 ];

		return pClassPointer;
	};

};

UClass* UYScope_Barrett::pClassPointer = NULL;

// Class SRGame.YUIScene_ScopeACOG
// 0x0000 (0x0858 - 0x0858)
class UYUIScene_ScopeACOG : public UYUIScene_Scope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87473 ];

		return pClassPointer;
	};

};

UClass* UYUIScene_ScopeACOG::pClassPointer = NULL;

// Class SRGame.YScope_FAMAS
// 0x0000 (0x0054 - 0x0054)
class UYScope_FAMAS : public UYScope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87476 ];

		return pClassPointer;
	};

};

UClass* UYScope_FAMAS::pClassPointer = NULL;

// Class SRGame.YUIScene_ScopeHK417
// 0x0000 (0x0858 - 0x0858)
class UYUIScene_ScopeHK417 : public UYUIScene_Scope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87479 ];

		return pClassPointer;
	};

};

UClass* UYUIScene_ScopeHK417::pClassPointer = NULL;

// Class SRGame.YScope_HK417
// 0x0000 (0x0054 - 0x0054)
class UYScope_HK417 : public UYScope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87482 ];

		return pClassPointer;
	};

};

UClass* UYScope_HK417::pClassPointer = NULL;

// Class SRGame.YScope_M110
// 0x0000 (0x0054 - 0x0054)
class UYScope_M110 : public UYScope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87485 ];

		return pClassPointer;
	};

};

UClass* UYScope_M110::pClassPointer = NULL;

// Class SRGame.YScope_MSG
// 0x0000 (0x0054 - 0x0054)
class UYScope_MSG : public UYScope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87487 ];

		return pClassPointer;
	};

};

UClass* UYScope_MSG::pClassPointer = NULL;

// Class SRGame.YScope_SteyrElite
// 0x0000 (0x0054 - 0x0054)
class UYScope_SteyrElite : public UYScope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87489 ];

		return pClassPointer;
	};

};

UClass* UYScope_SteyrElite::pClassPointer = NULL;

// Class SRGame.YScope_SteyrEliteHP
// 0x0000 (0x0054 - 0x0054)
class UYScope_SteyrEliteHP : public UYScope
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87491 ];

		return pClassPointer;
	};

};

UClass* UYScope_SteyrEliteHP::pClassPointer = NULL;

// Class SRGame.YSeqAct_AdditionalAnimsets
// 0x0018 (0x010C - 0x00F4)
class UYSeqAct_AdditionalAnimsets : public USequenceAction
{
public:
	TArray< struct FYS_AnimSet >                       m_animSets;                                       		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FYS_AimingSet >                     m_aimingSets;                                     		// 0x0100 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87600 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_AdditionalAnimsets::pClassPointer = NULL;

// Class SRGame.YSeqAct_AttachSCToGUI
// 0x0014 (0x0108 - 0x00F4)
class UYSeqAct_AttachSCToGUI : public USequenceAction
{
public:
	struct FVector2D                                   m_position;                                       		// 0x00F4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_size;                                           		// 0x00FC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_playerIndex;                                    		// 0x0104 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87653 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_AttachSCToGUI::pClassPointer = NULL;

// Class SRGame.YSeqAct_BDTrumpAnimEnded
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_BDTrumpAnimEnded : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87680 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_BDTrumpAnimEnded::pClassPointer = NULL;

// Class SRGame.YSeqAct_Berserk
// 0x0004 (0x011C - 0x0118)
class UYSeqAct_Berserk : public UYSeqAct_RunBehaviorTreeScripted
{
public:
	unsigned long                                      m_makePlayerTheAttackTarget : 1;                  		// 0x0118 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87712 ];

		return pClassPointer;
	};

	void OnActivated ( class AYAIController* ctrl );
	void SetBehaviorFilters ( TArray< unsigned char >* filters );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_Berserk::pClassPointer = NULL;

// Class SRGame.YSeqAct_BroadCastMessage
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_BroadCastMessage : public USequenceAction
{
public:
	int                                                m_message;                                        		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_teamIndex;                                      		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UObject*                                     m_otherPlayer;                                    		// 0x00FC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87728 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_BroadCastMessage::pClassPointer = NULL;

// Class SRGame.YSeqAct_CA_ChopperDestroyed
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_CA_ChopperDestroyed : public USequenceAction
{
public:
	class UObject*                                     m_clientPlayer;                                   		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87735 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_CA_ChopperDestroyed::pClassPointer = NULL;

// Class SRGame.YSeqAct_CA_NextTarget
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_CA_NextTarget : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87741 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_CA_NextTarget::pClassPointer = NULL;

// Class SRGame.YSeqAct_CauseSpatialDamage
// 0x0014 (0x0108 - 0x00F4)
class UYSeqAct_CauseSpatialDamage : public USequenceAction
{
public:
	class UObject*                                     m_spawnLocationObject;                            		// 0x00F4 (0x0004) [0x0000000000000000]              
	class UYDamageEvaluationParams*                    m_damageParams;                                   		// 0x00F8 (0x0004) [0x0000000000000000]              
	struct FName                                       m_damageParamsName;                               		// 0x00FC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_damageType;                                     		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87756 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_CauseSpatialDamage::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheapShooter_LookAt
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_CheapShooter_LookAt : public USequenceAction
{
public:
	class UObject*                                     m_cheapShooter;                                   		// 0x00F4 (0x0004) [0x0000000000000000]              
	class UObject*                                     m_lookAt;                                         		// 0x00F8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_enable : 1;                                     		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87852 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_CheapShooter_LookAt::pClassPointer = NULL;

// Class SRGame.YSeqAct_CheckEpilogueUnlocked
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_CheckEpilogueUnlocked : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87935 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_CheckEpilogueUnlocked::pClassPointer = NULL;

// Class SRGame.YSeqAct_CleanupSpawns
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_CleanupSpawns : public USequenceAction
{
public:
	float                                              m_range;                                          		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AActor*                                      m_locationActor;                                  		// 0x00F8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_destroyDroppedWeapons : 1;                      		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_destroyAmmoClips : 1;                           		// 0x00FC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_destroyProjectiles : 1;                         		// 0x00FC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_destroyDeadPawns : 1;                           		// 0x00FC (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_destroyKActors : 1;                             		// 0x00FC (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87966 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_CleanupSpawns::pClassPointer = NULL;

// Class SRGame.YSeqAct_CloseMenuScenes
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_CloseMenuScenes : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87992 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_CloseMenuScenes::pClassPointer = NULL;

// Class SRGame.YSeqAct_Combat
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_Combat : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 87998 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_Combat::pClassPointer = NULL;

// Class SRGame.YSeqAct_ControlAnimPlayback
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_ControlAnimPlayback : public USequenceAction
{
public:
	float                                              m_playbackPosition;                               		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_playbackRate;                                   		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88003 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_ControlAnimPlayback::pClassPointer = NULL;

// Class SRGame.YSeqAct_DestroyPoint
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_DestroyPoint : public USequenceAction
{
public:
	class AYDestroyPoint*                              m_destroyPoint;                                   		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88110 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_DestroyPoint::pClassPointer = NULL;

// Class SRGame.YSeqAct_DetachSCFromGUI
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_DetachSCFromGUI : public USequenceAction
{
public:
	int                                                m_playerIndex;                                    		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88114 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_DetachSCFromGUI::pClassPointer = NULL;

// Class SRGame.YSeqAct_DisableAmmoConsumption
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_DisableAmmoConsumption : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88117 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_DisableAmmoConsumption::pClassPointer = NULL;

// Class SRGame.YSeqAct_DisableDeathAnimSystem
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_DisableDeathAnimSystem : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88123 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_DisableDeathAnimSystem::pClassPointer = NULL;

// Class SRGame.YSeqAct_EnableGrenades4ExecutionLoot
// 0x0018 (0x010C - 0x00F4)
class UYSeqAct_EnableGrenades4ExecutionLoot : public USequenceAction
{
public:
	TArray< unsigned char >                            m_grenadesToAllow;                                		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_grenadesToForbid;                               		// 0x0100 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88177 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_EnableGrenades4ExecutionLoot::pClassPointer = NULL;

// Class SRGame.YSeqAct_EnableHitReactionAnimations
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_EnableHitReactionAnimations : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88193 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_EnableHitReactionAnimations::pClassPointer = NULL;

// Class SRGame.YSeqAct_EndCoopGame
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_EndCoopGame : public USequenceAction
{
public:
	unsigned long                                      m_playersWin : 1;                                 		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FName                                       m_endGameMessage;                                 		// 0x00F8 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88206 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_EndCoopGame::pClassPointer = NULL;

// Class SRGame.YSeqAct_EndGame
// 0x0001 (0x00F5 - 0x00F4)
class UYSeqAct_EndGame : public USequenceAction
{
public:
	unsigned char                                      m_winner;                                         		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88213 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_EndGame::pClassPointer = NULL;

// Class SRGame.YSeqAct_EventTracker
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_EventTracker : public USequenceAction
{
public:
	unsigned long                                      m_clearEventMessages : 1;                         		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88224 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_EventTracker::pClassPointer = NULL;

// Class SRGame.YSeqAct_FadeMasterVolume
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_FadeMasterVolume : public USequenceAction
{
public:
	float                                              m_time;                                           		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_targetVolume;                                   		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88238 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_FadeMasterVolume::pClassPointer = NULL;

// Class SRGame.YSeqAct_FadeToWhite
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_FadeToWhite : public USequenceAction
{
public:
	TArray< struct FString >                           m_fadeToWhiteMovies;                              		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class AYPlayerController*                          m_playerController;                               		// 0x0100 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88249 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_FadeToWhite::pClassPointer = NULL;

// Class SRGame.YSeqAct_FakeCutsceneWeapon
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_FakeCutsceneWeapon : public USequenceAction
{
public:
	unsigned char                                      m_cutsceneWeaponEnum;                             		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_storedWeaponClass;                              		// 0x00F8 (0x0004) [0x0000000000000000]              
	class AYWeapon*                                    m_tempWeapon;                                     		// 0x00FC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_input0Activated : 1;                            		// 0x0100 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_input1Activated : 1;                            		// 0x0100 (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88258 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_FakeCutsceneWeapon::pClassPointer = NULL;

// Class SRGame.YSeqAct_FireShots
// 0x0008 (0x0120 - 0x0118)
class UYSeqAct_FireShots : public UYSeqAct_RunBehaviorTreeScripted
{
public:
	int                                                m_numShots;                                       		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_crouch : 1;                                     		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88276 ];

		return pClassPointer;
	};

	void SetBehaviorFilters ( TArray< unsigned char >* filters );
	void OnActivated ( class AYAIController* ctrl );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_FireShots::pClassPointer = NULL;

// Class SRGame.YSeqAct_ForceInteractionSequence
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_ForceInteractionSequence : public USequenceAction
{
public:
	class AYTrigger_InteractionSequence*               m_interaction;                                    		// 0x00F4 (0x0004) [0x0000000000000000]              
	int                                                m_index;                                          		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88288 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ForceInteractionSequence::pClassPointer = NULL;

// Class SRGame.YTrigger_InteractionSequence
// 0x0010 (0x021C - 0x020C)
class AYTrigger_InteractionSequence : public AYTrigger_InteractionHold
{
public:
	TArray< struct FYS_InteractionSequence >           m_sequences;                                      		// 0x020C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_currentSequenceIndex;                           		// 0x0218 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88291 ];

		return pClassPointer;
	};

	void CompleteInteract ( );
	bool CanDoInteraction ( class AController* PC );
	void ActivateSequence ( int Index );
	void FirstInitializeSequence ( );
	void PostBeginPlay ( );
	void ReplicatedEvent ( struct FName VarName );
};

UClass* AYTrigger_InteractionSequence::pClassPointer = NULL;

// Class SRGame.YSeqAct_ForceLOD
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_ForceLOD : public USequenceAction
{
public:
	int                                                m_forcedLODLevel;                                 		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88294 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_ForceLOD::pClassPointer = NULL;

// Class SRGame.YSeqAct_ForceRadioFilter
// 0x0001 (0x0105 - 0x0104)
class UYSeqAct_ForceRadioFilter : public USeqAct_Latent
{
public:
	unsigned char                                      m_setting;                                        		// 0x0104 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88302 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ForceRadioFilter::pClassPointer = NULL;

// Class SRGame.YSeqAct_ForceRaisedWeapon
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ForceRaisedWeapon : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88307 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ForceRaisedWeapon::pClassPointer = NULL;

// Class SRGame.YSeqAct_ForceSprinting
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_ForceSprinting : public USequenceAction
{
public:
	unsigned long                                      m_combatSprint : 1;                               		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88312 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_ForceSprinting::pClassPointer = NULL;

// Class SRGame.YSeqAct_FreeFMODEventData
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_FreeFMODEventData : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88321 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_FreeFMODEventData::pClassPointer = NULL;

// Class SRGame.YSeqAct_GameEvent
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_GameEvent : public USequenceAction
{
public:
	int                                                m_specopsEventID;                                 		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_konradEventID;                                  		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UObject*                                     m_pawn;                                           		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88336 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_GameEvent::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetActorLocationRotation
// 0x0028 (0x011C - 0x00F4)
class UYSeqAct_GetActorLocationRotation : public USequenceAction
{
public:
	class UObject*                                     m_actor;                                          		// 0x00F4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_locationVector;                                 		// 0x00F8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_rotationVector;                                 		// 0x0104 (0x000C) [0x0000000000000000]              
	float                                              m_rotationPitch;                                  		// 0x0110 (0x0004) [0x0000000000000000]              
	float                                              m_rotationYaw;                                    		// 0x0114 (0x0004) [0x0000000000000000]              
	float                                              m_rotationRoll;                                   		// 0x0118 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88345 ];

		return pClassPointer;
	};

	void Activated ( );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_GetActorLocationRotation::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetEnemiesInRange
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_GetEnemiesInRange : public USequenceAction
{
public:
	float                                              m_outerRadius;                                    		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_innerRadius;                                    		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UObject*                                     m_locationObject;                                 		// 0x00FC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88364 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_GetEnemiesInRange::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetGameInfoType
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_GetGameInfoType : public USequenceAction
{
public:
	unsigned long                                      m_bIsMenuInfo : 1;                                		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88383 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_GetGameInfoType::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetGameMode
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_GetGameMode : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88390 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_GetGameMode::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetStormfrontRule
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_GetStormfrontRule : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88417 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_GetStormfrontRule::pClassPointer = NULL;

// Class SRGame.YSeqAct_GetTeamNum
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_GetTeamNum : public USequenceAction
{
public:
	int                                                m_teamNum;                                        		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88421 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_GetTeamNum::pClassPointer = NULL;

// Class SRGame.YSeqAct_GiveXP
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_GiveXP : public USequenceAction
{
public:
	int                                                m_xpModifierID;                                   		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88428 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_GiveXP::pClassPointer = NULL;

// Class SRGame.YSeqAct_HeadShot
// 0x001C (0x0134 - 0x0118)
class UYSeqAct_HeadShot : public UYSeqAct_RunBehaviorTreeScripted
{
public:
	class UObject*                                     m_attackTarget;                                   		// 0x0118 (0x0004) [0x0000000000000000]              
	float                                              m_delayBeforeShot;                                		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_numShots;                                       		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_delayBeforeForcedKill;                          		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_delayAfterShot;                                 		// 0x0128 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_vaporizationType;                               		// 0x012C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_crouch : 1;                                     		// 0x0130 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88459 ];

		return pClassPointer;
	};

	void SetBehaviorFilters ( TArray< unsigned char >* filters );
	bool SetKismetTimer ( unsigned char timerid, struct FYBT_Timer* Timer );
	void OnActivated ( class AYAIController* ctrl );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_HeadShot::pClassPointer = NULL;

// Class SRGame.YSeqAct_SilentHeadShot
// 0x000C (0x0140 - 0x0134)
class UYSeqAct_SilentHeadShot : public UYSeqAct_HeadShot
{
public:
	float                                              m_delayBeforeSwitchingToSecondaryWeapon;          		// 0x0134 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_delayBeforeSwitchingToPrimaryWeapon;            		// 0x0138 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_doNotSwitchToSecondaryWeapon : 1;               		// 0x013C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_doNotSwitchToPrimaryWeapon : 1;                 		// 0x013C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_doNotModifyArsenal : 1;                         		// 0x013C (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88480 ];

		return pClassPointer;
	};

	void SetBehaviorFilters ( TArray< unsigned char >* filters );
	bool SetKismetTimer ( unsigned char timerid, struct FYBT_Timer* Timer );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SilentHeadShot::pClassPointer = NULL;

// Class SRGame.YSeqAct_HeadShotSecondaryWeapon
// 0x0000 (0x0140 - 0x0140)
class UYSeqAct_HeadShotSecondaryWeapon : public UYSeqAct_SilentHeadShot
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88496 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
};

UClass* UYSeqAct_HeadShotSecondaryWeapon::pClassPointer = NULL;

// Class SRGame.YSeqAct_HideHUDElements
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_HideHUDElements : public USequenceAction
{
public:
	unsigned long                                      m_hideDNBOWarning : 1;                            		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88500 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_HideHUDElements::pClassPointer = NULL;

// Class SRGame.YSeqAct_InitSandstorm
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_InitSandstorm : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88509 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_InitSandstorm::pClassPointer = NULL;

// Class SRGame.YSeqAct_Melee
// 0x0008 (0x0120 - 0x0118)
class UYSeqAct_Melee : public UYSeqAct_RunBehaviorTreeScripted
{
public:
	float                                              m_timeOut;                                        		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_useTuningDelayBeforeMelee : 1;                  		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88558 ];

		return pClassPointer;
	};

	void SetBehaviorFilters ( TArray< unsigned char >* filters );
	bool SetKismetTimer ( unsigned char timerid, struct FYBT_Timer* Timer );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_Melee::pClassPointer = NULL;

// Class SRGame.YSeqAct_MirrorPawn
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_MirrorPawn : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88571 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_MirrorPawn::pClassPointer = NULL;

// Class SRGame.YSeqAct_ModifyMaxRagdolls
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_ModifyMaxRagdolls : public USequenceAction
{
public:
	int                                                m_NewMaxDeadPawns;                                		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88598 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ModifyMaxRagdolls::pClassPointer = NULL;

// Class SRGame.YSeqAct_MP_SetTimer
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_MP_SetTimer : public USequenceAction
{
public:
	float                                              m_time;                                           		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_displayOnHud : 1;                               		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88605 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_MP_SetTimer::pClassPointer = NULL;

// Class SRGame.YSeqAct_OnlyShowPrompts
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_OnlyShowPrompts : public USequenceAction
{
public:
	unsigned long                                      m_OnlyShowPrompts : 1;                            		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_markerRestrictedMode : 1;                       		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88639 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_OnlyShowPrompts::pClassPointer = NULL;

// Class SRGame.YSeqAct_OpenCredits
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_OpenCredits : public USequenceAction
{
public:
	unsigned long                                      m_bIsWalkerAlive : 1;                             		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FString                                     CreditsScene;                                     		// 0x00F8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88647 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_OpenCredits::pClassPointer = NULL;

// Class SRGame.YSeqAct_OverrideReverb
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_OverrideReverb : public USequenceAction
{
public:
	struct FReverbSettings                             Settings;                                         		// 0x00F4 (0x0010) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88686 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_OverrideReverb::pClassPointer = NULL;

// Class SRGame.YSeqAct_PlayerCount
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_PlayerCount : public USequenceAction
{
public:
	int                                                PlayerCount;                                      		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88710 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_PlayerCount::pClassPointer = NULL;

// Class SRGame.YSeqAct_PlayReplicatedAnimation
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_PlayReplicatedAnimation : public USequenceAction
{
public:
	unsigned char                                      m_replicatedAnimID;                               		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_playRateFactor;                                 		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_ignoresDBNO : 1;                                		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class UObject*                                     m_pawn;                                           		// 0x0100 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88720 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_PlayReplicatedAnimation::pClassPointer = NULL;

// Class SRGame.YSeqAct_RefillPawnsAmmo
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_RefillPawnsAmmo : public USequenceAction
{
public:
	unsigned long                                      m_onlyCurrentAmmo : 1;                            		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_onlyReserveAmmo : 1;                            		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88731 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_RefillPawnsAmmo::pClassPointer = NULL;

// Class SRGame.YSeqAct_RefillWater
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_RefillWater : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88738 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_RefillWater::pClassPointer = NULL;

// Class SRGame.YSeqAct_RemoveGrenades
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_RemoveGrenades : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88741 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_RemoveGrenades::pClassPointer = NULL;

// Class SRGame.YSeqAct_ResetInnocentKills
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ResetInnocentKills : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88748 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ResetInnocentKills::pClassPointer = NULL;

// Class SRGame.YSeqAct_ResetYDO
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ResetYDO : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88753 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ResetYDO::pClassPointer = NULL;

// Class SRGame.YSeqAct_RestrictControls
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_RestrictControls : public USequenceAction
{
public:
	struct FYS_ControlRestrictions                     m_controlRestrictions;                            		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88758 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_RestrictControls::pClassPointer = NULL;

// Class SRGame.YSeqAct_Revive
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_Revive : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88765 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_Revive::pClassPointer = NULL;

// Class SRGame.YSeqAct_ScoreTeam
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_ScoreTeam : public USequenceAction
{
public:
	int                                                m_team;                                           		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_scoreIncrease;                                  		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bIsEndOfRoundBonus : 1;                         		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88785 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ScoreTeam::pClassPointer = NULL;

// Class SRGame.YSeqAct_ScoreTeamSurvivalBonus
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_ScoreTeamSurvivalBonus : public USequenceAction
{
public:
	int                                                m_team;                                           		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_maxScoreIncrease;                               		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_perDownDecrease;                                		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88793 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ScoreTeamSurvivalBonus::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetActorLocationRotation
// 0x0020 (0x0114 - 0x00F4)
class UYSeqAct_SetActorLocationRotation : public USequenceAction
{
public:
	class UObject*                                     m_actor;                                          		// 0x00F4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_rotationVector;                                 		// 0x00F8 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_setRotation : 1;                                		// 0x0104 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_setLocation : 1;                                		// 0x0104 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	struct FVector                                     m_locationVector;                                 		// 0x0108 (0x000C) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88805 ];

		return pClassPointer;
	};

	void Activated ( );
	int GetObjClassVersion ( );
};

UClass* UYSeqAct_SetActorLocationRotation::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetBinkVolume
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetBinkVolume : public USequenceAction
{
public:
	float                                              m_volume;                                         		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88820 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetBinkVolume::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetCrowdBehavior
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_SetCrowdBehavior : public USequenceAction
{
public:
	class AGameCrowdAgent*                             m_crowdAgent;                                     		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_panicBehavior : 1;                              		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88829 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetCrowdBehavior::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetDetectorSquad
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetDetectorSquad : public USequenceAction
{
public:
	class AYAISquad*                                   m_squad;                                          		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88841 ];

		return pClassPointer;
	};

};

UClass* UYSeqAct_SetDetectorSquad::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetForceSquadCommand
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetForceSquadCommand : public USequenceAction
{
public:
	unsigned long                                      m_forceCommandsOn : 1;                            		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88878 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetForceSquadCommand::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetIntelSelection
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetIntelSelection : public USequenceAction
{
public:
	unsigned long                                      m_IntelSelectableLocked : 1;                      		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88894 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetIntelSelection::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetMissionSelect
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_SetMissionSelect : public USequenceAction
{
public:
	int                                                m_MissionSelected;                                		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88912 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetMissionSelect::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_SPMission
// 0x0038 (0x07AC - 0x0774)
class UYUIFrontEnd_SPMission : public UYUIFrontEnd
{
public:
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_MissionProgress >               m_missionProgress;                                		// 0x0778 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_currentMission;                                 		// 0x0784 (0x0004) [0x0000000000000000]              
	int                                                m_lastcurrentMission;                             		// 0x0788 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_lblChapterName;                                 		// 0x078C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMissionName;                                 		// 0x0790 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIDataStore_Missions*                      m_missionsDataStore;                              		// 0x0794 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblMissionDescription;                          		// 0x0798 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgDiffLevel;                                   		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             __OnChapterSelected__Delegate;                    		// 0x07A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88916 ];

		return pClassPointer;
	};

	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void OnOverridePlatformChanged ( );
	void SetCurrentMission ( int CurrentMission );
	void UpdateDifficultyIcon ( );
	void UpdateSceneVisuals ( );
	bool CheckNewSelection ( int NewSelection );
	void NewMissionSelection ( int Dir );
	void HandleTick ( float DeltaTime );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitWidget ( );
	void HidePanelsForPressDemo ( );
	void InitWidgetRef ( );
	void OnChapterSelected ( struct FString missionMap );
};

UClass* UYUIFrontEnd_SPMission::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetMoveCamShakes
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_SetMoveCamShakes : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88926 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_SetMoveCamShakes::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetObjective
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_SetObjective : public USequenceAction
{
public:
	unsigned char                                      m_objective;                                      		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_subObjective;                                   		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_complete : 1;                                   		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_showObjectiveTitle : 1;                         		// 0x00FC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88931 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetObjective::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetPawnsWeaponDamage
// 0x0014 (0x0108 - 0x00F4)
class UYSeqAct_SetPawnsWeaponDamage : public USequenceAction
{
public:
	float                                              m_newDPSvalue;                                    		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_newDamagePerBullet;                             		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_noDamageAtAll : 1;                              		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_oldDPSvalue;                                    		// 0x0100 (0x0004) [0x0000000000000000]              
	float                                              m_oldBulletDamageValue;                           		// 0x0104 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 88980 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_SetPawnsWeaponDamage::pClassPointer = NULL;

// Class SRGame.YSeqAct_SetPOI
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_SetPOI : public USequenceAction
{
public:
	class AYPointOfInterest*                           m_POI;                                            		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_FOV;                                            		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_autoActivateLookAt : 1;                         		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89003 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SetPOI::pClassPointer = NULL;

// Class SRGame.YSeqAct_Silhouette
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_Silhouette : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89067 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_Silhouette::pClassPointer = NULL;

// Class SRGame.YSeqAct_SitRepAvailable
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_SitRepAvailable : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89080 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_SitRepAvailable::pClassPointer = NULL;

// Class SRGame.YSeqAct_SkipMatinee
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_SkipMatinee : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89085 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_SkipMatinee::pClassPointer = NULL;

// Class SRGame.YSeqAct_SpawnGrenade
// 0x0020 (0x0124 - 0x0104)
class UYSeqAct_SpawnGrenade : public USeqAct_Latent
{
public:
	unsigned char                                      m_grenadeType;                                    		// 0x0104 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_grenadeThrowMode;                               		// 0x0105 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_showDebugTrail : 1;                             		// 0x0108 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_ignoreCollision : 1;                            		// 0x0108 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_notifyAI : 1;                                   		// 0x0108 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_aimAtUpperBody : 1;                             		// 0x0108 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bForceTriggerSandPool : 1;                      		// 0x0108 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	float                                              m_aimAngle;                                       		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_pawnAimTime;                                    		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AYProj_Physical*                             m_spawnedGrenade;                                 		// 0x0114 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AYProj_Physical*                             m_simulatedGrenade;                               		// 0x0118 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      m_grenadeStartPosition;                           		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      m_grenadeEndPosition;                             		// 0x0120 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89090 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
	void SpawnGrenadeAndTrail ( struct FVector StartPos );
	void ThrowGrenadeOnPawnCallback ( );
};

UClass* UYSeqAct_SpawnGrenade::pClassPointer = NULL;

// Class SRGame.YSeqAct_StartChapterForAchievementTracking
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_StartChapterForAchievementTracking : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89168 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_StartChapterForAchievementTracking::pClassPointer = NULL;

// Class SRGame.YSeqAct_StopChapterForAchievementTracking
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_StopChapterForAchievementTracking : public USequenceAction
{
public:
	unsigned long                                      m_DisableNoDeath : 1;                             		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89179 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_StopChapterForAchievementTracking::pClassPointer = NULL;

// Class SRGame.YSeqAct_StopRagdollCleanupOnPawn
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_StopRagdollCleanupOnPawn : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89187 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_StopRagdollCleanupOnPawn::pClassPointer = NULL;

// Class SRGame.YSeqAct_StopSpeakByUID
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_StopSpeakByUID : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89193 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	class APawn* GetPawnFromObject ( class UObject* TheActor );
	void Activated ( );
};

UClass* UYSeqAct_StopSpeakByUID::pClassPointer = NULL;

// Class SRGame.YSeqAct_SwitchWeapon
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_SwitchWeapon : public USequenceAction
{
public:
	class UClass*                                      m_weaponClass;                                    		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      m_oldWeaponClass;                                 		// 0x00F8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_forced : 1;                                     		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89210 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_SwitchWeapon::pClassPointer = NULL;

// Class SRGame.YSeqAct_TestIsExposedToSandStorm
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_TestIsExposedToSandStorm : public USequenceAction
{
public:
	unsigned long                                      m_ignoreActualSandStormLevel : 1;                 		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89228 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_TestIsExposedToSandStorm::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleContextualSlomo
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleContextualSlomo : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89251 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	class AYGamePawn* GetPawnFromObject ( class UObject* TheActor );
	void Activated ( );
};

UClass* UYSeqAct_ToggleContextualSlomo::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleContextualVoiceSlomo
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleContextualVoiceSlomo : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89267 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	class AYGamePawn* GetPawnFromObject ( class UObject* TheActor );
	void Activated ( );
};

UClass* UYSeqAct_ToggleContextualVoiceSlomo::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleHitCamShakes
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleHitCamShakes : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89289 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ToggleHitCamShakes::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleRadioManSpeaker
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_ToggleRadioManSpeaker : public USequenceAction
{
public:
	float                                              m_lowVolume;                                      		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fadeTime;                                       		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89294 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_ToggleRadioManSpeaker::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleShyfflrUpdate
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleShyfflrUpdate : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89306 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ToggleShyfflrUpdate::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleSilencerMesh
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleSilencerMesh : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89310 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ToggleSilencerMesh::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleSilhouette
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleSilhouette : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89316 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_ToggleSilhouette::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleStealth
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_ToggleStealth : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89326 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_ToggleStealth::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleUIDGroup
// 0x000C (0x0100 - 0x00F4)
class UYSeqAct_ToggleUIDGroup : public USequenceAction
{
public:
	struct FString                                     m_group;                                          		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89332 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_ToggleUIDGroup::pClassPointer = NULL;

// Class SRGame.YSeqAct_ToggleUISceneVisible
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_ToggleUISceneVisible : public USequenceAction
{
public:
	unsigned long                                      m_visible : 1;                                    		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_lockInput : 1;                                  		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_contentLoading : 1;                             		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89342 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_ToggleUISceneVisible::pClassPointer = NULL;

// Class SRGame.YSeqAct_TriggerExplodingObjects
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_TriggerExplodingObjects : public USequenceAction
{
public:
	class AActor*                                      m_instigator;                                     		// 0x00F4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89366 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_TriggerExplodingObjects::pClassPointer = NULL;

// Class SRGame.YSeqAct_TriggerPlayerSprint
// 0x0000 (0x00F4 - 0x00F4)
class UYSeqAct_TriggerPlayerSprint : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89374 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_TriggerPlayerSprint::pClassPointer = NULL;

// Class SRGame.YSeqAct_TruckRide
// 0x0014 (0x0108 - 0x00F4)
class UYSeqAct_TruckRide : public USequenceAction
{
public:
	struct FYS_AnimSet                                 m_animSet;                                        		// 0x00F4 (0x0014) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89384 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_TruckRide::pClassPointer = NULL;

// Class SRGame.YSeqAct_UI_COOP_Counter
// 0x0014 (0x0108 - 0x00F4)
class UYSeqAct_UI_COOP_Counter : public USequenceAction
{
public:
	struct FString                                     m_descripton;                                     		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_max_value;                                      		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_current_value;                                  		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89391 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_UI_COOP_Counter::pClassPointer = NULL;

// Class SRGame.YSeqAct_UI_COOP_Objective
// 0x0010 (0x0104 - 0x00F4)
class UYSeqAct_UI_COOP_Objective : public USequenceAction
{
public:
	struct FString                                     m_message;                                        		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_duration;                                       		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89399 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_UI_COOP_Objective::pClassPointer = NULL;

// Class SRGame.YSeqAct_UI_COOP_Timer
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_UI_COOP_Timer : public USequenceAction
{
public:
	int                                                m_timer_value;                                    		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89406 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_UI_COOP_Timer::pClassPointer = NULL;

// Class SRGame.YSeqAct_UnlockAchievement
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_UnlockAchievement : public USequenceAction
{
public:
	unsigned char                                      AchievementId;                                    		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                Value;                                            		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89412 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_UnlockAchievement::pClassPointer = NULL;

// Class SRGame.YSeqAct_UnlockMission
// 0x0004 (0x00F8 - 0x00F4)
class UYSeqAct_UnlockMission : public USequenceAction
{
public:
	unsigned long                                      m_AlsoUnlockEpilogue : 1;                         		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89419 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqAct_UnlockMission::pClassPointer = NULL;

// Class SRGame.YSeqAct_WakeKActors
// 0x0008 (0x00FC - 0x00F4)
class UYSeqAct_WakeKActors : public USequenceAction
{
public:
	float                                              m_range;                                          		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UObject*                                     m_locationObject;                                 		// 0x00F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89443 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqAct_WakeKActors::pClassPointer = NULL;

// Class SRGame.YSeqCond_AutoTestActive
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_AutoTestActive : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89455 ];

		return pClassPointer;
	};

	int GetObjClassVersion ( );
	void Activated ( );
};

UClass* UYSeqCond_AutoTestActive::pClassPointer = NULL;

// Class SRGame.YSeqCond_InCombat
// 0x0000 (0x00DC - 0x00DC)
class UYSeqCond_InCombat : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89467 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqCond_InCombat::pClassPointer = NULL;

// Class SRGame.YSeqCond_PlayVitalMatinee
// 0x0004 (0x00E0 - 0x00DC)
class UYSeqCond_PlayVitalMatinee : public USequenceCondition
{
public:
	class AYVitalPoint*                                m_vitalPoint;                                     		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89478 ];

		return pClassPointer;
	};

	void Activated ( );
};

UClass* UYSeqCond_PlayVitalMatinee::pClassPointer = NULL;

// Class SRGame.YSeqEvent_DangerousFlyBys
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_DangerousFlyBys : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89499 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_DangerousFlyBys::pClassPointer = NULL;

// Class SRGame.YSeqEvent_ExplosionNearby
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_ExplosionNearby : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89503 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_ExplosionNearby::pClassPointer = NULL;

// Class SRGame.YSeqEvent_TurretEntered
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_TurretEntered : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89533 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_TurretEntered::pClassPointer = NULL;

// Class SRGame.YSeqEvent_ZipLine
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvent_ZipLine : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89536 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvent_ZipLine::pClassPointer = NULL;

// Class SRGame.YSeqEvt_CountdownExpired
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_CountdownExpired : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89543 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_CountdownExpired::pClassPointer = NULL;

// Class SRGame.YSeqEvt_ProtoGameRoundEnded
// 0x0014 (0x0124 - 0x0110)
class UYSeqEvt_ProtoGameRoundEnded : public USequenceEvent
{
public:
	class APlayerReplicationInfo*                      m_winnerPRI;                                      		// 0x0110 (0x0004) [0x0000000000000000]              
	int                                                m_winningTeamNum;                                 		// 0x0114 (0x0004) [0x0000000000000000]              
	struct FString                                     m_reason;                                         		// 0x0118 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89586 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_ProtoGameRoundEnded::pClassPointer = NULL;

// Class SRGame.YSeqEvt_ProtoWinCondition
// 0x0004 (0x0114 - 0x0110)
class UYSeqEvt_ProtoWinCondition : public USequenceEvent
{
public:
	int                                                m_winningTeamNum;                                 		// 0x0110 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89591 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_ProtoWinCondition::pClassPointer = NULL;

// Class SRGame.YSeqEvt_RoundStarted
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_RoundStarted : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89596 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_RoundStarted::pClassPointer = NULL;

// Class SRGame.YSeqEvt_SpawnerDying
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_SpawnerDying : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89598 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_SpawnerDying::pClassPointer = NULL;

// Class SRGame.YSeqEvt_UnlockIntelItems
// 0x0000 (0x0110 - 0x0110)
class UYSeqEvt_UnlockIntelItems : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89605 ];

		return pClassPointer;
	};

};

UClass* UYSeqEvt_UnlockIntelItems::pClassPointer = NULL;

// Class SRGame.YShyfflr_Adams
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Adams : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89688 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Adams::pClassPointer = NULL;

// Class SRGame.YShyfflr_Commando
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Commando : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89694 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Commando::pClassPointer = NULL;

// Class SRGame.YShyfflr_Elite
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Elite : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89696 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Elite::pClassPointer = NULL;

// Class SRGame.YShyfflr_Enemy
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Enemy : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89700 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Enemy::pClassPointer = NULL;

// Class SRGame.YShyfflr_Heavy
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Heavy : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89706 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Heavy::pClassPointer = NULL;

// Class SRGame.YShyfflr_Konrad_Gunner
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Konrad_Gunner : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89708 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Konrad_Gunner::pClassPointer = NULL;

// Class SRGame.YShyfflr_Konrad_Medic
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Konrad_Medic : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89710 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Konrad_Medic::pClassPointer = NULL;

// Class SRGame.YShyfflr_Konrad_Officer
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Konrad_Officer : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89712 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Konrad_Officer::pClassPointer = NULL;

// Class SRGame.YShyfflr_Konrad_Scavenger
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Konrad_Scavenger : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89714 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Konrad_Scavenger::pClassPointer = NULL;

// Class SRGame.YShyfflr_Konrad_Sniper
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Konrad_Sniper : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89716 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Konrad_Sniper::pClassPointer = NULL;

// Class SRGame.YShyfflr_Lugo
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Lugo : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89718 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Lugo::pClassPointer = NULL;

// Class SRGame.YShyfflr_Marauder
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Marauder : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89724 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Marauder::pClassPointer = NULL;

// Class SRGame.YShyfflr_Marine
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Marine : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89730 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Marine::pClassPointer = NULL;

// Class SRGame.YShyfflr_SpecOps_Breacher
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_SpecOps_Breacher : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89734 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_SpecOps_Breacher::pClassPointer = NULL;

// Class SRGame.YShyfflr_SpecOps_Gunner
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_SpecOps_Gunner : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89736 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_SpecOps_Gunner::pClassPointer = NULL;

// Class SRGame.YShyfflr_SpecOps_Medic
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_SpecOps_Medic : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89738 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_SpecOps_Medic::pClassPointer = NULL;

// Class SRGame.YShyfflr_SpecOps_Officer
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_SpecOps_Officer : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89740 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_SpecOps_Officer::pClassPointer = NULL;

// Class SRGame.YShyfflr_SpecOps_Sniper
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_SpecOps_Sniper : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89742 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_SpecOps_Sniper::pClassPointer = NULL;

// Class SRGame.YShyfflr_Test
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Test : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89744 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Test::pClassPointer = NULL;

// Class SRGame.YShyfflr_Walker
// 0x0000 (0x0080 - 0x0080)
class UYShyfflr_Walker : public UYShyfflr
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 89746 ];

		return pClassPointer;
	};

};

UClass* UYShyfflr_Walker::pClassPointer = NULL;

// Class SRGame.YSkeletalMeshActorCustom
// 0x0001 (0x0235 - 0x0234)
class AYSkeletalMeshActorCustom : public ASkeletalMeshActor
{
public:
	unsigned char                                      m_blendId;                                        		// 0x0234 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 90197 ];

		return pClassPointer;
	};

};

UClass* AYSkeletalMeshActorCustom::pClassPointer = NULL;

// Class SRGame.YSpecialMove_LeavePeeking
// 0x0068 (0x0120 - 0x00B8)
class UYSpecialMove_LeavePeeking : public UYSpecialMove
{
public:
	struct FYS_MovementAnimProperties                  m_leavePeekingAnimations[ 0x4 ];                  		// 0x00B8 (0x0050) [0x0000000000000000]              
	struct FYS_AnimID                                  m_currentAnimID;                                  		// 0x0108 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_movementDirection;                              		// 0x010C (0x0001) [0x0000000000000000]              
	float                                              m_timeToAnimMidway;                               		// 0x0110 (0x0004) [0x0000000000000000]              
	float                                              m_middleOfAnimationPct;                           		// 0x0114 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_cancelByAccelerationThreshold;                  		// 0x0118 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                m_camMode;                                        		// 0x011C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 91364 ];

		return pClassPointer;
	};

	struct FYS_AnimID GetAnimID ( unsigned char coverStance, unsigned char coverMovementDirection, float* animPlaybackLength );
	void TickSpecialMove ( float DeltaTime );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	void Init ( unsigned char specialMove, class AYGamePawn* GamePawn );
};

UClass* UYSpecialMove_LeavePeeking::pClassPointer = NULL;

// Class SRGame.YSpecialMove_OutfitSilencerBase
// 0x000C (0x00C4 - 0x00B8)
class UYSpecialMove_OutfitSilencerBase : public UYSpecialMove
{
public:
	struct FYS_OutfitSilencerAnimations                m_animations[ 0x2 ];                              		// 0x00B8 (0x0008) [0x0000000000000000]              
	struct FYS_AnimID                                  m_currentAnimID;                                  		// 0x00C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 91462 ];

		return pClassPointer;
	};

	struct FYS_AnimID GetAnimID ( unsigned long Crouched, unsigned long Cover );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
};

UClass* UYSpecialMove_OutfitSilencerBase::pClassPointer = NULL;

// Class SRGame.YSpecialMove_PickUpLimitedUse
// 0x0024 (0x0108 - 0x00E4)
class UYSpecialMove_PickUpLimitedUse : public UYSpecialMove_PickUp
{
public:
	struct UYSpecialMove_PickUpLimitedUse_FYS_PickUpWeaponAnimation m_animations[ 0x2 ];                              		// 0x00E4 (0x0018) [0x0000000000000000]              
	struct FYS_AnimID                                  m_currentAnimID;                                  		// 0x00FC (0x0004) [0x0000000000000000]              
	unsigned char                                      m_weaponPickedUp;                                 		// 0x0100 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_isCrouched : 1;                                 		// 0x0104 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 91575 ];

		return pClassPointer;
	};

	struct FYS_AnimID GetAnimID ( unsigned long Crouched, float* pickUpDelay );
	void EquipSingleUseWeapon ( );
	void PickUpWeapon ( );
	void GoInPosition ( );
	void PlayAnimationHolster ( );
	bool GetCameraMode ( unsigned long inScopeMode, unsigned long inZoomMode, int* camMode, int* baseOffsetIndex, struct FVector* baseOffsetDirection );
	void OnCancelSpecialMoveInternal ( );
	bool OnStopSpecialMoveInternal ( );
	bool OnStartSpecialMoveInternal ( unsigned long forceSpecialMove, struct FYS_SpecialMoveData* Data );
	bool CanDoSpecialMoveInternal ( struct FYS_SpecialMoveData* Data );
	void Init ( unsigned char specialMove, class AYGamePawn* GamePawn );
};

UClass* UYSpecialMove_PickUpLimitedUse::pClassPointer = NULL;

// Class SRGame.YWeapon_Stationary
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Stationary : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 92768 ];

		return pClassPointer;
	};

	bool OverrideFOV ( float* FOV );
	class UClass* GetPickupClass ( );
};

UClass* AYWeapon_Stationary::pClassPointer = NULL;

// Class SRGame.YWeapon_M2E2HMG
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_M2E2HMG : public AYWeapon_Stationary
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 92767 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_M2E2HMG::pClassPointer = NULL;

// Class SRGame.YWeapon_TurretMiniGun
// 0x0020 (0x0CC8 - 0x0CA8)
class AYWeapon_TurretMiniGun : public AYWeapon_Stationary
{
public:
	struct FVector2D                                   m_defaultTurnSpeedModifier;                       		// 0x0CA8 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_firingTurnSpeedModifier;                        		// 0x0CB0 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_aimedFiringTurnSpeedModifier;                   		// 0x0CB8 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_aimingTurnSpeedModifier;                        		// 0x0CC0 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 92769 ];

		return pClassPointer;
	};

	void GetCameraRotationModifier ( float* turnH, float* turnV );
};

UClass* AYWeapon_TurretMiniGun::pClassPointer = NULL;

// Class SRGame.YWeapon_TurretMiniGunOnFlight
// 0x0020 (0x0CC8 - 0x0CA8)
class AYWeapon_TurretMiniGunOnFlight : public AYWeapon_Stationary
{
public:
	struct FVector2D                                   m_defaultTurnSpeedModifier;                       		// 0x0CA8 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_firingTurnSpeedModifier;                        		// 0x0CB0 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_aimedFiringTurnSpeedModifier;                   		// 0x0CB8 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )
	struct FVector2D                                   m_aimingTurnSpeedModifier;                        		// 0x0CC0 (0x0008) [0x0000000000004003]              ( CPF_Edit | CPF_Const | CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 92770 ];

		return pClassPointer;
	};

	void GetCameraRotationModifier ( float* turnH, float* turnV );
};

UClass* AYWeapon_TurretMiniGunOnFlight::pClassPointer = NULL;

// Class SRGame.YWeapon_Mk47Striker
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Mk47Striker : public AYWeapon_Stationary
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 92771 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Mk47Striker::pClassPointer = NULL;

// Class SRGame.YWeapon_HeliGun
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_HeliGun : public AYWeapon_Stationary
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 92772 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_HeliGun::pClassPointer = NULL;

// Class SRGame.YWeapon_HumveeGun
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_HumveeGun : public AYWeapon_Stationary
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 92773 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_HumveeGun::pClassPointer = NULL;

// Class SRGame.YWeapon_HumveeGunDFA
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_HumveeGunDFA : public AYWeapon_Stationary
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 92774 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_HumveeGunDFA::pClassPointer = NULL;

// Class SRGame.YWeapon_Mortar
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Mortar : public AYWeapon_Stationary
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 92775 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Mortar::pClassPointer = NULL;

// Class SRGame.YTeamGameMessage
// 0x0040 (0x00AC - 0x006C)
class UYTeamGameMessage : public UYLocalMessage
{
public:
	struct FString                                     RequestTeamSwapPrefix;                            		// 0x006C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     RequestTeamSwapPostfix;                           		// 0x0078 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     YouAreOnRedMessage;                               		// 0x0084 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     YouAreOnBlueMessage;                              		// 0x0090 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FColor                                      RedDrawColor;                                     		// 0x009C (0x0004) [0x0000000000000000]              
	struct FColor                                      BlueDrawColor;                                    		// 0x00A0 (0x0004) [0x0000000000000000]              
	class UYSoundCueFMOD*                              AnnouncerSounds[ 0x2 ];                           		// 0x00A4 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 93217 ];

		return pClassPointer;
	};

	struct FColor GetColor ( int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	float GetPos ( int Switch, class AHUD* myHUD );
	int GetFontSize ( int Switch, class APlayerReplicationInfo* RelatedPRI1, class APlayerReplicationInfo* RelatedPRI2, class APlayerReplicationInfo* LocalPlayer );
	class UYSoundCueFMOD* AnnouncementSound ( int MessageIndex, class UObject* OptionalObject, class APlayerController* PC );
	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
	void ClientReceive ( class APlayerController* P, int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYTeamGameMessage::pClassPointer = NULL;

// Class SRGame.YTrigger_OLComStationDetonator
// 0x0004 (0x0208 - 0x0204)
class AYTrigger_OLComStationDetonator : public AYTrigger_Interaction
{
public:
	class AYComStationDetonator*                       m_detonator;                                      		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 93525 ];

		return pClassPointer;
	};

};

UClass* AYTrigger_OLComStationDetonator::pClassPointer = NULL;

// Class SRGame.YUICharacterCustomArmorPanel
// 0x0064 (0x0114 - 0x00B0)
class UYUICharacterCustomArmorPanel : public UYUICharacterCustomPanel
{
public:
	TArray< struct FString >                           m_ArmorTypes;                                     		// 0x00B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UYUIMenuList*                                m_MenuList;                                       		// 0x00BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYMP_HandleAssetPair >              m_AssetList;                                      		// 0x00C0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FYS_ArmorListItem >                 m_ArmorList;                                      		// 0x00CC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UUILabel*                                    m_lblArmorName;                                   		// 0x00D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgArmor;                                       		// 0x00DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblArmorDescription;                            		// 0x00E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_ArmorStartIndex;                                		// 0x00E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlArmorDisplay;                                		// 0x00E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSpeedReductionTitle;                         		// 0x00EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblSpeedReductionValue;                         		// 0x00F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblDamageReductionTitle;                        		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblDamageReductionValue;                        		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblLockedArmorName;                             		// 0x00FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgLockedArmor;                                 		// 0x0100 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlLockedArmorPanel;                            		// 0x0104 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_IsSniper : 1;                                   		// 0x0108 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bCanSelect : 1;                                 		// 0x0108 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	float                                              m_SpeedReduction;                                 		// 0x010C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_DamageReduction;                                		// 0x0110 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 93780 ];

		return pClassPointer;
	};

	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void HandleSelection ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void HandleSelectionChange ( int Item );
	void OnMenu_SelectionChange ( class UYSimpleList* List, int Item );
	void OnMenu_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void OnDeactivate ( );
	void OnActivate ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void Init ( unsigned char panelEnum, class UUIScreenObject* Parent, struct FString panelName );
};

UClass* UYUICharacterCustomArmorPanel::pClassPointer = NULL;

// Class SRGame.YUICharacterCustomClassPanel
// 0x0040 (0x00F0 - 0x00B0)
class UYUICharacterCustomClassPanel : public UYUICharacterCustomPanel
{
public:
	class UYUIMenuList*                                m_ClassSelectList;                                		// 0x00B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgClass;                                       		// 0x00B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblClassLevel1Description;                      		// 0x00B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblClassLevel2Description;                      		// 0x00BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lbl_levelone_classhead;                         		// 0x00C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lbl_leveltwo_classhead;                         		// 0x00C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlLockedPanel1;                                		// 0x00C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblLockedText1;                                 		// 0x00CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgLockedPanel2;                                		// 0x00D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblLockedText2;                                 		// 0x00D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UYUIDataProvider_MajorPerks* >       m_PerkProviders;                                  		// 0x00D8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UClass* >                            m_Perks;                                          		// 0x00E4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 93858 ];

		return pClassPointer;
	};

	void SortListsByUnlockLevel ( TArray< class UYUIDataProvider_MajorPerks* >* SortList, TArray< class UClass* >* SubList );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void HandleSelection ( );
	struct FString ReplacePlaceholders ( struct FString original, TArray< int > Modifiers );
	void GetClassModifiers ( class UClass* perk, int Level, TArray< int >* Modifiers );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void HandleSelectionChange ( );
	void OnMenu_SelectionChange ( class UYSimpleList* List, int Item );
	void OnMenu_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void OnDeactivate ( );
	void OnActivate ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void Init ( unsigned char panelEnum, class UUIScreenObject* Parent, struct FString panelName );
};

UClass* UYUICharacterCustomClassPanel::pClassPointer = NULL;

// Class SRGame.YUICharacterCustomIndexPanel
// 0x0014 (0x00C4 - 0x00B0)
class UYUICharacterCustomIndexPanel : public UYUICharacterCustomPanel
{
public:
	class UUIImage*                                    m_imgClassIcon;                                   		// 0x00B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_SlotNumber;                                     		// 0x00B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_IndexList;                                      		// 0x00B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFactionBonusSpecops;                         		// 0x00BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFactionBonusKonrad;                          		// 0x00C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 93950 ];

		return pClassPointer;
	};

	int GetTeamBonusValues ( unsigned char TeamID, int Index );
	struct FString ReplaceTeamPlaceholders ( struct FString original, unsigned char TeamID );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void HandleSelection ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnMenu_SelectionChange ( class UYSimpleList* List, int Item );
	void OnMenu_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void OnDeactivate ( );
	void OnActivate ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void Init ( unsigned char panelEnum, class UUIScreenObject* Parent, struct FString panelName );
};

UClass* UYUICharacterCustomIndexPanel::pClassPointer = NULL;

// Class SRGame.YUICharacterCustomLoadoutPanel
// 0x002C (0x00DC - 0x00B0)
class UYUICharacterCustomLoadoutPanel : public UYUICharacterCustomPanel
{
public:
	class UYUIMenuList*                                m_LoadoutSelectList;                              		// 0x00B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_numLoadouts;                                    		// 0x00B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgClassBackground;                             		// 0x00B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UYUIDataProvider_CharacterSlots* >   m_CharSlotProviders;                              		// 0x00BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UUILabel*                                    m_MenuTitle;                                      		// 0x00C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFactionBonusSpecops;                         		// 0x00CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFactionBonusKonrad;                          		// 0x00D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgLockBar;                                     		// 0x00D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblLockText;                                    		// 0x00D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 93993 ];

		return pClassPointer;
	};

	int GetTeamBonusValues ( unsigned char TeamID, int Index );
	struct FString ReplaceTeamPlaceholders ( struct FString original, unsigned char TeamID );
	int GetNumLoadouts ( );
	class UClass* GetDefaultPerk ( int iCharacter );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void HandleSelection ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnMenu_SelectionChange ( class UYSimpleList* List, int Item );
	void OnMenu_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void OnDeactivate ( );
	void OnActivate ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void Init ( unsigned char panelEnum, class UUIScreenObject* Parent, struct FString panelName );
};

UClass* UYUICharacterCustomLoadoutPanel::pClassPointer = NULL;

// Class SRGame.YUICharacterCustomPerkPanel
// 0x00C0 (0x0170 - 0x00B0)
class UYUICharacterCustomPerkPanel : public UYUICharacterCustomPanel
{
public:
	class UYUIMenuList*                                m_PerkList;                                       		// 0x00B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_minorPerks[ 0x10 ];                             		// 0x00B4 (0x0040) [0x0000000000002000]              ( CPF_Transient )
	TArray< class UYUIDataProvider_MinorPerks* >       m_minorPerkProviders;                             		// 0x00F4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_SelectedPerks[ 0x3 ];                           		// 0x0100 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_CurrentPage;                                    		// 0x010C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnSmallPerks[ 0x3 ];                           		// 0x0110 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSmallPerks[ 0x3 ];                           		// 0x011C (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgPerkHighlight[ 0x3 ];                        		// 0x0128 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblPerkIndex;                                   		// 0x0134 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnLeftButton;                                  		// 0x0138 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnRightButton;                                 		// 0x013C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblPerkName;                                    		// 0x0140 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgPerk;                                        		// 0x0144 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIProgressBar*                              m_PerkProgressBar;                                		// 0x0148 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblPerkDescription1;                            		// 0x014C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblPerkDescription2;                            		// 0x0150 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlLockedPanel;                                 		// 0x0154 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblLockedText;                                  		// 0x0158 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lbl_levelone_perkhead;                          		// 0x015C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lbl_leveltwo_perkhead;                          		// 0x0160 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lbl_selectedperkname;                           		// 0x0164 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_3rdPerkLockBar;                                 		// 0x0168 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_3rdPerkLockText;                                		// 0x016C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94060 ];

		return pClassPointer;
	};

	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	int GetPerkNumber ( class UClass* perk );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnPageChange ( );
	void OnRightButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnLeftButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnPerkIconPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnMenu_SelectionChange ( class UYSimpleList* List, int Item );
	void GetPerkModifiers ( class UClass* perk, int Level, TArray< int >* Modifiers );
	struct FString ReplacePlaceholders ( struct FString original, TArray< int > Modifiers );
	void HandleSelection ( );
	void OnMenu_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void OnDeactivate ( );
	void OnActivate ( );
	void PopulatePerksList ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void Init ( unsigned char panelEnum, class UUIScreenObject* Parent, struct FString panelName );
};

UClass* UYUICharacterCustomPerkPanel::pClassPointer = NULL;

// Class SRGame.YUICharacterCustomWeaponPanel
// 0x0088 (0x0138 - 0x00B0)
class UYUICharacterCustomWeaponPanel : public UYUICharacterCustomPanel
{
public:
	TArray< class UYUIDataProvider_WeaponCategories* > m_CategoryProviders;                              		// 0x00B0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UYUIDataProvider_Weapons* >          m_WeaponProviders;                                		// 0x00BC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FYS_EquipmentClass                          m_CurrentProfileEquipment;                        		// 0x00C8 (0x001C) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblWeaponIndex;                                 		// 0x00E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnLeftButton;                                  		// 0x00E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btnRightButton;                                 		// 0x00EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_CategoryList;                                   		// 0x00F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_WeaponList;                                     		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_CurrentPage;                                    		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_CurrentCategory;                                		// 0x00FC (0x0001) [0x0000000000000000]              
	class UUIPanel*                                    m_pnlWeaponStats;                                 		// 0x0100 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblWeaponName;                                  		// 0x0104 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgWeapon;                                      		// 0x0108 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIProgressBar*                              m_pbWeaponRange;                                  		// 0x010C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIProgressBar*                              m_pbWeaponDamage;                                 		// 0x0110 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIProgressBar*                              m_pbWeaponAccuracy;                               		// 0x0114 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIProgressBar*                              m_pbWeaponFireRate;                               		// 0x0118 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRange;                                       		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblDamage;                                      		// 0x0120 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblAccuracy;                                    		// 0x0124 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblFireRate;                                    		// 0x0128 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlLockedPanel;                                 		// 0x012C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblLockedText;                                  		// 0x0130 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UClass*                                      m_DefaultHandgun;                                 		// 0x0134 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94177 ];

		return pClassPointer;
	};

	void SortWeaponsByUnlockLevel ( TArray< class UYUIDataProvider_Weapons* >* List );
	bool IsUnique ( class UYUIDataProvider_Weapons* WeaponProvider );
	void SetCurrentCategory ( );
	void PopulateWeaponList ( );
	void UpdateWeaponDisplay ( );
	void PopulateCategoryList ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void HandleSelection ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void HandleSecondarySelection ( );
	void HandlePrimarySelection ( );
	void OnSecondary_SelectionChange ( class UYSimpleList* List, int Item );
	void OnSecondary_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void OnPageChange ( );
	bool MenuList_DisableWeapon ( class UYSimpleList* SourceList, int Item );
	void SetSelectionToCurrentWeapon ( );
	void OnRightButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnLeftButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnPrimary_SelectionChange ( class UYSimpleList* List, int Item );
	void OnPrimary_SubmitSelection ( class UUIObject* Sender, int PlayerIndex );
	void OnDeactivate ( );
	void OnActivate ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void Init ( unsigned char panelEnum, class UUIScreenObject* Parent, struct FString panelName );
};

UClass* UYUICharacterCustomWeaponPanel::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CampaignMenuItem
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_CampaignMenuItem : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94296 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_CampaignMenuItem::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_ChallengeSectionItems
// 0x0001 (0x00BD - 0x00BC)
class UYUIDataProvider_ChallengeSectionItems : public UYUIDataProvider_MenuItems
{
public:
	unsigned char                                      ChallengeSection;                                 		// 0x00BC (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94298 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_ChallengeSectionItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_ChallengesFactionItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_ChallengesFactionItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94302 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_ChallengesFactionItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CharacterFactionSelectMenuItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_CharacterFactionSelectMenuItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94324 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_CharacterFactionSelectMenuItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_ControlsMenuItem
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_ControlsMenuItem : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94331 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_ControlsMenuItem::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CoopDifficulty
// 0x0004 (0x00C0 - 0x00BC)
class UYUIDataProvider_CoopDifficulty : public UYUIDataProvider_MenuItems
{
public:
	int                                                m_diffIndex;                                      		// 0x00BC (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94333 ];

		return pClassPointer;
	};

	bool ShouldBeFiltered ( );
};

UClass* UYUIDataProvider_CoopDifficulty::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CoopMatchMenuItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_CoopMatchMenuItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94338 ];

		return pClassPointer;
	};

	bool ShouldBeFiltered ( );
};

UClass* UYUIDataProvider_CoopMatchMenuItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CoopMatchResults
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_CoopMatchResults : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94342 ];

		return pClassPointer;
	};

	bool ShouldBeFiltered ( );
};

UClass* UYUIDataProvider_CoopMatchResults::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CoopMatchSettings
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_CoopMatchSettings : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94346 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_CoopMatchSettings::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CoopQuickMatch
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_CoopQuickMatch : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94348 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_CoopQuickMatch::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_CoopSystemLinkItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_CoopSystemLinkItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94350 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_CoopSystemLinkItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_ExodusMenuItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_ExodusMenuItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94378 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_ExodusMenuItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_ExodusMPMainItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_ExodusMPMainItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94380 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_ExodusMPMainItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_ExodusPrivateMenuItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_ExodusPrivateMenuItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94382 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_ExodusPrivateMenuItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_ExodusSystemLinkItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_ExodusSystemLinkItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94384 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_ExodusSystemLinkItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_FactionInfo
// 0x0001 (0x00C9 - 0x00C8)
class UYUIDataProvider_FactionInfo : public UYUIDataProvider_MatchSetting
{
public:
	unsigned char                                      MPFactionId;                                      		// 0x00C8 (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94386 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_FactionInfo::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_HeadquartersItems
// 0x0004 (0x00C0 - 0x00BC)
class UYUIDataProvider_HeadquartersItems : public UYUIDataProvider_MenuItems
{
public:
	int                                                m_UnlockLevel;                                    		// 0x00BC (0x0004) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94402 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_HeadquartersItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_LeaderboardsItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_LeaderboardsItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94409 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_LeaderboardsItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MainMenuItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_MainMenuItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94411 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MainMenuItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MatchTypeInfo
// 0x0001 (0x00C9 - 0x00C8)
class UYUIDataProvider_MatchTypeInfo : public UYUIDataProvider_MatchSetting
{
public:
	unsigned char                                      MPMatchTypeId;                                    		// 0x00C8 (0x0001) [0x0000000000004000]              ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94450 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MatchTypeInfo::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MidGameMenu
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_MidGameMenu : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94462 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MidGameMenu::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MidGameMenuCOOP
// 0x0000 (0x00C0 - 0x00C0)
class UYUIDataProvider_MidGameMenuCOOP : public UYUIDataProvider_CustomMatchMenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94464 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MidGameMenuCOOP::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MidGameMenuMP
// 0x0000 (0x00C0 - 0x00C0)
class UYUIDataProvider_MidGameMenuMP : public UYUIDataProvider_CustomMatchMenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94466 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MidGameMenuMP::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_MultiplayerMenuItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_MultiplayerMenuItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94500 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_MultiplayerMenuItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_OnlineCoopMainItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_OnlineCoopMainItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94502 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_OnlineCoopMainItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_OnlineMPMainItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_OnlineMPMainItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94504 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_OnlineMPMainItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_OptionItemsGame
// 0x0000 (0x0100 - 0x0100)
class UYUIDataProvider_OptionItemsGame : public UYUIDataProvider_MenuOptionItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94519 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_OptionItemsGame::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_OptionItemsGfx
// 0x0000 (0x0104 - 0x0104)
class UYUIDataProvider_OptionItemsGfx : public UYUIDataProvider_OptionItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94521 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_OptionItemsGfx::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_PCKeyMapping
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_PCKeyMapping : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94523 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_PCKeyMapping::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_PrestigeModeItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_PrestigeModeItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94553 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_PrestigeModeItems::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_SettingsCoop
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_SettingsCoop : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94564 ];

		return pClassPointer;
	};

	bool ShouldBeFiltered ( );
};

UClass* UYUIDataProvider_SettingsCoop::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_SpecialUnlockables
// 0x0000 (0x01EC - 0x01EC)
class UYUIDataProvider_SpecialUnlockables : public UYUIDataProvider_Equipment
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94568 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_SpecialUnlockables::pClassPointer = NULL;

// Class SRGame.YUIDataProvider_SystemLinkItems
// 0x0000 (0x00BC - 0x00BC)
class UYUIDataProvider_SystemLinkItems : public UYUIDataProvider_MenuItems
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 94570 ];

		return pClassPointer;
	};

};

UClass* UYUIDataProvider_SystemLinkItems::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_BindKeysPC
// 0x0024 (0x0798 - 0x0774)
class UYUIFrontEnd_BindKeysPC : public UYUIFrontEnd
{
public:
	class UYUIKeyBindingList*                          BindingList;                                      		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FKeyBind >                          OldBindings;                                      		// 0x077C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      bShowCrucialBindWarning : 1;                      		// 0x0788 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FScriptDelegate                             __MarkDirty__Delegate;                            		// 0x078C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 95317 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void OnBindingList_AcceptOptions ( class UUIScreenObject* InObject, int PlayerIndex );
	void OnResetToDefaults ( );
	bool OnResetOptions_Confirm ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	bool OnSetDefaultsClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnAccept ( );
	bool OnSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnBack ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnBackSceneDeactivated ( class UUIScene* DeactivatedScene );
	bool OnMenu_LoseChanges_Confirm ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	bool CheckForCrucialBindsAndClose ( );
	void OnBindingList_Regenerated ( class UUIObject* Sender );
	void InitWidget ( );
	void InitWidgetRef ( );
	void MarkDirty ( );
};

UClass* UYUIFrontEnd_BindKeysPC::pClassPointer = NULL;

// Class SRGame.YUIObjectFilter
// 0x0050 (0x008C - 0x003C)
class UYUIObjectFilter : public UObject
{
public:
	struct FFilterFlags                                m_FilterFlags;                                    		// 0x003C (0x0004) [0x0000000000000000]              
	struct FFilterCategories                           FilterOptions;                                    		// 0x0040 (0x0048) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bSimFrontEnd : 1;                               		// 0x0088 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bSimSP : 1;                                     		// 0x0088 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bSimMP : 1;                                     		// 0x0088 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bSim360 : 1;                                    		// 0x0088 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bSimPS3 : 1;                                    		// 0x0088 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bSimPC : 1;                                     		// 0x0088 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 95403 ];

		return pClassPointer;
	};

	bool CheckForflags ( class UUIObject* Object );
	void UpdateFilterFlagsEditor ( );
	void UpdateFilterFlagsGame ( );
	void FilterObjects ( class UUIObject* ObjectToFilter );
};

UClass* UYUIObjectFilter::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_BrightnessScreen
// 0x0034 (0x07E8 - 0x07B4)
class UYUIFrontEnd_BrightnessScreen : public UYUISceneFEOptions_Base
{
public:
	float                                              m_currentGamma;                                   		// 0x07B4 (0x0004) [0x0000000000000000]              
	int                                                m_currentPostFXPreset;                            		// 0x07B8 (0x0004) [0x0000000000000000]              
	class UUISlider*                                   m_brightnessSlider;                               		// 0x07BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIOptionList*                              m_postFXPreset;                                   		// 0x07C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_gamma;                                          		// 0x07C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_postFXFilter;                                   		// 0x07C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_listPanel;                                      		// 0x07CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_incrementButton;                                		// 0x07D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_decrementButton;                                		// 0x07D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bSliderSelected : 1;                            		// 0x07D8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FScriptDelegate                             __OnBrightnessScreenClosed__Delegate;             		// 0x07DC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 95536 ];

		return pClassPointer;
	};

	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	void UpdateProfileStatsAndSave ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnPostFXPresetValueChanged ( class UUIObject* Sender, int PlayerIndex );
	void OnSettingValueChanged ( class UUIObject* Sender, int PlayerIndex );
	bool SetToDefaults ( );
	void InitWidgetReferences ( );
	class UYUIOptionList* GetPostFXPresetSwitcher ( );
	int GetMouseOverSelected ( );
	void SelectNewItem ( int Selection );
	bool OnDecrementClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnIncrementClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void FilterSelected ( class UUIScreenObject* Sender, int PlayerIndex, class UUIState* NewlyActiveState, class UUIState* PreviouslyActiveState );
	void BrightnessSelected ( class UUIScreenObject* Sender, int PlayerIndex, class UUIState* NewlyActiveState, class UUIState* PreviouslyActiveState );
	void InitWidget ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void OnBrightnessScreenClosed ( );
};

UClass* UYUIFrontEnd_BrightnessScreen::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_SelectSaveSlotScreen
// 0x0240 (0x09B4 - 0x0774)
class UYUIFrontEnd_SelectSaveSlotScreen : public UYUIFrontEnd
{
public:
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTitle;                                       		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_tbDescription;                                  		// 0x077C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_difficultyIcon;                                 		// 0x0780 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_selectedMapImage;                               		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblDifficultyValue;                             		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTimePlayedValue;                             		// 0x078C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSelectedMap_Border;                          		// 0x0790 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   btn[ 0x4 ];                                       		// 0x0794 (0x0010) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_SelectableSlot                          m_slots[ 0x4 ];                                   		// 0x07A4 (0x0140) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_loadTitle;                                      		// 0x08E4 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_saveTitle;                                      		// 0x08F0 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_newTitle;                                       		// 0x08FC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_loadDescription;                                		// 0x0908 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_saveDescription;                                		// 0x0914 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_newDescription;                                 		// 0x0920 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_difficultyTitle;                                		// 0x092C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     timePlayedTitle;                                  		// 0x0938 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_emptyTitle;                                     		// 0x0944 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_corruptedTitle;                                 		// 0x0950 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_emptyChapter;                                   		// 0x095C (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_emptyTime;                                      		// 0x0968 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_emptyTimePlayed;                                		// 0x0974 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     m_emptyDifficulty;                                		// 0x0980 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	unsigned long                                      m_pendingSlotInit : 1;                            		// 0x098C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_widgetRefsInited : 1;                           		// 0x098C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_currentSlotLoadable : 1;                        		// 0x098C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned char                                      m_sceneMode;                                      		// 0x0990 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class UYGameEngine*                                m_engine;                                         		// 0x0994 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_currentSlot;                                    		// 0x0998 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_LastMousePositionX;                             		// 0x099C (0x0004) [0x0000000000000000]              
	int                                                m_LastMousePositionY;                             		// 0x09A0 (0x0004) [0x0000000000000000]              
	int                                                m_lastSelectedSlot;                               		// 0x09A4 (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __OnSaveSlotSelected__Delegate;                   		// 0x09A8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 95614 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	class UYDataProvider_DifficultyInfo* GetDifficultyInfoDataProvider ( unsigned char lvl );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool OverwriteValidate ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void OpenOverwriteQuestion ( );
	void CloseMenu ( );
	void Cancel ( int ControllerId );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void DoSelectCurrentSaveSlot ( );
	void SelectSlotClicked ( unsigned long bIsMouseClick );
	bool OnSlotSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void SelectSlot ( int Idx );
	void SelectNextSlot ( );
	void SelectPrevSlot ( );
	bool GetNextAvailableSlot ( int StartIdx, int Dir, int* nextSlot );
	void SetState ( int slot, unsigned char visState );
	void InitSlot ( int slot, unsigned long isCorrupted, unsigned long isEmpty, unsigned char gameChapter, unsigned char gameMission, struct FCheckpointTime cpDate, unsigned char Difficulty, float timePlayed );
	void InitSlots ( );
	void UpdateScene ( );
	void OnSelectItem ( int PlayerIndex );
	bool OnSlotSingleClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void UpdateSelectedButton ( );
	void UpdateMouseCursor ( );
	void HandleYUIFrontEndTick ( float DeltaTime );
	void CurrentStorageDeviceChanged ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void SceneActivated ( unsigned long bInitialActivation );
	void SetMode ( unsigned char sceneMode );
	void PostInitialize ( );
	void OnSaveSlotSelected ( int slotIdx, unsigned long isEmptySlot, unsigned char Difficulty );
};

UClass* UYUIFrontEnd_SelectSaveSlotScreen::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_CampaignMenu
// 0x0044 (0x07E0 - 0x079C)
class UYUIFrontEnd_CampaignMenu : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneMissionSelection;                          		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneNewGame;                                   		// 0x07A8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneIntel;                                     		// 0x07B4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneDifficulty;                                		// 0x07C0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_travelURL;                                      		// 0x07CC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      m_bUseNewMenu : 1;                                		// 0x07D8 (0x0004) [0x0000000000006000] [0x00000001] ( CPF_Transient | CPF_Config )
	unsigned long                                      m_slotsAvailable : 1;                             		// 0x07D8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_slotsCorrupted : 1;                             		// 0x07D8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_currentSlotAvailable : 1;                       		// 0x07D8 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_shouldRunPrologue : 1;                          		// 0x07D8 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	int                                                m_pendingSaveSlot;                                		// 0x07DC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 95789 ];

		return pClassPointer;
	};

	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnDifficultyLevelSelectedForChapterSelection ( unsigned char Difficulty );
	void OnSaveSlotSelectedForChapterSelection ( int saveSlotIdx, unsigned long isEmptySlot, unsigned char Difficulty );
	void OnChapterSelected ( struct FString missionMap );
	void OpenChapterSelection ( );
	void OnDifficultyLevelSelectedForLoadGame ( unsigned char Difficulty );
	void OnSaveSlotSelectedForLoadGame ( int saveSlotIdx, unsigned long isEmptySlot, unsigned char Difficulty );
	void SelectLoadGameMenu ( int ControllerId );
	void OnDifficultyLevelSelectedForNewGame ( unsigned char Difficulty );
	void OnSaveSlotSelectedForNewGame ( int saveSlotIdx, unsigned long isEmptySlot, unsigned char Difficulty );
	void SelectNewGameMenu ( int ControllerId );
	void ResumeGame ( int ControllerId );
	void SetProfileBeenAtMPMenu ( );
	void CreateOnlineGameCompleteCampaign ( struct FName SessionName, unsigned long bWasSuccessful );
	void LaunchMission ( unsigned long runPrologue, int PlayerIndex );
	void OpenSelectDifficultyMenu ( struct FScriptDelegate difficultyLevelSelectDelegate );
	void OpenSaveSlotMenu ( struct FScriptDelegate saveSlotSelectedDelegate, unsigned char sceneMode );
	void OpenIntelScene ( );
	bool SaveSlotAlreadyExists ( );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	void CurrentStorageDeviceChanged ( );
	void NotifyPlayerRemoved ( int PlayerIndex, class ULocalPlayer* RemovedPlayer );
	void NotifyPlayerAdded ( int PlayerIndex, class ULocalPlayer* AddedPlayer );
	void NotifyControllerStatusChanged ( int ControllerId, unsigned long bConnected );
	bool NotifyLoginStatusChanged ( int ControllerId, unsigned char NewStatus );
	void InitWidget ( );
	void SceneActivated ( unsigned long bInitialActivation );
};

UClass* UYUIFrontEnd_CampaignMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Headquarters
// 0x0098 (0x0834 - 0x079C)
class UYUIFrontEnd_Headquarters : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneCharacterCreation;                         		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneCareer;                                    		// 0x07A8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneLeaderboards;                              		// 0x07B4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneStatistics;                                		// 0x07C0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_ScenePrestigeMode;                              		// 0x07CC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneTitles;                                    		// 0x07D8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneBadges;                                    		// 0x07E4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneChallenges;                                		// 0x07F0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_sClanTagTitle;                                  		// 0x07FC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_sClanTagDesc;                                   		// 0x0808 (0x000C) [0x000000000040C002]              ( CPF_Const | CPF_Config | CPF_Localized | CPF_NeedCtorLink )
	int                                                m_nClanTagMaxLen;                                 		// 0x0814 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class UUIImage*                                    m_LockedBar;                                      		// 0x0818 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_LockedText;                                     		// 0x081C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_DescriptionText;                                		// 0x0820 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScrollingTextPanel*                      m_MessageOfTheDay;                                		// 0x0824 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FString                                     LockIcon;                                         		// 0x0828 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 95968 ];

		return pClassPointer;
	};

	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	bool OnConfirmClicked ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void ShowPrestigeMessageBox ( );
	void OnSelectItem ( int PlayerIndex );
	void OnKeyboardInputComplete ( unsigned long bWasSuccessful );
	void OnMenu_SelectionChange ( class UYSimpleList* List, int Item );
	void OnTick ( float DeltaTime );
	void InitWidget ( );
	void SceneActivated ( unsigned long bInitialActivation );
};

UClass* UYUIFrontEnd_Headquarters::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_ChallengeFactionMenu
// 0x0014 (0x07B0 - 0x079C)
class UYUIFrontEnd_ChallengeFactionMenu : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneSectionMenu;                               		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUIImage*                                    m_LockSpecopsChallenge;                           		// 0x07A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_LockKonradChallenge;                            		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 95973 ];

		return pClassPointer;
	};

	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	bool HaveChanllengeNewUnlocked ( unsigned char TeamID );
	void UpdateLockIcon ( );
	void InitWidget ( );
	void SceneActivated ( unsigned long bInitialActivation );
};

UClass* UYUIFrontEnd_ChallengeFactionMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_ChallengeMenu
// 0x0028 (0x07C4 - 0x079C)
class UYUIFrontEnd_ChallengeMenu : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneChallenges;                                		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned char                                      m_teamID;                                         		// 0x07A8 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_LockBasicChallenge;                             		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_LockFactionChallenge;                           		// 0x07B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_LockMultiplayerChallenge;                       		// 0x07B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< unsigned char >                            m_lUnlockedItem;                                  		// 0x07B8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 95992 ];

		return pClassPointer;
	};

	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	void UpdateUnlockedChallenge ( int iSelection );
	bool HaveChanllengeNewUnlocked ( unsigned char TeamID, unsigned char eChallengeSection );
	void UpdateChaleengeNewUnlocked ( );
	void SetTeamID ( unsigned char TeamID );
	void InitWidget ( );
};

UClass* UYUIFrontEnd_ChallengeMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Challenges
// 0x0148 (0x08BC - 0x0774)
class UYUIFrontEnd_Challenges : public UYUIFrontEnd
{
public:
	unsigned char                                      m_teamID;                                         		// 0x0774 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_ChallengeSectionID;                             		// 0x0775 (0x0001) [0x0000000000000000]              
	struct FYS_ChallengeRow                            m_Rows[ 0x6 ];                                    		// 0x0778 (0x0120) [0x0000000000000000]              
	class UUICalloutButtonPanel*                       m_ButtonBar;                                      		// 0x0898 (0x0004) [0x0000000000000000]              
	int                                                m_offset;                                         		// 0x089C (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_ScrollMarker;                                   		// 0x08A0 (0x0004) [0x0000000000000000]              
	class UUILabel*                                    m_ChallengeMenuIndex;                             		// 0x08A4 (0x0004) [0x0000000000000000]              
	class UUIButton*                                   m_ChallengeLeft;                                  		// 0x08A8 (0x0004) [0x0000000000000000]              
	class UUIButton*                                   m_ChallengeRight;                                 		// 0x08AC (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __OnUnlockedChallenge__Delegate;                  		// 0x08B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 96042 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	void OnCategoryPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	class UYUIDataProvider_Badges* GetChallengeBadge ( unsigned char ChallengeID );
	class UYUIDataProvider_Titles* GetChallengeTitle ( unsigned char ChallengeID );
	void ApplyChanges ( );
	void SetTeamAndSection ( unsigned char TeamID, unsigned char ChallengeSection );
	void ScrollDown ( int ScrollValue );
	void ScrollUp ( int ScrollValue );
	bool OnPageUp ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnPageDown ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnNextCat ( class UUIScreenObject* EventObject, int PlayerIndex );
	void UpdateNextCategoryButton ( );
	void OnSelectItem ( int PlayerIndex );
	void OnNextCatButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnPrevCatButtonPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void InitWidgetRef ( );
	void OnUnlockedChallenge ( int iSelection );
};

UClass* UYUIFrontEnd_Challenges::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_CharacterCreationCharacterSelect
// 0x016C (0x08FC - 0x0790)
class UYUIFrontEnd_CharacterCreationCharacterSelect : public UYUIFrontEnd_CharacterCreation
{
public:
	class UYUIW_CharacterEquipmentSelect*              m_wCharacterEquipmentDisplay;                     		// 0x0790 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      m_teamID;                                         		// 0x0794 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_iCharacterIndex;                                		// 0x0798 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FYS_EquipmentClass                          m_EquipmentOfSelectedCharacter;                   		// 0x079C (0x001C) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlKonradsFactionBG;                            		// 0x07B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_pnlSpecopsFactionBG;                            		// 0x07BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIButton*                                   m_btCharacters[ 0x5 ];                            		// 0x07C0 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCharactersImageSelected[ 0x5 ];              		// 0x07D4 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_lblCharactersImageUnselected[ 0x5 ];            		// 0x07E8 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCharactersNameSelected[ 0x5 ];               		// 0x07FC (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblCharactersNameUnselected[ 0x5 ];             		// 0x0810 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCharacterGradient[ 0x5 ];                    		// 0x0824 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCharacterLineLeft[ 0x5 ];                    		// 0x0838 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCharacterLineRight[ 0x5 ];                   		// 0x084C (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCharactersGrid[ 0x5 ];                       		// 0x0860 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCharactersGridSelected[ 0x5 ];               		// 0x0874 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgCharacterLocked[ 0x5 ];                      		// 0x0888 (0x0014) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblTimeLeft;                                    		// 0x089C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgTimer;                                       		// 0x08A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FLinearColor                                m_ColorLineSelectedSpecops;                       		// 0x08A4 (0x0010) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )
	struct FLinearColor                                m_ColorLineSelectedKonrads;                       		// 0x08B4 (0x0010) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )
	class UUILabel*                                    m_lblSelectedCharacterName;                       		// 0x08C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSelectedCharacterImage;                      		// 0x08C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTexture*                                    m_SelectorColouredSpecops;                        		// 0x08CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTexture*                                    m_SelectorColouredKonrads;                        		// 0x08D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     m_CharacterCreationName;                          		// 0x08D4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_iMaxSelectableCharacter;                        		// 0x08E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< int >                                      m_lUnlockedItem;                                  		// 0x08E4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_UnLockIconRef;                                  		// 0x08F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   m_LockIconRef;                                    		// 0x08F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bShowResetCharacter : 1;                        		// 0x08F8 (0x0004) [0x0000000000006000] [0x00000001] ( CPF_Transient | CPF_Config )
	unsigned long                                      m_bIsAButton : 1;                                 		// 0x08F8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bIsMouseClick : 1;                              		// 0x08F8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bIsEnter : 1;                                   		// 0x08F8 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 96195 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool OnButtonSlotProcessInputKey ( struct FSubscribedInputEventParameters* EventParms );
	bool OnButtonSlotRawInputKey ( struct FInputEventParameters* EventParms );
	bool TestDirection ( struct FInputEventParameters* EventParms );
	bool InternalHandleInputKey ( struct FInputEventParameters* EventParms );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	int GetCharacterIndex ( class UUIScreenObject* UIObject );
	void OnCharacterDoubleClick ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnCharacterClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnCharacterPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnCharacterReset ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnChangeFactionClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnSelectItem ( int PlayerIndex );
	void OpenCharacterCreation ( );
	int GetPlayerRankLevel ( );
	void InitMaxSelectableCharacter ( );
	int GetMaxSelectableCharacter ( );
	void ShowSelectedCharacterGrid ( );
	void HideSelectCharacterGrid ( );
	void InitUnselectedCharacterGrid ( );
	void SelectDownCharacter ( );
	void SelectUpCharacter ( );
	void SelectNextCharacter ( );
	void SelectPreviousCharacter ( );
	void UpdateUnlockedItem ( int iSlotSelected );
	void SelectNewCharacter ( int iNewSelection );
	void UpdateCharacterEquipment ( );
	struct FString GetPerkPreviewCharacterMesh ( int iNumCharacter );
	struct FString GetPerkPreview ( int iNumCharacter );
	bool ResetCharacter_Confirm ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void WantResetCharacter ( );
	void ResetCharacterToDefault ( );
	void UpdateCharacterGridName ( int iCharacter );
	void UpdateCharacterGridSelector ( int iCharacter );
	void UpdateCharactersGridSelector ( );
	bool IsJustUnlocked ( int iSlotIndex );
	void UpdateCharacterGridImage ( int iCharacter );
	void Update3DWeaponPreview ( );
	void Update3DCharacterPreview ( );
	void UpdateSelectedCharacterImage ( );
	void UpdateSelectedCharacterName ( );
	void UpdateSelectedCharacterGrid ( );
	void UpdateCharactersGrid ( );
	void UpdateFactionBackground ( );
	void FactionChanged ( );
	void SetFaction ( unsigned char TeamID );
	void ChangeFaction ( );
	void TickScene ( float DeltaTime );
	void InitFinalEditor ( );
	void InitFinal ( );
	void InitAllMaterialInstanceConstant ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void SceneActivated ( unsigned long bInitialActivation );
};

UClass* UYUIFrontEnd_CharacterCreationCharacterSelect::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_CharacterCreationFactionSelect
// 0x000C (0x07A8 - 0x079C)
class UYUIFrontEnd_CharacterCreationFactionSelect : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneCharacterSelect;                           		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 96442 ];

		return pClassPointer;
	};

	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	void InitWidget ( );
};

UClass* UYUIFrontEnd_CharacterCreationFactionSelect::pClassPointer = NULL;

// Class SRGame.YWeapon_TDIVector
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_TDIVector : public AYWeapon_SubmachineGun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 96902 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_TDIVector::pClassPointer = NULL;

// Class SRGame.YWeapon_Glock18
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Glock18 : public AYWeapon_Pistol
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 96903 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Glock18::pClassPointer = NULL;

// Class SRGame.YWeapon_Mossberg590A1
// 0x0000 (0x0D18 - 0x0D18)
class AYWeapon_Mossberg590A1 : public AYWeapon_Shotgun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 96904 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Mossberg590A1::pClassPointer = NULL;

// Class SRGame.YWeapon_M110SniperSystem
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_M110SniperSystem : public AYWeapon_Sniper
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 96905 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_M110SniperSystem::pClassPointer = NULL;

// Class SRGame.YWeapon_AKS74u
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_AKS74u : public AYWeapon_SubmachineGun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 96906 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_AKS74u::pClassPointer = NULL;

// Class SRGame.YWeapon_MSG90
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_MSG90 : public AYWeapon_Sniper
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 96907 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_MSG90::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_ControlScreen
// 0x001C (0x07D0 - 0x07B4)
class UYUIFrontEnd_ControlScreen : public UYUISceneFEOptions_Base
{
public:
	class UUIPanel*                                    pnlLayout_Default;                                		// 0x07B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    pnlLayout_Alternative;                            		// 0x07B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    pnl_SPSpecific;                                   		// 0x07BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    pnl_MPSpecific;                                   		// 0x07C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    pnl_SPSpecific_Alt;                               		// 0x07C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    pnl_MPSpecific_Alt;                               		// 0x07C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_AimSnapOnTip;                                   		// 0x07CC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 97024 ];

		return pClassPointer;
	};

	void ShowControlLayout ( unsigned char layout );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void HideLayoutPanels ( );
	void UpdateControlLayout ( );
	void HandleValuechanged ( class UUIObject* Sender, int PlayerIndex );
	void SetDefaultSwitcherValue ( class UYUIOptionList* CurrentSwitcher );
	void UpdateSwitcherValue ( class UYUIOptionList* CurrentSwitcher );
	void UpdateLabelForPanel ( struct FString Message, struct FName LabelName, class UUIPanel* panel );
	void ShowCoopControls ( );
	void ShowMultiplayerControls ( );
	void ShowSinglePlayerControls ( );
	void InitWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_ControlScreen::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_ControlScreen_PC
// 0x0014 (0x07C8 - 0x07B4)
class UYUIFrontEnd_ControlScreen_PC : public UYUISceneFEOptions_Base
{
public:
	class UYUIKeyBindingList*                          BindingList;                                      		// 0x07B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FKeyBind >                          OldBindings;                                      		// 0x07B8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      bShowCrucialBindWarning : 1;                      		// 0x07C4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 97073 ];

		return pClassPointer;
	};

	void UpdateHUDStrings ( );
	void KeyBindingComplete ( );
	bool SetToDefaults ( );
	void UpdateProfileStatsAndSave ( );
	bool ApplyChanges ( );
	bool CheckForCrucialBindsAndClose ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnBindingList_Regenerated ( class UUIObject* Sender );
	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_ControlScreen_PC::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_MainMenu
// 0x003C (0x07D8 - 0x079C)
class UYUIFrontEnd_MainMenu : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneCampaign;                                  		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneExodus;                                    		// 0x07A8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneMultiplayer;                               		// 0x07B4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneCooperative;                               		// 0x07C0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUIImage*                                    m_contentLoadingImage;                            		// 0x07CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_hidePanel;                                      		// 0x07D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_blinkDLC : 1;                                   		// 0x07D4 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 97126 ];

		return pClassPointer;
	};

	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	void TickScene ( float DeltaTime );
	void OnLoginChange ( unsigned char LocalUserNum );
	void ReselectCooperativeMenu ( );
	void SelectCooperativeMenu ( int ControllerId );
	void SelectMultiplayerMenu ( int ControllerId );
	void SelectCampaignMenu ( int ControllerId );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	bool MultiplayerValidate ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void OpenMultiplayerQuestion ( );
	class UYProfileSettings* GetProfileSettings ( );
	void CheckPlayerBeenAtMPMenu ( );
	void OpenDLCMenu ( );
	void OnInitializationComplete ( unsigned long bSuccess );
	void OnDLCCheckForLogin ( int ControllerId );
	bool OnConfirmingOutofGameDLCStore ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void OnDLCCheckForIngameStoreAndLogin ( );
	void OnSelectItem ( int PlayerIndex );
	void CheckSkipMenu ( int ControllerId );
	void CheckBlinkItem ( );
	void SceneDeactivated ( );
	void SceneActivated ( unsigned long bInitialActivation );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void InitWidget ( );
};

UClass* UYUIFrontEnd_MainMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Coop
// 0x0000 (0x07B0 - 0x07B0)
class UYUIFrontEnd_Coop : public UYUIFrontEnd_Multiplayer
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 97174 ];

		return pClassPointer;
	};

	struct FString GetRequiredDLCSimpleName ( );
	void OnInitializationComplete ( unsigned long bSuccess );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void CheckSkipMenu ( int ControllerId );
	void InitWidget ( );
};

UClass* UYUIFrontEnd_Coop::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Coop_CustomMatch
// 0x0030 (0x0908 - 0x08D8)
class UYUIFrontEnd_Coop_CustomMatch : public UYUIFrontEnd_CustomMatch
{
public:
	class UUIPanel*                                    m_diffMapInfoPanel;                               		// 0x08D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_diffHeader;                                     		// 0x08DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_diffDescription;                                		// 0x08E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_diffIcon;                                       		// 0x08E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_mapHeader;                                      		// 0x08E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_mapDescription;                                 		// 0x08EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_mapImage;                                       		// 0x08F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_selectionDescription;                           		// 0x08F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_selectionImage;                                 		// 0x08F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_selectionImageDiff;                             		// 0x08FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_currentDifficultySelected;                      		// 0x0900 (0x0004) [0x0000000000000000]              
	int                                                m_currentMapSelected;                             		// 0x0904 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 97659 ];

		return pClassPointer;
	};

	void SelectRandomMapFromPlaylist ( int MPPlaylistId );
	void OpenSubMenu ( );
	bool QuitToMainMenuAndReloadDLC ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	struct FString GetRequiredDLCSimpleName ( );
	void Play ( );
	void UpdateSelectedInfo ( );
	void SelectMap ( unsigned char MPMapId );
	void SelectDifficulty ( unsigned char MPDifficultyId );
	void OnMainMenuSelectItem ( int PlayerIndex );
	void UpdateRulesDescription ( );
	void UpdateCurrentMapSelection ( int MapIndex );
	void UpdateCurrentDiffSelection ( class UYUIDataProvider_CoopDifficulty* diffProv );
	void OnSubMenuSelectionChange ( class UYSimpleList* SourceList, int Item );
	unsigned char GetRandomCoopMap ( );
	void InitWidget ( );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_Coop_CustomMatch::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_ServerBrowser
// 0x0025 (0x07C1 - 0x079C)
class UYUIFrontEnd_ServerBrowser : public UYUIFrontEnd_BasicMenu
{
public:
	class UUIList*                                     ServerList;                                       		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUTDataStore_GameSearchBase*                 SearchDataStore;                                  		// 0x07A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UOnlineSubsystem*                            OnlineSub;                                        		// 0x07A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UOnlineGameInterface*                        GameInterface;                                    		// 0x07A8 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      UnknownData00[ 0x4 ];                             		// 0x07AC (0x0004) FIX WRONG TYPE SIZE OF PREVIUS PROPERTY
	struct FName                                       SearchDSName;                                     		// 0x07B0 (0x0008) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	unsigned long                                      bProcessingJoin : 1;                              		// 0x07B8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	class UUIObject*                                   RefreshingLabel;                                  		// 0x07BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned char                                      QueryCompletionAction;                            		// 0x07C0 (0x0001) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 97719 ];

		return pClassPointer;
	};

	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void SetupButtonBar ( );
	void UpdateButtonStates ( );
	void OnServerList_ValueChanged ( class UUIObject* Sender, int PlayerIndex );
	void OnServerList_SubmitSelection ( class UUIList* Sender, int PlayerIndex );
	bool OnButtonBar_CancelQuery ( class UUIScreenObject* InButton, int InPlayerIndex );
	bool OnButtonBar_Refresh ( class UUIScreenObject* InButton, int InPlayerIndex );
	bool OnButtonBar_JoinServer ( class UUIScreenObject* InButton, int InPlayerIndex );
	void OnCancelSearchComplete ( unsigned long bWasSuccessful );
	void CancelQuery ( unsigned char DesiredCancelAction );
	bool AllowJoinServer ( );
	void MessageBoxClosed ( class UUIScene* DeactivatedScene );
	void OnFindOnlineGamesComplete ( unsigned long bWasSuccessful );
	void OnFindOnlineGamesCompleteDelegate ( unsigned long bWasSuccessful );
	void SubmitServerListQuery ( int PlayerIndex );
	void RefreshServerList ( int InPlayerIndex, int MaxResults );
	struct FString BuildJoinURL ( struct FString ResolvedConnectionURL );
	void OpenFailedToJoinMessageBox ( int mismatchReason );
	void ProcessJoin ( );
	void JoinServer ( );
	void InitWidget ( );
	void InitWidgetRef ( );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_ServerBrowser::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Coop_ServerBrowser
// 0x0000 (0x07C1 - 0x07C1)
class UYUIFrontEnd_Coop_ServerBrowser : public UYUIFrontEnd_ServerBrowser
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 97802 ];

		return pClassPointer;
	};

	void RefreshServerList ( int InPlayerIndex, int MaxResults );
	bool QuitToMainMenuAndReloadDLC ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	struct FString GetRequiredDLCSimpleName ( );
	void JoinServer ( );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_Coop_ServerBrowser::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Coop_SystemLink
// 0x0000 (0x07B0 - 0x07B0)
class UYUIFrontEnd_Coop_SystemLink : public UYUIFrontEnd_SystemLink
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 97844 ];

		return pClassPointer;
	};

	void OpenSearchScene ( int ControllerIndex );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OpenCustomMatchScene ( int ControllerIndex, unsigned long bIsLanMatch, unsigned char exodusMode, unsigned long bStartParty );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_Coop_SystemLink::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_CoopSettings
// 0x005C (0x07F8 - 0x079C)
class UYUIFrontEnd_CoopSettings : public UYUIFrontEnd_BasicMenu
{
public:
	class UUIPanel*                                    m_diffPanel;                                      		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIPanel*                                    m_mapPanel;                                       		// 0x07A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_mapList;                                        		// 0x07A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIMenuList*                                m_diffList;                                       		// 0x07A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_currentInfo;                                    		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_diffIcon;                                       		// 0x07B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_mapImage;                                       		// 0x07B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_selectedMapImage;                               		// 0x07B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_selectedMapNameHeader;                          		// 0x07BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_selectedMapName;                                		// 0x07C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_selectedDificultyImage;                         		// 0x07C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_selectedDificultyNameHeader;                    		// 0x07C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_selectedDificultyName;                          		// 0x07CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_selectedSubMenu : 1;                            		// 0x07D0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned char                                      m_currentSelectedMap;                             		// 0x07D4 (0x0001) [0x0000000000000000]              
	int                                                m_currentSelectedDiff;                            		// 0x07D8 (0x0004) [0x0000000000000000]              
	class UYUIDataStore_MenuItems*                     m_MenuItemDataStorePatch;                         		// 0x07DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             __OnNewDifficultySelected__Delegate;              		// 0x07E0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnNewMapSelected__Delegate;                     		// 0x07EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 97868 ];

		return pClassPointer;
	};

	void UpdateCurrentSelectedDiffInfo ( );
	void UpdateCurrentSelectedMapInfo ( );
	void UpdateCurrentSelectedInfo ( );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	struct FString GetMapImageStringFromSelection ( int SelectionIndex );
	struct FString GetDiffImageStringFromSelection ( int SelectionIndex );
	struct FString GetMapDescriptionFromSelection ( int SelectionIndex );
	struct FString GetDiffDescriptionFromSelection ( int SelectionIndex );
	void OnSubListSelectionChanged ( class UYSimpleList* SourceList, int NewSelectedIndex );
	void SelectMap ( );
	void SelectDifficulty ( );
	void CloseSubMenu ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void OnMenu_SubmitMap ( class UUIObject* Sender, int PlayerIndex );
	void OnMenu_SubmitDifficulty ( class UUIObject* Sender, int PlayerIndex );
	void AcceptSettingsChanges ( );
	void OnSelectItem ( int PlayerIndex );
	void InitDatastoreMenuItem ( );
	void InitWidget ( );
	void OnNewMapSelected ( unsigned char NewMapID );
	void OnNewDifficultySelected ( int NewDifficultyIndex );
};

UClass* UYUIFrontEnd_CoopSettings::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_ExodusMenu
// 0x0024 (0x07C0 - 0x079C)
class UYUIFrontEnd_ExodusMenu : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneOnlineMP;                                  		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneSystemLink;                                		// 0x07A8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneIntel;                                     		// 0x07B4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98043 ];

		return pClassPointer;
	};

	void SelectSystemLink ( int ControllerId );
	void SelectOnline ( int ControllerId );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	bool CancelButtonPressed ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void OnInitializationComplete ( unsigned long bSuccess );
	void CheckSkipMenu ( int ControllerId );
	void InitWidget ( );
};

UClass* UYUIFrontEnd_ExodusMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_ExodusPrivate
// 0x0000 (0x079C - 0x079C)
class UYUIFrontEnd_ExodusPrivate : public UYUIFrontEnd_BasicMenu
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98076 ];

		return pClassPointer;
	};

	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	void InitWidget ( );
};

UClass* UYUIFrontEnd_ExodusPrivate::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_ExodusSystemLinkMenu
// 0x000C (0x07A8 - 0x079C)
class UYUIFrontEnd_ExodusSystemLinkMenu : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneIntel;                                     		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98089 ];

		return pClassPointer;
	};

	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void SelectMenuItem ( class UUIObject* Sender, int PlayerIndex );
	void OnSelectItem ( int PlayerIndex );
	void InitWidget ( );
};

UClass* UYUIFrontEnd_ExodusSystemLinkMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_GameLobby
// 0x0000 (0x0774 - 0x0774)
class UYUIFrontEnd_GameLobby : public UYUIFrontEnd
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98106 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_GameLobby::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_GameLobbyQM
// 0x0000 (0x0774 - 0x0774)
class UYUIFrontEnd_GameLobbyQM : public UYUIFrontEnd_GameLobby
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98110 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_GameLobbyQM::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_GameOptions
// 0x0004 (0x07B8 - 0x07B4)
class UYUIFrontEnd_GameOptions : public UYUISceneFEOptions_Base
{
public:
	class UYUIOptionList*                              m_AudioLanguageSwitcher;                          		// 0x07B4 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98114 ];

		return pClassPointer;
	};

	void SetDefaultSwitcherValue ( class UYUIOptionList* CurrentSwitcher );
	void SetSFXChannel ( );
	void UpdateListValues ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void UpdateProfileStatsAndSave ( );
	void HandleValuechanged ( class UUIObject* Sender, int PlayerIndex );
};

UClass* UYUIFrontEnd_GameOptions::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_Buried
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_Buried : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98512 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_Buried::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_Chopper
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_Chopper : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98516 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_Chopper::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_CP
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_CP : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98520 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_CP::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_Delivery
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_Delivery : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98524 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_Delivery::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_DM
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_DM : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98528 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_DM::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_HD
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_HD : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98532 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_HD::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_Offline
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_Offline : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98536 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_Offline::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_RP
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_RP : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98540 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_RP::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_SDM
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_SDM : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98544 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_SDM::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_SpecialDelivery
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_SpecialDelivery : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98548 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_SpecialDelivery::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_Spoils
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_Spoils : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98552 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_Spoils::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_TDM
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_TDM : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98556 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_TDM::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboard_TE
// 0x0000 (0x07F8 - 0x07F8)
class UYUIFrontEnd_Leaderboard_TE : public UYUIFrontEnd_Leaderboard
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98560 ];

		return pClassPointer;
	};

};

UClass* UYUIFrontEnd_Leaderboard_TE::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_Leaderboards
// 0x0018 (0x07B4 - 0x079C)
class UYUIFrontEnd_Leaderboards : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneKills;                                     		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneDeathmatch;                                		// 0x07A8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 98564 ];

		return pClassPointer;
	};

	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	void InitWidget ( );
};

UClass* UYUIFrontEnd_Leaderboards::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_OnlineCoopMenu
// 0x0000 (0x086C - 0x086C)
class UYUIFrontEnd_OnlineCoopMenu : public UYUIFrontEnd_OnlineMPMenu
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 99372 ];

		return pClassPointer;
	};

	bool HandleInterceptRawInputKey ( struct FInputEventParameters* EventParms );
	void OnSelectItem ( int PlayerIndex );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_OnlineCoopMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_OnlineExodusMenu
// 0x000C (0x07A8 - 0x079C)
class UYUIFrontEnd_OnlineExodusMenu : public UYUIFrontEnd_BasicMenu
{
public:
	struct FString                                     m_SceneExodusPrivate;                             		// 0x079C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 99389 ];

		return pClassPointer;
	};

	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	void InitTitleDependTarget ( );
	void InitWidget ( );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_OnlineExodusMenu::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_OptionScreen
// 0x007C (0x07F0 - 0x0774)
class UYUIFrontEnd_OptionScreen : public UYUIFrontEnd
{
public:
	struct FString                                     m_SceneGameSettings;                              		// 0x0774 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneGfxSettings;                               		// 0x0780 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneControlSettings_PC;                        		// 0x078C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneControlSettings_Xbox;                      		// 0x0798 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneControlSettings_PS3;                       		// 0x07A4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneBrightness;                                		// 0x07B0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneSafeZone;                                  		// 0x07BC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneDifficulty;                                		// 0x07C8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FString                                     m_SceneCredits;                                   		// 0x07D4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned char                                      m_tempDiffLvl;                                    		// 0x07E0 (0x0001) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_isPS3 : 1;                                      		// 0x07E4 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_isConsole : 1;                                  		// 0x07E4 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	class UYUIMenuList*                                m_OptionList;                                     		// 0x07E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x07EC (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 99409 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	void OnSelectItem ( int PlayerIndex );
	void OnSaveDeviceSelectionComplete ( unsigned long bWasSuccessful );
	void ShowSaveDeviceSelection ( );
	bool ReloadCheckpointValidate ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void OpenReloadCheckpointQuestion ( );
	void OnDifficultyLevelSelected ( unsigned char Difficulty );
	void OnSubmitSafeZone ( );
	void OpenSafeZoneScene ( );
	void OpenSelectDifficultyMenu ( struct FScriptDelegate difficultyLevelSelectDelegate );
	void OnItemChosen ( class UYSimpleList* SourceList, int SelectedIndex, int PlayerIndex );
	void SceneActivated ( unsigned long bInitialActivation );
	void OptionsSelectionChange ( class UYSimpleList* SourceList, int NewSelectedIndex );
	void InitWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIFrontEnd_OptionScreen::pClassPointer = NULL;

// Class SRGame.YUIFrontend_SafeZoneAdjust
// 0x006C (0x07E0 - 0x0774)
class UYUIFrontend_SafeZoneAdjust : public UYUIFrontEnd
{
public:
	struct FVector2D                                   m_SafeZone;                                       		// 0x0774 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_SafeZoneOffset;                                 		// 0x077C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_InitialSafezone;                                		// 0x0784 (0x0008) [0x0000000000000000]              
	struct FVector2D                                   m_InitialSafeZoneOffset;                          		// 0x078C (0x0008) [0x0000000000000000]              
	float                                              m_xInitialZone;                                   		// 0x0794 (0x0004) [0x0000000000000000]              
	float                                              m_yInitialZone;                                   		// 0x0798 (0x0004) [0x0000000000000000]              
	float                                              m_safeZoneNugdeValue;                             		// 0x079C (0x0004) [0x0000000000000000]              
	float                                              m_minYZone;                                       		// 0x07A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_minXZone;                                       		// 0x07A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxYZone;                                       		// 0x07A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_maxXZone;                                       		// 0x07AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_speedX;                                         		// 0x07B0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_speedY;                                         		// 0x07B4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UUILabel*                                    m_labelX;                                         		// 0x07B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_labelY;                                         		// 0x07BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYAdjustableSafeRegionPanel*                 m_SafeRegionPanel;                                		// 0x07C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYProfileSettings*                           Profile;                                          		// 0x07C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FScriptDelegate                             __OnCloseSafeZoneScene__Delegate;                 		// 0x07C8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnSubmitDelegate__Delegate;                     		// 0x07D4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 99442 ];

		return pClassPointer;
	};

	void UpdateDisplay ( );
	void OnAdjust ( float ZoneDeltaX, float ZoneDeltaY, float ZoneOffsetDeltaX, float ZoneOffsetDeltaY );
	void OnSubmitDelegate ( );
	void OnCloseSafeZoneScene ( );
	void CloseSafeZone ( );
	void OnUISceneProcessGameInvite ( );
	void OnSubmit ( );
	bool ReloadCheckpointValidate ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void OpenReloadCheckpointQuestion ( );
	void SetToDefaults ( );
	bool SetDefaultsResponse ( class UUIMessageBoxBase* Sender, struct FName SelectedInputAlias, int PlayerIndex );
	void SetDefaultsClicked ( );
	void CheckForSubmit ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool HandleInputAxis ( struct FInputEventParameters* EventParms );
	void InitWidget ( );
	void InitWidgetRef ( );
	void SceneActivated ( unsigned long bInitialActivation );
};

UClass* UYUIFrontend_SafeZoneAdjust::pClassPointer = NULL;

// Class SRGame.YUIScene_TimedMessageBox
// 0x0038 (0x07AC - 0x0774)
class UYUIScene_TimedMessageBox : public UYUIFrontEnd
{
public:
	float                                              m_TotalDisplayTime;                               		// 0x0774 (0x0004) [0x0000000000006000]              ( CPF_Transient | CPF_Config )
	float                                              m_DisplayTimeLeft;                                		// 0x0778 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       m_TimePassParameter;                              		// 0x077C (0x0008) [0x0000000000000000]              
	class UUIImage*                                    m_RotatorImage;                                   		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_RotatorMaterialConstant;                        		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_TimeLeftNumber;                                 		// 0x078C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_ButtonBarCallout;                               		// 0x0790 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabelButton*                              m_btChoiceYes;                                    		// 0x0794 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabelButton*                              m_btChoiceNo;                                     		// 0x0798 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bFirstTick : 1;                                 		// 0x079C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	struct FScriptDelegate                             __OnSelectionPressed__Delegate;                   		// 0x07A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 99541 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnSelectClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool NoPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool YesPressed ( class UUIScreenObject* EventObject, int PlayerIndex );
	void UpdateDisplayTime ( );
	void TickScene ( float DeltaTime );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitRotatorImage ( );
	void InitWidgetRef ( );
	void OnSelectionPressed ( struct FString MessageBoxResponse );
};

UClass* UYUIScene_TimedMessageBox::pClassPointer = NULL;

// Class SRGame.YUIFrontEnd_PrestigeMode
// 0x0010 (0x07AC - 0x079C)
class UYUIFrontEnd_PrestigeMode : public UYUIFrontEnd_BasicMenu
{
public:
	unsigned long                                      m_bSpecopsPrestigeAvailable : 1;                  		// 0x079C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bKonradPrestigeAvailable : 1;                   		// 0x079C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	int                                                m_NextSpecopsPrestigeLevel;                       		// 0x07A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_NextKonradPrestigeLevel;                        		// 0x07A4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_ConfirmTeam;                                    		// 0x07A8 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 99600 ];

		return pClassPointer;
	};

	bool OnConfirmClicked ( class UUIMessageBoxBase* MessageBox, struct FName SelectedOption, int PlayerIndex );
	void OnSelectItem ( int PlayerIndex );
	bool MenuEntryDisable ( class UYSimpleList* SourceList, int Item );
	struct FString GetMenuItem ( int TeamID );
	void SceneActivated ( unsigned long bInitialActivation );
	void InitWidget ( );
	void PostInitialize ( );
};

UClass* UYUIFrontEnd_PrestigeMode::pClassPointer = NULL;

// Class SRGame.YUIScene_TimedUIMessge
// 0x0008 (0x0760 - 0x0758)
class UYUIScene_TimedUIMessge : public UYUIScene_TimedUIScene
{
public:
	class UUILabel*                                    m_messageHeader;                                  		// 0x0758 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_messageText;                                    		// 0x075C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 99775 ];

		return pClassPointer;
	};

	void SetTexts ( struct FString Header, struct FString Text );
	void TimeIsUp ( );
	void PostInitialize ( );
};

UClass* UYUIScene_TimedUIMessge::pClassPointer = NULL;

// Class SRGame.YUIInfo_ModificatorPlacement
// 0x0050 (0x008C - 0x003C)
class UYUIInfo_ModificatorPlacement : public UObject
{
public:
	struct FYS_ModificatorGUIPlacement                 m_modificatorGUIPlacement[ 0x5 ];                 		// 0x003C (0x0050) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 99912 ];

		return pClassPointer;
	};

	bool GetPlacementFor ( unsigned char modType, unsigned long configMenu, struct FYS_ModificatorGUIPlacement* placement );
};

UClass* UYUIInfo_ModificatorPlacement::pClassPointer = NULL;

// Class SRGame.YUIMapSingleList
// 0x0000 (0x07E0 - 0x07E0)
class UYUIMapSingleList : public UYUIMenuList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 100388 ];

		return pClassPointer;
	};

};

UClass* UYUIMapSingleList::pClassPointer = NULL;

// Class SRGame.YUIScene_Badges
// 0x0288 (0x0A30 - 0x07A8)
class UYUIScene_Badges : public UYUIScene_CommonItems
{
public:
	class UUIImage*                                    m_ImageArray[ 0x28 ];                             		// 0x07A8 (0x00A0) [0x0000000000000000]              
	class UUIButton*                                   m_ButtonArray[ 0x28 ];                            		// 0x0848 (0x00A0) [0x0000000000000000]              
	class UUIImage*                                    m_ImageLockArray[ 0x28 ];                         		// 0x08E8 (0x00A0) [0x0000000000000000]              
	class UUILabel*                                    m_LabelLockArray[ 0x28 ];                         		// 0x0988 (0x00A0) [0x0000000000000000]              
	class UUIImage*                                    m_CurrentImage;                                   		// 0x0A28 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   DefaultMaterial;                                  		// 0x0A2C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 100504 ];

		return pClassPointer;
	};

	void PostInitialize ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool IsItemUnlocked ( int Index );
	void ApplyChanges ( );
	bool OnChooseItem ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void InitWidgetRef ( );
};

UClass* UYUIScene_Badges::pClassPointer = NULL;

// Class SRGame.YUIScene_MatchResult
// 0x0010 (0x0754 - 0x0744)
class UYUIScene_MatchResult : public UYUIScenes
{
public:
	class UUILabel*                                    m_lblVictory;                                     		// 0x0744 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSpecopsSeal;                                 		// 0x0748 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgKonradSeal;                                  		// 0x074C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgDrawSeal;                                    		// 0x0750 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 101299 ];

		return pClassPointer;
	};

	void ShowSeal ( int TeamIndex );
	void InitWidget ( );
	void InitWidgetRef ( );
	void PostInitialize ( );
};

UClass* UYUIScene_MatchResult::pClassPointer = NULL;

// Class SRGame.YUIScene_Promotion
// 0x002C (0x07A0 - 0x0774)
class UYUIScene_Promotion : public UYUIFrontEnd
{
public:
	class UUIImage*                                    m_imgBackground;                                  		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgSeal[ 0x3 ];                                 		// 0x0778 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblRankName;                                    		// 0x0784 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblUnlockDesc1;                                 		// 0x0788 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUILabel*                                    m_lblUnlockDesc2;                                 		// 0x078C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UUIImage*                                    m_imgUnlock[ 0x3 ];                               		// 0x0790 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	class UUICalloutButtonPanel*                       m_ButtonBar;                                      		// 0x079C (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 101369 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnCloseClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	void InitWidgetWithRank ( unsigned char TeamID, int rankLevel );
	void InitWidget ( );
	void InitWidgetRef ( );
};

UClass* UYUIScene_Promotion::pClassPointer = NULL;

// Class SRGame.YUIScene_Scoreboard_TDM
// 0x0008 (0x07B4 - 0x07AC)
class UYUIScene_Scoreboard_TDM : public UYUIScene_Scoreboard
{
public:
	class UYUIScoreboardPanel*                         m_pnlScoreboardSpecops;                           		// 0x07AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UYUIScoreboardPanel*                         m_pnlScoreboardKonrad;                            		// 0x07B0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 101438 ];

		return pClassPointer;
	};

	void PostInitialize ( );
};

UClass* UYUIScene_Scoreboard_TDM::pClassPointer = NULL;

// Class SRGame.YUIScene_Statistics
// 0x00A8 (0x081C - 0x0774)
class UYUIScene_Statistics : public UYUIFrontEnd
{
public:
	class UUICalloutButtonPanel*                       m_ButtonBar;                                      		// 0x0774 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FYS_StatData >                      m_StatData;                                       		// 0x0778 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FYS_StatRow                                 m_StatRows[ 0xB ];                                		// 0x0784 (0x0084) [0x0000000000000000]              
	int                                                m_offset;                                         		// 0x0808 (0x0004) [0x0000000000000000]              
	class UUIImage*                                    m_ScrollMarker;                                   		// 0x080C (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __StatDelegate__Delegate;                         		// 0x0810 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 101446 ];

		return pClassPointer;
	};

	void OnOverridePlatformChanged ( );
	struct FString PlaysAsDamned ( );
	struct FString PlaysAsExiles ( );
	struct FString TimeRallyPointsHeld ( );
	struct FString MostUsedWeapon ( );
	struct FString TimesDBNO ( );
	struct FString TeammatesJuiced ( );
	struct FString KilledByExplosive ( );
	struct FString KilledByGun ( );
	struct FString OrdersGiven ( );
	struct FString FlashThrown ( );
	struct FString PercussionKills ( );
	struct FString PercussionThrown ( );
	struct FString FragKills ( );
	struct FString FragsThrown ( );
	struct FString RockKills ( );
	struct FString RocksThrown ( );
	struct FString MineKills ( );
	struct FString MinesPlanted ( );
	struct FString C4Disarmed ( );
	struct FString C4Planted ( );
	struct FString MinesDisarmed ( );
	struct FString SandstormDeaths ( );
	struct FString KilledOnZiplines ( );
	struct FString WinRatio ( );
	int GetNumGamesPlayed ( );
	struct FString NumGamesPlayed ( );
	struct FString LowerRankKills ( );
	struct FString HigherRankKills ( );
	struct FString AccuracyLauncher ( );
	struct FString AccuracySniper ( );
	struct FString AccuracyHMG ( );
	struct FString AccuracyLMG ( );
	struct FString AccuracyShotgun ( );
	struct FString AccuracyPistol ( );
	struct FString AccuracySMG ( );
	struct FString AccuracyAssaultRifle ( );
	struct FString GetBreacherTime ( );
	struct FString GetSniperTime ( );
	struct FString GetScavengerTime ( );
	struct FString GetMedicTime ( );
	struct FString GetGunnerTime ( );
	struct FString GetOfficerTime ( );
	int GetPerkTime ( unsigned char perk );
	struct FString FavoritePerk ( );
	struct FString FavoriteClass ( );
	struct FString ClassKilledByMostOften ( );
	struct FString TimeInCover ( );
	struct FString timePlayed ( );
	struct FString TimesRevived ( );
	struct FString NumberofRevives ( );
	struct FString BulletsFired ( );
	struct FString KillsFromC4 ( );
	struct FString BombsDisarmed ( );
	struct FString BombsDelivered ( );
	struct FString BasesMarked ( );
	struct FString VitalPointsRepaired ( );
	struct FString ChoppersDestroyed ( );
	struct FString ChopperCalls ( );
	struct FString StolenLootValue ( );
	struct FString KillsInSandstorm ( );
	struct FString SandKills ( );
	struct FString AvalancheTriggers ( );
	struct FString ZiplineKills ( );
	struct FString VaultKills ( );
	struct FString MeleeKills ( );
	struct FString TotalHeadShots ( );
	struct FString TotalDeaths ( );
	struct FString TotalKills ( );
	void ApplyChanges ( );
	void ScrollDown ( int ScrollValue );
	void ScrollUp ( int ScrollValue );
	bool OnPageUp ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool OnPageDown ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void OnSelectItem ( int PlayerIndex );
	void AddStatRow ( struct FString Title, struct FScriptDelegate callback );
	void InitWidget ( );
	void InitWidgetRef ( );
	void SceneActivated ( unsigned long bInitialActivation );
	struct FString StatDelegate ( );
};

UClass* UYUIScene_Statistics::pClassPointer = NULL;

// Class SRGame.YUIScene_Titles
// 0x019C (0x0944 - 0x07A8)
class UYUIScene_Titles : public UYUIScene_CommonItems
{
public:
	class UUIImage*                                    m_ImageArray[ 0x14 ];                             		// 0x07A8 (0x0050) [0x0000000000000000]              
	class UUILabelButton*                              m_ButtonLabelArray[ 0x14 ];                       		// 0x07F8 (0x0050) [0x0000000000000000]              
	class UUIImage*                                    m_LockImage[ 0x14 ];                              		// 0x0848 (0x0050) [0x0000000000000000]              
	class UUILabel*                                    m_LockText[ 0x14 ];                               		// 0x0898 (0x0050) [0x0000000000000000]              
	class UUIButton*                                   m_FullButton[ 0x14 ];                             		// 0x08E8 (0x0050) [0x0000000000000000]              
	class UUIImage*                                    m_CurrentTitle;                                   		// 0x0938 (0x0004) [0x0000000000000000]              
	class UUILabelButton*                              m_ButtonCurrentTitle;                             		// 0x093C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   DefaultMaterial;                                  		// 0x0940 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 101772 ];

		return pClassPointer;
	};

	void PostInitialize ( );
	bool OnBackClicked ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool IsItemUnlocked ( int Index );
	void ApplyChanges ( );
	bool OnChooseItem ( class UUIScreenObject* EventObject, int PlayerIndex );
	bool HandleInputKey ( struct FInputEventParameters* EventParms );
	void InitWidgetRef ( );
};

UClass* UYUIScene_Titles::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_TDM
// 0x0020 (0x060C - 0x05EC)
class UYUIScoreboardPanel_TDM : public UYUIScoreboardPanel
{
public:
	struct FYS_ScoreboardFontData                      m_ColumnFont;                                     		// 0x05EC (0x0010) [0x0000000000000001]              ( CPF_Edit )
	struct FLinearColor                                m_CellTextScoreColor;                             		// 0x05FC (0x0010) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102040 ];

		return pClassPointer;
	};

	struct FString GetTeamScore ( struct FYS_CellInputParams* Params );
	void SetupScoreboard ( );
};

UClass* UYUIScoreboardPanel_TDM::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_Buried
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_Buried : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102049 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_Buried::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_ChopperAttack
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_ChopperAttack : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102052 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_ChopperAttack::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_CP
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_CP : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102055 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_CP::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_Delivery
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_Delivery : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102058 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_Delivery::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_DM
// 0x0000 (0x05EC - 0x05EC)
class UYUIScoreboardPanel_DM : public UYUIScoreboardPanel
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102061 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_DM::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_ExodusCoop
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_ExodusCoop : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102064 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_ExodusCoop::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_HD
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_HD : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102067 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_HD::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_Offline
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_Offline : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102147 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_Offline::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_RP
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_RP : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102150 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_RP::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_SDM
// 0x0010 (0x061C - 0x060C)
class UYUIScoreboardPanel_SDM : public UYUIScoreboardPanel_TDM
{
public:
	struct FYS_ScoreboardFontData                      m_BonusScoreFont;                                 		// 0x060C (0x0010) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102153 ];

		return pClassPointer;
	};

	struct FString GetTeamBonusScore ( struct FYS_CellInputParams* Params );
	void SetupScoreboard ( );
};

UClass* UYUIScoreboardPanel_SDM::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_SpecialDelivery
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_SpecialDelivery : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102161 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_SpecialDelivery::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_SW
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_SW : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102164 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_SW::pClassPointer = NULL;

// Class SRGame.YUIScoreboardPanel_TE
// 0x0000 (0x060C - 0x060C)
class UYUIScoreboardPanel_TE : public UYUIScoreboardPanel_TDM
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102167 ];

		return pClassPointer;
	};

};

UClass* UYUIScoreboardPanel_TE::pClassPointer = NULL;

// Class SRGame.YUIW_OptionsList
// 0x0000 (0x080C - 0x080C)
class UYUIW_OptionsList : public UUIList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102280 ];

		return pClassPointer;
	};

};

UClass* UYUIW_OptionsList::pClassPointer = NULL;

// Class SRGame.YUIW_OptionsListRange
// 0x0000 (0x080C - 0x080C)
class UYUIW_OptionsListRange : public UYUIW_OptionsList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102292 ];

		return pClassPointer;
	};

};

UClass* UYUIW_OptionsListRange::pClassPointer = NULL;

// Class SRGame.YWeapon_NoWeapon
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_NoWeapon : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102672 ];

		return pClassPointer;
	};

	void Init ( class AYArsenalManager* newArsenalManager, class AYGamePawn* NewPawn, class AYCheapShooter* cheapShooter, struct FName hookName );
	class UClass* GetPickupClass ( );
};

UClass* AYWeapon_NoWeapon::pClassPointer = NULL;

// Class SRGame.YUnrealScriptStudioParserBuster
// 0x0000 (0x003C - 0x003C)
class UYUnrealScriptStudioParserBuster : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102717 ];

		return pClassPointer;
	};

	void MacroRecursionIsNotWorking ( );
	void WriteHelloSamMsg ( );
	void FunctionInsideSwitchFails ( struct FYS_GroupID paramGroupID );
	void StaticFunctionInsideSwitchFails ( struct FYS_GroupID paramGroupID );
	void MacroInsideSwitchFails ( struct FYS_GroupID paramGroupID );
	struct FYS_GroupID NonStatic_GetGroupID1 ( unsigned char subID );
	struct FYS_GroupID GetGroupID2 ( unsigned char subID );
	struct FYS_GroupID GetGroupID1 ( unsigned char subID );
};

UClass* UYUnrealScriptStudioParserBuster::pClassPointer = NULL;

// Class SRGame.YUnrealScriptStudioParserBuster2
// 0x0000 (0x003C - 0x003C)
class UYUnrealScriptStudioParserBuster2 : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102746 ];

		return pClassPointer;
	};

	void MacroRecursionIsNotWorking ( );
	void WriteHelloSamMsg ( );
};

UClass* UYUnrealScriptStudioParserBuster2::pClassPointer = NULL;

// Class SRGame.YVictimMessage
// 0x0024 (0x0090 - 0x006C)
class UYVictimMessage : public UYLocalMessage
{
public:
	struct FString                                     YouWereKilledBy;                                  		// 0x006C (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     YouWereKilledByTrailer;                           		// 0x0078 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FString                                     YouKilledYourself;                                		// 0x0084 (0x000C) [0x0000000000408003]              ( CPF_Edit | CPF_Const | CPF_Localized | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102792 ];

		return pClassPointer;
	};

	struct FString GetString ( int Switch, unsigned long bPRI1HUD, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01, class UObject* OptionalObject );
};

UClass* UYVictimMessage::pClassPointer = NULL;

// Class SRGame.YWeapon_AK47_Scnd
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_AK47_Scnd : public AYWeapon_AK47
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102895 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_AK47_Scnd::pClassPointer = NULL;

// Class SRGame.YWeapon_AK74
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_AK74 : public AYWeapon_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 102929 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_AK74::pClassPointer = NULL;

// Class SRGame.YWeapon_BarrettM99_HPScope
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_BarrettM99_HPScope : public AYWeapon_BarrettM99
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103010 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_BarrettM99_HPScope::pClassPointer = NULL;

// Class SRGame.YWeapon_Expl_Percussion
// 0x0000 (0x0CA9 - 0x0CA9)
class AYWeapon_Expl_Percussion : public AYWeapon_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103405 ];

		return pClassPointer;
	};

	class AController* GetDamageInstigator ( );
};

UClass* AYWeapon_Expl_Percussion::pClassPointer = NULL;

// Class SRGame.YWeapon_FAMAS_Scnd
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_FAMAS_Scnd : public AYWeapon_FAMAS
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103432 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_FAMAS_Scnd::pClassPointer = NULL;

// Class SRGame.YWeapon_FNP90_LaserSight
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_FNP90_LaserSight : public AYWeapon_FNP90
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103484 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_FNP90_LaserSight::pClassPointer = NULL;

// Class SRGame.YWeapon_Grenade
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Grenade : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103545 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Grenade::pClassPointer = NULL;

// Class SRGame.YWeapon_HK417_Scope
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_HK417_Scope : public AYWeapon_HK417
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103599 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_HK417_Scope::pClassPointer = NULL;

// Class SRGame.YWeapon_M4Carbine_Silencer
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_M4Carbine_Silencer : public AYWeapon_M4Carbine
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103723 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_M4Carbine_Silencer::pClassPointer = NULL;

// Class SRGame.YWeapon_M4CarbineSquad
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_M4CarbineSquad : public AYWeapon_M4Carbine
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103750 ];

		return pClassPointer;
	};

	class UClass* GetPickupClass ( );
};

UClass* AYWeapon_M4CarbineSquad::pClassPointer = NULL;

// Class SRGame.YWeapon_M9A1_Scnd
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_M9A1_Scnd : public AYWeapon_M9A1
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103774 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_M9A1_Scnd::pClassPointer = NULL;

// Class SRGame.YWeapon_MicroUzi_Silencer
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_MicroUzi_Silencer : public AYWeapon_MicroUzi
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103826 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_MicroUzi_Silencer::pClassPointer = NULL;

// Class SRGame.YWeapon_MilkorMGL_Truckride
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_MilkorMGL_Truckride : public AYWeapon_MilkorMGL
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103906 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_MilkorMGL_Truckride::pClassPointer = NULL;

// Class SRGame.YWeapon_MP7
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_MP7 : public AYWeapon_SubmachineGun
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 103959 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_MP7::pClassPointer = NULL;

// Class SRGame.YWeapon_Multiplayer
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_Multiplayer : public AYWeapon
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 104091 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_Multiplayer::pClassPointer = NULL;

// Class SRGame.YWeapon_NoExplosive
// 0x0000 (0x0CA9 - 0x0CA9)
class AYWeapon_NoExplosive : public AYWeapon_Explosive
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 104105 ];

		return pClassPointer;
	};

	void Init ( class AYArsenalManager* newArsenalManager, class AYGamePawn* NewPawn, class AYCheapShooter* cheapShooter, struct FName hookName );
};

UClass* AYWeapon_NoExplosive::pClassPointer = NULL;

// Class SRGame.YWeapon_OTs14Groza
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_OTs14Groza : public AYWeapon_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 104144 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_OTs14Groza::pClassPointer = NULL;

// Class SRGame.YWeapon_RPG_Chopper
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_RPG_Chopper : public AYWeapon_RPG
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 104201 ];

		return pClassPointer;
	};

	class UClass* GetPickupClass ( );
};

UClass* AYWeapon_RPG_Chopper::pClassPointer = NULL;

// Class SRGame.YWeapon_SCAR_Scnd
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_SCAR_Scnd : public AYWeapon_SCAR
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 104281 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_SCAR_Scnd::pClassPointer = NULL;

// Class SRGame.YWeapon_SteyrElite_HPScope
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_SteyrElite_HPScope : public AYWeapon_SteyrElite
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 104335 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_SteyrElite_HPScope::pClassPointer = NULL;

// Class SRGame.YWeapon_TestWeapon
// 0x0000 (0x0CA8 - 0x0CA8)
class AYWeapon_TestWeapon : public AYWeapon_AssaultRifle
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 104410 ];

		return pClassPointer;
	};

};

UClass* AYWeapon_TestWeapon::pClassPointer = NULL;


#ifdef _MSC_VER
	#pragma pack ( pop )
#endif